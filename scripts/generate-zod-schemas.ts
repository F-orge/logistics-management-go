/**
 * PocketBase Types to Zod Schema Generator
 *
 * This script reads the pb.types.ts file and generates corresponding Zod schemas.
 * Usage: bun scripts/generate-zod-schemas.ts
 *
 * Output: Generated schemas are written to src/lib/schemas/pb-schemas.ts
 */

import * as fs from "node:fs";
import * as path from "node:path";

interface FieldInfo {
  name: string;
  type: string;
  isOptional: boolean;
  isArray: boolean;
  isEnum?: boolean;
}

interface RecordTypeInfo {
  name: string;
  fields: FieldInfo[];
  isAuthType: boolean;
}

const pbTypesPath = path.join(process.cwd(), "src/lib/pb.types.ts");
const outputPath = path.join(process.cwd(), "src/pocketbase/pb-schemas.ts");

// Ensure output directory exists
const outputDir = path.dirname(outputPath);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

function parseTypeString(typeStr: string): {
  baseType: string;
  isOptional: boolean;
  isArray: boolean;
} {
  let isOptional = false;
  let isArray = false;

  // Handle optional types (ending with ?)
  if (typeStr.endsWith("?")) {
    isOptional = true;
    typeStr = typeStr.slice(0, -1);
  }

  // Handle array types
  if (typeStr.endsWith("[]")) {
    isArray = true;
    typeStr = typeStr.slice(0, -2);
  }

  // Handle union types with null
  if (typeStr.includes("| null")) {
    isOptional = true;
    typeStr = typeStr.replace("| null", "").trim();
  }

  // Clean up remaining type
  typeStr = typeStr.replace(/^null \| /, "").trim();

  return { baseType: typeStr, isOptional, isArray };
}

function mapTypeToZod(baseType: string, isEnum: boolean = false): string {
  const typeMap: Record<string, string> = {
    string: "z.string()",
    number: "z.number()",
    boolean: "z.boolean()",
    RecordIdString: "z.string()",
    IsoDateString: "z.iso.date()",
    IsoAutoDateString: "z.iso.date()",
    FileNameString: "z.string()",
    HTMLString: "z.string()",
  };

  if (typeMap[baseType]) {
    return typeMap[baseType];
  }

  // Check if it's an enum type - use nativeEnum with PB namespace reference
  if (isEnum && baseType.includes("Options")) {
    return `z.enum(PB.${baseType})`;
  }

  // Default to string
  return "z.string()";
}

function parseRecordType(content: string, typeName: string): RecordTypeInfo {
  const recordRegex = new RegExp(`export type ${typeName}Record(?:<.*?>)? = \\{([^}]+)\\};`, "s");
  const match = content.match(recordRegex);

  if (!match) {
    return { name: typeName, fields: [], isAuthType: false };
  }

  const fieldsStr = match[1];
  const fields: FieldInfo[] = [];
  const fieldPattern = /(\w+)(\?)?:\s*([^;]+);/g;

  for (let fieldMatch = fieldPattern.exec(fieldsStr); fieldMatch !== null; fieldMatch = fieldPattern.exec(fieldsStr)) {
    const [, fieldName, optional, typeStr] = fieldMatch;
    const { baseType, isOptional: typeOptional, isArray } = parseTypeString(typeStr);

    fields.push({
      name: fieldName,
      type: baseType,
      isOptional: !!optional || typeOptional,
      isArray,
      isEnum: baseType.includes("Options"),
    });
  }

  return {
    name: typeName,
    fields,
    isAuthType: typeName.includes("Auth"),
  };
}

function generateZodSchema(record: RecordTypeInfo): string {
  const schemaName = `${record.name}Schema`;
  let schema = `export const ${schemaName} = z.object({\n`;

  for (const field of record.fields) {
    const fieldName = field.name;
    let zodType = mapTypeToZod(field.type, field.isEnum);

    // Handle arrays
    if (field.isArray) {
      zodType = `z.array(${zodType})`;
    }

    // Handle optional fields
    if (field.isOptional) {
      zodType = `${zodType}.optional()`;
    }

    schema += `  ${fieldName}: ${zodType},\n`;
  }

  schema += `});\n\n`;
  schema += `export type ${record.name} = z.infer<typeof ${schemaName}>;\n`;

  return schema;
}

function main() {
  try {
    console.log("üìñ Reading PocketBase types file...");
    const pbContent = fs.readFileSync(pbTypesPath, "utf-8");

    console.log("üîç Parsing record types...");

    // Extract all Record type names
    const recordTypeRegex = /export type (\w+Record)(?:<.*?>)? = \{/g;
    const recordTypes: RecordTypeInfo[] = [];

    for (let match = recordTypeRegex.exec(pbContent); match !== null; match = recordTypeRegex.exec(pbContent)) {
      const typeName = match[1].replace("Record", "");
      const recordInfo = parseRecordType(pbContent, typeName);
      recordTypes.push(recordInfo);
    }

    console.log(`‚úÖ Found ${recordTypes.length} record types`);

    // Generate Zod schemas
    console.log("üîß Generating Zod schemas...");
    let output = `/**
 * Auto-generated Zod schemas from PocketBase types
 * Generated by: scripts/generate-zod-schemas.ts
 * DO NOT EDIT MANUALLY
 */

import { z } from "zod";
import * as PB from "../lib/pb.types";

`;

    for (const record of recordTypes) {
      output += generateZodSchema(record);
    }

    // Write output file
    console.log(`üìù Writing schemas to ${outputPath}...`);
    fs.writeFileSync(outputPath, output);

    console.log("‚ú® Schema generation complete!");
    console.log(`üì¶ Generated schemas for ${recordTypes.length} types`);
  } catch (error) {
    console.error("‚ùå Error generating schemas:", error);
    process.exit(1);
  }
}

main();
