description = "Generate a Rust GraphQL query file following project conventions."
prompt = """
@{services/graphql-wms/src/query/inbound_shipments.rs}
@{services/graphql-wms/src/query/outbound_shipments.rs}
@{migrations}

You are an expert Rust backend developer. Given the following table names, generate a new Rust file for each as a GraphQL query module in this codebase, following these conventions:

1. For each table name provided (all arguments except the last), search the migrations for a table matching the name (e.g., billing.disputes).
2. Extract the table's columns and types from the migration SQL. Use these as the basis for the query methods.
3. If a table is not found, return an error or a helpful message for that table.
4. For each found table, follow these conventions:
   - Implement a `Query` struct and an `#[Object]` impl block with methods for listing and fetching by id, following the async_graphql and sqlx patterns in the reference files.
   - Use pagination (page, limit) for the list query, and fetch by id for the single query.
   - Use the same naming, error handling, and module/import structure as in the provided examples.
   - The file should be placed in the output directory specified as the last argument.

Argument format:
- Table name(s) (e.g., billing.disputes billing.credit_notes ...)
- Output directory (last argument, e.g., services/graphql-billing/src/query)

Example usage:
/graphql-query "billing.disputes" "billing.credit_notes" "services/graphql-billing/src/query"

Arguments provided:
{{args}}

Output:
A complete Rust file for each query module, following the conventions in the reference files, and placed in the specified output directory. If a table is not found, return an error message for that table.
"""
