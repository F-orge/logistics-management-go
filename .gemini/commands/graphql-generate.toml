description = "Generate TypeScript GraphQL client code based on schema introspection."
prompt = """
@{src/lib/graphql/client/execute.ts}
@{src/lib/graphql/client/graphql.ts}
@{src/graphql/queries/crm/companies.ts}
@{src/graphql/mutations/crm/companies.ts}

You are an expert TypeScript developer specializing in GraphQL client implementation. Your task is to generate high-quality TypeScript code for a GraphQL client based on schema introspection. The code you generate will be used to integrate with the backend GraphQL API.

I've included reference files above to help you understand the project structure and patterns:
- execute.ts: Shows how GraphQL operations are executed with proper typing
- graphql.ts: Contains the core GraphQL client functionality
- companies.ts (queries): Shows examples of query operations with proper field selection, pagination, and single entity fetching
- companies.ts (mutations): Shows examples of mutation operations including create, update, and delete patterns

You are an expert TypeScript developer specializing in GraphQL client implementation. Your task is to generate high-quality TypeScript code for a GraphQL client based on schema introspection. The code you generate will be used to integrate with the backend GraphQL API.

I've included reference files above to help you understand the project structure and patterns:
- execute.ts: Shows how GraphQL operations are executed with proper typing
- graphql.ts: Contains the core GraphQL client functionality
- companies.ts (queries and mutations): Examples of GraphQL operations definition

I will now run the introspect command to sync up the backend implementation with the frontend and generate the schema.graphql file:

!{just introspect}

Now I'll analyze the schema.graphql file to understand the GraphQL schema:

@{src/lib/graphql/schema.graphql}

Let me also check the code generation configuration:

@{codegen.ts}

Based on the above schema, existing types, and project structure, I need you to generate TypeScript client code for the operation specified.

## Command Usage Examples
- `/graphql-generate "AuthQueries" "src/graphql/queries/auth/session.ts" "Generate query operations for session management"`
- `/graphql-generate "WarehouseInventoryMutations" "src/graphql/mutations/wms/inventory.ts" "Create CRUD operations for warehouse inventory"`
- `/graphql-generate "ShipmentQueries" "src/graphql/queries/tms/shipments.ts" "Implement pagination and filtering for shipments"`

## Instructions
1. Parse the command arguments to determine:
   - The type of operation to generate from the OperationType argument (e.g., "AuthQueries" means queries for authentication)
   - The output path where the GraphQL operation should be defined
   - Any additional requirements or specifications

2. Analyze the schema and generated types carefully to find the relevant types for the specified domain.

3. Create a strongly-typed GraphQL operation file:
   - For queries: Create operations that fetch data (get by ID, list with pagination, etc.)
   - For mutations: Create operations that modify data (create, update, delete, etc.)
   - For subscriptions: Create operations that subscribe to data changes
   - Use the `graphql` template tag from `@/lib/graphql/client`
   - Place the file at the specified output path

4. Follow the project's patterns for:
   - Naming conventions
   - GraphQL operation structure
   - Type definitions
   - File organization

5. Add proper documentation/comments explaining the purpose and usage of the generated code.

6. Ensure the code follows TypeScript best practices and existing project patterns.

## Request Details:
The command is executed with specific arguments to determine what to generate:

Command format: `/graphql-generate "<OperationType>" "<OutputPath>" "<AdditionalDetails>"`

Where:
- **OperationType**: Specifies what type of GraphQL operation to generate (e.g., "AuthQueries", "WarehouseInventoryMutations", "ShipmentQueries")
- **OutputPath**: The file path where the GraphQL operation should be defined (e.g., "src/graphql/queries/auth/session.ts")
- **AdditionalDetails** (optional): Any additional specifications or requirements

Arguments provided:
{{args}}

## Output
Based on the provided command arguments, generate the following:

**GraphQL Operation Definition File** (place this file at the exact path specified in the OutputPath argument):
- The file should be created at the exact path provided (e.g., "src/graphql/queries/auth/session.ts")
- If the OperationType ends with "Queries", create query operations
- If the OperationType ends with "Mutations", create mutation operations
- If the OperationType ends with "Subscriptions", create subscription operations

This file should include:
- Import of `graphql` from `@/lib/graphql/client`
- One or more GraphQL operations as named exports using the `graphql` template tag
- Operations that make sense for the domain specified in the OperationType
- Follow the naming patterns shown in the reference files
- Comprehensive field selection based on the schema
- Proper variable typing and usage
- **IMPORTANT**: Group operations by model/entity with clear section headers and comments

Example based on project patterns: 
```typescript
import { graphql } from "@/lib/graphql/client";

// ============================================================================
// COMPANY OPERATIONS
// ============================================================================

// Get a single company by ID
export const getCompany = graphql(`
  query GetCompany($id: UUID!) {
    crm {
      company(id: $id) {
        id
        name
        industry
        # other company fields based on the schema...
        createdAt
        updatedAt
      }
    }
  }
`);

// List companies with pagination
export const getCompanies = graphql(`
  query GetCompanies($limit: Int!, $page: Int!) {
    crm {
      companies(limit: $limit, page: $page) {
        id
        name
        industry
        # other company fields...
        createdAt
        updatedAt
      }
    }
  }
`);

// Create a new company
export const createCompany = graphql(`
  mutation CreateCompany($payload: CreateCompanyInput!) {
    crm {
      createCompany(payload: $payload) {
        id
        name
        industry
        # other company fields...
        createdAt
        updatedAt
      }
    }
  }
`);

// ============================================================================
// CONTACT OPERATIONS (if applicable)
// ============================================================================

// Get a single contact by ID
export const getContact = graphql(`
  query GetContact($id: UUID!) {
    crm {
      contact(id: $id) {
        id
        firstName
        lastName
        # other contact fields based on the schema...
        createdAt
        updatedAt
      }
    }
  }
`);

// Add more contact operations here...
```

**Organization Requirements**:
1. **Use clear section headers** with equal signs (=) to separate different models/entities
2. **Group related operations together** (all company operations in one section, all contact operations in another, etc.)
3. **Add descriptive comments** for each operation explaining what it does
4. **Follow consistent naming patterns** based on the model name (e.g., getCompany, getCompanies, createCompany)
5. **Include comprehensive field selection** for each model based on the GraphQL schema

**Usage Notes**:
The generated operations can be used with the `execute` function from `@/lib/graphql/client/execute`:

```typescript
import { execute } from '@/lib/graphql/client/execute';
import { getEntity, createEntity } from './path/to/generated/operations';

// For queries
const data = await execute(getEntity, { id: 'some-uuid' });

// For mutations
const result = await execute(createEntity, { payload: { name: 'New Entity' } });
```

Ensure the code follows the project's existing patterns and integrates with the auto-generated types from graphql-codegen. Include comments explaining the purpose and structure of each operation.
"""
