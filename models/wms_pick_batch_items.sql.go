// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_pick_batch_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyPickBatchItem = `-- name: WmsAnyPickBatchItem :many
select
  pick_batch_items.id, pick_batch_items.pick_batch_id, pick_batch_items.sales_order_id, pick_batch_items.order_priority, pick_batch_items.estimated_pick_time, pick_batch_items.actual_pick_time, pick_batch_items.created_at, pick_batch_items.updated_at,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at
from
  "wms"."pick_batch_items" as pick_batch_items
  inner join "wms"."pick_batches" as pick_batch on pick_batch_items.pick_batch_id = pick_batch.id
  inner join "wms"."sales_orders" as sales_order on pick_batch_items.sales_order_id = sales_order.id
where
  pick_batch_items.id = any ($1::uuid[])
`

type WmsAnyPickBatchItemRow struct {
	WmsPickBatchItem WmsPickBatchItem
	WmsPickBatch     WmsPickBatch
	WmsSalesOrder    WmsSalesOrder
}

func (q *Queries) WmsAnyPickBatchItem(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyPickBatchItemRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyPickBatchItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyPickBatchItemRow
	for rows.Next() {
		var i WmsAnyPickBatchItemRow
		if err := rows.Scan(
			&i.WmsPickBatchItem.ID,
			&i.WmsPickBatchItem.PickBatchID,
			&i.WmsPickBatchItem.SalesOrderID,
			&i.WmsPickBatchItem.OrderPriority,
			&i.WmsPickBatchItem.EstimatedPickTime,
			&i.WmsPickBatchItem.ActualPickTime,
			&i.WmsPickBatchItem.CreatedAt,
			&i.WmsPickBatchItem.UpdatedAt,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
			&i.WmsSalesOrder.ID,
			&i.WmsSalesOrder.OrderNumber,
			&i.WmsSalesOrder.ClientID,
			&i.WmsSalesOrder.CrmOpportunityID,
			&i.WmsSalesOrder.Status,
			&i.WmsSalesOrder.ShippingAddress,
			&i.WmsSalesOrder.CreatedAt,
			&i.WmsSalesOrder.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindPickBatchItem = `-- name: WmsFindPickBatchItem :one
select
  pick_batch_items.id, pick_batch_items.pick_batch_id, pick_batch_items.sales_order_id, pick_batch_items.order_priority, pick_batch_items.estimated_pick_time, pick_batch_items.actual_pick_time, pick_batch_items.created_at, pick_batch_items.updated_at,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at
from
  "wms"."pick_batch_items" as pick_batch_items
  inner join "wms"."pick_batches" as pick_batch on pick_batch_items.pick_batch_id = pick_batch.id
  inner join "wms"."sales_orders" as sales_order on pick_batch_items.sales_order_id = sales_order.id
where
  pick_batch_items.id = $1::uuid
`

type WmsFindPickBatchItemRow struct {
	WmsPickBatchItem WmsPickBatchItem
	WmsPickBatch     WmsPickBatch
	WmsSalesOrder    WmsSalesOrder
}

func (q *Queries) WmsFindPickBatchItem(ctx context.Context, id pgtype.UUID) (WmsFindPickBatchItemRow, error) {
	row := q.db.QueryRow(ctx, wmsFindPickBatchItem, id)
	var i WmsFindPickBatchItemRow
	err := row.Scan(
		&i.WmsPickBatchItem.ID,
		&i.WmsPickBatchItem.PickBatchID,
		&i.WmsPickBatchItem.SalesOrderID,
		&i.WmsPickBatchItem.OrderPriority,
		&i.WmsPickBatchItem.EstimatedPickTime,
		&i.WmsPickBatchItem.ActualPickTime,
		&i.WmsPickBatchItem.CreatedAt,
		&i.WmsPickBatchItem.UpdatedAt,
		&i.WmsPickBatch.ID,
		&i.WmsPickBatch.BatchNumber,
		&i.WmsPickBatch.WarehouseID,
		&i.WmsPickBatch.Status,
		&i.WmsPickBatch.Strategy,
		&i.WmsPickBatch.Priority,
		&i.WmsPickBatch.AssignedUserID,
		&i.WmsPickBatch.WaveID,
		&i.WmsPickBatch.ZoneRestrictions,
		&i.WmsPickBatch.EstimatedDuration,
		&i.WmsPickBatch.ActualDuration,
		&i.WmsPickBatch.TotalItems,
		&i.WmsPickBatch.CompletedItems,
		&i.WmsPickBatch.StartedAt,
		&i.WmsPickBatch.CompletedAt,
		&i.WmsPickBatch.CreatedAt,
		&i.WmsPickBatch.UpdatedAt,
		&i.WmsSalesOrder.ID,
		&i.WmsSalesOrder.OrderNumber,
		&i.WmsSalesOrder.ClientID,
		&i.WmsSalesOrder.CrmOpportunityID,
		&i.WmsSalesOrder.Status,
		&i.WmsSalesOrder.ShippingAddress,
		&i.WmsSalesOrder.CreatedAt,
		&i.WmsSalesOrder.UpdatedAt,
	)
	return i, err
}

const wmsInsertPickBatchItem = `-- name: WmsInsertPickBatchItem :one
insert into "wms"."pick_batch_items"(pick_batch_id, sales_order_id, order_priority, estimated_pick_time, actual_pick_time)
  values ($1, $2, $3, $4, $5)
returning
  id, pick_batch_id, sales_order_id, order_priority, estimated_pick_time, actual_pick_time, created_at, updated_at
`

type WmsInsertPickBatchItemParams struct {
	PickBatchID       pgtype.UUID
	SalesOrderID      pgtype.UUID
	OrderPriority     pgtype.Int4
	EstimatedPickTime pgtype.Int4
	ActualPickTime    pgtype.Int4
}

func (q *Queries) WmsInsertPickBatchItem(ctx context.Context, arg WmsInsertPickBatchItemParams) (WmsPickBatchItem, error) {
	row := q.db.QueryRow(ctx, wmsInsertPickBatchItem,
		arg.PickBatchID,
		arg.SalesOrderID,
		arg.OrderPriority,
		arg.EstimatedPickTime,
		arg.ActualPickTime,
	)
	var i WmsPickBatchItem
	err := row.Scan(
		&i.ID,
		&i.PickBatchID,
		&i.SalesOrderID,
		&i.OrderPriority,
		&i.EstimatedPickTime,
		&i.ActualPickTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginatePickBatchItem = `-- name: WmsPaginatePickBatchItem :many
select
  pick_batch_items.id, pick_batch_items.pick_batch_id, pick_batch_items.sales_order_id, pick_batch_items.order_priority, pick_batch_items.estimated_pick_time, pick_batch_items.actual_pick_time, pick_batch_items.created_at, pick_batch_items.updated_at,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at
from
  "wms"."pick_batch_items" as pick_batch_items
  inner join "wms"."pick_batches" as pick_batch on pick_batch_items.pick_batch_id = pick_batch.id
  inner join "wms"."sales_orders" as sales_order on pick_batch_items.sales_order_id = sales_order.id
where
  (pick_batch.batch_number ilike $1::text
  or sales_order.order_number ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginatePickBatchItemParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginatePickBatchItemRow struct {
	WmsPickBatchItem WmsPickBatchItem
	WmsPickBatch     WmsPickBatch
	WmsSalesOrder    WmsSalesOrder
}

func (q *Queries) WmsPaginatePickBatchItem(ctx context.Context, arg WmsPaginatePickBatchItemParams) ([]WmsPaginatePickBatchItemRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginatePickBatchItem, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginatePickBatchItemRow
	for rows.Next() {
		var i WmsPaginatePickBatchItemRow
		if err := rows.Scan(
			&i.WmsPickBatchItem.ID,
			&i.WmsPickBatchItem.PickBatchID,
			&i.WmsPickBatchItem.SalesOrderID,
			&i.WmsPickBatchItem.OrderPriority,
			&i.WmsPickBatchItem.EstimatedPickTime,
			&i.WmsPickBatchItem.ActualPickTime,
			&i.WmsPickBatchItem.CreatedAt,
			&i.WmsPickBatchItem.UpdatedAt,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
			&i.WmsSalesOrder.ID,
			&i.WmsSalesOrder.OrderNumber,
			&i.WmsSalesOrder.ClientID,
			&i.WmsSalesOrder.CrmOpportunityID,
			&i.WmsSalesOrder.Status,
			&i.WmsSalesOrder.ShippingAddress,
			&i.WmsSalesOrder.CreatedAt,
			&i.WmsSalesOrder.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangePickBatchItem = `-- name: WmsRangePickBatchItem :many
select
  pick_batch_items.id, pick_batch_items.pick_batch_id, pick_batch_items.sales_order_id, pick_batch_items.order_priority, pick_batch_items.estimated_pick_time, pick_batch_items.actual_pick_time, pick_batch_items.created_at, pick_batch_items.updated_at,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at
from
  "wms"."pick_batch_items" as pick_batch_items
  inner join "wms"."pick_batches" as pick_batch on pick_batch_items.pick_batch_id = pick_batch.id
  inner join "wms"."sales_orders" as sales_order on pick_batch_items.sales_order_id = sales_order.id
where
  pick_batch_items.created_at >= $1::date
  and pick_batch_items.created_at <= $2::date
  and (pick_batch.batch_number ilike $3::text
  or sales_order.order_number ilike $3::text
  or $3::text is null)
`

type WmsRangePickBatchItemParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangePickBatchItemRow struct {
	WmsPickBatchItem WmsPickBatchItem
	WmsPickBatch     WmsPickBatch
	WmsSalesOrder    WmsSalesOrder
}

func (q *Queries) WmsRangePickBatchItem(ctx context.Context, arg WmsRangePickBatchItemParams) ([]WmsRangePickBatchItemRow, error) {
	rows, err := q.db.Query(ctx, wmsRangePickBatchItem, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangePickBatchItemRow
	for rows.Next() {
		var i WmsRangePickBatchItemRow
		if err := rows.Scan(
			&i.WmsPickBatchItem.ID,
			&i.WmsPickBatchItem.PickBatchID,
			&i.WmsPickBatchItem.SalesOrderID,
			&i.WmsPickBatchItem.OrderPriority,
			&i.WmsPickBatchItem.EstimatedPickTime,
			&i.WmsPickBatchItem.ActualPickTime,
			&i.WmsPickBatchItem.CreatedAt,
			&i.WmsPickBatchItem.UpdatedAt,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
			&i.WmsSalesOrder.ID,
			&i.WmsSalesOrder.OrderNumber,
			&i.WmsSalesOrder.ClientID,
			&i.WmsSalesOrder.CrmOpportunityID,
			&i.WmsSalesOrder.Status,
			&i.WmsSalesOrder.ShippingAddress,
			&i.WmsSalesOrder.CreatedAt,
			&i.WmsSalesOrder.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemovePickBatchItem = `-- name: WmsRemovePickBatchItem :exec
delete from "wms"."pick_batch_items"
where id = $1::uuid
`

func (q *Queries) WmsRemovePickBatchItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemovePickBatchItem, id)
	return err
}

const wmsUpdatePickBatchItem = `-- name: WmsUpdatePickBatchItem :one
update
  "wms"."pick_batch_items"
set
  updated_at = now(),
  pick_batch_id = case when $1::boolean then
    $2::uuid
  else
    pick_batch_id
  end,
  sales_order_id = case when $3::boolean then
    $4::uuid
  else
    sales_order_id
  end,
  order_priority = case when $5::boolean then
    $6::integer
  else
    order_priority
  end,
  estimated_pick_time = case when $7::boolean then
    $8::integer
  else
    estimated_pick_time
  end,
  actual_pick_time = case when $9::boolean then
    $10::integer
  else
    actual_pick_time
  end
where
  id = $11::uuid
returning
  id, pick_batch_id, sales_order_id, order_priority, estimated_pick_time, actual_pick_time, created_at, updated_at
`

type WmsUpdatePickBatchItemParams struct {
	SetPickBatchID       bool
	PickBatchID          pgtype.UUID
	SetSalesOrderID      bool
	SalesOrderID         pgtype.UUID
	SetOrderPriority     bool
	OrderPriority        int32
	SetEstimatedPickTime bool
	EstimatedPickTime    int32
	SetActualPickTime    bool
	ActualPickTime       int32
	ID                   pgtype.UUID
}

func (q *Queries) WmsUpdatePickBatchItem(ctx context.Context, arg WmsUpdatePickBatchItemParams) (WmsPickBatchItem, error) {
	row := q.db.QueryRow(ctx, wmsUpdatePickBatchItem,
		arg.SetPickBatchID,
		arg.PickBatchID,
		arg.SetSalesOrderID,
		arg.SalesOrderID,
		arg.SetOrderPriority,
		arg.OrderPriority,
		arg.SetEstimatedPickTime,
		arg.EstimatedPickTime,
		arg.SetActualPickTime,
		arg.ActualPickTime,
		arg.ID,
	)
	var i WmsPickBatchItem
	err := row.Scan(
		&i.ID,
		&i.PickBatchID,
		&i.SalesOrderID,
		&i.OrderPriority,
		&i.EstimatedPickTime,
		&i.ActualPickTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
