// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_pick_batch_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyPickBatchItem = `-- name: WmsAnyPickBatchItem :many
select
  pick_batch_items.id, pick_batch_items.pick_batch_id, pick_batch_items.sales_order_id, pick_batch_items.order_priority, pick_batch_items.estimated_pick_time, pick_batch_items.actual_pick_time, pick_batch_items.created_at, pick_batch_items.updated_at,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at
from
  "wms"."pick_batch_items" as pick_batch_items
  inner join "wms"."pick_batches" as pick_batch on pick_batch_items.pick_batch_id = pick_batch.id
  inner join "wms"."sales_orders" as sales_order on pick_batch_items.sales_order_id = sales_order.id
where
  pick_batch_items.id = any ($1::uuid[])
`

type WmsAnyPickBatchItemRow struct {
	WmsPickBatchItem WmsPickBatchItem `db:"wms_pick_batch_item" json:"wms_pick_batch_item"`
	WmsPickBatch     WmsPickBatch     `db:"wms_pick_batch" json:"wms_pick_batch"`
	WmsSalesOrder    WmsSalesOrder    `db:"wms_sales_order" json:"wms_sales_order"`
}

func (q *Queries) WmsAnyPickBatchItem(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyPickBatchItemRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyPickBatchItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyPickBatchItemRow
	for rows.Next() {
		var i WmsAnyPickBatchItemRow
		if err := rows.Scan(
			&i.WmsPickBatchItem.ID,
			&i.WmsPickBatchItem.PickBatchID,
			&i.WmsPickBatchItem.SalesOrderID,
			&i.WmsPickBatchItem.OrderPriority,
			&i.WmsPickBatchItem.EstimatedPickTime,
			&i.WmsPickBatchItem.ActualPickTime,
			&i.WmsPickBatchItem.CreatedAt,
			&i.WmsPickBatchItem.UpdatedAt,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
			&i.WmsSalesOrder.ID,
			&i.WmsSalesOrder.OrderNumber,
			&i.WmsSalesOrder.ClientID,
			&i.WmsSalesOrder.CrmOpportunityID,
			&i.WmsSalesOrder.Status,
			&i.WmsSalesOrder.ShippingAddress,
			&i.WmsSalesOrder.CreatedAt,
			&i.WmsSalesOrder.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindPickBatchItem = `-- name: WmsFindPickBatchItem :one
select
  pick_batch_items.id, pick_batch_items.pick_batch_id, pick_batch_items.sales_order_id, pick_batch_items.order_priority, pick_batch_items.estimated_pick_time, pick_batch_items.actual_pick_time, pick_batch_items.created_at, pick_batch_items.updated_at,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at
from
  "wms"."pick_batch_items" as pick_batch_items
  inner join "wms"."pick_batches" as pick_batch on pick_batch_items.pick_batch_id = pick_batch.id
  inner join "wms"."sales_orders" as sales_order on pick_batch_items.sales_order_id = sales_order.id
where
  pick_batch_items.id = $1::uuid
`

type WmsFindPickBatchItemRow struct {
	WmsPickBatchItem WmsPickBatchItem `db:"wms_pick_batch_item" json:"wms_pick_batch_item"`
	WmsPickBatch     WmsPickBatch     `db:"wms_pick_batch" json:"wms_pick_batch"`
	WmsSalesOrder    WmsSalesOrder    `db:"wms_sales_order" json:"wms_sales_order"`
}

func (q *Queries) WmsFindPickBatchItem(ctx context.Context, id pgtype.UUID) (WmsFindPickBatchItemRow, error) {
	row := q.db.QueryRow(ctx, wmsFindPickBatchItem, id)
	var i WmsFindPickBatchItemRow
	err := row.Scan(
		&i.WmsPickBatchItem.ID,
		&i.WmsPickBatchItem.PickBatchID,
		&i.WmsPickBatchItem.SalesOrderID,
		&i.WmsPickBatchItem.OrderPriority,
		&i.WmsPickBatchItem.EstimatedPickTime,
		&i.WmsPickBatchItem.ActualPickTime,
		&i.WmsPickBatchItem.CreatedAt,
		&i.WmsPickBatchItem.UpdatedAt,
		&i.WmsPickBatch.ID,
		&i.WmsPickBatch.BatchNumber,
		&i.WmsPickBatch.WarehouseID,
		&i.WmsPickBatch.Status,
		&i.WmsPickBatch.Strategy,
		&i.WmsPickBatch.Priority,
		&i.WmsPickBatch.AssignedUserID,
		&i.WmsPickBatch.WaveID,
		&i.WmsPickBatch.ZoneRestrictions,
		&i.WmsPickBatch.EstimatedDuration,
		&i.WmsPickBatch.ActualDuration,
		&i.WmsPickBatch.TotalItems,
		&i.WmsPickBatch.CompletedItems,
		&i.WmsPickBatch.StartedAt,
		&i.WmsPickBatch.CompletedAt,
		&i.WmsPickBatch.CreatedAt,
		&i.WmsPickBatch.UpdatedAt,
		&i.WmsSalesOrder.ID,
		&i.WmsSalesOrder.OrderNumber,
		&i.WmsSalesOrder.ClientID,
		&i.WmsSalesOrder.CrmOpportunityID,
		&i.WmsSalesOrder.Status,
		&i.WmsSalesOrder.ShippingAddress,
		&i.WmsSalesOrder.CreatedAt,
		&i.WmsSalesOrder.UpdatedAt,
	)
	return i, err
}

const wmsInsertPickBatchItem = `-- name: WmsInsertPickBatchItem :one
insert into "wms"."pick_batch_items"(pick_batch_id, sales_order_id, order_priority, estimated_pick_time, actual_pick_time)
  values ($1, $2, $3, $4, $5)
returning
  id, pick_batch_id, sales_order_id, order_priority, estimated_pick_time, actual_pick_time, created_at, updated_at
`

type WmsInsertPickBatchItemParams struct {
	PickBatchID       pgtype.UUID `db:"pick_batch_id" json:"pick_batch_id"`
	SalesOrderID      pgtype.UUID `db:"sales_order_id" json:"sales_order_id"`
	OrderPriority     pgtype.Int4 `db:"order_priority" json:"order_priority"`
	EstimatedPickTime pgtype.Int4 `db:"estimated_pick_time" json:"estimated_pick_time"`
	ActualPickTime    pgtype.Int4 `db:"actual_pick_time" json:"actual_pick_time"`
}

func (q *Queries) WmsInsertPickBatchItem(ctx context.Context, arg WmsInsertPickBatchItemParams) (WmsPickBatchItem, error) {
	row := q.db.QueryRow(ctx, wmsInsertPickBatchItem,
		arg.PickBatchID,
		arg.SalesOrderID,
		arg.OrderPriority,
		arg.EstimatedPickTime,
		arg.ActualPickTime,
	)
	var i WmsPickBatchItem
	err := row.Scan(
		&i.ID,
		&i.PickBatchID,
		&i.SalesOrderID,
		&i.OrderPriority,
		&i.EstimatedPickTime,
		&i.ActualPickTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginatePickBatchItem = `-- name: WmsPaginatePickBatchItem :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page,
  pick_batch_items.id, pick_batch_items.pick_batch_id, pick_batch_items.sales_order_id, pick_batch_items.order_priority, pick_batch_items.estimated_pick_time, pick_batch_items.actual_pick_time, pick_batch_items.created_at, pick_batch_items.updated_at,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at
from
  "wms"."pick_batch_items" as pick_batch_items
  inner join "wms"."pick_batches" as pick_batch on pick_batch_items.pick_batch_id = pick_batch.id
  inner join "wms"."sales_orders" as sales_order on pick_batch_items.sales_order_id = sales_order.id
where (pick_batch.batch_number ilike $3::text
  or sales_order.order_number ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type WmsPaginatePickBatchItemParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type WmsPaginatePickBatchItemRow struct {
	TotalItems       int64            `db:"total_items" json:"total_items"`
	TotalPages       float64          `db:"total_pages" json:"total_pages"`
	Page             int32            `db:"page" json:"page"`
	PerPage          int32            `db:"per_page" json:"per_page"`
	WmsPickBatchItem WmsPickBatchItem `db:"wms_pick_batch_item" json:"wms_pick_batch_item"`
	WmsPickBatch     WmsPickBatch     `db:"wms_pick_batch" json:"wms_pick_batch"`
	WmsSalesOrder    WmsSalesOrder    `db:"wms_sales_order" json:"wms_sales_order"`
}

func (q *Queries) WmsPaginatePickBatchItem(ctx context.Context, arg WmsPaginatePickBatchItemParams) ([]WmsPaginatePickBatchItemRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginatePickBatchItem, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginatePickBatchItemRow
	for rows.Next() {
		var i WmsPaginatePickBatchItemRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.WmsPickBatchItem.ID,
			&i.WmsPickBatchItem.PickBatchID,
			&i.WmsPickBatchItem.SalesOrderID,
			&i.WmsPickBatchItem.OrderPriority,
			&i.WmsPickBatchItem.EstimatedPickTime,
			&i.WmsPickBatchItem.ActualPickTime,
			&i.WmsPickBatchItem.CreatedAt,
			&i.WmsPickBatchItem.UpdatedAt,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
			&i.WmsSalesOrder.ID,
			&i.WmsSalesOrder.OrderNumber,
			&i.WmsSalesOrder.ClientID,
			&i.WmsSalesOrder.CrmOpportunityID,
			&i.WmsSalesOrder.Status,
			&i.WmsSalesOrder.ShippingAddress,
			&i.WmsSalesOrder.CreatedAt,
			&i.WmsSalesOrder.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangePickBatchItem = `-- name: WmsRangePickBatchItem :many
select
  pick_batch_items.id, pick_batch_items.pick_batch_id, pick_batch_items.sales_order_id, pick_batch_items.order_priority, pick_batch_items.estimated_pick_time, pick_batch_items.actual_pick_time, pick_batch_items.created_at, pick_batch_items.updated_at,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at
from
  "wms"."pick_batch_items" as pick_batch_items
  inner join "wms"."pick_batches" as pick_batch on pick_batch_items.pick_batch_id = pick_batch.id
  inner join "wms"."sales_orders" as sales_order on pick_batch_items.sales_order_id = sales_order.id
where
  pick_batch_items.created_at >= $1::date
  and pick_batch_items.created_at <= $2::date
  and (pick_batch.batch_number ilike $3::text
    or sales_order.order_number ilike $3::text
    or $3::text is null)
`

type WmsRangePickBatchItemParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangePickBatchItemRow struct {
	WmsPickBatchItem WmsPickBatchItem `db:"wms_pick_batch_item" json:"wms_pick_batch_item"`
	WmsPickBatch     WmsPickBatch     `db:"wms_pick_batch" json:"wms_pick_batch"`
	WmsSalesOrder    WmsSalesOrder    `db:"wms_sales_order" json:"wms_sales_order"`
}

func (q *Queries) WmsRangePickBatchItem(ctx context.Context, arg WmsRangePickBatchItemParams) ([]WmsRangePickBatchItemRow, error) {
	rows, err := q.db.Query(ctx, wmsRangePickBatchItem, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangePickBatchItemRow
	for rows.Next() {
		var i WmsRangePickBatchItemRow
		if err := rows.Scan(
			&i.WmsPickBatchItem.ID,
			&i.WmsPickBatchItem.PickBatchID,
			&i.WmsPickBatchItem.SalesOrderID,
			&i.WmsPickBatchItem.OrderPriority,
			&i.WmsPickBatchItem.EstimatedPickTime,
			&i.WmsPickBatchItem.ActualPickTime,
			&i.WmsPickBatchItem.CreatedAt,
			&i.WmsPickBatchItem.UpdatedAt,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
			&i.WmsSalesOrder.ID,
			&i.WmsSalesOrder.OrderNumber,
			&i.WmsSalesOrder.ClientID,
			&i.WmsSalesOrder.CrmOpportunityID,
			&i.WmsSalesOrder.Status,
			&i.WmsSalesOrder.ShippingAddress,
			&i.WmsSalesOrder.CreatedAt,
			&i.WmsSalesOrder.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemovePickBatchItem = `-- name: WmsRemovePickBatchItem :exec
delete from "wms"."pick_batch_items"
where id = $1::uuid
`

func (q *Queries) WmsRemovePickBatchItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemovePickBatchItem, id)
	return err
}

const wmsUpdatePickBatchItem = `-- name: WmsUpdatePickBatchItem :one
update
  "wms"."pick_batch_items"
set
  updated_at = now(),
  pick_batch_id = case when $1 is not null then
    $1::uuid
  else
    pick_batch_id
  end,
  sales_order_id = case when $2 is not null then
    $2::uuid
  else
    sales_order_id
  end,
  order_priority = case when $3 is not null then
    $3::integer
  else
    order_priority
  end,
  estimated_pick_time = case when $4 is not null then
    $4::integer
  else
    estimated_pick_time
  end,
  actual_pick_time = case when $5 is not null then
    $5::integer
  else
    actual_pick_time
  end
where
  id = $6::uuid
returning
  id, pick_batch_id, sales_order_id, order_priority, estimated_pick_time, actual_pick_time, created_at, updated_at
`

type WmsUpdatePickBatchItemParams struct {
	PickBatchID       pgtype.UUID `db:"pick_batch_id" json:"pick_batch_id"`
	SalesOrderID      pgtype.UUID `db:"sales_order_id" json:"sales_order_id"`
	OrderPriority     pgtype.Int4 `db:"order_priority" json:"order_priority"`
	EstimatedPickTime pgtype.Int4 `db:"estimated_pick_time" json:"estimated_pick_time"`
	ActualPickTime    pgtype.Int4 `db:"actual_pick_time" json:"actual_pick_time"`
	ID                pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) WmsUpdatePickBatchItem(ctx context.Context, arg WmsUpdatePickBatchItemParams) (WmsPickBatchItem, error) {
	row := q.db.QueryRow(ctx, wmsUpdatePickBatchItem,
		arg.PickBatchID,
		arg.SalesOrderID,
		arg.OrderPriority,
		arg.EstimatedPickTime,
		arg.ActualPickTime,
		arg.ID,
	)
	var i WmsPickBatchItem
	err := row.Scan(
		&i.ID,
		&i.PickBatchID,
		&i.SalesOrderID,
		&i.OrderPriority,
		&i.EstimatedPickTime,
		&i.ActualPickTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
