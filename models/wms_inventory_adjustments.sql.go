// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_inventory_adjustments.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyInventoryAdjustment = `-- name: WmsAnyInventoryAdjustment :many
select
  inventory_adjustments.id, inventory_adjustments.product_id, inventory_adjustments.warehouse_id, inventory_adjustments.user_id, inventory_adjustments.quantity_change, inventory_adjustments.reason, inventory_adjustments.notes, inventory_adjustments.created_at, inventory_adjustments.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "wms"."inventory_adjustments" as inventory_adjustments
  inner join "wms"."products" as product on inventory_adjustments.product_id = product.id
  inner join "public"."user" as users on inventory_adjustments.user_id = users.id
where
  inventory_adjustments.id = any ($1::uuid[])
`

type WmsAnyInventoryAdjustmentRow struct {
	WmsInventoryAdjustment WmsInventoryAdjustment
	WmsProduct             WmsProduct
	User                   User
}

func (q *Queries) WmsAnyInventoryAdjustment(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyInventoryAdjustmentRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyInventoryAdjustment, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyInventoryAdjustmentRow
	for rows.Next() {
		var i WmsAnyInventoryAdjustmentRow
		if err := rows.Scan(
			&i.WmsInventoryAdjustment.ID,
			&i.WmsInventoryAdjustment.ProductID,
			&i.WmsInventoryAdjustment.WarehouseID,
			&i.WmsInventoryAdjustment.UserID,
			&i.WmsInventoryAdjustment.QuantityChange,
			&i.WmsInventoryAdjustment.Reason,
			&i.WmsInventoryAdjustment.Notes,
			&i.WmsInventoryAdjustment.CreatedAt,
			&i.WmsInventoryAdjustment.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindInventoryAdjustment = `-- name: WmsFindInventoryAdjustment :one
select
  inventory_adjustments.id, inventory_adjustments.product_id, inventory_adjustments.warehouse_id, inventory_adjustments.user_id, inventory_adjustments.quantity_change, inventory_adjustments.reason, inventory_adjustments.notes, inventory_adjustments.created_at, inventory_adjustments.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "wms"."inventory_adjustments" as inventory_adjustments
  inner join "wms"."products" as product on inventory_adjustments.product_id = product.id
  inner join "public"."user" as users on inventory_adjustments.user_id = users.id
where
  inventory_adjustments.id = $1::uuid
`

type WmsFindInventoryAdjustmentRow struct {
	WmsInventoryAdjustment WmsInventoryAdjustment
	WmsProduct             WmsProduct
	User                   User
}

func (q *Queries) WmsFindInventoryAdjustment(ctx context.Context, id pgtype.UUID) (WmsFindInventoryAdjustmentRow, error) {
	row := q.db.QueryRow(ctx, wmsFindInventoryAdjustment, id)
	var i WmsFindInventoryAdjustmentRow
	err := row.Scan(
		&i.WmsInventoryAdjustment.ID,
		&i.WmsInventoryAdjustment.ProductID,
		&i.WmsInventoryAdjustment.WarehouseID,
		&i.WmsInventoryAdjustment.UserID,
		&i.WmsInventoryAdjustment.QuantityChange,
		&i.WmsInventoryAdjustment.Reason,
		&i.WmsInventoryAdjustment.Notes,
		&i.WmsInventoryAdjustment.CreatedAt,
		&i.WmsInventoryAdjustment.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const wmsInsertInventoryAdjustment = `-- name: WmsInsertInventoryAdjustment :one
insert into "wms"."inventory_adjustments"(product_id, warehouse_id, user_id, quantity_change, reason, notes)
  values ($1, $2, $3, $4, $5, $6)
returning
  id, product_id, warehouse_id, user_id, quantity_change, reason, notes, created_at, updated_at
`

type WmsInsertInventoryAdjustmentParams struct {
	ProductID      pgtype.UUID
	WarehouseID    pgtype.UUID
	UserID         string
	QuantityChange int32
	Reason         NullWmsInventoryAdjustmentReasonEnum
	Notes          pgtype.Text
}

func (q *Queries) WmsInsertInventoryAdjustment(ctx context.Context, arg WmsInsertInventoryAdjustmentParams) (WmsInventoryAdjustment, error) {
	row := q.db.QueryRow(ctx, wmsInsertInventoryAdjustment,
		arg.ProductID,
		arg.WarehouseID,
		arg.UserID,
		arg.QuantityChange,
		arg.Reason,
		arg.Notes,
	)
	var i WmsInventoryAdjustment
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.UserID,
		&i.QuantityChange,
		&i.Reason,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateInventoryAdjustment = `-- name: WmsPaginateInventoryAdjustment :many
select
  inventory_adjustments.id, inventory_adjustments.product_id, inventory_adjustments.warehouse_id, inventory_adjustments.user_id, inventory_adjustments.quantity_change, inventory_adjustments.reason, inventory_adjustments.notes, inventory_adjustments.created_at, inventory_adjustments.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "wms"."inventory_adjustments" as inventory_adjustments
  inner join "wms"."products" as product on inventory_adjustments.product_id = product.id
  inner join "public"."user" as users on inventory_adjustments.user_id = users.id
where (product.name ilike $1::text
  or users.name ilike $1::text
  or inventory_adjustments.reason::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateInventoryAdjustmentParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginateInventoryAdjustmentRow struct {
	WmsInventoryAdjustment WmsInventoryAdjustment
	WmsProduct             WmsProduct
	User                   User
}

func (q *Queries) WmsPaginateInventoryAdjustment(ctx context.Context, arg WmsPaginateInventoryAdjustmentParams) ([]WmsPaginateInventoryAdjustmentRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateInventoryAdjustment, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateInventoryAdjustmentRow
	for rows.Next() {
		var i WmsPaginateInventoryAdjustmentRow
		if err := rows.Scan(
			&i.WmsInventoryAdjustment.ID,
			&i.WmsInventoryAdjustment.ProductID,
			&i.WmsInventoryAdjustment.WarehouseID,
			&i.WmsInventoryAdjustment.UserID,
			&i.WmsInventoryAdjustment.QuantityChange,
			&i.WmsInventoryAdjustment.Reason,
			&i.WmsInventoryAdjustment.Notes,
			&i.WmsInventoryAdjustment.CreatedAt,
			&i.WmsInventoryAdjustment.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeInventoryAdjustment = `-- name: WmsRangeInventoryAdjustment :many
select
  inventory_adjustments.id, inventory_adjustments.product_id, inventory_adjustments.warehouse_id, inventory_adjustments.user_id, inventory_adjustments.quantity_change, inventory_adjustments.reason, inventory_adjustments.notes, inventory_adjustments.created_at, inventory_adjustments.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "wms"."inventory_adjustments" as inventory_adjustments
  inner join "wms"."products" as product on inventory_adjustments.product_id = product.id
  inner join "public"."user" as users on inventory_adjustments.user_id = users.id
where
  inventory_adjustments.created_at >= $1::date
  and inventory_adjustments.created_at <= $2::date
  and (product.name ilike $3::text
    or users.name ilike $3::text
    or inventory_adjustments.reason::text ilike $3::text
    or $3::text is null)
`

type WmsRangeInventoryAdjustmentParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangeInventoryAdjustmentRow struct {
	WmsInventoryAdjustment WmsInventoryAdjustment
	WmsProduct             WmsProduct
	User                   User
}

func (q *Queries) WmsRangeInventoryAdjustment(ctx context.Context, arg WmsRangeInventoryAdjustmentParams) ([]WmsRangeInventoryAdjustmentRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeInventoryAdjustment, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeInventoryAdjustmentRow
	for rows.Next() {
		var i WmsRangeInventoryAdjustmentRow
		if err := rows.Scan(
			&i.WmsInventoryAdjustment.ID,
			&i.WmsInventoryAdjustment.ProductID,
			&i.WmsInventoryAdjustment.WarehouseID,
			&i.WmsInventoryAdjustment.UserID,
			&i.WmsInventoryAdjustment.QuantityChange,
			&i.WmsInventoryAdjustment.Reason,
			&i.WmsInventoryAdjustment.Notes,
			&i.WmsInventoryAdjustment.CreatedAt,
			&i.WmsInventoryAdjustment.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveInventoryAdjustment = `-- name: WmsRemoveInventoryAdjustment :exec
delete from "wms"."inventory_adjustments"
where id = $1::uuid
`

func (q *Queries) WmsRemoveInventoryAdjustment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveInventoryAdjustment, id)
	return err
}

const wmsUpdateInventoryAdjustment = `-- name: WmsUpdateInventoryAdjustment :one
update
  "wms"."inventory_adjustments"
set
  updated_at = now(),
  product_id = case when $1 is not null then
    $1::uuid
  else
    product_id
  end,
  warehouse_id = case when $2 is not null then
    $2::uuid
  else
    warehouse_id
  end,
  user_id = case when $3 is not null then
    $3::text
  else
    user_id
  end,
  quantity_change = case when $4 is not null then
    $4::integer
  else
    quantity_change
  end,
  reason = case when $5 is not null then
    $5::wms.inventory_adjustment_reason_enum
  else
    reason
  end,
  notes = case when $6 is not null then
    $6::text
  else
    notes
  end
where
  id = $7::uuid
returning
  id, product_id, warehouse_id, user_id, quantity_change, reason, notes, created_at, updated_at
`

type WmsUpdateInventoryAdjustmentParams struct {
	ProductID      pgtype.UUID
	WarehouseID    pgtype.UUID
	UserID         string
	QuantityChange int32
	Reason         NullWmsInventoryAdjustmentReasonEnum
	Notes          pgtype.Text
	ID             pgtype.UUID
}

func (q *Queries) WmsUpdateInventoryAdjustment(ctx context.Context, arg WmsUpdateInventoryAdjustmentParams) (WmsInventoryAdjustment, error) {
	row := q.db.QueryRow(ctx, wmsUpdateInventoryAdjustment,
		arg.ProductID,
		arg.WarehouseID,
		arg.UserID,
		arg.QuantityChange,
		arg.Reason,
		arg.Notes,
		arg.ID,
	)
	var i WmsInventoryAdjustment
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.UserID,
		&i.QuantityChange,
		&i.Reason,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
