// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_return_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyReturnItem = `-- name: WmsAnyReturnItem :many
select
  return_items.id, return_items.return_id, return_items.product_id, return_items.quantity_expected, return_items.quantity_received, return_items.quantity_variance, return_items.condition, return_items.created_at, return_items.updated_at,
  return.id, return.return_number, return.sales_order_id, return.client_id, return.status, return.reason, return.created_at, return.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."return_items" as return_items
  inner join "wms"."returns" as return on return_items.return_id = return.id
  inner join "wms"."products" as product on return_items.product_id = product.id
where
  return_items.id = any ($1::uuid[])
`

type WmsAnyReturnItemRow struct {
	WmsReturnItem WmsReturnItem
	WmsReturn     WmsReturn
	WmsProduct    WmsProduct
}

func (q *Queries) WmsAnyReturnItem(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyReturnItemRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyReturnItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyReturnItemRow
	for rows.Next() {
		var i WmsAnyReturnItemRow
		if err := rows.Scan(
			&i.WmsReturnItem.ID,
			&i.WmsReturnItem.ReturnID,
			&i.WmsReturnItem.ProductID,
			&i.WmsReturnItem.QuantityExpected,
			&i.WmsReturnItem.QuantityReceived,
			&i.WmsReturnItem.QuantityVariance,
			&i.WmsReturnItem.Condition,
			&i.WmsReturnItem.CreatedAt,
			&i.WmsReturnItem.UpdatedAt,
			&i.WmsReturn.ID,
			&i.WmsReturn.ReturnNumber,
			&i.WmsReturn.SalesOrderID,
			&i.WmsReturn.ClientID,
			&i.WmsReturn.Status,
			&i.WmsReturn.Reason,
			&i.WmsReturn.CreatedAt,
			&i.WmsReturn.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindReturnItem = `-- name: WmsFindReturnItem :one
select
  return_items.id, return_items.return_id, return_items.product_id, return_items.quantity_expected, return_items.quantity_received, return_items.quantity_variance, return_items.condition, return_items.created_at, return_items.updated_at,
  return.id, return.return_number, return.sales_order_id, return.client_id, return.status, return.reason, return.created_at, return.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."return_items" as return_items
  inner join "wms"."returns" as return on return_items.return_id = return.id
  inner join "wms"."products" as product on return_items.product_id = product.id
where
  return_items.id = $1::uuid
`

type WmsFindReturnItemRow struct {
	WmsReturnItem WmsReturnItem
	WmsReturn     WmsReturn
	WmsProduct    WmsProduct
}

func (q *Queries) WmsFindReturnItem(ctx context.Context, id pgtype.UUID) (WmsFindReturnItemRow, error) {
	row := q.db.QueryRow(ctx, wmsFindReturnItem, id)
	var i WmsFindReturnItemRow
	err := row.Scan(
		&i.WmsReturnItem.ID,
		&i.WmsReturnItem.ReturnID,
		&i.WmsReturnItem.ProductID,
		&i.WmsReturnItem.QuantityExpected,
		&i.WmsReturnItem.QuantityReceived,
		&i.WmsReturnItem.QuantityVariance,
		&i.WmsReturnItem.Condition,
		&i.WmsReturnItem.CreatedAt,
		&i.WmsReturnItem.UpdatedAt,
		&i.WmsReturn.ID,
		&i.WmsReturn.ReturnNumber,
		&i.WmsReturn.SalesOrderID,
		&i.WmsReturn.ClientID,
		&i.WmsReturn.Status,
		&i.WmsReturn.Reason,
		&i.WmsReturn.CreatedAt,
		&i.WmsReturn.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
	)
	return i, err
}

const wmsInsertReturnItem = `-- name: WmsInsertReturnItem :one
insert into "wms"."return_items"(return_id, product_id, quantity_expected, quantity_received, condition)
  values ($1, $2, $3, $4, $5)
returning
  id, return_id, product_id, quantity_expected, quantity_received, quantity_variance, condition, created_at, updated_at
`

type WmsInsertReturnItemParams struct {
	ReturnID         pgtype.UUID
	ProductID        pgtype.UUID
	QuantityExpected int32
	QuantityReceived pgtype.Int4
	Condition        NullWmsReturnItemConditionEnum
}

func (q *Queries) WmsInsertReturnItem(ctx context.Context, arg WmsInsertReturnItemParams) (WmsReturnItem, error) {
	row := q.db.QueryRow(ctx, wmsInsertReturnItem,
		arg.ReturnID,
		arg.ProductID,
		arg.QuantityExpected,
		arg.QuantityReceived,
		arg.Condition,
	)
	var i WmsReturnItem
	err := row.Scan(
		&i.ID,
		&i.ReturnID,
		&i.ProductID,
		&i.QuantityExpected,
		&i.QuantityReceived,
		&i.QuantityVariance,
		&i.Condition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateReturnItem = `-- name: WmsPaginateReturnItem :many
select
  return_items.id, return_items.return_id, return_items.product_id, return_items.quantity_expected, return_items.quantity_received, return_items.quantity_variance, return_items.condition, return_items.created_at, return_items.updated_at,
  return.id, return.return_number, return.sales_order_id, return.client_id, return.status, return.reason, return.created_at, return.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."return_items" as return_items
  inner join "wms"."returns" as return on return_items.return_id = return.id
  inner join "wms"."products" as product on return_items.product_id = product.id
where
  (return.return_number ilike $1::text
  or product.name ilike $1::text
  or return_items.condition::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateReturnItemParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginateReturnItemRow struct {
	WmsReturnItem WmsReturnItem
	WmsReturn     WmsReturn
	WmsProduct    WmsProduct
}

func (q *Queries) WmsPaginateReturnItem(ctx context.Context, arg WmsPaginateReturnItemParams) ([]WmsPaginateReturnItemRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateReturnItem, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateReturnItemRow
	for rows.Next() {
		var i WmsPaginateReturnItemRow
		if err := rows.Scan(
			&i.WmsReturnItem.ID,
			&i.WmsReturnItem.ReturnID,
			&i.WmsReturnItem.ProductID,
			&i.WmsReturnItem.QuantityExpected,
			&i.WmsReturnItem.QuantityReceived,
			&i.WmsReturnItem.QuantityVariance,
			&i.WmsReturnItem.Condition,
			&i.WmsReturnItem.CreatedAt,
			&i.WmsReturnItem.UpdatedAt,
			&i.WmsReturn.ID,
			&i.WmsReturn.ReturnNumber,
			&i.WmsReturn.SalesOrderID,
			&i.WmsReturn.ClientID,
			&i.WmsReturn.Status,
			&i.WmsReturn.Reason,
			&i.WmsReturn.CreatedAt,
			&i.WmsReturn.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeReturnItem = `-- name: WmsRangeReturnItem :many
select
  return_items.id, return_items.return_id, return_items.product_id, return_items.quantity_expected, return_items.quantity_received, return_items.quantity_variance, return_items.condition, return_items.created_at, return_items.updated_at,
  return.id, return.return_number, return.sales_order_id, return.client_id, return.status, return.reason, return.created_at, return.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."return_items" as return_items
  inner join "wms"."returns" as return on return_items.return_id = return.id
  inner join "wms"."products" as product on return_items.product_id = product.id
where
  return_items.created_at >= $1::date
  and return_items.created_at <= $2::date
  and (return.return_number ilike $3::text
  or product.name ilike $3::text
  or return_items.condition::text ilike $3::text
  or $3::text is null)
`

type WmsRangeReturnItemParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangeReturnItemRow struct {
	WmsReturnItem WmsReturnItem
	WmsReturn     WmsReturn
	WmsProduct    WmsProduct
}

func (q *Queries) WmsRangeReturnItem(ctx context.Context, arg WmsRangeReturnItemParams) ([]WmsRangeReturnItemRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeReturnItem, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeReturnItemRow
	for rows.Next() {
		var i WmsRangeReturnItemRow
		if err := rows.Scan(
			&i.WmsReturnItem.ID,
			&i.WmsReturnItem.ReturnID,
			&i.WmsReturnItem.ProductID,
			&i.WmsReturnItem.QuantityExpected,
			&i.WmsReturnItem.QuantityReceived,
			&i.WmsReturnItem.QuantityVariance,
			&i.WmsReturnItem.Condition,
			&i.WmsReturnItem.CreatedAt,
			&i.WmsReturnItem.UpdatedAt,
			&i.WmsReturn.ID,
			&i.WmsReturn.ReturnNumber,
			&i.WmsReturn.SalesOrderID,
			&i.WmsReturn.ClientID,
			&i.WmsReturn.Status,
			&i.WmsReturn.Reason,
			&i.WmsReturn.CreatedAt,
			&i.WmsReturn.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveReturnItem = `-- name: WmsRemoveReturnItem :exec
delete from "wms"."return_items"
where id = $1::uuid
`

func (q *Queries) WmsRemoveReturnItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveReturnItem, id)
	return err
}

const wmsUpdateReturnItem = `-- name: WmsUpdateReturnItem :one
update
  "wms"."return_items"
set
  return_id = case when $1::boolean then
    $2::uuid
  else
    return_id
  end,
  product_id = case when $3::boolean then
    $4::uuid
  else
    product_id
  end,
  quantity_expected = case when $5::boolean then
    $6::integer
  else
    quantity_expected
  end,
  quantity_received = case when $7::boolean then
    $8::integer
  else
    quantity_received
  end,
  condition = case when $9::boolean then
    $10::wms.return_item_condition_enum
  else
    condition
  end
where
  id = $11::uuid
returning
  id, return_id, product_id, quantity_expected, quantity_received, quantity_variance, condition, created_at, updated_at
`

type WmsUpdateReturnItemParams struct {
	SetReturnID         bool
	ReturnID            pgtype.UUID
	SetProductID        bool
	ProductID           pgtype.UUID
	SetQuantityExpected bool
	QuantityExpected    int32
	SetQuantityReceived bool
	QuantityReceived    int32
	SetCondition        bool
	Condition           WmsReturnItemConditionEnum
	ID                  pgtype.UUID
}

func (q *Queries) WmsUpdateReturnItem(ctx context.Context, arg WmsUpdateReturnItemParams) (WmsReturnItem, error) {
	row := q.db.QueryRow(ctx, wmsUpdateReturnItem,
		arg.SetReturnID,
		arg.ReturnID,
		arg.SetProductID,
		arg.ProductID,
		arg.SetQuantityExpected,
		arg.QuantityExpected,
		arg.SetQuantityReceived,
		arg.QuantityReceived,
		arg.SetCondition,
		arg.Condition,
		arg.ID,
	)
	var i WmsReturnItem
	err := row.Scan(
		&i.ID,
		&i.ReturnID,
		&i.ProductID,
		&i.QuantityExpected,
		&i.QuantityReceived,
		&i.QuantityVariance,
		&i.Condition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
