// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_opportunities.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyOpportunity = `-- name: CrmAnyOpportunity :many
select
  opportunities.id, opportunities.name, opportunities.stage, opportunities.deal_value, opportunities.probability, opportunities.expected_close_date, opportunities.lost_reason, opportunities.source, opportunities.owner_id, opportunities.contact_id, opportunities.company_id, opportunities.campaign_id, opportunities.created_at, opportunities.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at,
  company.id, company.name, company.street, company.city, company.state, company.postal_code, company.country, company.phone_number, company.industry, company.website, company.annual_revenue, company.owner_id, company.created_at, company.updated_at,
  campaign.id, campaign.name, campaign.budget, campaign.start_date, campaign.end_date, campaign.created_at, campaign.updated_at
from
  "crm"."opportunities" as opportunities
  inner join "public"."user" as owner on opportunities.owner_id = owner.id
  left join "crm"."contacts" as contact on opportunities.contact_id = contact.id
  left join "crm"."companies" as company on opportunities.company_id = company.id
  left join "crm"."campaigns" as campaign on opportunities.campaign_id = campaign.id
where
  opportunities.id = any ($1::uuid[])
`

type CrmAnyOpportunityRow struct {
	CrmOpportunity CrmOpportunity
	User           User
	CrmContact     CrmContact
	CrmCompany     CrmCompany
	CrmCampaign    CrmCampaign
}

func (q *Queries) CrmAnyOpportunity(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyOpportunityRow, error) {
	rows, err := q.db.Query(ctx, crmAnyOpportunity, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyOpportunityRow
	for rows.Next() {
		var i CrmAnyOpportunityRow
		if err := rows.Scan(
			&i.CrmOpportunity.ID,
			&i.CrmOpportunity.Name,
			&i.CrmOpportunity.Stage,
			&i.CrmOpportunity.DealValue,
			&i.CrmOpportunity.Probability,
			&i.CrmOpportunity.ExpectedCloseDate,
			&i.CrmOpportunity.LostReason,
			&i.CrmOpportunity.Source,
			&i.CrmOpportunity.OwnerID,
			&i.CrmOpportunity.ContactID,
			&i.CrmOpportunity.CompanyID,
			&i.CrmOpportunity.CampaignID,
			&i.CrmOpportunity.CreatedAt,
			&i.CrmOpportunity.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.CrmCampaign.ID,
			&i.CrmCampaign.Name,
			&i.CrmCampaign.Budget,
			&i.CrmCampaign.StartDate,
			&i.CrmCampaign.EndDate,
			&i.CrmCampaign.CreatedAt,
			&i.CrmCampaign.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindOpportunity = `-- name: CrmFindOpportunity :one
select
  opportunities.id, opportunities.name, opportunities.stage, opportunities.deal_value, opportunities.probability, opportunities.expected_close_date, opportunities.lost_reason, opportunities.source, opportunities.owner_id, opportunities.contact_id, opportunities.company_id, opportunities.campaign_id, opportunities.created_at, opportunities.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at,
  company.id, company.name, company.street, company.city, company.state, company.postal_code, company.country, company.phone_number, company.industry, company.website, company.annual_revenue, company.owner_id, company.created_at, company.updated_at,
  campaign.id, campaign.name, campaign.budget, campaign.start_date, campaign.end_date, campaign.created_at, campaign.updated_at
from
  "crm"."opportunities" as opportunities
  inner join "public"."user" as owner on opportunities.owner_id = owner.id
  left join "crm"."contacts" as contact on opportunities.contact_id = contact.id
  left join "crm"."companies" as company on opportunities.company_id = company.id
  left join "crm"."campaigns" as campaign on opportunities.campaign_id = campaign.id
where
  opportunities.id = $1::uuid
`

type CrmFindOpportunityRow struct {
	CrmOpportunity CrmOpportunity
	User           User
	CrmContact     CrmContact
	CrmCompany     CrmCompany
	CrmCampaign    CrmCampaign
}

func (q *Queries) CrmFindOpportunity(ctx context.Context, id pgtype.UUID) (CrmFindOpportunityRow, error) {
	row := q.db.QueryRow(ctx, crmFindOpportunity, id)
	var i CrmFindOpportunityRow
	err := row.Scan(
		&i.CrmOpportunity.ID,
		&i.CrmOpportunity.Name,
		&i.CrmOpportunity.Stage,
		&i.CrmOpportunity.DealValue,
		&i.CrmOpportunity.Probability,
		&i.CrmOpportunity.ExpectedCloseDate,
		&i.CrmOpportunity.LostReason,
		&i.CrmOpportunity.Source,
		&i.CrmOpportunity.OwnerID,
		&i.CrmOpportunity.ContactID,
		&i.CrmOpportunity.CompanyID,
		&i.CrmOpportunity.CampaignID,
		&i.CrmOpportunity.CreatedAt,
		&i.CrmOpportunity.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
		&i.CrmContact.ID,
		&i.CrmContact.Name,
		&i.CrmContact.Email,
		&i.CrmContact.PhoneNumber,
		&i.CrmContact.JobTitle,
		&i.CrmContact.CompanyID,
		&i.CrmContact.OwnerID,
		&i.CrmContact.CreatedAt,
		&i.CrmContact.UpdatedAt,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
		&i.CrmCampaign.ID,
		&i.CrmCampaign.Name,
		&i.CrmCampaign.Budget,
		&i.CrmCampaign.StartDate,
		&i.CrmCampaign.EndDate,
		&i.CrmCampaign.CreatedAt,
		&i.CrmCampaign.UpdatedAt,
	)
	return i, err
}

const crmInsertOpportunity = `-- name: CrmInsertOpportunity :one
insert into "crm"."opportunities"(name, stage, deal_value, probability, expected_close_date, lost_reason, source, owner_id, contact_id, company_id, campaign_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning
  id, name, stage, deal_value, probability, expected_close_date, lost_reason, source, owner_id, contact_id, company_id, campaign_id, created_at, updated_at
`

type CrmInsertOpportunityParams struct {
	Name              string
	Stage             NullCrmOpportunityStage
	DealValue         pgtype.Numeric
	Probability       pgtype.Float4
	ExpectedCloseDate pgtype.Date
	LostReason        pgtype.Text
	Source            NullCrmOpportunitySource
	OwnerID           string
	ContactID         pgtype.UUID
	CompanyID         pgtype.UUID
	CampaignID        pgtype.UUID
}

func (q *Queries) CrmInsertOpportunity(ctx context.Context, arg CrmInsertOpportunityParams) (CrmOpportunity, error) {
	row := q.db.QueryRow(ctx, crmInsertOpportunity,
		arg.Name,
		arg.Stage,
		arg.DealValue,
		arg.Probability,
		arg.ExpectedCloseDate,
		arg.LostReason,
		arg.Source,
		arg.OwnerID,
		arg.ContactID,
		arg.CompanyID,
		arg.CampaignID,
	)
	var i CrmOpportunity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Stage,
		&i.DealValue,
		&i.Probability,
		&i.ExpectedCloseDate,
		&i.LostReason,
		&i.Source,
		&i.OwnerID,
		&i.ContactID,
		&i.CompanyID,
		&i.CampaignID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateOpportunity = `-- name: CrmPaginateOpportunity :many
select
  opportunities.id, opportunities.name, opportunities.stage, opportunities.deal_value, opportunities.probability, opportunities.expected_close_date, opportunities.lost_reason, opportunities.source, opportunities.owner_id, opportunities.contact_id, opportunities.company_id, opportunities.campaign_id, opportunities.created_at, opportunities.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at,
  company.id, company.name, company.street, company.city, company.state, company.postal_code, company.country, company.phone_number, company.industry, company.website, company.annual_revenue, company.owner_id, company.created_at, company.updated_at,
  campaign.id, campaign.name, campaign.budget, campaign.start_date, campaign.end_date, campaign.created_at, campaign.updated_at
from
  "crm"."opportunities" as opportunities
  inner join "public"."user" as owner on opportunities.owner_id = owner.id
  left join "crm"."contacts" as contact on opportunities.contact_id = contact.id
  left join "crm"."companies" as company on opportunities.company_id = company.id
  left join "crm"."campaigns" as campaign on opportunities.campaign_id = campaign.id
where (opportunities.name ilike $1::text
  or opportunities.stage::text ilike $1::text
  or owner.name ilike $1::text
  or company.name ilike $1::text
  or contact.name ilike $1::text
  or campaign.name ilike $1::text
  or opportunities.source::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateOpportunityParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type CrmPaginateOpportunityRow struct {
	CrmOpportunity CrmOpportunity
	User           User
	CrmContact     CrmContact
	CrmCompany     CrmCompany
	CrmCampaign    CrmCampaign
}

func (q *Queries) CrmPaginateOpportunity(ctx context.Context, arg CrmPaginateOpportunityParams) ([]CrmPaginateOpportunityRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateOpportunity, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateOpportunityRow
	for rows.Next() {
		var i CrmPaginateOpportunityRow
		if err := rows.Scan(
			&i.CrmOpportunity.ID,
			&i.CrmOpportunity.Name,
			&i.CrmOpportunity.Stage,
			&i.CrmOpportunity.DealValue,
			&i.CrmOpportunity.Probability,
			&i.CrmOpportunity.ExpectedCloseDate,
			&i.CrmOpportunity.LostReason,
			&i.CrmOpportunity.Source,
			&i.CrmOpportunity.OwnerID,
			&i.CrmOpportunity.ContactID,
			&i.CrmOpportunity.CompanyID,
			&i.CrmOpportunity.CampaignID,
			&i.CrmOpportunity.CreatedAt,
			&i.CrmOpportunity.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.CrmCampaign.ID,
			&i.CrmCampaign.Name,
			&i.CrmCampaign.Budget,
			&i.CrmCampaign.StartDate,
			&i.CrmCampaign.EndDate,
			&i.CrmCampaign.CreatedAt,
			&i.CrmCampaign.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeOpportunity = `-- name: CrmRangeOpportunity :many
select
  opportunities.id, opportunities.name, opportunities.stage, opportunities.deal_value, opportunities.probability, opportunities.expected_close_date, opportunities.lost_reason, opportunities.source, opportunities.owner_id, opportunities.contact_id, opportunities.company_id, opportunities.campaign_id, opportunities.created_at, opportunities.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at,
  company.id, company.name, company.street, company.city, company.state, company.postal_code, company.country, company.phone_number, company.industry, company.website, company.annual_revenue, company.owner_id, company.created_at, company.updated_at,
  campaign.id, campaign.name, campaign.budget, campaign.start_date, campaign.end_date, campaign.created_at, campaign.updated_at
from
  "crm"."opportunities" as opportunities
  inner join "public"."user" as owner on opportunities.owner_id = owner.id
  left join "crm"."contacts" as contact on opportunities.contact_id = contact.id
  left join "crm"."companies" as company on opportunities.company_id = company.id
  left join "crm"."campaigns" as campaign on opportunities.campaign_id = campaign.id
where
  opportunities.created_at >= $1::date
  and opportunities.created_at <= $2::date
  and (opportunities.name ilike $3::text
    or opportunities.stage::text ilike $3::text
    or owner.name ilike $3::text
    or company.name ilike $3::text
    or contact.name ilike $3::text
    or campaign.name ilike $3::text
    or opportunities.source::text ilike $3::text
    or $3::text is null)
`

type CrmRangeOpportunityParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type CrmRangeOpportunityRow struct {
	CrmOpportunity CrmOpportunity
	User           User
	CrmContact     CrmContact
	CrmCompany     CrmCompany
	CrmCampaign    CrmCampaign
}

func (q *Queries) CrmRangeOpportunity(ctx context.Context, arg CrmRangeOpportunityParams) ([]CrmRangeOpportunityRow, error) {
	rows, err := q.db.Query(ctx, crmRangeOpportunity, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeOpportunityRow
	for rows.Next() {
		var i CrmRangeOpportunityRow
		if err := rows.Scan(
			&i.CrmOpportunity.ID,
			&i.CrmOpportunity.Name,
			&i.CrmOpportunity.Stage,
			&i.CrmOpportunity.DealValue,
			&i.CrmOpportunity.Probability,
			&i.CrmOpportunity.ExpectedCloseDate,
			&i.CrmOpportunity.LostReason,
			&i.CrmOpportunity.Source,
			&i.CrmOpportunity.OwnerID,
			&i.CrmOpportunity.ContactID,
			&i.CrmOpportunity.CompanyID,
			&i.CrmOpportunity.CampaignID,
			&i.CrmOpportunity.CreatedAt,
			&i.CrmOpportunity.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.CrmCampaign.ID,
			&i.CrmCampaign.Name,
			&i.CrmCampaign.Budget,
			&i.CrmCampaign.StartDate,
			&i.CrmCampaign.EndDate,
			&i.CrmCampaign.CreatedAt,
			&i.CrmCampaign.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveOpportunity = `-- name: CrmRemoveOpportunity :exec
delete from "crm"."opportunities"
where id = $1::uuid
`

func (q *Queries) CrmRemoveOpportunity(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveOpportunity, id)
	return err
}

const crmUpdateOpportunity = `-- name: CrmUpdateOpportunity :one
update
  "crm"."opportunities"
set
  name = case when $1::boolean then
    $2::text
  else
    name
  end,
  stage = case when $3::boolean then
    $4::crm.opportunity_stage
  else
    stage
  end,
  deal_value = case when $5::boolean then
    $6::numeric
  else
    deal_value
  end,
  probability = case when $7::boolean then
    $8::real
  else
    probability
  end,
  expected_close_date = case when $9::boolean then
    $10::date
  else
    expected_close_date
  end,
  lost_reason = case when $11::boolean then
    $12::text
  else
    lost_reason
  end,
  source = case when $13::boolean then
    $14::crm.opportunity_source
  else
    source
  end,
  owner_id = case when $15::boolean then
    $16::text
  else
    owner_id
  end,
  contact_id = case when $17::boolean then
    $18::uuid
  else
    contact_id
  end,
  company_id = case when $19::boolean then
    $20::uuid
  else
    company_id
  end,
  campaign_id = case when $21::boolean then
    $22::uuid
  else
    campaign_id
  end
where
  id = $23::uuid
returning
  id, name, stage, deal_value, probability, expected_close_date, lost_reason, source, owner_id, contact_id, company_id, campaign_id, created_at, updated_at
`

type CrmUpdateOpportunityParams struct {
	SetName              bool
	Name                 string
	SetStage             bool
	Stage                CrmOpportunityStage
	SetDealValue         bool
	DealValue            pgtype.Numeric
	SetProbability       bool
	Probability          float32
	SetExpectedCloseDate bool
	ExpectedCloseDate    pgtype.Date
	SetLostReason        bool
	LostReason           string
	SetSource            bool
	Source               CrmOpportunitySource
	SetOwnerID           bool
	OwnerID              string
	SetContactID         bool
	ContactID            pgtype.UUID
	SetCompanyID         bool
	CompanyID            pgtype.UUID
	SetCampaignID        bool
	CampaignID           pgtype.UUID
	ID                   pgtype.UUID
}

func (q *Queries) CrmUpdateOpportunity(ctx context.Context, arg CrmUpdateOpportunityParams) (CrmOpportunity, error) {
	row := q.db.QueryRow(ctx, crmUpdateOpportunity,
		arg.SetName,
		arg.Name,
		arg.SetStage,
		arg.Stage,
		arg.SetDealValue,
		arg.DealValue,
		arg.SetProbability,
		arg.Probability,
		arg.SetExpectedCloseDate,
		arg.ExpectedCloseDate,
		arg.SetLostReason,
		arg.LostReason,
		arg.SetSource,
		arg.Source,
		arg.SetOwnerID,
		arg.OwnerID,
		arg.SetContactID,
		arg.ContactID,
		arg.SetCompanyID,
		arg.CompanyID,
		arg.SetCampaignID,
		arg.CampaignID,
		arg.ID,
	)
	var i CrmOpportunity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Stage,
		&i.DealValue,
		&i.Probability,
		&i.ExpectedCloseDate,
		&i.LostReason,
		&i.Source,
		&i.OwnerID,
		&i.ContactID,
		&i.CompanyID,
		&i.CampaignID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
