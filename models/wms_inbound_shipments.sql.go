// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_inbound_shipments.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyInboundShipment = `-- name: WmsAnyInboundShipment :many
select
  inbound_shipments.id, inbound_shipments.client_id, inbound_shipments.warehouse_id, inbound_shipments.status, inbound_shipments.expected_arrival_date, inbound_shipments.actual_arrival_date, inbound_shipments.created_at, inbound_shipments.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."inbound_shipments" as inbound_shipments
  left join "crm"."companies" as client on inbound_shipments.client_id = client.id
where
  inbound_shipments.id = any ($1::uuid[])
`

type WmsAnyInboundShipmentRow struct {
	WmsInboundShipment WmsInboundShipment
	CrmCompany         CrmCompany
}

func (q *Queries) WmsAnyInboundShipment(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyInboundShipmentRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyInboundShipment, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyInboundShipmentRow
	for rows.Next() {
		var i WmsAnyInboundShipmentRow
		if err := rows.Scan(
			&i.WmsInboundShipment.ID,
			&i.WmsInboundShipment.ClientID,
			&i.WmsInboundShipment.WarehouseID,
			&i.WmsInboundShipment.Status,
			&i.WmsInboundShipment.ExpectedArrivalDate,
			&i.WmsInboundShipment.ActualArrivalDate,
			&i.WmsInboundShipment.CreatedAt,
			&i.WmsInboundShipment.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindInboundShipment = `-- name: WmsFindInboundShipment :one
select
  inbound_shipments.id, inbound_shipments.client_id, inbound_shipments.warehouse_id, inbound_shipments.status, inbound_shipments.expected_arrival_date, inbound_shipments.actual_arrival_date, inbound_shipments.created_at, inbound_shipments.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."inbound_shipments" as inbound_shipments
  left join "crm"."companies" as client on inbound_shipments.client_id = client.id
where
  inbound_shipments.id = $1::uuid
`

type WmsFindInboundShipmentRow struct {
	WmsInboundShipment WmsInboundShipment
	CrmCompany         CrmCompany
}

func (q *Queries) WmsFindInboundShipment(ctx context.Context, id pgtype.UUID) (WmsFindInboundShipmentRow, error) {
	row := q.db.QueryRow(ctx, wmsFindInboundShipment, id)
	var i WmsFindInboundShipmentRow
	err := row.Scan(
		&i.WmsInboundShipment.ID,
		&i.WmsInboundShipment.ClientID,
		&i.WmsInboundShipment.WarehouseID,
		&i.WmsInboundShipment.Status,
		&i.WmsInboundShipment.ExpectedArrivalDate,
		&i.WmsInboundShipment.ActualArrivalDate,
		&i.WmsInboundShipment.CreatedAt,
		&i.WmsInboundShipment.UpdatedAt,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
	)
	return i, err
}

const wmsInsertInboundShipment = `-- name: WmsInsertInboundShipment :one
insert into "wms"."inbound_shipments"(client_id, warehouse_id, status, expected_arrival_date, actual_arrival_date)
  values ($1, $2, $3, $4, $5)
returning
  id, client_id, warehouse_id, status, expected_arrival_date, actual_arrival_date, created_at, updated_at
`

type WmsInsertInboundShipmentParams struct {
	ClientID            pgtype.UUID
	WarehouseID         pgtype.UUID
	Status              NullWmsInboundShipmentStatusEnum
	ExpectedArrivalDate pgtype.Date
	ActualArrivalDate   pgtype.Date
}

func (q *Queries) WmsInsertInboundShipment(ctx context.Context, arg WmsInsertInboundShipmentParams) (WmsInboundShipment, error) {
	row := q.db.QueryRow(ctx, wmsInsertInboundShipment,
		arg.ClientID,
		arg.WarehouseID,
		arg.Status,
		arg.ExpectedArrivalDate,
		arg.ActualArrivalDate,
	)
	var i WmsInboundShipment
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.WarehouseID,
		&i.Status,
		&i.ExpectedArrivalDate,
		&i.ActualArrivalDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateInboundShipment = `-- name: WmsPaginateInboundShipment :many
select
  inbound_shipments.id, inbound_shipments.client_id, inbound_shipments.warehouse_id, inbound_shipments.status, inbound_shipments.expected_arrival_date, inbound_shipments.actual_arrival_date, inbound_shipments.created_at, inbound_shipments.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."inbound_shipments" as inbound_shipments
  left join "crm"."companies" as client on inbound_shipments.client_id = client.id
where
  (client.name ilike $1::text
  or inbound_shipments.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateInboundShipmentParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginateInboundShipmentRow struct {
	WmsInboundShipment WmsInboundShipment
	CrmCompany         CrmCompany
}

func (q *Queries) WmsPaginateInboundShipment(ctx context.Context, arg WmsPaginateInboundShipmentParams) ([]WmsPaginateInboundShipmentRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateInboundShipment, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateInboundShipmentRow
	for rows.Next() {
		var i WmsPaginateInboundShipmentRow
		if err := rows.Scan(
			&i.WmsInboundShipment.ID,
			&i.WmsInboundShipment.ClientID,
			&i.WmsInboundShipment.WarehouseID,
			&i.WmsInboundShipment.Status,
			&i.WmsInboundShipment.ExpectedArrivalDate,
			&i.WmsInboundShipment.ActualArrivalDate,
			&i.WmsInboundShipment.CreatedAt,
			&i.WmsInboundShipment.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeInboundShipment = `-- name: WmsRangeInboundShipment :many
select
  inbound_shipments.id, inbound_shipments.client_id, inbound_shipments.warehouse_id, inbound_shipments.status, inbound_shipments.expected_arrival_date, inbound_shipments.actual_arrival_date, inbound_shipments.created_at, inbound_shipments.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."inbound_shipments" as inbound_shipments
  left join "crm"."companies" as client on inbound_shipments.client_id = client.id
where
  inbound_shipments.created_at >= $1::date
  and inbound_shipments.created_at <= $2::date
  and (client.name ilike $3::text
  or inbound_shipments.status::text ilike $3::text
  or $3::text is null)
`

type WmsRangeInboundShipmentParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangeInboundShipmentRow struct {
	WmsInboundShipment WmsInboundShipment
	CrmCompany         CrmCompany
}

func (q *Queries) WmsRangeInboundShipment(ctx context.Context, arg WmsRangeInboundShipmentParams) ([]WmsRangeInboundShipmentRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeInboundShipment, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeInboundShipmentRow
	for rows.Next() {
		var i WmsRangeInboundShipmentRow
		if err := rows.Scan(
			&i.WmsInboundShipment.ID,
			&i.WmsInboundShipment.ClientID,
			&i.WmsInboundShipment.WarehouseID,
			&i.WmsInboundShipment.Status,
			&i.WmsInboundShipment.ExpectedArrivalDate,
			&i.WmsInboundShipment.ActualArrivalDate,
			&i.WmsInboundShipment.CreatedAt,
			&i.WmsInboundShipment.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveInboundShipment = `-- name: WmsRemoveInboundShipment :exec
delete from "wms"."inbound_shipments"
where id = $1::uuid
`

func (q *Queries) WmsRemoveInboundShipment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveInboundShipment, id)
	return err
}

const wmsUpdateInboundShipment = `-- name: WmsUpdateInboundShipment :one
update
  "wms"."inbound_shipments"
set
  updated_at = now(),
  client_id = case when $1::boolean then
    $2::uuid
  else
    client_id
  end,
  warehouse_id = case when $3::boolean then
    $4::uuid
  else
    warehouse_id
  end,
  status = case when $5::boolean then
    $6::wms.inbound_shipment_status_enum
  else
    status
  end,
  expected_arrival_date = case when $7::boolean then
    $8::date
  else
    expected_arrival_date
  end,
  actual_arrival_date = case when $9::boolean then
    $10::date
  else
    actual_arrival_date
  end
where
  id = $11::uuid
returning
  id, client_id, warehouse_id, status, expected_arrival_date, actual_arrival_date, created_at, updated_at
`

type WmsUpdateInboundShipmentParams struct {
	SetClientID            bool
	ClientID               pgtype.UUID
	SetWarehouseID         bool
	WarehouseID            pgtype.UUID
	SetStatus              bool
	Status                 WmsInboundShipmentStatusEnum
	SetExpectedArrivalDate bool
	ExpectedArrivalDate    pgtype.Date
	SetActualArrivalDate   bool
	ActualArrivalDate      pgtype.Date
	ID                     pgtype.UUID
}

func (q *Queries) WmsUpdateInboundShipment(ctx context.Context, arg WmsUpdateInboundShipmentParams) (WmsInboundShipment, error) {
	row := q.db.QueryRow(ctx, wmsUpdateInboundShipment,
		arg.SetClientID,
		arg.ClientID,
		arg.SetWarehouseID,
		arg.WarehouseID,
		arg.SetStatus,
		arg.Status,
		arg.SetExpectedArrivalDate,
		arg.ExpectedArrivalDate,
		arg.SetActualArrivalDate,
		arg.ActualArrivalDate,
		arg.ID,
	)
	var i WmsInboundShipment
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.WarehouseID,
		&i.Status,
		&i.ExpectedArrivalDate,
		&i.ActualArrivalDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
