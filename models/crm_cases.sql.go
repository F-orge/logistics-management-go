// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_cases.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyCase = `-- name: CrmAnyCase :many
select
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at
from
  "crm"."cases" as cases
  inner join "public"."user" as owner on cases.owner_id = owner.id
  left join "crm"."contacts" as contact on cases.contact_id = contact.id
where
  cases.id = any ($1::uuid[])
`

type CrmAnyCaseRow struct {
	ID          pgtype.UUID         `db:"id" json:"id"`
	CaseNumber  string              `db:"case_number" fake:"{uuid}" json:"case_number"`
	Status      NullCrmCaseStatus   `db:"status" json:"status"`
	Priority    NullCrmCasePriority `db:"priority" json:"priority"`
	Type        NullCrmCaseType     `db:"type" json:"type"`
	OwnerID     string              `db:"owner_id" json:"owner_id"`
	ContactID   pgtype.UUID         `db:"contact_id" json:"contact_id"`
	Description pgtype.Text         `db:"description" fake:"{sentence}" json:"description"`
	CreatedAt   pgtype.Timestamptz  `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `db:"updated_at" json:"updated_at"`
	User        User                `db:"user" json:"user"`
	CrmContact  CrmContact          `db:"crm_contact" json:"crm_contact"`
}

func (q *Queries) CrmAnyCase(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyCaseRow, error) {
	rows, err := q.db.Query(ctx, crmAnyCase, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyCaseRow
	for rows.Next() {
		var i CrmAnyCaseRow
		if err := rows.Scan(
			&i.ID,
			&i.CaseNumber,
			&i.Status,
			&i.Priority,
			&i.Type,
			&i.OwnerID,
			&i.ContactID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindCase = `-- name: CrmFindCase :one
select
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at
from
  "crm"."cases" as cases
  inner join "public"."user" as owner on cases.owner_id = owner.id
  left join "crm"."contacts" as contact on cases.contact_id = contact.id
where
  cases.id = $1::uuid
`

type CrmFindCaseRow struct {
	ID          pgtype.UUID         `db:"id" json:"id"`
	CaseNumber  string              `db:"case_number" fake:"{uuid}" json:"case_number"`
	Status      NullCrmCaseStatus   `db:"status" json:"status"`
	Priority    NullCrmCasePriority `db:"priority" json:"priority"`
	Type        NullCrmCaseType     `db:"type" json:"type"`
	OwnerID     string              `db:"owner_id" json:"owner_id"`
	ContactID   pgtype.UUID         `db:"contact_id" json:"contact_id"`
	Description pgtype.Text         `db:"description" fake:"{sentence}" json:"description"`
	CreatedAt   pgtype.Timestamptz  `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `db:"updated_at" json:"updated_at"`
	User        User                `db:"user" json:"user"`
	CrmContact  CrmContact          `db:"crm_contact" json:"crm_contact"`
}

func (q *Queries) CrmFindCase(ctx context.Context, id pgtype.UUID) (CrmFindCaseRow, error) {
	row := q.db.QueryRow(ctx, crmFindCase, id)
	var i CrmFindCaseRow
	err := row.Scan(
		&i.ID,
		&i.CaseNumber,
		&i.Status,
		&i.Priority,
		&i.Type,
		&i.OwnerID,
		&i.ContactID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
		&i.CrmContact.ID,
		&i.CrmContact.Name,
		&i.CrmContact.Email,
		&i.CrmContact.PhoneNumber,
		&i.CrmContact.JobTitle,
		&i.CrmContact.CompanyID,
		&i.CrmContact.OwnerID,
		&i.CrmContact.CreatedAt,
		&i.CrmContact.UpdatedAt,
	)
	return i, err
}

const crmInsertCase = `-- name: CrmInsertCase :one
insert into "crm"."cases"(case_number, status, priority, type, owner_id, contact_id, description)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, case_number, status, priority, type, owner_id, contact_id, description, created_at, updated_at
`

type CrmInsertCaseParams struct {
	CaseNumber  string              `db:"case_number" fake:"{uuid}" json:"case_number"`
	Status      NullCrmCaseStatus   `db:"status" json:"status"`
	Priority    NullCrmCasePriority `db:"priority" json:"priority"`
	Type        NullCrmCaseType     `db:"type" json:"type"`
	OwnerID     string              `db:"owner_id" json:"owner_id"`
	ContactID   pgtype.UUID         `db:"contact_id" json:"contact_id"`
	Description pgtype.Text         `db:"description" fake:"{sentence}" json:"description"`
}

func (q *Queries) CrmInsertCase(ctx context.Context, arg CrmInsertCaseParams) (CrmCase, error) {
	row := q.db.QueryRow(ctx, crmInsertCase,
		arg.CaseNumber,
		arg.Status,
		arg.Priority,
		arg.Type,
		arg.OwnerID,
		arg.ContactID,
		arg.Description,
	)
	var i CrmCase
	err := row.Scan(
		&i.ID,
		&i.CaseNumber,
		&i.Status,
		&i.Priority,
		&i.Type,
		&i.OwnerID,
		&i.ContactID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateCase = `-- name: CrmPaginateCase :many
select
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at
from
  "crm"."cases" as cases
  inner join "public"."user" as owner on cases.owner_id = owner.id
  left join "crm"."contacts" as contact on cases.contact_id = contact.id
where (cases.case_number ilike $1::text
  or cases.status::text ilike $1::text
  or cases.priority::text ilike $1::text
  or cases.type::text ilike $1::text
  or owner.name ilike $1::text
  or contact.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateCaseParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type CrmPaginateCaseRow struct {
	ID          pgtype.UUID         `db:"id" json:"id"`
	CaseNumber  string              `db:"case_number" fake:"{uuid}" json:"case_number"`
	Status      NullCrmCaseStatus   `db:"status" json:"status"`
	Priority    NullCrmCasePriority `db:"priority" json:"priority"`
	Type        NullCrmCaseType     `db:"type" json:"type"`
	OwnerID     string              `db:"owner_id" json:"owner_id"`
	ContactID   pgtype.UUID         `db:"contact_id" json:"contact_id"`
	Description pgtype.Text         `db:"description" fake:"{sentence}" json:"description"`
	CreatedAt   pgtype.Timestamptz  `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `db:"updated_at" json:"updated_at"`
	User        User                `db:"user" json:"user"`
	CrmContact  CrmContact          `db:"crm_contact" json:"crm_contact"`
}

func (q *Queries) CrmPaginateCase(ctx context.Context, arg CrmPaginateCaseParams) ([]CrmPaginateCaseRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateCase, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateCaseRow
	for rows.Next() {
		var i CrmPaginateCaseRow
		if err := rows.Scan(
			&i.ID,
			&i.CaseNumber,
			&i.Status,
			&i.Priority,
			&i.Type,
			&i.OwnerID,
			&i.ContactID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmPaginateCaseMetadata = `-- name: CrmPaginateCaseMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "crm"."cases" as cases
`

type CrmPaginateCaseMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type CrmPaginateCaseMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) CrmPaginateCaseMetadata(ctx context.Context, arg CrmPaginateCaseMetadataParams) (CrmPaginateCaseMetadataRow, error) {
	row := q.db.QueryRow(ctx, crmPaginateCaseMetadata, arg.PerPage, arg.Page)
	var i CrmPaginateCaseMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const crmRangeCase = `-- name: CrmRangeCase :many
select
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at
from
  "crm"."cases" as cases
  inner join "public"."user" as owner on cases.owner_id = owner.id
  left join "crm"."contacts" as contact on cases.contact_id = contact.id
where
  cases.created_at >= $1::date
  and cases.created_at <= $2::date
  and (cases.case_number ilike $3::text
    or cases.status::text ilike $3::text
    or cases.priority::text ilike $3::text
    or cases.type::text ilike $3::text
    or owner.name ilike $3::text
    or contact.name ilike $3::text
    or $3::text is null)
`

type CrmRangeCaseParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type CrmRangeCaseRow struct {
	ID          pgtype.UUID         `db:"id" json:"id"`
	CaseNumber  string              `db:"case_number" fake:"{uuid}" json:"case_number"`
	Status      NullCrmCaseStatus   `db:"status" json:"status"`
	Priority    NullCrmCasePriority `db:"priority" json:"priority"`
	Type        NullCrmCaseType     `db:"type" json:"type"`
	OwnerID     string              `db:"owner_id" json:"owner_id"`
	ContactID   pgtype.UUID         `db:"contact_id" json:"contact_id"`
	Description pgtype.Text         `db:"description" fake:"{sentence}" json:"description"`
	CreatedAt   pgtype.Timestamptz  `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamptz  `db:"updated_at" json:"updated_at"`
	User        User                `db:"user" json:"user"`
	CrmContact  CrmContact          `db:"crm_contact" json:"crm_contact"`
}

func (q *Queries) CrmRangeCase(ctx context.Context, arg CrmRangeCaseParams) ([]CrmRangeCaseRow, error) {
	rows, err := q.db.Query(ctx, crmRangeCase, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeCaseRow
	for rows.Next() {
		var i CrmRangeCaseRow
		if err := rows.Scan(
			&i.ID,
			&i.CaseNumber,
			&i.Status,
			&i.Priority,
			&i.Type,
			&i.OwnerID,
			&i.ContactID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveCase = `-- name: CrmRemoveCase :exec
delete from "crm"."cases"
where id = $1::uuid
`

func (q *Queries) CrmRemoveCase(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveCase, id)
	return err
}

const crmUpdateCase = `-- name: CrmUpdateCase :one
update
  "crm"."cases"
set
  updated_at = now(),
  case_number = case when $1 is not null then
    $1::text
  else
    case_number
  end,
  status = case when $2 is not null then
    $2::crm.case_status
  else
    status
  end,
  priority = case when $3 is not null then
    $3::crm.case_priority
  else
    priority
  end,
  type = case when $4 is not null then
    $4::crm.case_type
  else
    type
  end,
  owner_id = case when $5 is not null then
    $5::text
  else
    owner_id
  end,
  contact_id = case when $6 is not null then
    $6::uuid
  else
    contact_id
  end,
  description = case when $7 is not null then
    $7::text
  else
    description
  end
where
  id = $8::uuid
returning
  id, case_number, status, priority, type, owner_id, contact_id, description, created_at, updated_at
`

type CrmUpdateCaseParams struct {
	CaseNumber  string              `db:"case_number" fake:"{uuid}" json:"case_number"`
	Status      NullCrmCaseStatus   `db:"status" json:"status"`
	Priority    NullCrmCasePriority `db:"priority" json:"priority"`
	Type        NullCrmCaseType     `db:"type" json:"type"`
	OwnerID     string              `db:"owner_id" json:"owner_id"`
	ContactID   pgtype.UUID         `db:"contact_id" json:"contact_id"`
	Description pgtype.Text         `db:"description" fake:"{sentence}" json:"description"`
	ID          pgtype.UUID         `db:"id" json:"id"`
}

func (q *Queries) CrmUpdateCase(ctx context.Context, arg CrmUpdateCaseParams) (CrmCase, error) {
	row := q.db.QueryRow(ctx, crmUpdateCase,
		arg.CaseNumber,
		arg.Status,
		arg.Priority,
		arg.Type,
		arg.OwnerID,
		arg.ContactID,
		arg.Description,
		arg.ID,
	)
	var i CrmCase
	err := row.Scan(
		&i.ID,
		&i.CaseNumber,
		&i.Status,
		&i.Priority,
		&i.Type,
		&i.OwnerID,
		&i.ContactID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
