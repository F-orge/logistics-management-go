// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_carriers.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyCarrier = `-- name: TmsAnyCarrier :many
select
  id, name, contact_details, services_offered, created_at, updated_at, contact_person, contact_email, contact_phone, carrier_rates, shipment_legs, partner_invoices
from
  "tms"."carriers_view"
where
  id = any ($1::uuid[])
`

func (q *Queries) TmsAnyCarrier(ctx context.Context, ids []pgtype.UUID) ([]TmsCarriersView, error) {
	rows, err := q.db.Query(ctx, tmsAnyCarrier, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsCarriersView
	for rows.Next() {
		var i TmsCarriersView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContactDetails,
			&i.ServicesOffered,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.CarrierRates,
			&i.ShipmentLegs,
			&i.PartnerInvoices,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindCarrier = `-- name: TmsFindCarrier :one
select
  id, name, contact_details, services_offered, created_at, updated_at, contact_person, contact_email, contact_phone, carrier_rates, shipment_legs, partner_invoices
from
  "tms"."carriers_view"
where
  id = $1::uuid
`

func (q *Queries) TmsFindCarrier(ctx context.Context, id pgtype.UUID) (TmsCarriersView, error) {
	row := q.db.QueryRow(ctx, tmsFindCarrier, id)
	var i TmsCarriersView
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactDetails,
		&i.ServicesOffered,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.CarrierRates,
		&i.ShipmentLegs,
		&i.PartnerInvoices,
	)
	return i, err
}

const tmsInsertCarrier = `-- name: TmsInsertCarrier :one
insert into "tms"."carriers"(name, contact_details, services_offered)
  values ($1, $2, $3)
returning
  id, name, contact_details, services_offered, created_at, updated_at, contact_person, contact_email, contact_phone
`

type TmsInsertCarrierParams struct {
	Name            string      `db:"name" json:"name"`
	ContactDetails  pgtype.Text `db:"contact_details" json:"contact_details"`
	ServicesOffered pgtype.Text `db:"services_offered" json:"services_offered"`
}

func (q *Queries) TmsInsertCarrier(ctx context.Context, arg TmsInsertCarrierParams) (TmsCarrier, error) {
	row := q.db.QueryRow(ctx, tmsInsertCarrier, arg.Name, arg.ContactDetails, arg.ServicesOffered)
	var i TmsCarrier
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactDetails,
		&i.ServicesOffered,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
	)
	return i, err
}

const tmsPaginateCarrier = `-- name: TmsPaginateCarrier :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page,
  carriers.id, carriers.name, carriers.contact_details, carriers.services_offered, carriers.created_at, carriers.updated_at, carriers.contact_person, carriers.contact_email, carriers.contact_phone, carriers.carrier_rates, carriers.shipment_legs, carriers.partner_invoices
from
  "tms"."carriers_view" as carriers
where (name ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type TmsPaginateCarrierParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type TmsPaginateCarrierRow struct {
	TotalItems      int64           `db:"total_items" json:"total_items"`
	TotalPages      float64         `db:"total_pages" json:"total_pages"`
	Page            int32           `db:"page" json:"page"`
	PerPage         int32           `db:"per_page" json:"per_page"`
	TmsCarriersView TmsCarriersView `db:"tms_carriers_view" json:"tms_carriers_view"`
}

func (q *Queries) TmsPaginateCarrier(ctx context.Context, arg TmsPaginateCarrierParams) ([]TmsPaginateCarrierRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateCarrier, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateCarrierRow
	for rows.Next() {
		var i TmsPaginateCarrierRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.TmsCarriersView.ID,
			&i.TmsCarriersView.Name,
			&i.TmsCarriersView.ContactDetails,
			&i.TmsCarriersView.ServicesOffered,
			&i.TmsCarriersView.CreatedAt,
			&i.TmsCarriersView.UpdatedAt,
			&i.TmsCarriersView.ContactPerson,
			&i.TmsCarriersView.ContactEmail,
			&i.TmsCarriersView.ContactPhone,
			&i.TmsCarriersView.CarrierRates,
			&i.TmsCarriersView.ShipmentLegs,
			&i.TmsCarriersView.PartnerInvoices,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeCarrier = `-- name: TmsRangeCarrier :many
select
  id, name, contact_details, services_offered, created_at, updated_at, contact_person, contact_email, contact_phone, carrier_rates, shipment_legs, partner_invoices
from
  "tms"."carriers_view"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (name ilike $3::text
    or $3::text is null)
`

type TmsRangeCarrierParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) TmsRangeCarrier(ctx context.Context, arg TmsRangeCarrierParams) ([]TmsCarriersView, error) {
	rows, err := q.db.Query(ctx, tmsRangeCarrier, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsCarriersView
	for rows.Next() {
		var i TmsCarriersView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContactDetails,
			&i.ServicesOffered,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.CarrierRates,
			&i.ShipmentLegs,
			&i.PartnerInvoices,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveCarrier = `-- name: TmsRemoveCarrier :exec
delete from "tms"."carriers"
where id = $1::uuid
`

func (q *Queries) TmsRemoveCarrier(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveCarrier, id)
	return err
}

const tmsUpdateCarrier = `-- name: TmsUpdateCarrier :one
update
  "tms"."carriers"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::varchar
  else
    name
  end,
  contact_details = case when $2 is not null then
    $2::text
  else
    contact_details
  end,
  services_offered = case when $3 is not null then
    $3::text
  else
    services_offered
  end
where
  id = $4::uuid
returning
  id, name, contact_details, services_offered, created_at, updated_at, contact_person, contact_email, contact_phone
`

type TmsUpdateCarrierParams struct {
	Name            string      `db:"name" json:"name"`
	ContactDetails  pgtype.Text `db:"contact_details" json:"contact_details"`
	ServicesOffered pgtype.Text `db:"services_offered" json:"services_offered"`
	ID              pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateCarrier(ctx context.Context, arg TmsUpdateCarrierParams) (TmsCarrier, error) {
	row := q.db.QueryRow(ctx, tmsUpdateCarrier,
		arg.Name,
		arg.ContactDetails,
		arg.ServicesOffered,
		arg.ID,
	)
	var i TmsCarrier
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactDetails,
		&i.ServicesOffered,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
	)
	return i, err
}
