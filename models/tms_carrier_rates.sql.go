// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_carrier_rates.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyCarrierRate = `-- name: TmsAnyCarrierRate :many
select
  carrier_rates.id, carrier_rates.carrier_id, carrier_rates.service_type, carrier_rates.origin, carrier_rates.destination, carrier_rates.rate, carrier_rates.unit, carrier_rates.created_at, carrier_rates.updated_at,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone
from
  "tms"."carrier_rates" as carrier_rates
  inner join "tms"."carriers" as carrier on carrier_rates.carrier_id = carrier.id
where
  carrier_rates.id = any ($1::uuid[])
`

type TmsAnyCarrierRateRow struct {
	ID          pgtype.UUID                `db:"id" json:"id"`
	CarrierID   pgtype.UUID                `db:"carrier_id" json:"carrier_id"`
	ServiceType pgtype.Text                `db:"service_type" json:"service_type"`
	Origin      pgtype.Text                `db:"origin" json:"origin"`
	Destination pgtype.Text                `db:"destination" json:"destination"`
	Rate        pgtype.Numeric             `db:"rate" json:"rate"`
	Unit        NullTmsCarrierRateUnitEnum `db:"unit" json:"unit"`
	CreatedAt   pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	TmsCarrier  TmsCarrier                 `db:"tms_carrier" json:"tms_carrier"`
}

func (q *Queries) TmsAnyCarrierRate(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyCarrierRateRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyCarrierRate, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyCarrierRateRow
	for rows.Next() {
		var i TmsAnyCarrierRateRow
		if err := rows.Scan(
			&i.ID,
			&i.CarrierID,
			&i.ServiceType,
			&i.Origin,
			&i.Destination,
			&i.Rate,
			&i.Unit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindCarrierRate = `-- name: TmsFindCarrierRate :one
select
  carrier_rates.id, carrier_rates.carrier_id, carrier_rates.service_type, carrier_rates.origin, carrier_rates.destination, carrier_rates.rate, carrier_rates.unit, carrier_rates.created_at, carrier_rates.updated_at,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone
from
  "tms"."carrier_rates" as carrier_rates
  inner join "tms"."carriers" as carrier on carrier_rates.carrier_id = carrier.id
where
  carrier_rates.id = $1::uuid
`

type TmsFindCarrierRateRow struct {
	ID          pgtype.UUID                `db:"id" json:"id"`
	CarrierID   pgtype.UUID                `db:"carrier_id" json:"carrier_id"`
	ServiceType pgtype.Text                `db:"service_type" json:"service_type"`
	Origin      pgtype.Text                `db:"origin" json:"origin"`
	Destination pgtype.Text                `db:"destination" json:"destination"`
	Rate        pgtype.Numeric             `db:"rate" json:"rate"`
	Unit        NullTmsCarrierRateUnitEnum `db:"unit" json:"unit"`
	CreatedAt   pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	TmsCarrier  TmsCarrier                 `db:"tms_carrier" json:"tms_carrier"`
}

func (q *Queries) TmsFindCarrierRate(ctx context.Context, id pgtype.UUID) (TmsFindCarrierRateRow, error) {
	row := q.db.QueryRow(ctx, tmsFindCarrierRate, id)
	var i TmsFindCarrierRateRow
	err := row.Scan(
		&i.ID,
		&i.CarrierID,
		&i.ServiceType,
		&i.Origin,
		&i.Destination,
		&i.Rate,
		&i.Unit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TmsCarrier.ID,
		&i.TmsCarrier.Name,
		&i.TmsCarrier.ContactDetails,
		&i.TmsCarrier.ServicesOffered,
		&i.TmsCarrier.CreatedAt,
		&i.TmsCarrier.UpdatedAt,
		&i.TmsCarrier.ContactPerson,
		&i.TmsCarrier.ContactEmail,
		&i.TmsCarrier.ContactPhone,
	)
	return i, err
}

const tmsInsertCarrierRate = `-- name: TmsInsertCarrierRate :one
insert into "tms"."carrier_rates"(carrier_id, service_type, origin, destination, rate, unit)
  values ($1, $2, $3, $4, $5, $6)
returning
  id, carrier_id, service_type, origin, destination, rate, unit, created_at, updated_at
`

type TmsInsertCarrierRateParams struct {
	CarrierID   pgtype.UUID                `db:"carrier_id" json:"carrier_id"`
	ServiceType pgtype.Text                `db:"service_type" json:"service_type"`
	Origin      pgtype.Text                `db:"origin" json:"origin"`
	Destination pgtype.Text                `db:"destination" json:"destination"`
	Rate        pgtype.Numeric             `db:"rate" json:"rate"`
	Unit        NullTmsCarrierRateUnitEnum `db:"unit" json:"unit"`
}

func (q *Queries) TmsInsertCarrierRate(ctx context.Context, arg TmsInsertCarrierRateParams) (TmsCarrierRate, error) {
	row := q.db.QueryRow(ctx, tmsInsertCarrierRate,
		arg.CarrierID,
		arg.ServiceType,
		arg.Origin,
		arg.Destination,
		arg.Rate,
		arg.Unit,
	)
	var i TmsCarrierRate
	err := row.Scan(
		&i.ID,
		&i.CarrierID,
		&i.ServiceType,
		&i.Origin,
		&i.Destination,
		&i.Rate,
		&i.Unit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateCarrierRate = `-- name: TmsPaginateCarrierRate :many
select
  carrier_rates.id, carrier_rates.carrier_id, carrier_rates.service_type, carrier_rates.origin, carrier_rates.destination, carrier_rates.rate, carrier_rates.unit, carrier_rates.created_at, carrier_rates.updated_at,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone
from
  "tms"."carrier_rates" as carrier_rates
  inner join "tms"."carriers" as carrier on carrier_rates.carrier_id = carrier.id
where (carrier.name ilike $1::text
  or carrier_rates.service_type ilike $1::text
  or carrier_rates.origin ilike $1::text
  or carrier_rates.destination ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateCarrierRateParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type TmsPaginateCarrierRateRow struct {
	ID          pgtype.UUID                `db:"id" json:"id"`
	CarrierID   pgtype.UUID                `db:"carrier_id" json:"carrier_id"`
	ServiceType pgtype.Text                `db:"service_type" json:"service_type"`
	Origin      pgtype.Text                `db:"origin" json:"origin"`
	Destination pgtype.Text                `db:"destination" json:"destination"`
	Rate        pgtype.Numeric             `db:"rate" json:"rate"`
	Unit        NullTmsCarrierRateUnitEnum `db:"unit" json:"unit"`
	CreatedAt   pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	TmsCarrier  TmsCarrier                 `db:"tms_carrier" json:"tms_carrier"`
}

func (q *Queries) TmsPaginateCarrierRate(ctx context.Context, arg TmsPaginateCarrierRateParams) ([]TmsPaginateCarrierRateRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateCarrierRate, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateCarrierRateRow
	for rows.Next() {
		var i TmsPaginateCarrierRateRow
		if err := rows.Scan(
			&i.ID,
			&i.CarrierID,
			&i.ServiceType,
			&i.Origin,
			&i.Destination,
			&i.Rate,
			&i.Unit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsPaginateCarrierRateMetadata = `-- name: TmsPaginateCarrierRateMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "tms"."carrier_rates" as carrier_rates
`

type TmsPaginateCarrierRateMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type TmsPaginateCarrierRateMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) TmsPaginateCarrierRateMetadata(ctx context.Context, arg TmsPaginateCarrierRateMetadataParams) (TmsPaginateCarrierRateMetadataRow, error) {
	row := q.db.QueryRow(ctx, tmsPaginateCarrierRateMetadata, arg.PerPage, arg.Page)
	var i TmsPaginateCarrierRateMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const tmsRangeCarrierRate = `-- name: TmsRangeCarrierRate :many
select
  carrier_rates.id, carrier_rates.carrier_id, carrier_rates.service_type, carrier_rates.origin, carrier_rates.destination, carrier_rates.rate, carrier_rates.unit, carrier_rates.created_at, carrier_rates.updated_at,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone
from
  "tms"."carrier_rates" as carrier_rates
  inner join "tms"."carriers" as carrier on carrier_rates.carrier_id = carrier.id
where
  carrier_rates.created_at >= $1::date
  and carrier_rates.created_at <= $2::date
  and (carrier.name ilike $3::text
    or carrier_rates.service_type ilike $3::text
    or carrier_rates.origin ilike $3::text
    or carrier_rates.destination ilike $3::text
    or $3::text is null)
`

type TmsRangeCarrierRateParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeCarrierRateRow struct {
	ID          pgtype.UUID                `db:"id" json:"id"`
	CarrierID   pgtype.UUID                `db:"carrier_id" json:"carrier_id"`
	ServiceType pgtype.Text                `db:"service_type" json:"service_type"`
	Origin      pgtype.Text                `db:"origin" json:"origin"`
	Destination pgtype.Text                `db:"destination" json:"destination"`
	Rate        pgtype.Numeric             `db:"rate" json:"rate"`
	Unit        NullTmsCarrierRateUnitEnum `db:"unit" json:"unit"`
	CreatedAt   pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	TmsCarrier  TmsCarrier                 `db:"tms_carrier" json:"tms_carrier"`
}

func (q *Queries) TmsRangeCarrierRate(ctx context.Context, arg TmsRangeCarrierRateParams) ([]TmsRangeCarrierRateRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeCarrierRate, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeCarrierRateRow
	for rows.Next() {
		var i TmsRangeCarrierRateRow
		if err := rows.Scan(
			&i.ID,
			&i.CarrierID,
			&i.ServiceType,
			&i.Origin,
			&i.Destination,
			&i.Rate,
			&i.Unit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveCarrierRate = `-- name: TmsRemoveCarrierRate :exec
delete from "tms"."carrier_rates"
where id = $1::uuid
`

func (q *Queries) TmsRemoveCarrierRate(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveCarrierRate, id)
	return err
}

const tmsUpdateCarrierRate = `-- name: TmsUpdateCarrierRate :one
update
  "tms"."carrier_rates"
set
  updated_at = now(),
  carrier_id = case when $1 is not null then
    $1::uuid
  else
    carrier_id
  end,
  service_type = case when $2 is not null then
    $2::varchar
  else
    service_type
  end,
  origin = case when $3 is not null then
    $3::varchar
  else
    origin
  end,
  destination = case when $4 is not null then
    $4::varchar
  else
    destination
  end,
  rate = case when $5 is not null then
    $5::numeric
  else
    rate
  end,
  unit = case when $6 is not null then
    $6::tms.carrier_rate_unit_enum
  else
    unit
  end
where
  id = $7::uuid
returning
  id, carrier_id, service_type, origin, destination, rate, unit, created_at, updated_at
`

type TmsUpdateCarrierRateParams struct {
	CarrierID   pgtype.UUID                `db:"carrier_id" json:"carrier_id"`
	ServiceType pgtype.Text                `db:"service_type" json:"service_type"`
	Origin      pgtype.Text                `db:"origin" json:"origin"`
	Destination pgtype.Text                `db:"destination" json:"destination"`
	Rate        pgtype.Numeric             `db:"rate" json:"rate"`
	Unit        NullTmsCarrierRateUnitEnum `db:"unit" json:"unit"`
	ID          pgtype.UUID                `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateCarrierRate(ctx context.Context, arg TmsUpdateCarrierRateParams) (TmsCarrierRate, error) {
	row := q.db.QueryRow(ctx, tmsUpdateCarrierRate,
		arg.CarrierID,
		arg.ServiceType,
		arg.Origin,
		arg.Destination,
		arg.Rate,
		arg.Unit,
		arg.ID,
	)
	var i TmsCarrierRate
	err := row.Scan(
		&i.ID,
		&i.CarrierID,
		&i.ServiceType,
		&i.Origin,
		&i.Destination,
		&i.Rate,
		&i.Unit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
