// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_task_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyTaskItem = `-- name: WmsAnyTaskItem :many
select
  task_items.id, task_items.task_id, task_items.product_id, task_items.batch_id, task_items.source_location_id, task_items.destination_location_id, task_items.quantity_required, task_items.quantity_completed, task_items.quantity_remaining, task_items.status, task_items.lot_number, task_items.serial_numbers, task_items.expiry_date, task_items.notes, task_items.completed_at, task_items.created_at, task_items.updated_at,
  task.id, task.task_number, task.warehouse_id, task.user_id, task.type, task.status, task.priority, task.source_entity_id, task.source_entity_type, task.pick_batch_id, task.estimated_duration, task.actual_duration, task.instructions, task.notes, task.start_time, task.end_time, task.duration_seconds, task.created_at, task.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at,
  source_location.id, source_location.warehouse_id, source_location.parent_location_id, source_location.name, source_location.barcode, source_location.type, source_location.level, source_location.path, source_location.max_weight, source_location.max_volume, source_location.max_pallets, source_location.x_coordinate, source_location.y_coordinate, source_location.z_coordinate, source_location.is_pickable, source_location.is_receivable, source_location.temperature_controlled, source_location.hazmat_approved, source_location.is_active, source_location.created_at, source_location.updated_at,
  destination_location.id, destination_location.warehouse_id, destination_location.parent_location_id, destination_location.name, destination_location.barcode, destination_location.type, destination_location.level, destination_location.path, destination_location.max_weight, destination_location.max_volume, destination_location.max_pallets, destination_location.x_coordinate, destination_location.y_coordinate, destination_location.z_coordinate, destination_location.is_pickable, destination_location.is_receivable, destination_location.temperature_controlled, destination_location.hazmat_approved, destination_location.is_active, destination_location.created_at, destination_location.updated_at
from
  "wms"."task_items" as task_items
  inner join "wms"."tasks" as task on task_items.task_id = task.id
  inner join "wms"."products" as product on task_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on task_items.batch_id = batch.id
  left join "wms"."locations" as source_location on task_items.source_location_id = source_location.id
  left join "wms"."locations" as destination_location on task_items.destination_location_id = destination_location.id
where
  task_items.id = any ($1::uuid[])
`

type WmsAnyTaskItemRow struct {
	WmsTaskItem       WmsTaskItem
	WmsTask           WmsTask
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
	WmsLocation       WmsLocation
	WmsLocation_2     WmsLocation
}

func (q *Queries) WmsAnyTaskItem(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyTaskItemRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyTaskItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyTaskItemRow
	for rows.Next() {
		var i WmsAnyTaskItemRow
		if err := rows.Scan(
			&i.WmsTaskItem.ID,
			&i.WmsTaskItem.TaskID,
			&i.WmsTaskItem.ProductID,
			&i.WmsTaskItem.BatchID,
			&i.WmsTaskItem.SourceLocationID,
			&i.WmsTaskItem.DestinationLocationID,
			&i.WmsTaskItem.QuantityRequired,
			&i.WmsTaskItem.QuantityCompleted,
			&i.WmsTaskItem.QuantityRemaining,
			&i.WmsTaskItem.Status,
			&i.WmsTaskItem.LotNumber,
			&i.WmsTaskItem.SerialNumbers,
			&i.WmsTaskItem.ExpiryDate,
			&i.WmsTaskItem.Notes,
			&i.WmsTaskItem.CompletedAt,
			&i.WmsTaskItem.CreatedAt,
			&i.WmsTaskItem.UpdatedAt,
			&i.WmsTask.ID,
			&i.WmsTask.TaskNumber,
			&i.WmsTask.WarehouseID,
			&i.WmsTask.UserID,
			&i.WmsTask.Type,
			&i.WmsTask.Status,
			&i.WmsTask.Priority,
			&i.WmsTask.SourceEntityID,
			&i.WmsTask.SourceEntityType,
			&i.WmsTask.PickBatchID,
			&i.WmsTask.EstimatedDuration,
			&i.WmsTask.ActualDuration,
			&i.WmsTask.Instructions,
			&i.WmsTask.Notes,
			&i.WmsTask.StartTime,
			&i.WmsTask.EndTime,
			&i.WmsTask.DurationSeconds,
			&i.WmsTask.CreatedAt,
			&i.WmsTask.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsLocation_2.ID,
			&i.WmsLocation_2.WarehouseID,
			&i.WmsLocation_2.ParentLocationID,
			&i.WmsLocation_2.Name,
			&i.WmsLocation_2.Barcode,
			&i.WmsLocation_2.Type,
			&i.WmsLocation_2.Level,
			&i.WmsLocation_2.Path,
			&i.WmsLocation_2.MaxWeight,
			&i.WmsLocation_2.MaxVolume,
			&i.WmsLocation_2.MaxPallets,
			&i.WmsLocation_2.XCoordinate,
			&i.WmsLocation_2.YCoordinate,
			&i.WmsLocation_2.ZCoordinate,
			&i.WmsLocation_2.IsPickable,
			&i.WmsLocation_2.IsReceivable,
			&i.WmsLocation_2.TemperatureControlled,
			&i.WmsLocation_2.HazmatApproved,
			&i.WmsLocation_2.IsActive,
			&i.WmsLocation_2.CreatedAt,
			&i.WmsLocation_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindTaskItem = `-- name: WmsFindTaskItem :one
select
  task_items.id, task_items.task_id, task_items.product_id, task_items.batch_id, task_items.source_location_id, task_items.destination_location_id, task_items.quantity_required, task_items.quantity_completed, task_items.quantity_remaining, task_items.status, task_items.lot_number, task_items.serial_numbers, task_items.expiry_date, task_items.notes, task_items.completed_at, task_items.created_at, task_items.updated_at,
  task.id, task.task_number, task.warehouse_id, task.user_id, task.type, task.status, task.priority, task.source_entity_id, task.source_entity_type, task.pick_batch_id, task.estimated_duration, task.actual_duration, task.instructions, task.notes, task.start_time, task.end_time, task.duration_seconds, task.created_at, task.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at,
  source_location.id, source_location.warehouse_id, source_location.parent_location_id, source_location.name, source_location.barcode, source_location.type, source_location.level, source_location.path, source_location.max_weight, source_location.max_volume, source_location.max_pallets, source_location.x_coordinate, source_location.y_coordinate, source_location.z_coordinate, source_location.is_pickable, source_location.is_receivable, source_location.temperature_controlled, source_location.hazmat_approved, source_location.is_active, source_location.created_at, source_location.updated_at,
  destination_location.id, destination_location.warehouse_id, destination_location.parent_location_id, destination_location.name, destination_location.barcode, destination_location.type, destination_location.level, destination_location.path, destination_location.max_weight, destination_location.max_volume, destination_location.max_pallets, destination_location.x_coordinate, destination_location.y_coordinate, destination_location.z_coordinate, destination_location.is_pickable, destination_location.is_receivable, destination_location.temperature_controlled, destination_location.hazmat_approved, destination_location.is_active, destination_location.created_at, destination_location.updated_at
from
  "wms"."task_items" as task_items
  inner join "wms"."tasks" as task on task_items.task_id = task.id
  inner join "wms"."products" as product on task_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on task_items.batch_id = batch.id
  left join "wms"."locations" as source_location on task_items.source_location_id = source_location.id
  left join "wms"."locations" as destination_location on task_items.destination_location_id = destination_location.id
where
  task_items.id = $1::uuid
`

type WmsFindTaskItemRow struct {
	WmsTaskItem       WmsTaskItem
	WmsTask           WmsTask
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
	WmsLocation       WmsLocation
	WmsLocation_2     WmsLocation
}

func (q *Queries) WmsFindTaskItem(ctx context.Context, id pgtype.UUID) (WmsFindTaskItemRow, error) {
	row := q.db.QueryRow(ctx, wmsFindTaskItem, id)
	var i WmsFindTaskItemRow
	err := row.Scan(
		&i.WmsTaskItem.ID,
		&i.WmsTaskItem.TaskID,
		&i.WmsTaskItem.ProductID,
		&i.WmsTaskItem.BatchID,
		&i.WmsTaskItem.SourceLocationID,
		&i.WmsTaskItem.DestinationLocationID,
		&i.WmsTaskItem.QuantityRequired,
		&i.WmsTaskItem.QuantityCompleted,
		&i.WmsTaskItem.QuantityRemaining,
		&i.WmsTaskItem.Status,
		&i.WmsTaskItem.LotNumber,
		&i.WmsTaskItem.SerialNumbers,
		&i.WmsTaskItem.ExpiryDate,
		&i.WmsTaskItem.Notes,
		&i.WmsTaskItem.CompletedAt,
		&i.WmsTaskItem.CreatedAt,
		&i.WmsTaskItem.UpdatedAt,
		&i.WmsTask.ID,
		&i.WmsTask.TaskNumber,
		&i.WmsTask.WarehouseID,
		&i.WmsTask.UserID,
		&i.WmsTask.Type,
		&i.WmsTask.Status,
		&i.WmsTask.Priority,
		&i.WmsTask.SourceEntityID,
		&i.WmsTask.SourceEntityType,
		&i.WmsTask.PickBatchID,
		&i.WmsTask.EstimatedDuration,
		&i.WmsTask.ActualDuration,
		&i.WmsTask.Instructions,
		&i.WmsTask.Notes,
		&i.WmsTask.StartTime,
		&i.WmsTask.EndTime,
		&i.WmsTask.DurationSeconds,
		&i.WmsTask.CreatedAt,
		&i.WmsTask.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
		&i.WmsInventoryBatch.ID,
		&i.WmsInventoryBatch.ProductID,
		&i.WmsInventoryBatch.BatchNumber,
		&i.WmsInventoryBatch.ExpirationDate,
		&i.WmsInventoryBatch.CreatedAt,
		&i.WmsInventoryBatch.UpdatedAt,
		&i.WmsLocation.ID,
		&i.WmsLocation.WarehouseID,
		&i.WmsLocation.ParentLocationID,
		&i.WmsLocation.Name,
		&i.WmsLocation.Barcode,
		&i.WmsLocation.Type,
		&i.WmsLocation.Level,
		&i.WmsLocation.Path,
		&i.WmsLocation.MaxWeight,
		&i.WmsLocation.MaxVolume,
		&i.WmsLocation.MaxPallets,
		&i.WmsLocation.XCoordinate,
		&i.WmsLocation.YCoordinate,
		&i.WmsLocation.ZCoordinate,
		&i.WmsLocation.IsPickable,
		&i.WmsLocation.IsReceivable,
		&i.WmsLocation.TemperatureControlled,
		&i.WmsLocation.HazmatApproved,
		&i.WmsLocation.IsActive,
		&i.WmsLocation.CreatedAt,
		&i.WmsLocation.UpdatedAt,
		&i.WmsLocation_2.ID,
		&i.WmsLocation_2.WarehouseID,
		&i.WmsLocation_2.ParentLocationID,
		&i.WmsLocation_2.Name,
		&i.WmsLocation_2.Barcode,
		&i.WmsLocation_2.Type,
		&i.WmsLocation_2.Level,
		&i.WmsLocation_2.Path,
		&i.WmsLocation_2.MaxWeight,
		&i.WmsLocation_2.MaxVolume,
		&i.WmsLocation_2.MaxPallets,
		&i.WmsLocation_2.XCoordinate,
		&i.WmsLocation_2.YCoordinate,
		&i.WmsLocation_2.ZCoordinate,
		&i.WmsLocation_2.IsPickable,
		&i.WmsLocation_2.IsReceivable,
		&i.WmsLocation_2.TemperatureControlled,
		&i.WmsLocation_2.HazmatApproved,
		&i.WmsLocation_2.IsActive,
		&i.WmsLocation_2.CreatedAt,
		&i.WmsLocation_2.UpdatedAt,
	)
	return i, err
}

const wmsInsertTaskItem = `-- name: WmsInsertTaskItem :one
insert into "wms"."task_items"(task_id, product_id, batch_id, source_location_id, destination_location_id, quantity_required, quantity_completed, status, lot_number, serial_numbers, expiry_date, notes, completed_at)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
returning
  id, task_id, product_id, batch_id, source_location_id, destination_location_id, quantity_required, quantity_completed, quantity_remaining, status, lot_number, serial_numbers, expiry_date, notes, completed_at, created_at, updated_at
`

type WmsInsertTaskItemParams struct {
	TaskID                pgtype.UUID
	ProductID             pgtype.UUID
	BatchID               pgtype.UUID
	SourceLocationID      pgtype.UUID
	DestinationLocationID pgtype.UUID
	QuantityRequired      int32
	QuantityCompleted     int32
	Status                NullWmsTaskItemStatusEnum
	LotNumber             pgtype.Text
	SerialNumbers         []string
	ExpiryDate            pgtype.Date
	Notes                 pgtype.Text
	CompletedAt           pgtype.Timestamp
}

func (q *Queries) WmsInsertTaskItem(ctx context.Context, arg WmsInsertTaskItemParams) (WmsTaskItem, error) {
	row := q.db.QueryRow(ctx, wmsInsertTaskItem,
		arg.TaskID,
		arg.ProductID,
		arg.BatchID,
		arg.SourceLocationID,
		arg.DestinationLocationID,
		arg.QuantityRequired,
		arg.QuantityCompleted,
		arg.Status,
		arg.LotNumber,
		arg.SerialNumbers,
		arg.ExpiryDate,
		arg.Notes,
		arg.CompletedAt,
	)
	var i WmsTaskItem
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.ProductID,
		&i.BatchID,
		&i.SourceLocationID,
		&i.DestinationLocationID,
		&i.QuantityRequired,
		&i.QuantityCompleted,
		&i.QuantityRemaining,
		&i.Status,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.Notes,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateTaskItem = `-- name: WmsPaginateTaskItem :many
select
  task_items.id, task_items.task_id, task_items.product_id, task_items.batch_id, task_items.source_location_id, task_items.destination_location_id, task_items.quantity_required, task_items.quantity_completed, task_items.quantity_remaining, task_items.status, task_items.lot_number, task_items.serial_numbers, task_items.expiry_date, task_items.notes, task_items.completed_at, task_items.created_at, task_items.updated_at,
  task.id, task.task_number, task.warehouse_id, task.user_id, task.type, task.status, task.priority, task.source_entity_id, task.source_entity_type, task.pick_batch_id, task.estimated_duration, task.actual_duration, task.instructions, task.notes, task.start_time, task.end_time, task.duration_seconds, task.created_at, task.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at,
  source_location.id, source_location.warehouse_id, source_location.parent_location_id, source_location.name, source_location.barcode, source_location.type, source_location.level, source_location.path, source_location.max_weight, source_location.max_volume, source_location.max_pallets, source_location.x_coordinate, source_location.y_coordinate, source_location.z_coordinate, source_location.is_pickable, source_location.is_receivable, source_location.temperature_controlled, source_location.hazmat_approved, source_location.is_active, source_location.created_at, source_location.updated_at,
  destination_location.id, destination_location.warehouse_id, destination_location.parent_location_id, destination_location.name, destination_location.barcode, destination_location.type, destination_location.level, destination_location.path, destination_location.max_weight, destination_location.max_volume, destination_location.max_pallets, destination_location.x_coordinate, destination_location.y_coordinate, destination_location.z_coordinate, destination_location.is_pickable, destination_location.is_receivable, destination_location.temperature_controlled, destination_location.hazmat_approved, destination_location.is_active, destination_location.created_at, destination_location.updated_at
from
  "wms"."task_items" as task_items
  inner join "wms"."tasks" as task on task_items.task_id = task.id
  inner join "wms"."products" as product on task_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on task_items.batch_id = batch.id
  left join "wms"."locations" as source_location on task_items.source_location_id = source_location.id
  left join "wms"."locations" as destination_location on task_items.destination_location_id = destination_location.id
where
  (task.task_number ilike $1::text
  or product.name ilike $1::text
  or batch.batch_number ilike $1::text
  or source_location.name ilike $1::text
  or destination_location.name ilike $1::text
  or task_items.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateTaskItemParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginateTaskItemRow struct {
	WmsTaskItem       WmsTaskItem
	WmsTask           WmsTask
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
	WmsLocation       WmsLocation
	WmsLocation_2     WmsLocation
}

func (q *Queries) WmsPaginateTaskItem(ctx context.Context, arg WmsPaginateTaskItemParams) ([]WmsPaginateTaskItemRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateTaskItem, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateTaskItemRow
	for rows.Next() {
		var i WmsPaginateTaskItemRow
		if err := rows.Scan(
			&i.WmsTaskItem.ID,
			&i.WmsTaskItem.TaskID,
			&i.WmsTaskItem.ProductID,
			&i.WmsTaskItem.BatchID,
			&i.WmsTaskItem.SourceLocationID,
			&i.WmsTaskItem.DestinationLocationID,
			&i.WmsTaskItem.QuantityRequired,
			&i.WmsTaskItem.QuantityCompleted,
			&i.WmsTaskItem.QuantityRemaining,
			&i.WmsTaskItem.Status,
			&i.WmsTaskItem.LotNumber,
			&i.WmsTaskItem.SerialNumbers,
			&i.WmsTaskItem.ExpiryDate,
			&i.WmsTaskItem.Notes,
			&i.WmsTaskItem.CompletedAt,
			&i.WmsTaskItem.CreatedAt,
			&i.WmsTaskItem.UpdatedAt,
			&i.WmsTask.ID,
			&i.WmsTask.TaskNumber,
			&i.WmsTask.WarehouseID,
			&i.WmsTask.UserID,
			&i.WmsTask.Type,
			&i.WmsTask.Status,
			&i.WmsTask.Priority,
			&i.WmsTask.SourceEntityID,
			&i.WmsTask.SourceEntityType,
			&i.WmsTask.PickBatchID,
			&i.WmsTask.EstimatedDuration,
			&i.WmsTask.ActualDuration,
			&i.WmsTask.Instructions,
			&i.WmsTask.Notes,
			&i.WmsTask.StartTime,
			&i.WmsTask.EndTime,
			&i.WmsTask.DurationSeconds,
			&i.WmsTask.CreatedAt,
			&i.WmsTask.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsLocation_2.ID,
			&i.WmsLocation_2.WarehouseID,
			&i.WmsLocation_2.ParentLocationID,
			&i.WmsLocation_2.Name,
			&i.WmsLocation_2.Barcode,
			&i.WmsLocation_2.Type,
			&i.WmsLocation_2.Level,
			&i.WmsLocation_2.Path,
			&i.WmsLocation_2.MaxWeight,
			&i.WmsLocation_2.MaxVolume,
			&i.WmsLocation_2.MaxPallets,
			&i.WmsLocation_2.XCoordinate,
			&i.WmsLocation_2.YCoordinate,
			&i.WmsLocation_2.ZCoordinate,
			&i.WmsLocation_2.IsPickable,
			&i.WmsLocation_2.IsReceivable,
			&i.WmsLocation_2.TemperatureControlled,
			&i.WmsLocation_2.HazmatApproved,
			&i.WmsLocation_2.IsActive,
			&i.WmsLocation_2.CreatedAt,
			&i.WmsLocation_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeTaskItem = `-- name: WmsRangeTaskItem :many
select
  task_items.id, task_items.task_id, task_items.product_id, task_items.batch_id, task_items.source_location_id, task_items.destination_location_id, task_items.quantity_required, task_items.quantity_completed, task_items.quantity_remaining, task_items.status, task_items.lot_number, task_items.serial_numbers, task_items.expiry_date, task_items.notes, task_items.completed_at, task_items.created_at, task_items.updated_at,
  task.id, task.task_number, task.warehouse_id, task.user_id, task.type, task.status, task.priority, task.source_entity_id, task.source_entity_type, task.pick_batch_id, task.estimated_duration, task.actual_duration, task.instructions, task.notes, task.start_time, task.end_time, task.duration_seconds, task.created_at, task.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at,
  source_location.id, source_location.warehouse_id, source_location.parent_location_id, source_location.name, source_location.barcode, source_location.type, source_location.level, source_location.path, source_location.max_weight, source_location.max_volume, source_location.max_pallets, source_location.x_coordinate, source_location.y_coordinate, source_location.z_coordinate, source_location.is_pickable, source_location.is_receivable, source_location.temperature_controlled, source_location.hazmat_approved, source_location.is_active, source_location.created_at, source_location.updated_at,
  destination_location.id, destination_location.warehouse_id, destination_location.parent_location_id, destination_location.name, destination_location.barcode, destination_location.type, destination_location.level, destination_location.path, destination_location.max_weight, destination_location.max_volume, destination_location.max_pallets, destination_location.x_coordinate, destination_location.y_coordinate, destination_location.z_coordinate, destination_location.is_pickable, destination_location.is_receivable, destination_location.temperature_controlled, destination_location.hazmat_approved, destination_location.is_active, destination_location.created_at, destination_location.updated_at
from
  "wms"."task_items" as task_items
  inner join "wms"."tasks" as task on task_items.task_id = task.id
  inner join "wms"."products" as product on task_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on task_items.batch_id = batch.id
  left join "wms"."locations" as source_location on task_items.source_location_id = source_location.id
  left join "wms"."locations" as destination_location on task_items.destination_location_id = destination_location.id
where
  task_items.created_at >= $1::date
  and task_items.created_at <= $2::date
  and (task.task_number ilike $3::text
  or product.name ilike $3::text
  or batch.batch_number ilike $3::text
  or source_location.name ilike $3::text
  or destination_location.name ilike $3::text
  or task_items.status::text ilike $3::text
  or $3::text is null)
`

type WmsRangeTaskItemParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangeTaskItemRow struct {
	WmsTaskItem       WmsTaskItem
	WmsTask           WmsTask
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
	WmsLocation       WmsLocation
	WmsLocation_2     WmsLocation
}

func (q *Queries) WmsRangeTaskItem(ctx context.Context, arg WmsRangeTaskItemParams) ([]WmsRangeTaskItemRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeTaskItem, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeTaskItemRow
	for rows.Next() {
		var i WmsRangeTaskItemRow
		if err := rows.Scan(
			&i.WmsTaskItem.ID,
			&i.WmsTaskItem.TaskID,
			&i.WmsTaskItem.ProductID,
			&i.WmsTaskItem.BatchID,
			&i.WmsTaskItem.SourceLocationID,
			&i.WmsTaskItem.DestinationLocationID,
			&i.WmsTaskItem.QuantityRequired,
			&i.WmsTaskItem.QuantityCompleted,
			&i.WmsTaskItem.QuantityRemaining,
			&i.WmsTaskItem.Status,
			&i.WmsTaskItem.LotNumber,
			&i.WmsTaskItem.SerialNumbers,
			&i.WmsTaskItem.ExpiryDate,
			&i.WmsTaskItem.Notes,
			&i.WmsTaskItem.CompletedAt,
			&i.WmsTaskItem.CreatedAt,
			&i.WmsTaskItem.UpdatedAt,
			&i.WmsTask.ID,
			&i.WmsTask.TaskNumber,
			&i.WmsTask.WarehouseID,
			&i.WmsTask.UserID,
			&i.WmsTask.Type,
			&i.WmsTask.Status,
			&i.WmsTask.Priority,
			&i.WmsTask.SourceEntityID,
			&i.WmsTask.SourceEntityType,
			&i.WmsTask.PickBatchID,
			&i.WmsTask.EstimatedDuration,
			&i.WmsTask.ActualDuration,
			&i.WmsTask.Instructions,
			&i.WmsTask.Notes,
			&i.WmsTask.StartTime,
			&i.WmsTask.EndTime,
			&i.WmsTask.DurationSeconds,
			&i.WmsTask.CreatedAt,
			&i.WmsTask.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsLocation_2.ID,
			&i.WmsLocation_2.WarehouseID,
			&i.WmsLocation_2.ParentLocationID,
			&i.WmsLocation_2.Name,
			&i.WmsLocation_2.Barcode,
			&i.WmsLocation_2.Type,
			&i.WmsLocation_2.Level,
			&i.WmsLocation_2.Path,
			&i.WmsLocation_2.MaxWeight,
			&i.WmsLocation_2.MaxVolume,
			&i.WmsLocation_2.MaxPallets,
			&i.WmsLocation_2.XCoordinate,
			&i.WmsLocation_2.YCoordinate,
			&i.WmsLocation_2.ZCoordinate,
			&i.WmsLocation_2.IsPickable,
			&i.WmsLocation_2.IsReceivable,
			&i.WmsLocation_2.TemperatureControlled,
			&i.WmsLocation_2.HazmatApproved,
			&i.WmsLocation_2.IsActive,
			&i.WmsLocation_2.CreatedAt,
			&i.WmsLocation_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveTaskItem = `-- name: WmsRemoveTaskItem :exec
delete from "wms"."task_items"
where id = $1::uuid
`

func (q *Queries) WmsRemoveTaskItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveTaskItem, id)
	return err
}

const wmsUpdateTaskItem = `-- name: WmsUpdateTaskItem :one
update
  "wms"."task_items"
set
  updated_at = now(),
  task_id = case when $1::boolean then
    $2::uuid
  else
    task_id
  end,
  product_id = case when $3::boolean then
    $4::uuid
  else
    product_id
  end,
  batch_id = case when $5::boolean then
    $6::uuid
  else
    batch_id
  end,
  source_location_id = case when $7::boolean then
    $8::uuid
  else
    source_location_id
  end,
  destination_location_id = case when $9::boolean then
    $10::uuid
  else
    destination_location_id
  end,
  quantity_required = case when $11::boolean then
    $12::integer
  else
    quantity_required
  end,
  quantity_completed = case when $13::boolean then
    $14::integer
  else
    quantity_completed
  end,
  status = case when $15::boolean then
    $16::wms.task_item_status_enum
  else
    status
  end,
  lot_number = case when $17::boolean then
    $18::varchar
  else
    lot_number
  end,
  serial_numbers = case when $19::boolean then
    $20::text[]
  else
    serial_numbers
  end,
  expiry_date = case when $21::boolean then
    $22::date
  else
    expiry_date
  end,
  notes = case when $23::boolean then
    $24::text
  else
    notes
  end,
  completed_at = case when $25::boolean then
    $26::timestamp
  else
    completed_at
  end
where
  id = $27::uuid
returning
  id, task_id, product_id, batch_id, source_location_id, destination_location_id, quantity_required, quantity_completed, quantity_remaining, status, lot_number, serial_numbers, expiry_date, notes, completed_at, created_at, updated_at
`

type WmsUpdateTaskItemParams struct {
	SetTaskID                bool
	TaskID                   pgtype.UUID
	SetProductID             bool
	ProductID                pgtype.UUID
	SetBatchID               bool
	BatchID                  pgtype.UUID
	SetSourceLocationID      bool
	SourceLocationID         pgtype.UUID
	SetDestinationLocationID bool
	DestinationLocationID    pgtype.UUID
	SetQuantityRequired      bool
	QuantityRequired         int32
	SetQuantityCompleted     bool
	QuantityCompleted        int32
	SetStatus                bool
	Status                   WmsTaskItemStatusEnum
	SetLotNumber             bool
	LotNumber                string
	SetSerialNumbers         bool
	SerialNumbers            []string
	SetExpiryDate            bool
	ExpiryDate               pgtype.Date
	SetNotes                 bool
	Notes                    string
	SetCompletedAt           bool
	CompletedAt              pgtype.Timestamp
	ID                       pgtype.UUID
}

func (q *Queries) WmsUpdateTaskItem(ctx context.Context, arg WmsUpdateTaskItemParams) (WmsTaskItem, error) {
	row := q.db.QueryRow(ctx, wmsUpdateTaskItem,
		arg.SetTaskID,
		arg.TaskID,
		arg.SetProductID,
		arg.ProductID,
		arg.SetBatchID,
		arg.BatchID,
		arg.SetSourceLocationID,
		arg.SourceLocationID,
		arg.SetDestinationLocationID,
		arg.DestinationLocationID,
		arg.SetQuantityRequired,
		arg.QuantityRequired,
		arg.SetQuantityCompleted,
		arg.QuantityCompleted,
		arg.SetStatus,
		arg.Status,
		arg.SetLotNumber,
		arg.LotNumber,
		arg.SetSerialNumbers,
		arg.SerialNumbers,
		arg.SetExpiryDate,
		arg.ExpiryDate,
		arg.SetNotes,
		arg.Notes,
		arg.SetCompletedAt,
		arg.CompletedAt,
		arg.ID,
	)
	var i WmsTaskItem
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.ProductID,
		&i.BatchID,
		&i.SourceLocationID,
		&i.DestinationLocationID,
		&i.QuantityRequired,
		&i.QuantityCompleted,
		&i.QuantityRemaining,
		&i.Status,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.Notes,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
