// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_task_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyTaskItem = `-- name: WmsAnyTaskItem :many
select
  task_items.id, task_items.task_id, task_items.product_id, task_items.batch_id, task_items.source_location_id, task_items.destination_location_id, task_items.quantity_required, task_items.quantity_completed, task_items.quantity_remaining, task_items.status, task_items.lot_number, task_items.serial_numbers, task_items.expiry_date, task_items.notes, task_items.completed_at, task_items.created_at, task_items.updated_at,
  task.id, task.task_number, task.warehouse_id, task.user_id, task.type, task.status, task.priority, task.source_entity_id, task.source_entity_type, task.pick_batch_id, task.estimated_duration, task.actual_duration, task.instructions, task.notes, task.start_time, task.end_time, task.duration_seconds, task.created_at, task.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at,
  source_location.id, source_location.warehouse_id, source_location.parent_location_id, source_location.name, source_location.barcode, source_location.type, source_location.level, source_location.path, source_location.max_weight, source_location.max_volume, source_location.max_pallets, source_location.x_coordinate, source_location.y_coordinate, source_location.z_coordinate, source_location.is_pickable, source_location.is_receivable, source_location.temperature_controlled, source_location.hazmat_approved, source_location.is_active, source_location.created_at, source_location.updated_at,
  destination_location.id, destination_location.warehouse_id, destination_location.parent_location_id, destination_location.name, destination_location.barcode, destination_location.type, destination_location.level, destination_location.path, destination_location.max_weight, destination_location.max_volume, destination_location.max_pallets, destination_location.x_coordinate, destination_location.y_coordinate, destination_location.z_coordinate, destination_location.is_pickable, destination_location.is_receivable, destination_location.temperature_controlled, destination_location.hazmat_approved, destination_location.is_active, destination_location.created_at, destination_location.updated_at
from
  "wms"."task_items" as task_items
  inner join "wms"."tasks" as task on task_items.task_id = task.id
  inner join "wms"."products" as product on task_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on task_items.batch_id = batch.id
  left join "wms"."locations" as source_location on task_items.source_location_id = source_location.id
  left join "wms"."locations" as destination_location on task_items.destination_location_id = destination_location.id
where
  task_items.id = any ($1::uuid[])
`

type WmsAnyTaskItemRow struct {
	ID                    pgtype.UUID               `db:"id" json:"id"`
	TaskID                pgtype.UUID               `db:"task_id" json:"task_id"`
	ProductID             pgtype.UUID               `db:"product_id" json:"product_id"`
	BatchID               pgtype.UUID               `db:"batch_id" json:"batch_id"`
	SourceLocationID      pgtype.UUID               `db:"source_location_id" json:"source_location_id"`
	DestinationLocationID pgtype.UUID               `db:"destination_location_id" json:"destination_location_id"`
	QuantityRequired      int32                     `db:"quantity_required" json:"quantity_required"`
	QuantityCompleted     int32                     `db:"quantity_completed" json:"quantity_completed"`
	QuantityRemaining     pgtype.Int4               `db:"quantity_remaining" json:"quantity_remaining"`
	Status                NullWmsTaskItemStatusEnum `db:"status" json:"status"`
	LotNumber             pgtype.Text               `db:"lot_number" json:"lot_number"`
	SerialNumbers         []string                  `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate            pgtype.Date               `db:"expiry_date" json:"expiry_date"`
	Notes                 pgtype.Text               `db:"notes" json:"notes"`
	CompletedAt           pgtype.Timestamp          `db:"completed_at" json:"completed_at"`
	CreatedAt             pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt             pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	WmsTask               WmsTask                   `db:"wms_task" json:"wms_task"`
	WmsProduct            WmsProduct                `db:"wms_product" json:"wms_product"`
	WmsInventoryBatch     WmsInventoryBatch         `db:"wms_inventory_batch" json:"wms_inventory_batch"`
	WmsLocation           WmsLocation               `db:"wms_location" json:"wms_location"`
	WmsLocation_2         WmsLocation               `db:"wms_location_2" json:"wms_location_2"`
}

func (q *Queries) WmsAnyTaskItem(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyTaskItemRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyTaskItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyTaskItemRow
	for rows.Next() {
		var i WmsAnyTaskItemRow
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.ProductID,
			&i.BatchID,
			&i.SourceLocationID,
			&i.DestinationLocationID,
			&i.QuantityRequired,
			&i.QuantityCompleted,
			&i.QuantityRemaining,
			&i.Status,
			&i.LotNumber,
			&i.SerialNumbers,
			&i.ExpiryDate,
			&i.Notes,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsTask.ID,
			&i.WmsTask.TaskNumber,
			&i.WmsTask.WarehouseID,
			&i.WmsTask.UserID,
			&i.WmsTask.Type,
			&i.WmsTask.Status,
			&i.WmsTask.Priority,
			&i.WmsTask.SourceEntityID,
			&i.WmsTask.SourceEntityType,
			&i.WmsTask.PickBatchID,
			&i.WmsTask.EstimatedDuration,
			&i.WmsTask.ActualDuration,
			&i.WmsTask.Instructions,
			&i.WmsTask.Notes,
			&i.WmsTask.StartTime,
			&i.WmsTask.EndTime,
			&i.WmsTask.DurationSeconds,
			&i.WmsTask.CreatedAt,
			&i.WmsTask.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsLocation_2.ID,
			&i.WmsLocation_2.WarehouseID,
			&i.WmsLocation_2.ParentLocationID,
			&i.WmsLocation_2.Name,
			&i.WmsLocation_2.Barcode,
			&i.WmsLocation_2.Type,
			&i.WmsLocation_2.Level,
			&i.WmsLocation_2.Path,
			&i.WmsLocation_2.MaxWeight,
			&i.WmsLocation_2.MaxVolume,
			&i.WmsLocation_2.MaxPallets,
			&i.WmsLocation_2.XCoordinate,
			&i.WmsLocation_2.YCoordinate,
			&i.WmsLocation_2.ZCoordinate,
			&i.WmsLocation_2.IsPickable,
			&i.WmsLocation_2.IsReceivable,
			&i.WmsLocation_2.TemperatureControlled,
			&i.WmsLocation_2.HazmatApproved,
			&i.WmsLocation_2.IsActive,
			&i.WmsLocation_2.CreatedAt,
			&i.WmsLocation_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindTaskItem = `-- name: WmsFindTaskItem :one
select
  task_items.id, task_items.task_id, task_items.product_id, task_items.batch_id, task_items.source_location_id, task_items.destination_location_id, task_items.quantity_required, task_items.quantity_completed, task_items.quantity_remaining, task_items.status, task_items.lot_number, task_items.serial_numbers, task_items.expiry_date, task_items.notes, task_items.completed_at, task_items.created_at, task_items.updated_at,
  task.id, task.task_number, task.warehouse_id, task.user_id, task.type, task.status, task.priority, task.source_entity_id, task.source_entity_type, task.pick_batch_id, task.estimated_duration, task.actual_duration, task.instructions, task.notes, task.start_time, task.end_time, task.duration_seconds, task.created_at, task.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at,
  source_location.id, source_location.warehouse_id, source_location.parent_location_id, source_location.name, source_location.barcode, source_location.type, source_location.level, source_location.path, source_location.max_weight, source_location.max_volume, source_location.max_pallets, source_location.x_coordinate, source_location.y_coordinate, source_location.z_coordinate, source_location.is_pickable, source_location.is_receivable, source_location.temperature_controlled, source_location.hazmat_approved, source_location.is_active, source_location.created_at, source_location.updated_at,
  destination_location.id, destination_location.warehouse_id, destination_location.parent_location_id, destination_location.name, destination_location.barcode, destination_location.type, destination_location.level, destination_location.path, destination_location.max_weight, destination_location.max_volume, destination_location.max_pallets, destination_location.x_coordinate, destination_location.y_coordinate, destination_location.z_coordinate, destination_location.is_pickable, destination_location.is_receivable, destination_location.temperature_controlled, destination_location.hazmat_approved, destination_location.is_active, destination_location.created_at, destination_location.updated_at
from
  "wms"."task_items" as task_items
  inner join "wms"."tasks" as task on task_items.task_id = task.id
  inner join "wms"."products" as product on task_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on task_items.batch_id = batch.id
  left join "wms"."locations" as source_location on task_items.source_location_id = source_location.id
  left join "wms"."locations" as destination_location on task_items.destination_location_id = destination_location.id
where
  task_items.id = $1::uuid
`

type WmsFindTaskItemRow struct {
	ID                    pgtype.UUID               `db:"id" json:"id"`
	TaskID                pgtype.UUID               `db:"task_id" json:"task_id"`
	ProductID             pgtype.UUID               `db:"product_id" json:"product_id"`
	BatchID               pgtype.UUID               `db:"batch_id" json:"batch_id"`
	SourceLocationID      pgtype.UUID               `db:"source_location_id" json:"source_location_id"`
	DestinationLocationID pgtype.UUID               `db:"destination_location_id" json:"destination_location_id"`
	QuantityRequired      int32                     `db:"quantity_required" json:"quantity_required"`
	QuantityCompleted     int32                     `db:"quantity_completed" json:"quantity_completed"`
	QuantityRemaining     pgtype.Int4               `db:"quantity_remaining" json:"quantity_remaining"`
	Status                NullWmsTaskItemStatusEnum `db:"status" json:"status"`
	LotNumber             pgtype.Text               `db:"lot_number" json:"lot_number"`
	SerialNumbers         []string                  `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate            pgtype.Date               `db:"expiry_date" json:"expiry_date"`
	Notes                 pgtype.Text               `db:"notes" json:"notes"`
	CompletedAt           pgtype.Timestamp          `db:"completed_at" json:"completed_at"`
	CreatedAt             pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt             pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	WmsTask               WmsTask                   `db:"wms_task" json:"wms_task"`
	WmsProduct            WmsProduct                `db:"wms_product" json:"wms_product"`
	WmsInventoryBatch     WmsInventoryBatch         `db:"wms_inventory_batch" json:"wms_inventory_batch"`
	WmsLocation           WmsLocation               `db:"wms_location" json:"wms_location"`
	WmsLocation_2         WmsLocation               `db:"wms_location_2" json:"wms_location_2"`
}

func (q *Queries) WmsFindTaskItem(ctx context.Context, id pgtype.UUID) (WmsFindTaskItemRow, error) {
	row := q.db.QueryRow(ctx, wmsFindTaskItem, id)
	var i WmsFindTaskItemRow
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.ProductID,
		&i.BatchID,
		&i.SourceLocationID,
		&i.DestinationLocationID,
		&i.QuantityRequired,
		&i.QuantityCompleted,
		&i.QuantityRemaining,
		&i.Status,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.Notes,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WmsTask.ID,
		&i.WmsTask.TaskNumber,
		&i.WmsTask.WarehouseID,
		&i.WmsTask.UserID,
		&i.WmsTask.Type,
		&i.WmsTask.Status,
		&i.WmsTask.Priority,
		&i.WmsTask.SourceEntityID,
		&i.WmsTask.SourceEntityType,
		&i.WmsTask.PickBatchID,
		&i.WmsTask.EstimatedDuration,
		&i.WmsTask.ActualDuration,
		&i.WmsTask.Instructions,
		&i.WmsTask.Notes,
		&i.WmsTask.StartTime,
		&i.WmsTask.EndTime,
		&i.WmsTask.DurationSeconds,
		&i.WmsTask.CreatedAt,
		&i.WmsTask.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
		&i.WmsInventoryBatch.ID,
		&i.WmsInventoryBatch.ProductID,
		&i.WmsInventoryBatch.BatchNumber,
		&i.WmsInventoryBatch.ExpirationDate,
		&i.WmsInventoryBatch.CreatedAt,
		&i.WmsInventoryBatch.UpdatedAt,
		&i.WmsLocation.ID,
		&i.WmsLocation.WarehouseID,
		&i.WmsLocation.ParentLocationID,
		&i.WmsLocation.Name,
		&i.WmsLocation.Barcode,
		&i.WmsLocation.Type,
		&i.WmsLocation.Level,
		&i.WmsLocation.Path,
		&i.WmsLocation.MaxWeight,
		&i.WmsLocation.MaxVolume,
		&i.WmsLocation.MaxPallets,
		&i.WmsLocation.XCoordinate,
		&i.WmsLocation.YCoordinate,
		&i.WmsLocation.ZCoordinate,
		&i.WmsLocation.IsPickable,
		&i.WmsLocation.IsReceivable,
		&i.WmsLocation.TemperatureControlled,
		&i.WmsLocation.HazmatApproved,
		&i.WmsLocation.IsActive,
		&i.WmsLocation.CreatedAt,
		&i.WmsLocation.UpdatedAt,
		&i.WmsLocation_2.ID,
		&i.WmsLocation_2.WarehouseID,
		&i.WmsLocation_2.ParentLocationID,
		&i.WmsLocation_2.Name,
		&i.WmsLocation_2.Barcode,
		&i.WmsLocation_2.Type,
		&i.WmsLocation_2.Level,
		&i.WmsLocation_2.Path,
		&i.WmsLocation_2.MaxWeight,
		&i.WmsLocation_2.MaxVolume,
		&i.WmsLocation_2.MaxPallets,
		&i.WmsLocation_2.XCoordinate,
		&i.WmsLocation_2.YCoordinate,
		&i.WmsLocation_2.ZCoordinate,
		&i.WmsLocation_2.IsPickable,
		&i.WmsLocation_2.IsReceivable,
		&i.WmsLocation_2.TemperatureControlled,
		&i.WmsLocation_2.HazmatApproved,
		&i.WmsLocation_2.IsActive,
		&i.WmsLocation_2.CreatedAt,
		&i.WmsLocation_2.UpdatedAt,
	)
	return i, err
}

const wmsInsertTaskItem = `-- name: WmsInsertTaskItem :one
insert into "wms"."task_items"(task_id, product_id, batch_id, source_location_id, destination_location_id, quantity_required, quantity_completed, status, lot_number, serial_numbers, expiry_date, notes, completed_at)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
returning
  id, task_id, product_id, batch_id, source_location_id, destination_location_id, quantity_required, quantity_completed, quantity_remaining, status, lot_number, serial_numbers, expiry_date, notes, completed_at, created_at, updated_at
`

type WmsInsertTaskItemParams struct {
	TaskID                pgtype.UUID               `db:"task_id" json:"task_id"`
	ProductID             pgtype.UUID               `db:"product_id" json:"product_id"`
	BatchID               pgtype.UUID               `db:"batch_id" json:"batch_id"`
	SourceLocationID      pgtype.UUID               `db:"source_location_id" json:"source_location_id"`
	DestinationLocationID pgtype.UUID               `db:"destination_location_id" json:"destination_location_id"`
	QuantityRequired      int32                     `db:"quantity_required" json:"quantity_required"`
	QuantityCompleted     int32                     `db:"quantity_completed" json:"quantity_completed"`
	Status                NullWmsTaskItemStatusEnum `db:"status" json:"status"`
	LotNumber             pgtype.Text               `db:"lot_number" json:"lot_number"`
	SerialNumbers         []string                  `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate            pgtype.Date               `db:"expiry_date" json:"expiry_date"`
	Notes                 pgtype.Text               `db:"notes" json:"notes"`
	CompletedAt           pgtype.Timestamp          `db:"completed_at" json:"completed_at"`
}

func (q *Queries) WmsInsertTaskItem(ctx context.Context, arg WmsInsertTaskItemParams) (WmsTaskItem, error) {
	row := q.db.QueryRow(ctx, wmsInsertTaskItem,
		arg.TaskID,
		arg.ProductID,
		arg.BatchID,
		arg.SourceLocationID,
		arg.DestinationLocationID,
		arg.QuantityRequired,
		arg.QuantityCompleted,
		arg.Status,
		arg.LotNumber,
		arg.SerialNumbers,
		arg.ExpiryDate,
		arg.Notes,
		arg.CompletedAt,
	)
	var i WmsTaskItem
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.ProductID,
		&i.BatchID,
		&i.SourceLocationID,
		&i.DestinationLocationID,
		&i.QuantityRequired,
		&i.QuantityCompleted,
		&i.QuantityRemaining,
		&i.Status,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.Notes,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateTaskItem = `-- name: WmsPaginateTaskItem :many
select
  task_items.id, task_items.task_id, task_items.product_id, task_items.batch_id, task_items.source_location_id, task_items.destination_location_id, task_items.quantity_required, task_items.quantity_completed, task_items.quantity_remaining, task_items.status, task_items.lot_number, task_items.serial_numbers, task_items.expiry_date, task_items.notes, task_items.completed_at, task_items.created_at, task_items.updated_at,
  task.id, task.task_number, task.warehouse_id, task.user_id, task.type, task.status, task.priority, task.source_entity_id, task.source_entity_type, task.pick_batch_id, task.estimated_duration, task.actual_duration, task.instructions, task.notes, task.start_time, task.end_time, task.duration_seconds, task.created_at, task.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at,
  source_location.id, source_location.warehouse_id, source_location.parent_location_id, source_location.name, source_location.barcode, source_location.type, source_location.level, source_location.path, source_location.max_weight, source_location.max_volume, source_location.max_pallets, source_location.x_coordinate, source_location.y_coordinate, source_location.z_coordinate, source_location.is_pickable, source_location.is_receivable, source_location.temperature_controlled, source_location.hazmat_approved, source_location.is_active, source_location.created_at, source_location.updated_at,
  destination_location.id, destination_location.warehouse_id, destination_location.parent_location_id, destination_location.name, destination_location.barcode, destination_location.type, destination_location.level, destination_location.path, destination_location.max_weight, destination_location.max_volume, destination_location.max_pallets, destination_location.x_coordinate, destination_location.y_coordinate, destination_location.z_coordinate, destination_location.is_pickable, destination_location.is_receivable, destination_location.temperature_controlled, destination_location.hazmat_approved, destination_location.is_active, destination_location.created_at, destination_location.updated_at
from
  "wms"."task_items" as task_items
  inner join "wms"."tasks" as task on task_items.task_id = task.id
  inner join "wms"."products" as product on task_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on task_items.batch_id = batch.id
  left join "wms"."locations" as source_location on task_items.source_location_id = source_location.id
  left join "wms"."locations" as destination_location on task_items.destination_location_id = destination_location.id
where (task.task_number ilike $1::text
  or product.name ilike $1::text
  or batch.batch_number ilike $1::text
  or source_location.name ilike $1::text
  or destination_location.name ilike $1::text
  or task_items.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateTaskItemParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type WmsPaginateTaskItemRow struct {
	ID                    pgtype.UUID               `db:"id" json:"id"`
	TaskID                pgtype.UUID               `db:"task_id" json:"task_id"`
	ProductID             pgtype.UUID               `db:"product_id" json:"product_id"`
	BatchID               pgtype.UUID               `db:"batch_id" json:"batch_id"`
	SourceLocationID      pgtype.UUID               `db:"source_location_id" json:"source_location_id"`
	DestinationLocationID pgtype.UUID               `db:"destination_location_id" json:"destination_location_id"`
	QuantityRequired      int32                     `db:"quantity_required" json:"quantity_required"`
	QuantityCompleted     int32                     `db:"quantity_completed" json:"quantity_completed"`
	QuantityRemaining     pgtype.Int4               `db:"quantity_remaining" json:"quantity_remaining"`
	Status                NullWmsTaskItemStatusEnum `db:"status" json:"status"`
	LotNumber             pgtype.Text               `db:"lot_number" json:"lot_number"`
	SerialNumbers         []string                  `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate            pgtype.Date               `db:"expiry_date" json:"expiry_date"`
	Notes                 pgtype.Text               `db:"notes" json:"notes"`
	CompletedAt           pgtype.Timestamp          `db:"completed_at" json:"completed_at"`
	CreatedAt             pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt             pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	WmsTask               WmsTask                   `db:"wms_task" json:"wms_task"`
	WmsProduct            WmsProduct                `db:"wms_product" json:"wms_product"`
	WmsInventoryBatch     WmsInventoryBatch         `db:"wms_inventory_batch" json:"wms_inventory_batch"`
	WmsLocation           WmsLocation               `db:"wms_location" json:"wms_location"`
	WmsLocation_2         WmsLocation               `db:"wms_location_2" json:"wms_location_2"`
}

func (q *Queries) WmsPaginateTaskItem(ctx context.Context, arg WmsPaginateTaskItemParams) ([]WmsPaginateTaskItemRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateTaskItem, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateTaskItemRow
	for rows.Next() {
		var i WmsPaginateTaskItemRow
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.ProductID,
			&i.BatchID,
			&i.SourceLocationID,
			&i.DestinationLocationID,
			&i.QuantityRequired,
			&i.QuantityCompleted,
			&i.QuantityRemaining,
			&i.Status,
			&i.LotNumber,
			&i.SerialNumbers,
			&i.ExpiryDate,
			&i.Notes,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsTask.ID,
			&i.WmsTask.TaskNumber,
			&i.WmsTask.WarehouseID,
			&i.WmsTask.UserID,
			&i.WmsTask.Type,
			&i.WmsTask.Status,
			&i.WmsTask.Priority,
			&i.WmsTask.SourceEntityID,
			&i.WmsTask.SourceEntityType,
			&i.WmsTask.PickBatchID,
			&i.WmsTask.EstimatedDuration,
			&i.WmsTask.ActualDuration,
			&i.WmsTask.Instructions,
			&i.WmsTask.Notes,
			&i.WmsTask.StartTime,
			&i.WmsTask.EndTime,
			&i.WmsTask.DurationSeconds,
			&i.WmsTask.CreatedAt,
			&i.WmsTask.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsLocation_2.ID,
			&i.WmsLocation_2.WarehouseID,
			&i.WmsLocation_2.ParentLocationID,
			&i.WmsLocation_2.Name,
			&i.WmsLocation_2.Barcode,
			&i.WmsLocation_2.Type,
			&i.WmsLocation_2.Level,
			&i.WmsLocation_2.Path,
			&i.WmsLocation_2.MaxWeight,
			&i.WmsLocation_2.MaxVolume,
			&i.WmsLocation_2.MaxPallets,
			&i.WmsLocation_2.XCoordinate,
			&i.WmsLocation_2.YCoordinate,
			&i.WmsLocation_2.ZCoordinate,
			&i.WmsLocation_2.IsPickable,
			&i.WmsLocation_2.IsReceivable,
			&i.WmsLocation_2.TemperatureControlled,
			&i.WmsLocation_2.HazmatApproved,
			&i.WmsLocation_2.IsActive,
			&i.WmsLocation_2.CreatedAt,
			&i.WmsLocation_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsPaginateTaskItemMetadata = `-- name: WmsPaginateTaskItemMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "wms"."task_items" as task_items
`

type WmsPaginateTaskItemMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type WmsPaginateTaskItemMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) WmsPaginateTaskItemMetadata(ctx context.Context, arg WmsPaginateTaskItemMetadataParams) (WmsPaginateTaskItemMetadataRow, error) {
	row := q.db.QueryRow(ctx, wmsPaginateTaskItemMetadata, arg.PerPage, arg.Page)
	var i WmsPaginateTaskItemMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const wmsRangeTaskItem = `-- name: WmsRangeTaskItem :many
select
  task_items.id, task_items.task_id, task_items.product_id, task_items.batch_id, task_items.source_location_id, task_items.destination_location_id, task_items.quantity_required, task_items.quantity_completed, task_items.quantity_remaining, task_items.status, task_items.lot_number, task_items.serial_numbers, task_items.expiry_date, task_items.notes, task_items.completed_at, task_items.created_at, task_items.updated_at,
  task.id, task.task_number, task.warehouse_id, task.user_id, task.type, task.status, task.priority, task.source_entity_id, task.source_entity_type, task.pick_batch_id, task.estimated_duration, task.actual_duration, task.instructions, task.notes, task.start_time, task.end_time, task.duration_seconds, task.created_at, task.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at,
  source_location.id, source_location.warehouse_id, source_location.parent_location_id, source_location.name, source_location.barcode, source_location.type, source_location.level, source_location.path, source_location.max_weight, source_location.max_volume, source_location.max_pallets, source_location.x_coordinate, source_location.y_coordinate, source_location.z_coordinate, source_location.is_pickable, source_location.is_receivable, source_location.temperature_controlled, source_location.hazmat_approved, source_location.is_active, source_location.created_at, source_location.updated_at,
  destination_location.id, destination_location.warehouse_id, destination_location.parent_location_id, destination_location.name, destination_location.barcode, destination_location.type, destination_location.level, destination_location.path, destination_location.max_weight, destination_location.max_volume, destination_location.max_pallets, destination_location.x_coordinate, destination_location.y_coordinate, destination_location.z_coordinate, destination_location.is_pickable, destination_location.is_receivable, destination_location.temperature_controlled, destination_location.hazmat_approved, destination_location.is_active, destination_location.created_at, destination_location.updated_at
from
  "wms"."task_items" as task_items
  inner join "wms"."tasks" as task on task_items.task_id = task.id
  inner join "wms"."products" as product on task_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on task_items.batch_id = batch.id
  left join "wms"."locations" as source_location on task_items.source_location_id = source_location.id
  left join "wms"."locations" as destination_location on task_items.destination_location_id = destination_location.id
where
  task_items.created_at >= $1::date
  and task_items.created_at <= $2::date
  and (task.task_number ilike $3::text
    or product.name ilike $3::text
    or batch.batch_number ilike $3::text
    or source_location.name ilike $3::text
    or destination_location.name ilike $3::text
    or task_items.status::text ilike $3::text
    or $3::text is null)
`

type WmsRangeTaskItemParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangeTaskItemRow struct {
	ID                    pgtype.UUID               `db:"id" json:"id"`
	TaskID                pgtype.UUID               `db:"task_id" json:"task_id"`
	ProductID             pgtype.UUID               `db:"product_id" json:"product_id"`
	BatchID               pgtype.UUID               `db:"batch_id" json:"batch_id"`
	SourceLocationID      pgtype.UUID               `db:"source_location_id" json:"source_location_id"`
	DestinationLocationID pgtype.UUID               `db:"destination_location_id" json:"destination_location_id"`
	QuantityRequired      int32                     `db:"quantity_required" json:"quantity_required"`
	QuantityCompleted     int32                     `db:"quantity_completed" json:"quantity_completed"`
	QuantityRemaining     pgtype.Int4               `db:"quantity_remaining" json:"quantity_remaining"`
	Status                NullWmsTaskItemStatusEnum `db:"status" json:"status"`
	LotNumber             pgtype.Text               `db:"lot_number" json:"lot_number"`
	SerialNumbers         []string                  `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate            pgtype.Date               `db:"expiry_date" json:"expiry_date"`
	Notes                 pgtype.Text               `db:"notes" json:"notes"`
	CompletedAt           pgtype.Timestamp          `db:"completed_at" json:"completed_at"`
	CreatedAt             pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt             pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	WmsTask               WmsTask                   `db:"wms_task" json:"wms_task"`
	WmsProduct            WmsProduct                `db:"wms_product" json:"wms_product"`
	WmsInventoryBatch     WmsInventoryBatch         `db:"wms_inventory_batch" json:"wms_inventory_batch"`
	WmsLocation           WmsLocation               `db:"wms_location" json:"wms_location"`
	WmsLocation_2         WmsLocation               `db:"wms_location_2" json:"wms_location_2"`
}

func (q *Queries) WmsRangeTaskItem(ctx context.Context, arg WmsRangeTaskItemParams) ([]WmsRangeTaskItemRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeTaskItem, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeTaskItemRow
	for rows.Next() {
		var i WmsRangeTaskItemRow
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.ProductID,
			&i.BatchID,
			&i.SourceLocationID,
			&i.DestinationLocationID,
			&i.QuantityRequired,
			&i.QuantityCompleted,
			&i.QuantityRemaining,
			&i.Status,
			&i.LotNumber,
			&i.SerialNumbers,
			&i.ExpiryDate,
			&i.Notes,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsTask.ID,
			&i.WmsTask.TaskNumber,
			&i.WmsTask.WarehouseID,
			&i.WmsTask.UserID,
			&i.WmsTask.Type,
			&i.WmsTask.Status,
			&i.WmsTask.Priority,
			&i.WmsTask.SourceEntityID,
			&i.WmsTask.SourceEntityType,
			&i.WmsTask.PickBatchID,
			&i.WmsTask.EstimatedDuration,
			&i.WmsTask.ActualDuration,
			&i.WmsTask.Instructions,
			&i.WmsTask.Notes,
			&i.WmsTask.StartTime,
			&i.WmsTask.EndTime,
			&i.WmsTask.DurationSeconds,
			&i.WmsTask.CreatedAt,
			&i.WmsTask.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsLocation_2.ID,
			&i.WmsLocation_2.WarehouseID,
			&i.WmsLocation_2.ParentLocationID,
			&i.WmsLocation_2.Name,
			&i.WmsLocation_2.Barcode,
			&i.WmsLocation_2.Type,
			&i.WmsLocation_2.Level,
			&i.WmsLocation_2.Path,
			&i.WmsLocation_2.MaxWeight,
			&i.WmsLocation_2.MaxVolume,
			&i.WmsLocation_2.MaxPallets,
			&i.WmsLocation_2.XCoordinate,
			&i.WmsLocation_2.YCoordinate,
			&i.WmsLocation_2.ZCoordinate,
			&i.WmsLocation_2.IsPickable,
			&i.WmsLocation_2.IsReceivable,
			&i.WmsLocation_2.TemperatureControlled,
			&i.WmsLocation_2.HazmatApproved,
			&i.WmsLocation_2.IsActive,
			&i.WmsLocation_2.CreatedAt,
			&i.WmsLocation_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveTaskItem = `-- name: WmsRemoveTaskItem :exec
delete from "wms"."task_items"
where id = $1::uuid
`

func (q *Queries) WmsRemoveTaskItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveTaskItem, id)
	return err
}

const wmsUpdateTaskItem = `-- name: WmsUpdateTaskItem :one
update
  "wms"."task_items"
set
  updated_at = now(),
  task_id = case when $1 is not null then
    $1::uuid
  else
    task_id
  end,
  product_id = case when $2 is not null then
    $2::uuid
  else
    product_id
  end,
  batch_id = case when $3 is not null then
    $3::uuid
  else
    batch_id
  end,
  source_location_id = case when $4 is not null then
    $4::uuid
  else
    source_location_id
  end,
  destination_location_id = case when $5 is not null then
    $5::uuid
  else
    destination_location_id
  end,
  quantity_required = case when $6 is not null then
    $6::integer
  else
    quantity_required
  end,
  quantity_completed = case when $7 is not null then
    $7::integer
  else
    quantity_completed
  end,
  status = case when $8 is not null then
    $8::wms.task_item_status_enum
  else
    status
  end,
  lot_number = case when $9 is not null then
    $9::varchar
  else
    lot_number
  end,
  serial_numbers = case when $10 is not null then
    $10::text[]
  else
    serial_numbers
  end,
  expiry_date = case when $11 is not null then
    $11::date
  else
    expiry_date
  end,
  notes = case when $12 is not null then
    $12::text
  else
    notes
  end,
  completed_at = case when $13 is not null then
    $13::timestamp
  else
    completed_at
  end
where
  id = $14::uuid
returning
  id, task_id, product_id, batch_id, source_location_id, destination_location_id, quantity_required, quantity_completed, quantity_remaining, status, lot_number, serial_numbers, expiry_date, notes, completed_at, created_at, updated_at
`

type WmsUpdateTaskItemParams struct {
	TaskID                pgtype.UUID               `db:"task_id" json:"task_id"`
	ProductID             pgtype.UUID               `db:"product_id" json:"product_id"`
	BatchID               pgtype.UUID               `db:"batch_id" json:"batch_id"`
	SourceLocationID      pgtype.UUID               `db:"source_location_id" json:"source_location_id"`
	DestinationLocationID pgtype.UUID               `db:"destination_location_id" json:"destination_location_id"`
	QuantityRequired      int32                     `db:"quantity_required" json:"quantity_required"`
	QuantityCompleted     int32                     `db:"quantity_completed" json:"quantity_completed"`
	Status                NullWmsTaskItemStatusEnum `db:"status" json:"status"`
	LotNumber             pgtype.Text               `db:"lot_number" json:"lot_number"`
	SerialNumbers         []string                  `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate            pgtype.Date               `db:"expiry_date" json:"expiry_date"`
	Notes                 pgtype.Text               `db:"notes" json:"notes"`
	CompletedAt           pgtype.Timestamp          `db:"completed_at" json:"completed_at"`
	ID                    pgtype.UUID               `db:"id" json:"id"`
}

func (q *Queries) WmsUpdateTaskItem(ctx context.Context, arg WmsUpdateTaskItemParams) (WmsTaskItem, error) {
	row := q.db.QueryRow(ctx, wmsUpdateTaskItem,
		arg.TaskID,
		arg.ProductID,
		arg.BatchID,
		arg.SourceLocationID,
		arg.DestinationLocationID,
		arg.QuantityRequired,
		arg.QuantityCompleted,
		arg.Status,
		arg.LotNumber,
		arg.SerialNumbers,
		arg.ExpiryDate,
		arg.Notes,
		arg.CompletedAt,
		arg.ID,
	)
	var i WmsTaskItem
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.ProductID,
		&i.BatchID,
		&i.SourceLocationID,
		&i.DestinationLocationID,
		&i.QuantityRequired,
		&i.QuantityCompleted,
		&i.QuantityRemaining,
		&i.Status,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.Notes,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
