// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_trips.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyTrip = `-- name: TmsAnyTrip :many
select
  trips.id, trips.driver_id, trips.vehicle_id, trips.status, trips.created_at, trips.updated_at, trips.end_location, trips.end_time, trips.start_location, trips.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."trips" as trips
  left join "tms"."drivers" as driver on trips.driver_id = driver.id
  left join "tms"."vehicles" as vehicle on trips.vehicle_id = vehicle.id
where
  trips.id = any ($1::uuid[])
`

type TmsAnyTripRow struct {
	TmsTrip    TmsTrip
	TmsDriver  TmsDriver
	TmsVehicle TmsVehicle
}

func (q *Queries) TmsAnyTrip(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyTripRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyTrip, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyTripRow
	for rows.Next() {
		var i TmsAnyTripRow
		if err := rows.Scan(
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindTrip = `-- name: TmsFindTrip :one
select
  trips.id, trips.driver_id, trips.vehicle_id, trips.status, trips.created_at, trips.updated_at, trips.end_location, trips.end_time, trips.start_location, trips.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."trips" as trips
  left join "tms"."drivers" as driver on trips.driver_id = driver.id
  left join "tms"."vehicles" as vehicle on trips.vehicle_id = vehicle.id
where
  trips.id = $1::uuid
`

type TmsFindTripRow struct {
	TmsTrip    TmsTrip
	TmsDriver  TmsDriver
	TmsVehicle TmsVehicle
}

func (q *Queries) TmsFindTrip(ctx context.Context, id pgtype.UUID) (TmsFindTripRow, error) {
	row := q.db.QueryRow(ctx, tmsFindTrip, id)
	var i TmsFindTripRow
	err := row.Scan(
		&i.TmsTrip.ID,
		&i.TmsTrip.DriverID,
		&i.TmsTrip.VehicleID,
		&i.TmsTrip.Status,
		&i.TmsTrip.CreatedAt,
		&i.TmsTrip.UpdatedAt,
		&i.TmsTrip.EndLocation,
		&i.TmsTrip.EndTime,
		&i.TmsTrip.StartLocation,
		&i.TmsTrip.StartTime,
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
		&i.TmsVehicle.ID,
		&i.TmsVehicle.RegistrationNumber,
		&i.TmsVehicle.Model,
		&i.TmsVehicle.CapacityVolume,
		&i.TmsVehicle.CapacityWeight,
		&i.TmsVehicle.Status,
		&i.TmsVehicle.CreatedAt,
		&i.TmsVehicle.UpdatedAt,
		&i.TmsVehicle.Make,
		&i.TmsVehicle.Year,
		&i.TmsVehicle.Vin,
		&i.TmsVehicle.CurrentMileage,
		&i.TmsVehicle.LastMaintenanceDate,
	)
	return i, err
}

const tmsInsertTrip = `-- name: TmsInsertTrip :one
insert into "tms"."trips"(driver_id, vehicle_id, status)
  values ($1, $2, $3)
returning
  id, driver_id, vehicle_id, status, created_at, updated_at, end_location, end_time, start_location, start_time
`

type TmsInsertTripParams struct {
	DriverID  pgtype.UUID
	VehicleID pgtype.UUID
	Status    NullTmsTripStatusEnum
}

func (q *Queries) TmsInsertTrip(ctx context.Context, arg TmsInsertTripParams) (TmsTrip, error) {
	row := q.db.QueryRow(ctx, tmsInsertTrip, arg.DriverID, arg.VehicleID, arg.Status)
	var i TmsTrip
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.VehicleID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EndLocation,
		&i.EndTime,
		&i.StartLocation,
		&i.StartTime,
	)
	return i, err
}

const tmsPaginateTrip = `-- name: TmsPaginateTrip :many
select
  trips.id, trips.driver_id, trips.vehicle_id, trips.status, trips.created_at, trips.updated_at, trips.end_location, trips.end_time, trips.start_location, trips.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."trips" as trips
  left join "tms"."drivers" as driver on trips.driver_id = driver.id
  left join "tms"."vehicles" as vehicle on trips.vehicle_id = vehicle.id
where
  (driver.name ilike $1::text
  or vehicle.registration_number ilike $1::text
  or trips.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateTripParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type TmsPaginateTripRow struct {
	TmsTrip    TmsTrip
	TmsDriver  TmsDriver
	TmsVehicle TmsVehicle
}

func (q *Queries) TmsPaginateTrip(ctx context.Context, arg TmsPaginateTripParams) ([]TmsPaginateTripRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateTrip, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateTripRow
	for rows.Next() {
		var i TmsPaginateTripRow
		if err := rows.Scan(
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeTrip = `-- name: TmsRangeTrip :many
select
  trips.id, trips.driver_id, trips.vehicle_id, trips.status, trips.created_at, trips.updated_at, trips.end_location, trips.end_time, trips.start_location, trips.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."trips" as trips
  left join "tms"."drivers" as driver on trips.driver_id = driver.id
  left join "tms"."vehicles" as vehicle on trips.vehicle_id = vehicle.id
where
  trips.created_at >= $1::date
  and trips.created_at <= $2::date
  and (driver.name ilike $3::text
  or vehicle.registration_number ilike $3::text
  or trips.status::text ilike $3::text
  or $3::text is null)
`

type TmsRangeTripParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type TmsRangeTripRow struct {
	TmsTrip    TmsTrip
	TmsDriver  TmsDriver
	TmsVehicle TmsVehicle
}

func (q *Queries) TmsRangeTrip(ctx context.Context, arg TmsRangeTripParams) ([]TmsRangeTripRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeTrip, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeTripRow
	for rows.Next() {
		var i TmsRangeTripRow
		if err := rows.Scan(
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveTrip = `-- name: TmsRemoveTrip :exec
delete from "tms"."trips"
where id = $1::uuid
`

func (q *Queries) TmsRemoveTrip(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveTrip, id)
	return err
}

const tmsUpdateTrip = `-- name: TmsUpdateTrip :one
update
  "tms"."trips"
set
  updated_at = now(),
  driver_id = case when $1::boolean then
    $2::uuid
  else
    driver_id
  end,
  vehicle_id = case when $3::boolean then
    $4::uuid
  else
    vehicle_id
  end,
  status = case when $5::boolean then
    $6::tms.trip_status_enum
  else
    status
  end
where
  id = $7::uuid
returning
  id, driver_id, vehicle_id, status, created_at, updated_at, end_location, end_time, start_location, start_time
`

type TmsUpdateTripParams struct {
	SetDriverID  bool
	DriverID     pgtype.UUID
	SetVehicleID bool
	VehicleID    pgtype.UUID
	SetStatus    bool
	Status       TmsTripStatusEnum
	ID           pgtype.UUID
}

func (q *Queries) TmsUpdateTrip(ctx context.Context, arg TmsUpdateTripParams) (TmsTrip, error) {
	row := q.db.QueryRow(ctx, tmsUpdateTrip,
		arg.SetDriverID,
		arg.DriverID,
		arg.SetVehicleID,
		arg.VehicleID,
		arg.SetStatus,
		arg.Status,
		arg.ID,
	)
	var i TmsTrip
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.VehicleID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EndLocation,
		&i.EndTime,
		&i.StartLocation,
		&i.StartTime,
	)
	return i, err
}
