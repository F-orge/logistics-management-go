// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_locations.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyLocation = `-- name: WmsAnyLocation :many
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at, locations.inventory_stock, locations.putaway_rules, locations.bin_thresholds,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations_view" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  locations.id = any ($1::uuid[])
`

type WmsAnyLocationRow struct {
	WmsLocationsView WmsLocationsView `db:"wms_locations_view" json:"wms_locations_view"`
	WmsWarehouse     WmsWarehouse     `db:"wms_warehouse" json:"wms_warehouse"`
}

func (q *Queries) WmsAnyLocation(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyLocationRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyLocation, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyLocationRow
	for rows.Next() {
		var i WmsAnyLocationRow
		if err := rows.Scan(
			&i.WmsLocationsView.ID,
			&i.WmsLocationsView.WarehouseID,
			&i.WmsLocationsView.ParentLocationID,
			&i.WmsLocationsView.Name,
			&i.WmsLocationsView.Barcode,
			&i.WmsLocationsView.Type,
			&i.WmsLocationsView.Level,
			&i.WmsLocationsView.Path,
			&i.WmsLocationsView.MaxWeight,
			&i.WmsLocationsView.MaxVolume,
			&i.WmsLocationsView.MaxPallets,
			&i.WmsLocationsView.XCoordinate,
			&i.WmsLocationsView.YCoordinate,
			&i.WmsLocationsView.ZCoordinate,
			&i.WmsLocationsView.IsPickable,
			&i.WmsLocationsView.IsReceivable,
			&i.WmsLocationsView.TemperatureControlled,
			&i.WmsLocationsView.HazmatApproved,
			&i.WmsLocationsView.IsActive,
			&i.WmsLocationsView.CreatedAt,
			&i.WmsLocationsView.UpdatedAt,
			&i.WmsLocationsView.InventoryStock,
			&i.WmsLocationsView.PutawayRules,
			&i.WmsLocationsView.BinThresholds,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindLocation = `-- name: WmsFindLocation :one
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at, locations.inventory_stock, locations.putaway_rules, locations.bin_thresholds,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations_view" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  locations.id = $1::uuid
`

type WmsFindLocationRow struct {
	WmsLocationsView WmsLocationsView `db:"wms_locations_view" json:"wms_locations_view"`
	WmsWarehouse     WmsWarehouse     `db:"wms_warehouse" json:"wms_warehouse"`
}

func (q *Queries) WmsFindLocation(ctx context.Context, id pgtype.UUID) (WmsFindLocationRow, error) {
	row := q.db.QueryRow(ctx, wmsFindLocation, id)
	var i WmsFindLocationRow
	err := row.Scan(
		&i.WmsLocationsView.ID,
		&i.WmsLocationsView.WarehouseID,
		&i.WmsLocationsView.ParentLocationID,
		&i.WmsLocationsView.Name,
		&i.WmsLocationsView.Barcode,
		&i.WmsLocationsView.Type,
		&i.WmsLocationsView.Level,
		&i.WmsLocationsView.Path,
		&i.WmsLocationsView.MaxWeight,
		&i.WmsLocationsView.MaxVolume,
		&i.WmsLocationsView.MaxPallets,
		&i.WmsLocationsView.XCoordinate,
		&i.WmsLocationsView.YCoordinate,
		&i.WmsLocationsView.ZCoordinate,
		&i.WmsLocationsView.IsPickable,
		&i.WmsLocationsView.IsReceivable,
		&i.WmsLocationsView.TemperatureControlled,
		&i.WmsLocationsView.HazmatApproved,
		&i.WmsLocationsView.IsActive,
		&i.WmsLocationsView.CreatedAt,
		&i.WmsLocationsView.UpdatedAt,
		&i.WmsLocationsView.InventoryStock,
		&i.WmsLocationsView.PutawayRules,
		&i.WmsLocationsView.BinThresholds,
		&i.WmsWarehouse.ID,
		&i.WmsWarehouse.Name,
		&i.WmsWarehouse.Address,
		&i.WmsWarehouse.City,
		&i.WmsWarehouse.State,
		&i.WmsWarehouse.PostalCode,
		&i.WmsWarehouse.Country,
		&i.WmsWarehouse.Timezone,
		&i.WmsWarehouse.ContactPerson,
		&i.WmsWarehouse.ContactEmail,
		&i.WmsWarehouse.ContactPhone,
		&i.WmsWarehouse.IsActive,
		&i.WmsWarehouse.CreatedAt,
		&i.WmsWarehouse.UpdatedAt,
	)
	return i, err
}

const wmsInsertLocation = `-- name: WmsInsertLocation :one
insert into "wms"."locations"(warehouse_id, parent_location_id, name, barcode, type, level, path, max_weight, max_volume, max_pallets, x_coordinate, y_coordinate, z_coordinate, is_pickable, is_receivable, temperature_controlled, hazmat_approved, is_active)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
returning
  id, warehouse_id, parent_location_id, name, barcode, type, level, path, max_weight, max_volume, max_pallets, x_coordinate, y_coordinate, z_coordinate, is_pickable, is_receivable, temperature_controlled, hazmat_approved, is_active, created_at, updated_at
`

type WmsInsertLocationParams struct {
	WarehouseID           pgtype.UUID         `db:"warehouse_id" json:"warehouse_id"`
	ParentLocationID      pgtype.UUID         `db:"parent_location_id" json:"parent_location_id"`
	Name                  string              `db:"name" json:"name"`
	Barcode               pgtype.Text         `db:"barcode" json:"barcode"`
	Type                  WmsLocationTypeEnum `db:"type" json:"type"`
	Level                 pgtype.Int4         `db:"level" json:"level"`
	Path                  pgtype.Text         `db:"path" json:"path"`
	MaxWeight             pgtype.Float4       `db:"max_weight" json:"max_weight"`
	MaxVolume             pgtype.Float4       `db:"max_volume" json:"max_volume"`
	MaxPallets            pgtype.Int4         `db:"max_pallets" json:"max_pallets"`
	XCoordinate           pgtype.Float4       `db:"x_coordinate" json:"x_coordinate"`
	YCoordinate           pgtype.Float4       `db:"y_coordinate" json:"y_coordinate"`
	ZCoordinate           pgtype.Float4       `db:"z_coordinate" json:"z_coordinate"`
	IsPickable            pgtype.Bool         `db:"is_pickable" json:"is_pickable"`
	IsReceivable          pgtype.Bool         `db:"is_receivable" json:"is_receivable"`
	TemperatureControlled pgtype.Bool         `db:"temperature_controlled" json:"temperature_controlled"`
	HazmatApproved        pgtype.Bool         `db:"hazmat_approved" json:"hazmat_approved"`
	IsActive              pgtype.Bool         `db:"is_active" json:"is_active"`
}

func (q *Queries) WmsInsertLocation(ctx context.Context, arg WmsInsertLocationParams) (WmsLocation, error) {
	row := q.db.QueryRow(ctx, wmsInsertLocation,
		arg.WarehouseID,
		arg.ParentLocationID,
		arg.Name,
		arg.Barcode,
		arg.Type,
		arg.Level,
		arg.Path,
		arg.MaxWeight,
		arg.MaxVolume,
		arg.MaxPallets,
		arg.XCoordinate,
		arg.YCoordinate,
		arg.ZCoordinate,
		arg.IsPickable,
		arg.IsReceivable,
		arg.TemperatureControlled,
		arg.HazmatApproved,
		arg.IsActive,
	)
	var i WmsLocation
	err := row.Scan(
		&i.ID,
		&i.WarehouseID,
		&i.ParentLocationID,
		&i.Name,
		&i.Barcode,
		&i.Type,
		&i.Level,
		&i.Path,
		&i.MaxWeight,
		&i.MaxVolume,
		&i.MaxPallets,
		&i.XCoordinate,
		&i.YCoordinate,
		&i.ZCoordinate,
		&i.IsPickable,
		&i.IsReceivable,
		&i.TemperatureControlled,
		&i.HazmatApproved,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateLocation = `-- name: WmsPaginateLocation :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page,
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at, locations.inventory_stock, locations.putaway_rules, locations.bin_thresholds,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations_view" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where (warehouse.name ilike $3::text
  or locations.name ilike $3::text
  or locations.barcode ilike $3::text
  or locations.type::text ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type WmsPaginateLocationParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type WmsPaginateLocationRow struct {
	TotalItems       int64            `db:"total_items" json:"total_items"`
	TotalPages       float64          `db:"total_pages" json:"total_pages"`
	Page             int32            `db:"page" json:"page"`
	PerPage          int32            `db:"per_page" json:"per_page"`
	WmsLocationsView WmsLocationsView `db:"wms_locations_view" json:"wms_locations_view"`
	WmsWarehouse     WmsWarehouse     `db:"wms_warehouse" json:"wms_warehouse"`
}

func (q *Queries) WmsPaginateLocation(ctx context.Context, arg WmsPaginateLocationParams) ([]WmsPaginateLocationRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateLocation, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateLocationRow
	for rows.Next() {
		var i WmsPaginateLocationRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.WmsLocationsView.ID,
			&i.WmsLocationsView.WarehouseID,
			&i.WmsLocationsView.ParentLocationID,
			&i.WmsLocationsView.Name,
			&i.WmsLocationsView.Barcode,
			&i.WmsLocationsView.Type,
			&i.WmsLocationsView.Level,
			&i.WmsLocationsView.Path,
			&i.WmsLocationsView.MaxWeight,
			&i.WmsLocationsView.MaxVolume,
			&i.WmsLocationsView.MaxPallets,
			&i.WmsLocationsView.XCoordinate,
			&i.WmsLocationsView.YCoordinate,
			&i.WmsLocationsView.ZCoordinate,
			&i.WmsLocationsView.IsPickable,
			&i.WmsLocationsView.IsReceivable,
			&i.WmsLocationsView.TemperatureControlled,
			&i.WmsLocationsView.HazmatApproved,
			&i.WmsLocationsView.IsActive,
			&i.WmsLocationsView.CreatedAt,
			&i.WmsLocationsView.UpdatedAt,
			&i.WmsLocationsView.InventoryStock,
			&i.WmsLocationsView.PutawayRules,
			&i.WmsLocationsView.BinThresholds,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeLocation = `-- name: WmsRangeLocation :many
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at, locations.inventory_stock, locations.putaway_rules, locations.bin_thresholds,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations_view" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  locations.created_at >= $1::date
  and locations.created_at <= $2::date
  and (warehouse.name ilike $3::text
    or locations.name ilike $3::text
    or locations.barcode ilike $3::text
    or locations.type::text ilike $3::text
    or $3::text is null)
`

type WmsRangeLocationParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangeLocationRow struct {
	WmsLocationsView WmsLocationsView `db:"wms_locations_view" json:"wms_locations_view"`
	WmsWarehouse     WmsWarehouse     `db:"wms_warehouse" json:"wms_warehouse"`
}

func (q *Queries) WmsRangeLocation(ctx context.Context, arg WmsRangeLocationParams) ([]WmsRangeLocationRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeLocation, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeLocationRow
	for rows.Next() {
		var i WmsRangeLocationRow
		if err := rows.Scan(
			&i.WmsLocationsView.ID,
			&i.WmsLocationsView.WarehouseID,
			&i.WmsLocationsView.ParentLocationID,
			&i.WmsLocationsView.Name,
			&i.WmsLocationsView.Barcode,
			&i.WmsLocationsView.Type,
			&i.WmsLocationsView.Level,
			&i.WmsLocationsView.Path,
			&i.WmsLocationsView.MaxWeight,
			&i.WmsLocationsView.MaxVolume,
			&i.WmsLocationsView.MaxPallets,
			&i.WmsLocationsView.XCoordinate,
			&i.WmsLocationsView.YCoordinate,
			&i.WmsLocationsView.ZCoordinate,
			&i.WmsLocationsView.IsPickable,
			&i.WmsLocationsView.IsReceivable,
			&i.WmsLocationsView.TemperatureControlled,
			&i.WmsLocationsView.HazmatApproved,
			&i.WmsLocationsView.IsActive,
			&i.WmsLocationsView.CreatedAt,
			&i.WmsLocationsView.UpdatedAt,
			&i.WmsLocationsView.InventoryStock,
			&i.WmsLocationsView.PutawayRules,
			&i.WmsLocationsView.BinThresholds,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveLocation = `-- name: WmsRemoveLocation :exec
delete from "wms"."locations"
where id = $1::uuid
`

func (q *Queries) WmsRemoveLocation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveLocation, id)
	return err
}

const wmsUpdateLocation = `-- name: WmsUpdateLocation :one
update
  "wms"."locations"
set
  updated_at = now(),
  warehouse_id = case when $1 is not null then
    $1::uuid
  else
    warehouse_id
  end,
  parent_location_id = case when $2 is not null then
    $2::uuid
  else
    parent_location_id
  end,
  name = case when $3 is not null then
    $3::varchar
  else
    name
  end,
  barcode = case when $4 is not null then
    $4::varchar
  else
    barcode
  end,
  type = case when $5 is not null then
    $5::wms.location_type_enum
  else
    type
  end,
  level = case when $6 is not null then
    $6::integer
  else
    level
  end,
  path = case when $7 is not null then
    $7::text
  else
    path
  end,
  max_weight = case when $8 is not null then
    $8::real
  else
    max_weight
  end,
  max_volume = case when $9 is not null then
    $9::real
  else
    max_volume
  end,
  max_pallets = case when $10 is not null then
    $10::integer
  else
    max_pallets
  end,
  x_coordinate = case when $11 is not null then
    $11::real
  else
    x_coordinate
  end,
  y_coordinate = case when $12 is not null then
    $12::real
  else
    y_coordinate
  end,
  z_coordinate = case when $13 is not null then
    $13::real
  else
    z_coordinate
  end,
  is_pickable = case when $14 is not null then
    $14::boolean
  else
    is_pickable
  end,
  is_receivable = case when $15 is not null then
    $15::boolean
  else
    is_receivable
  end,
  temperature_controlled = case when $16 is not null then
    $16::boolean
  else
    temperature_controlled
  end,
  hazmat_approved = case when $17 is not null then
    $17::boolean
  else
    hazmat_approved
  end,
  is_active = case when $18 is not null then
    $18::boolean
  else
    is_active
  end
where
  id = $19::uuid
returning
  id, warehouse_id, parent_location_id, name, barcode, type, level, path, max_weight, max_volume, max_pallets, x_coordinate, y_coordinate, z_coordinate, is_pickable, is_receivable, temperature_controlled, hazmat_approved, is_active, created_at, updated_at
`

type WmsUpdateLocationParams struct {
	WarehouseID           pgtype.UUID         `db:"warehouse_id" json:"warehouse_id"`
	ParentLocationID      pgtype.UUID         `db:"parent_location_id" json:"parent_location_id"`
	Name                  string              `db:"name" json:"name"`
	Barcode               pgtype.Text         `db:"barcode" json:"barcode"`
	Type                  WmsLocationTypeEnum `db:"type" json:"type"`
	Level                 pgtype.Int4         `db:"level" json:"level"`
	Path                  pgtype.Text         `db:"path" json:"path"`
	MaxWeight             pgtype.Float4       `db:"max_weight" json:"max_weight"`
	MaxVolume             pgtype.Float4       `db:"max_volume" json:"max_volume"`
	MaxPallets            pgtype.Int4         `db:"max_pallets" json:"max_pallets"`
	XCoordinate           pgtype.Float4       `db:"x_coordinate" json:"x_coordinate"`
	YCoordinate           pgtype.Float4       `db:"y_coordinate" json:"y_coordinate"`
	ZCoordinate           pgtype.Float4       `db:"z_coordinate" json:"z_coordinate"`
	IsPickable            pgtype.Bool         `db:"is_pickable" json:"is_pickable"`
	IsReceivable          pgtype.Bool         `db:"is_receivable" json:"is_receivable"`
	TemperatureControlled pgtype.Bool         `db:"temperature_controlled" json:"temperature_controlled"`
	HazmatApproved        pgtype.Bool         `db:"hazmat_approved" json:"hazmat_approved"`
	IsActive              pgtype.Bool         `db:"is_active" json:"is_active"`
	ID                    pgtype.UUID         `db:"id" json:"id"`
}

func (q *Queries) WmsUpdateLocation(ctx context.Context, arg WmsUpdateLocationParams) (WmsLocation, error) {
	row := q.db.QueryRow(ctx, wmsUpdateLocation,
		arg.WarehouseID,
		arg.ParentLocationID,
		arg.Name,
		arg.Barcode,
		arg.Type,
		arg.Level,
		arg.Path,
		arg.MaxWeight,
		arg.MaxVolume,
		arg.MaxPallets,
		arg.XCoordinate,
		arg.YCoordinate,
		arg.ZCoordinate,
		arg.IsPickable,
		arg.IsReceivable,
		arg.TemperatureControlled,
		arg.HazmatApproved,
		arg.IsActive,
		arg.ID,
	)
	var i WmsLocation
	err := row.Scan(
		&i.ID,
		&i.WarehouseID,
		&i.ParentLocationID,
		&i.Name,
		&i.Barcode,
		&i.Type,
		&i.Level,
		&i.Path,
		&i.MaxWeight,
		&i.MaxVolume,
		&i.MaxPallets,
		&i.XCoordinate,
		&i.YCoordinate,
		&i.ZCoordinate,
		&i.IsPickable,
		&i.IsReceivable,
		&i.TemperatureControlled,
		&i.HazmatApproved,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
