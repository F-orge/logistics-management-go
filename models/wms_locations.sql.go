// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_locations.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyLocation = `-- name: WmsAnyLocation :many
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  locations.id = any ($1::uuid[])
`

type WmsAnyLocationRow struct {
	WmsLocation  WmsLocation
	WmsWarehouse WmsWarehouse
}

func (q *Queries) WmsAnyLocation(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyLocationRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyLocation, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyLocationRow
	for rows.Next() {
		var i WmsAnyLocationRow
		if err := rows.Scan(
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindLocation = `-- name: WmsFindLocation :one
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  locations.id = $1::uuid
`

type WmsFindLocationRow struct {
	WmsLocation  WmsLocation
	WmsWarehouse WmsWarehouse
}

func (q *Queries) WmsFindLocation(ctx context.Context, id pgtype.UUID) (WmsFindLocationRow, error) {
	row := q.db.QueryRow(ctx, wmsFindLocation, id)
	var i WmsFindLocationRow
	err := row.Scan(
		&i.WmsLocation.ID,
		&i.WmsLocation.WarehouseID,
		&i.WmsLocation.ParentLocationID,
		&i.WmsLocation.Name,
		&i.WmsLocation.Barcode,
		&i.WmsLocation.Type,
		&i.WmsLocation.Level,
		&i.WmsLocation.Path,
		&i.WmsLocation.MaxWeight,
		&i.WmsLocation.MaxVolume,
		&i.WmsLocation.MaxPallets,
		&i.WmsLocation.XCoordinate,
		&i.WmsLocation.YCoordinate,
		&i.WmsLocation.ZCoordinate,
		&i.WmsLocation.IsPickable,
		&i.WmsLocation.IsReceivable,
		&i.WmsLocation.TemperatureControlled,
		&i.WmsLocation.HazmatApproved,
		&i.WmsLocation.IsActive,
		&i.WmsLocation.CreatedAt,
		&i.WmsLocation.UpdatedAt,
		&i.WmsWarehouse.ID,
		&i.WmsWarehouse.Name,
		&i.WmsWarehouse.Address,
		&i.WmsWarehouse.City,
		&i.WmsWarehouse.State,
		&i.WmsWarehouse.PostalCode,
		&i.WmsWarehouse.Country,
		&i.WmsWarehouse.Timezone,
		&i.WmsWarehouse.ContactPerson,
		&i.WmsWarehouse.ContactEmail,
		&i.WmsWarehouse.ContactPhone,
		&i.WmsWarehouse.IsActive,
		&i.WmsWarehouse.CreatedAt,
		&i.WmsWarehouse.UpdatedAt,
	)
	return i, err
}

const wmsInsertLocation = `-- name: WmsInsertLocation :one
insert into "wms"."locations"(warehouse_id, parent_location_id, name, barcode, type, level, path, max_weight, max_volume, max_pallets, x_coordinate, y_coordinate, z_coordinate, is_pickable, is_receivable, temperature_controlled, hazmat_approved, is_active)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
returning
  id, warehouse_id, parent_location_id, name, barcode, type, level, path, max_weight, max_volume, max_pallets, x_coordinate, y_coordinate, z_coordinate, is_pickable, is_receivable, temperature_controlled, hazmat_approved, is_active, created_at, updated_at
`

type WmsInsertLocationParams struct {
	WarehouseID           pgtype.UUID
	ParentLocationID      pgtype.UUID
	Name                  string
	Barcode               pgtype.Text
	Type                  WmsLocationTypeEnum
	Level                 pgtype.Int4
	Path                  pgtype.Text
	MaxWeight             pgtype.Float4
	MaxVolume             pgtype.Float4
	MaxPallets            pgtype.Int4
	XCoordinate           pgtype.Float4
	YCoordinate           pgtype.Float4
	ZCoordinate           pgtype.Float4
	IsPickable            pgtype.Bool
	IsReceivable          pgtype.Bool
	TemperatureControlled pgtype.Bool
	HazmatApproved        pgtype.Bool
	IsActive              pgtype.Bool
}

func (q *Queries) WmsInsertLocation(ctx context.Context, arg WmsInsertLocationParams) (WmsLocation, error) {
	row := q.db.QueryRow(ctx, wmsInsertLocation,
		arg.WarehouseID,
		arg.ParentLocationID,
		arg.Name,
		arg.Barcode,
		arg.Type,
		arg.Level,
		arg.Path,
		arg.MaxWeight,
		arg.MaxVolume,
		arg.MaxPallets,
		arg.XCoordinate,
		arg.YCoordinate,
		arg.ZCoordinate,
		arg.IsPickable,
		arg.IsReceivable,
		arg.TemperatureControlled,
		arg.HazmatApproved,
		arg.IsActive,
	)
	var i WmsLocation
	err := row.Scan(
		&i.ID,
		&i.WarehouseID,
		&i.ParentLocationID,
		&i.Name,
		&i.Barcode,
		&i.Type,
		&i.Level,
		&i.Path,
		&i.MaxWeight,
		&i.MaxVolume,
		&i.MaxPallets,
		&i.XCoordinate,
		&i.YCoordinate,
		&i.ZCoordinate,
		&i.IsPickable,
		&i.IsReceivable,
		&i.TemperatureControlled,
		&i.HazmatApproved,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateLocation = `-- name: WmsPaginateLocation :many
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where (warehouse.name ilike $1::text
  or locations.name ilike $1::text
  or locations.barcode ilike $1::text
  or locations.type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateLocationParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginateLocationRow struct {
	WmsLocation  WmsLocation
	WmsWarehouse WmsWarehouse
}

func (q *Queries) WmsPaginateLocation(ctx context.Context, arg WmsPaginateLocationParams) ([]WmsPaginateLocationRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateLocation, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateLocationRow
	for rows.Next() {
		var i WmsPaginateLocationRow
		if err := rows.Scan(
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeLocation = `-- name: WmsRangeLocation :many
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  locations.created_at >= $1::date
  and locations.created_at <= $2::date
  and (warehouse.name ilike $3::text
    or locations.name ilike $3::text
    or locations.barcode ilike $3::text
    or locations.type::text ilike $3::text
    or $3::text is null)
`

type WmsRangeLocationParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangeLocationRow struct {
	WmsLocation  WmsLocation
	WmsWarehouse WmsWarehouse
}

func (q *Queries) WmsRangeLocation(ctx context.Context, arg WmsRangeLocationParams) ([]WmsRangeLocationRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeLocation, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeLocationRow
	for rows.Next() {
		var i WmsRangeLocationRow
		if err := rows.Scan(
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveLocation = `-- name: WmsRemoveLocation :exec
delete from "wms"."locations"
where id = $1::uuid
`

func (q *Queries) WmsRemoveLocation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveLocation, id)
	return err
}

const wmsUpdateLocation = `-- name: WmsUpdateLocation :one
update
  "wms"."locations"
set
  updated_at = now(),
  warehouse_id = case when $1 is not null then
    $1::uuid
  else
    warehouse_id
  end,
  parent_location_id = case when $2 is not null then
    $2::uuid
  else
    parent_location_id
  end,
  name = case when $3 is not null then
    $3::varchar
  else
    name
  end,
  barcode = case when $4 is not null then
    $4::varchar
  else
    barcode
  end,
  type = case when $5 is not null then
    $5::wms.location_type_enum
  else
    type
  end,
  level = case when $6 is not null then
    $6::integer
  else
    level
  end,
  path = case when $7 is not null then
    $7::text
  else
    path
  end,
  max_weight = case when $8 is not null then
    $8::real
  else
    max_weight
  end,
  max_volume = case when $9 is not null then
    $9::real
  else
    max_volume
  end,
  max_pallets = case when $10 is not null then
    $10::integer
  else
    max_pallets
  end,
  x_coordinate = case when $11 is not null then
    $11::real
  else
    x_coordinate
  end,
  y_coordinate = case when $12 is not null then
    $12::real
  else
    y_coordinate
  end,
  z_coordinate = case when $13 is not null then
    $13::real
  else
    z_coordinate
  end,
  is_pickable = case when $14 is not null then
    $14::boolean
  else
    is_pickable
  end,
  is_receivable = case when $15 is not null then
    $15::boolean
  else
    is_receivable
  end,
  temperature_controlled = case when $16 is not null then
    $16::boolean
  else
    temperature_controlled
  end,
  hazmat_approved = case when $17 is not null then
    $17::boolean
  else
    hazmat_approved
  end,
  is_active = case when $18 is not null then
    $18::boolean
  else
    is_active
  end
where
  id = $19::uuid
returning
  id, warehouse_id, parent_location_id, name, barcode, type, level, path, max_weight, max_volume, max_pallets, x_coordinate, y_coordinate, z_coordinate, is_pickable, is_receivable, temperature_controlled, hazmat_approved, is_active, created_at, updated_at
`

type WmsUpdateLocationParams struct {
	WarehouseID           pgtype.UUID
	ParentLocationID      pgtype.UUID
	Name                  string
	Barcode               pgtype.Text
	Type                  WmsLocationTypeEnum
	Level                 pgtype.Int4
	Path                  pgtype.Text
	MaxWeight             pgtype.Float4
	MaxVolume             pgtype.Float4
	MaxPallets            pgtype.Int4
	XCoordinate           pgtype.Float4
	YCoordinate           pgtype.Float4
	ZCoordinate           pgtype.Float4
	IsPickable            pgtype.Bool
	IsReceivable          pgtype.Bool
	TemperatureControlled pgtype.Bool
	HazmatApproved        pgtype.Bool
	IsActive              pgtype.Bool
	ID                    pgtype.UUID
}

func (q *Queries) WmsUpdateLocation(ctx context.Context, arg WmsUpdateLocationParams) (WmsLocation, error) {
	row := q.db.QueryRow(ctx, wmsUpdateLocation,
		arg.WarehouseID,
		arg.ParentLocationID,
		arg.Name,
		arg.Barcode,
		arg.Type,
		arg.Level,
		arg.Path,
		arg.MaxWeight,
		arg.MaxVolume,
		arg.MaxPallets,
		arg.XCoordinate,
		arg.YCoordinate,
		arg.ZCoordinate,
		arg.IsPickable,
		arg.IsReceivable,
		arg.TemperatureControlled,
		arg.HazmatApproved,
		arg.IsActive,
		arg.ID,
	)
	var i WmsLocation
	err := row.Scan(
		&i.ID,
		&i.WarehouseID,
		&i.ParentLocationID,
		&i.Name,
		&i.Barcode,
		&i.Type,
		&i.Level,
		&i.Path,
		&i.MaxWeight,
		&i.MaxVolume,
		&i.MaxPallets,
		&i.XCoordinate,
		&i.YCoordinate,
		&i.ZCoordinate,
		&i.IsPickable,
		&i.IsReceivable,
		&i.TemperatureControlled,
		&i.HazmatApproved,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
