// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_locations.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyLocation = `-- name: WmsAnyLocation :many
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  locations.id = any ($1::uuid[])
`

type WmsAnyLocationRow struct {
	WmsLocation  WmsLocation
	WmsWarehouse WmsWarehouse
}

func (q *Queries) WmsAnyLocation(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyLocationRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyLocation, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyLocationRow
	for rows.Next() {
		var i WmsAnyLocationRow
		if err := rows.Scan(
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindLocation = `-- name: WmsFindLocation :one
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  locations.id = $1::uuid
`

type WmsFindLocationRow struct {
	WmsLocation  WmsLocation
	WmsWarehouse WmsWarehouse
}

func (q *Queries) WmsFindLocation(ctx context.Context, id pgtype.UUID) (WmsFindLocationRow, error) {
	row := q.db.QueryRow(ctx, wmsFindLocation, id)
	var i WmsFindLocationRow
	err := row.Scan(
		&i.WmsLocation.ID,
		&i.WmsLocation.WarehouseID,
		&i.WmsLocation.ParentLocationID,
		&i.WmsLocation.Name,
		&i.WmsLocation.Barcode,
		&i.WmsLocation.Type,
		&i.WmsLocation.Level,
		&i.WmsLocation.Path,
		&i.WmsLocation.MaxWeight,
		&i.WmsLocation.MaxVolume,
		&i.WmsLocation.MaxPallets,
		&i.WmsLocation.XCoordinate,
		&i.WmsLocation.YCoordinate,
		&i.WmsLocation.ZCoordinate,
		&i.WmsLocation.IsPickable,
		&i.WmsLocation.IsReceivable,
		&i.WmsLocation.TemperatureControlled,
		&i.WmsLocation.HazmatApproved,
		&i.WmsLocation.IsActive,
		&i.WmsLocation.CreatedAt,
		&i.WmsLocation.UpdatedAt,
		&i.WmsWarehouse.ID,
		&i.WmsWarehouse.Name,
		&i.WmsWarehouse.Address,
		&i.WmsWarehouse.City,
		&i.WmsWarehouse.State,
		&i.WmsWarehouse.PostalCode,
		&i.WmsWarehouse.Country,
		&i.WmsWarehouse.Timezone,
		&i.WmsWarehouse.ContactPerson,
		&i.WmsWarehouse.ContactEmail,
		&i.WmsWarehouse.ContactPhone,
		&i.WmsWarehouse.IsActive,
		&i.WmsWarehouse.CreatedAt,
		&i.WmsWarehouse.UpdatedAt,
	)
	return i, err
}

const wmsInsertLocation = `-- name: WmsInsertLocation :one
insert into "wms"."locations"(warehouse_id, parent_location_id, name, barcode, type, level, path, max_weight, max_volume, max_pallets, x_coordinate, y_coordinate, z_coordinate, is_pickable, is_receivable, temperature_controlled, hazmat_approved, is_active)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
returning
  id, warehouse_id, parent_location_id, name, barcode, type, level, path, max_weight, max_volume, max_pallets, x_coordinate, y_coordinate, z_coordinate, is_pickable, is_receivable, temperature_controlled, hazmat_approved, is_active, created_at, updated_at
`

type WmsInsertLocationParams struct {
	WarehouseID           pgtype.UUID
	ParentLocationID      pgtype.UUID
	Name                  string
	Barcode               pgtype.Text
	Type                  WmsLocationTypeEnum
	Level                 pgtype.Int4
	Path                  pgtype.Text
	MaxWeight             pgtype.Float4
	MaxVolume             pgtype.Float4
	MaxPallets            pgtype.Int4
	XCoordinate           pgtype.Float4
	YCoordinate           pgtype.Float4
	ZCoordinate           pgtype.Float4
	IsPickable            pgtype.Bool
	IsReceivable          pgtype.Bool
	TemperatureControlled pgtype.Bool
	HazmatApproved        pgtype.Bool
	IsActive              pgtype.Bool
}

func (q *Queries) WmsInsertLocation(ctx context.Context, arg WmsInsertLocationParams) (WmsLocation, error) {
	row := q.db.QueryRow(ctx, wmsInsertLocation,
		arg.WarehouseID,
		arg.ParentLocationID,
		arg.Name,
		arg.Barcode,
		arg.Type,
		arg.Level,
		arg.Path,
		arg.MaxWeight,
		arg.MaxVolume,
		arg.MaxPallets,
		arg.XCoordinate,
		arg.YCoordinate,
		arg.ZCoordinate,
		arg.IsPickable,
		arg.IsReceivable,
		arg.TemperatureControlled,
		arg.HazmatApproved,
		arg.IsActive,
	)
	var i WmsLocation
	err := row.Scan(
		&i.ID,
		&i.WarehouseID,
		&i.ParentLocationID,
		&i.Name,
		&i.Barcode,
		&i.Type,
		&i.Level,
		&i.Path,
		&i.MaxWeight,
		&i.MaxVolume,
		&i.MaxPallets,
		&i.XCoordinate,
		&i.YCoordinate,
		&i.ZCoordinate,
		&i.IsPickable,
		&i.IsReceivable,
		&i.TemperatureControlled,
		&i.HazmatApproved,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateLocation = `-- name: WmsPaginateLocation :many
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  (warehouse.name ilike $1::text
  or locations.name ilike $1::text
  or locations.barcode ilike $1::text
  or locations.type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateLocationParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginateLocationRow struct {
	WmsLocation  WmsLocation
	WmsWarehouse WmsWarehouse
}

func (q *Queries) WmsPaginateLocation(ctx context.Context, arg WmsPaginateLocationParams) ([]WmsPaginateLocationRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateLocation, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateLocationRow
	for rows.Next() {
		var i WmsPaginateLocationRow
		if err := rows.Scan(
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeLocation = `-- name: WmsRangeLocation :many
select
  locations.id, locations.warehouse_id, locations.parent_location_id, locations.name, locations.barcode, locations.type, locations.level, locations.path, locations.max_weight, locations.max_volume, locations.max_pallets, locations.x_coordinate, locations.y_coordinate, locations.z_coordinate, locations.is_pickable, locations.is_receivable, locations.temperature_controlled, locations.hazmat_approved, locations.is_active, locations.created_at, locations.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at
from
  "wms"."locations" as locations
  inner join "wms"."warehouses" as warehouse on locations.warehouse_id = warehouse.id
where
  locations.created_at >= $1::date
  and locations.created_at <= $2::date
  and (warehouse.name ilike $3::text
  or locations.name ilike $3::text
  or locations.barcode ilike $3::text
  or locations.type::text ilike $3::text
  or $3::text is null)
`

type WmsRangeLocationParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangeLocationRow struct {
	WmsLocation  WmsLocation
	WmsWarehouse WmsWarehouse
}

func (q *Queries) WmsRangeLocation(ctx context.Context, arg WmsRangeLocationParams) ([]WmsRangeLocationRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeLocation, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeLocationRow
	for rows.Next() {
		var i WmsRangeLocationRow
		if err := rows.Scan(
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveLocation = `-- name: WmsRemoveLocation :exec
delete from "wms"."locations"
where id = $1::uuid
`

func (q *Queries) WmsRemoveLocation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveLocation, id)
	return err
}

const wmsUpdateLocation = `-- name: WmsUpdateLocation :one
update
  "wms"."locations"
set
  warehouse_id = case when $1::boolean then
    $2::uuid
  else
    warehouse_id
  end,
  parent_location_id = case when $3::boolean then
    $4::uuid
  else
    parent_location_id
  end,
  name = case when $5::boolean then
    $6::varchar
  else
    name
  end,
  barcode = case when $7::boolean then
    $8::varchar
  else
    barcode
  end,
  type = case when $9::boolean then
    $10::wms.location_type_enum
  else
    type
  end,
  level = case when $11::boolean then
    $12::integer
  else
    level
  end,
  path = case when $13::boolean then
    $14::text
  else
    path
  end,
  max_weight = case when $15::boolean then
    $16::real
  else
    max_weight
  end,
  max_volume = case when $17::boolean then
    $18::real
  else
    max_volume
  end,
  max_pallets = case when $19::boolean then
    $20::integer
  else
    max_pallets
  end,
  x_coordinate = case when $21::boolean then
    $22::real
  else
    x_coordinate
  end,
  y_coordinate = case when $23::boolean then
    $24::real
  else
    y_coordinate
  end,
  z_coordinate = case when $25::boolean then
    $26::real
  else
    z_coordinate
  end,
  is_pickable = case when $27::boolean then
    $28::boolean
  else
    is_pickable
  end,
  is_receivable = case when $29::boolean then
    $30::boolean
  else
    is_receivable
  end,
  temperature_controlled = case when $31::boolean then
    $32::boolean
  else
    temperature_controlled
  end,
  hazmat_approved = case when $33::boolean then
    $34::boolean
  else
    hazmat_approved
  end,
  is_active = case when $35::boolean then
    $36::boolean
  else
    is_active
  end
where
  id = $37::uuid
returning
  id, warehouse_id, parent_location_id, name, barcode, type, level, path, max_weight, max_volume, max_pallets, x_coordinate, y_coordinate, z_coordinate, is_pickable, is_receivable, temperature_controlled, hazmat_approved, is_active, created_at, updated_at
`

type WmsUpdateLocationParams struct {
	SetWarehouseID           bool
	WarehouseID              pgtype.UUID
	SetParentLocationID      bool
	ParentLocationID         pgtype.UUID
	SetName                  bool
	Name                     string
	SetBarcode               bool
	Barcode                  string
	SetType                  bool
	Type                     WmsLocationTypeEnum
	SetLevel                 bool
	Level                    int32
	SetPath                  bool
	Path                     string
	SetMaxWeight             bool
	MaxWeight                float32
	SetMaxVolume             bool
	MaxVolume                float32
	SetMaxPallets            bool
	MaxPallets               int32
	SetXCoordinate           bool
	XCoordinate              float32
	SetYCoordinate           bool
	YCoordinate              float32
	SetZCoordinate           bool
	ZCoordinate              float32
	SetIsPickable            bool
	IsPickable               bool
	SetIsReceivable          bool
	IsReceivable             bool
	SetTemperatureControlled bool
	TemperatureControlled    bool
	SetHazmatApproved        bool
	HazmatApproved           bool
	SetIsActive              bool
	IsActive                 bool
	ID                       pgtype.UUID
}

func (q *Queries) WmsUpdateLocation(ctx context.Context, arg WmsUpdateLocationParams) (WmsLocation, error) {
	row := q.db.QueryRow(ctx, wmsUpdateLocation,
		arg.SetWarehouseID,
		arg.WarehouseID,
		arg.SetParentLocationID,
		arg.ParentLocationID,
		arg.SetName,
		arg.Name,
		arg.SetBarcode,
		arg.Barcode,
		arg.SetType,
		arg.Type,
		arg.SetLevel,
		arg.Level,
		arg.SetPath,
		arg.Path,
		arg.SetMaxWeight,
		arg.MaxWeight,
		arg.SetMaxVolume,
		arg.MaxVolume,
		arg.SetMaxPallets,
		arg.MaxPallets,
		arg.SetXCoordinate,
		arg.XCoordinate,
		arg.SetYCoordinate,
		arg.YCoordinate,
		arg.SetZCoordinate,
		arg.ZCoordinate,
		arg.SetIsPickable,
		arg.IsPickable,
		arg.SetIsReceivable,
		arg.IsReceivable,
		arg.SetTemperatureControlled,
		arg.TemperatureControlled,
		arg.SetHazmatApproved,
		arg.HazmatApproved,
		arg.SetIsActive,
		arg.IsActive,
		arg.ID,
	)
	var i WmsLocation
	err := row.Scan(
		&i.ID,
		&i.WarehouseID,
		&i.ParentLocationID,
		&i.Name,
		&i.Barcode,
		&i.Type,
		&i.Level,
		&i.Path,
		&i.MaxWeight,
		&i.MaxVolume,
		&i.MaxPallets,
		&i.XCoordinate,
		&i.YCoordinate,
		&i.ZCoordinate,
		&i.IsPickable,
		&i.IsReceivable,
		&i.TemperatureControlled,
		&i.HazmatApproved,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
