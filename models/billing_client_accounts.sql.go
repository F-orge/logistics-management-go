// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_client_accounts.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyClientAccount = `-- name: BillingAnyClientAccount :many
select
  client_accounts.id, client_accounts.client_id, client_accounts.credit_limit, client_accounts.available_credit, client_accounts.wallet_balance, client_accounts.currency, client_accounts.payment_terms_days, client_accounts.is_credit_approved, client_accounts.last_payment_date, client_accounts.created_at, client_accounts.updated_at, client_accounts.account_transactions,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "billing"."client_accounts_view" as client_accounts
  inner join "crm"."companies" as client on client_accounts.client_id = client.id
where
  client_accounts.id = any ($1::uuid[])
`

type BillingAnyClientAccountRow struct {
	ID                  pgtype.UUID                 `db:"id" json:"id"`
	ClientID            pgtype.UUID                 `db:"client_id" json:"client_id"`
	CreditLimit         pgtype.Numeric              `db:"credit_limit" json:"credit_limit"`
	AvailableCredit     pgtype.Numeric              `db:"available_credit" json:"available_credit"`
	WalletBalance       pgtype.Numeric              `db:"wallet_balance" json:"wallet_balance"`
	Currency            pgtype.Text                 `db:"currency" json:"currency"`
	PaymentTermsDays    pgtype.Int4                 `db:"payment_terms_days" json:"payment_terms_days"`
	IsCreditApproved    pgtype.Bool                 `db:"is_credit_approved" json:"is_credit_approved"`
	LastPaymentDate     pgtype.Date                 `db:"last_payment_date" json:"last_payment_date"`
	CreatedAt           pgtype.Timestamp            `db:"created_at" json:"created_at"`
	UpdatedAt           pgtype.Timestamp            `db:"updated_at" json:"updated_at"`
	AccountTransactions []BillingAccountTransaction `db:"account_transactions" json:"account_transactions"`
	CrmCompany          CrmCompany                  `db:"crm_company" json:"crm_company"`
}

func (q *Queries) BillingAnyClientAccount(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyClientAccountRow, error) {
	rows, err := q.db.Query(ctx, billingAnyClientAccount, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyClientAccountRow
	for rows.Next() {
		var i BillingAnyClientAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.CreditLimit,
			&i.AvailableCredit,
			&i.WalletBalance,
			&i.Currency,
			&i.PaymentTermsDays,
			&i.IsCreditApproved,
			&i.LastPaymentDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountTransactions,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindClientAccount = `-- name: BillingFindClientAccount :one
select
  client_accounts.id, client_accounts.client_id, client_accounts.credit_limit, client_accounts.available_credit, client_accounts.wallet_balance, client_accounts.currency, client_accounts.payment_terms_days, client_accounts.is_credit_approved, client_accounts.last_payment_date, client_accounts.created_at, client_accounts.updated_at, client_accounts.account_transactions,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "billing"."client_accounts_view" as client_accounts
  inner join "crm"."companies" as client on client_accounts.client_id = client.id
where
  client_accounts.id = $1::uuid
`

type BillingFindClientAccountRow struct {
	ID                  pgtype.UUID                 `db:"id" json:"id"`
	ClientID            pgtype.UUID                 `db:"client_id" json:"client_id"`
	CreditLimit         pgtype.Numeric              `db:"credit_limit" json:"credit_limit"`
	AvailableCredit     pgtype.Numeric              `db:"available_credit" json:"available_credit"`
	WalletBalance       pgtype.Numeric              `db:"wallet_balance" json:"wallet_balance"`
	Currency            pgtype.Text                 `db:"currency" json:"currency"`
	PaymentTermsDays    pgtype.Int4                 `db:"payment_terms_days" json:"payment_terms_days"`
	IsCreditApproved    pgtype.Bool                 `db:"is_credit_approved" json:"is_credit_approved"`
	LastPaymentDate     pgtype.Date                 `db:"last_payment_date" json:"last_payment_date"`
	CreatedAt           pgtype.Timestamp            `db:"created_at" json:"created_at"`
	UpdatedAt           pgtype.Timestamp            `db:"updated_at" json:"updated_at"`
	AccountTransactions []BillingAccountTransaction `db:"account_transactions" json:"account_transactions"`
	CrmCompany          CrmCompany                  `db:"crm_company" json:"crm_company"`
}

func (q *Queries) BillingFindClientAccount(ctx context.Context, id pgtype.UUID) (BillingFindClientAccountRow, error) {
	row := q.db.QueryRow(ctx, billingFindClientAccount, id)
	var i BillingFindClientAccountRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CreditLimit,
		&i.AvailableCredit,
		&i.WalletBalance,
		&i.Currency,
		&i.PaymentTermsDays,
		&i.IsCreditApproved,
		&i.LastPaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccountTransactions,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
	)
	return i, err
}

const billingInsertClientAccount = `-- name: BillingInsertClientAccount :one
insert into "billing"."client_accounts"(client_id, credit_limit, available_credit, wallet_balance, currency, payment_terms_days, is_credit_approved, last_payment_date)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, client_id, credit_limit, available_credit, wallet_balance, currency, payment_terms_days, is_credit_approved, last_payment_date, created_at, updated_at
`

type BillingInsertClientAccountParams struct {
	ClientID         pgtype.UUID    `db:"client_id" json:"client_id"`
	CreditLimit      pgtype.Numeric `db:"credit_limit" json:"credit_limit"`
	AvailableCredit  pgtype.Numeric `db:"available_credit" json:"available_credit"`
	WalletBalance    pgtype.Numeric `db:"wallet_balance" json:"wallet_balance"`
	Currency         pgtype.Text    `db:"currency" json:"currency"`
	PaymentTermsDays pgtype.Int4    `db:"payment_terms_days" json:"payment_terms_days"`
	IsCreditApproved pgtype.Bool    `db:"is_credit_approved" json:"is_credit_approved"`
	LastPaymentDate  pgtype.Date    `db:"last_payment_date" json:"last_payment_date"`
}

func (q *Queries) BillingInsertClientAccount(ctx context.Context, arg BillingInsertClientAccountParams) (BillingClientAccount, error) {
	row := q.db.QueryRow(ctx, billingInsertClientAccount,
		arg.ClientID,
		arg.CreditLimit,
		arg.AvailableCredit,
		arg.WalletBalance,
		arg.Currency,
		arg.PaymentTermsDays,
		arg.IsCreditApproved,
		arg.LastPaymentDate,
	)
	var i BillingClientAccount
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CreditLimit,
		&i.AvailableCredit,
		&i.WalletBalance,
		&i.Currency,
		&i.PaymentTermsDays,
		&i.IsCreditApproved,
		&i.LastPaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateClientAccount = `-- name: BillingPaginateClientAccount :many
select
  client_accounts.id, client_accounts.client_id, client_accounts.credit_limit, client_accounts.available_credit, client_accounts.wallet_balance, client_accounts.currency, client_accounts.payment_terms_days, client_accounts.is_credit_approved, client_accounts.last_payment_date, client_accounts.created_at, client_accounts.updated_at, client_accounts.account_transactions,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "billing"."client_accounts_view" as client_accounts
  inner join "crm"."companies" as client on client_accounts.client_id = client.id
where (client.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateClientAccountParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type BillingPaginateClientAccountRow struct {
	ID                  pgtype.UUID                 `db:"id" json:"id"`
	ClientID            pgtype.UUID                 `db:"client_id" json:"client_id"`
	CreditLimit         pgtype.Numeric              `db:"credit_limit" json:"credit_limit"`
	AvailableCredit     pgtype.Numeric              `db:"available_credit" json:"available_credit"`
	WalletBalance       pgtype.Numeric              `db:"wallet_balance" json:"wallet_balance"`
	Currency            pgtype.Text                 `db:"currency" json:"currency"`
	PaymentTermsDays    pgtype.Int4                 `db:"payment_terms_days" json:"payment_terms_days"`
	IsCreditApproved    pgtype.Bool                 `db:"is_credit_approved" json:"is_credit_approved"`
	LastPaymentDate     pgtype.Date                 `db:"last_payment_date" json:"last_payment_date"`
	CreatedAt           pgtype.Timestamp            `db:"created_at" json:"created_at"`
	UpdatedAt           pgtype.Timestamp            `db:"updated_at" json:"updated_at"`
	AccountTransactions []BillingAccountTransaction `db:"account_transactions" json:"account_transactions"`
	CrmCompany          CrmCompany                  `db:"crm_company" json:"crm_company"`
}

func (q *Queries) BillingPaginateClientAccount(ctx context.Context, arg BillingPaginateClientAccountParams) ([]BillingPaginateClientAccountRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateClientAccount, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateClientAccountRow
	for rows.Next() {
		var i BillingPaginateClientAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.CreditLimit,
			&i.AvailableCredit,
			&i.WalletBalance,
			&i.Currency,
			&i.PaymentTermsDays,
			&i.IsCreditApproved,
			&i.LastPaymentDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountTransactions,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingPaginateClientAccountMetadata = `-- name: BillingPaginateClientAccountMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "billing"."client_accounts_view" as client_accounts
`

type BillingPaginateClientAccountMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type BillingPaginateClientAccountMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) BillingPaginateClientAccountMetadata(ctx context.Context, arg BillingPaginateClientAccountMetadataParams) (BillingPaginateClientAccountMetadataRow, error) {
	row := q.db.QueryRow(ctx, billingPaginateClientAccountMetadata, arg.PerPage, arg.Page)
	var i BillingPaginateClientAccountMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const billingRangeClientAccount = `-- name: BillingRangeClientAccount :many
select
  client_accounts.id, client_accounts.client_id, client_accounts.credit_limit, client_accounts.available_credit, client_accounts.wallet_balance, client_accounts.currency, client_accounts.payment_terms_days, client_accounts.is_credit_approved, client_accounts.last_payment_date, client_accounts.created_at, client_accounts.updated_at, client_accounts.account_transactions,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "billing"."client_accounts_view" as client_accounts
  inner join "crm"."companies" as client on client_accounts.client_id = client.id
where
  client_accounts.created_at >= $1::date
  and client_accounts.created_at <= $2::date
  and (client.name ilike $3::text
    or $3::text is null)
`

type BillingRangeClientAccountParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type BillingRangeClientAccountRow struct {
	ID                  pgtype.UUID                 `db:"id" json:"id"`
	ClientID            pgtype.UUID                 `db:"client_id" json:"client_id"`
	CreditLimit         pgtype.Numeric              `db:"credit_limit" json:"credit_limit"`
	AvailableCredit     pgtype.Numeric              `db:"available_credit" json:"available_credit"`
	WalletBalance       pgtype.Numeric              `db:"wallet_balance" json:"wallet_balance"`
	Currency            pgtype.Text                 `db:"currency" json:"currency"`
	PaymentTermsDays    pgtype.Int4                 `db:"payment_terms_days" json:"payment_terms_days"`
	IsCreditApproved    pgtype.Bool                 `db:"is_credit_approved" json:"is_credit_approved"`
	LastPaymentDate     pgtype.Date                 `db:"last_payment_date" json:"last_payment_date"`
	CreatedAt           pgtype.Timestamp            `db:"created_at" json:"created_at"`
	UpdatedAt           pgtype.Timestamp            `db:"updated_at" json:"updated_at"`
	AccountTransactions []BillingAccountTransaction `db:"account_transactions" json:"account_transactions"`
	CrmCompany          CrmCompany                  `db:"crm_company" json:"crm_company"`
}

func (q *Queries) BillingRangeClientAccount(ctx context.Context, arg BillingRangeClientAccountParams) ([]BillingRangeClientAccountRow, error) {
	rows, err := q.db.Query(ctx, billingRangeClientAccount, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeClientAccountRow
	for rows.Next() {
		var i BillingRangeClientAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.CreditLimit,
			&i.AvailableCredit,
			&i.WalletBalance,
			&i.Currency,
			&i.PaymentTermsDays,
			&i.IsCreditApproved,
			&i.LastPaymentDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountTransactions,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveClientAccount = `-- name: BillingRemoveClientAccount :exec
delete from "billing"."client_accounts"
where id = $1::uuid
`

func (q *Queries) BillingRemoveClientAccount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveClientAccount, id)
	return err
}

const billingUpdateClientAccount = `-- name: BillingUpdateClientAccount :one
update
  "billing"."client_accounts"
set
  updated_at = now(),
  client_id = case when $1 is not null then
    $1::uuid
  else
    client_id
  end,
  credit_limit = case when $2 is not null then
    $2::numeric
  else
    credit_limit
  end,
  available_credit = case when $3 is not null then
    $3::numeric
  else
    available_credit
  end,
  wallet_balance = case when $4 is not null then
    $4::numeric
  else
    wallet_balance
  end,
  currency = case when $5 is not null then
    $5::varchar
  else
    currency
  end,
  payment_terms_days = case when $6 is not null then
    $6::integer
  else
    payment_terms_days
  end,
  is_credit_approved = case when $7 is not null then
    $7::boolean
  else
    is_credit_approved
  end,
  last_payment_date = case when $8 is not null then
    $8::date
  else
    last_payment_date
  end
where
  id = $9::uuid
returning
  id, client_id, credit_limit, available_credit, wallet_balance, currency, payment_terms_days, is_credit_approved, last_payment_date, created_at, updated_at
`

type BillingUpdateClientAccountParams struct {
	ClientID         pgtype.UUID    `db:"client_id" json:"client_id"`
	CreditLimit      pgtype.Numeric `db:"credit_limit" json:"credit_limit"`
	AvailableCredit  pgtype.Numeric `db:"available_credit" json:"available_credit"`
	WalletBalance    pgtype.Numeric `db:"wallet_balance" json:"wallet_balance"`
	Currency         pgtype.Text    `db:"currency" json:"currency"`
	PaymentTermsDays pgtype.Int4    `db:"payment_terms_days" json:"payment_terms_days"`
	IsCreditApproved pgtype.Bool    `db:"is_credit_approved" json:"is_credit_approved"`
	LastPaymentDate  pgtype.Date    `db:"last_payment_date" json:"last_payment_date"`
	ID               pgtype.UUID    `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateClientAccount(ctx context.Context, arg BillingUpdateClientAccountParams) (BillingClientAccount, error) {
	row := q.db.QueryRow(ctx, billingUpdateClientAccount,
		arg.ClientID,
		arg.CreditLimit,
		arg.AvailableCredit,
		arg.WalletBalance,
		arg.Currency,
		arg.PaymentTermsDays,
		arg.IsCreditApproved,
		arg.LastPaymentDate,
		arg.ID,
	)
	var i BillingClientAccount
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CreditLimit,
		&i.AvailableCredit,
		&i.WalletBalance,
		&i.Currency,
		&i.PaymentTermsDays,
		&i.IsCreditApproved,
		&i.LastPaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
