// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_client_accounts.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyClientAccount = `-- name: BillingAnyClientAccount :many
select
  client_accounts.id, client_accounts.client_id, client_accounts.credit_limit, client_accounts.available_credit, client_accounts.wallet_balance, client_accounts.currency, client_accounts.payment_terms_days, client_accounts.is_credit_approved, client_accounts.last_payment_date, client_accounts.created_at, client_accounts.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "billing"."client_accounts" as client_accounts
  inner join "crm"."companies" as client on client_accounts.client_id = client.id
where
  client_accounts.id = any ($1::uuid[])
`

type BillingAnyClientAccountRow struct {
	BillingClientAccount BillingClientAccount
	CrmCompany           CrmCompany
}

func (q *Queries) BillingAnyClientAccount(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyClientAccountRow, error) {
	rows, err := q.db.Query(ctx, billingAnyClientAccount, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyClientAccountRow
	for rows.Next() {
		var i BillingAnyClientAccountRow
		if err := rows.Scan(
			&i.BillingClientAccount.ID,
			&i.BillingClientAccount.ClientID,
			&i.BillingClientAccount.CreditLimit,
			&i.BillingClientAccount.AvailableCredit,
			&i.BillingClientAccount.WalletBalance,
			&i.BillingClientAccount.Currency,
			&i.BillingClientAccount.PaymentTermsDays,
			&i.BillingClientAccount.IsCreditApproved,
			&i.BillingClientAccount.LastPaymentDate,
			&i.BillingClientAccount.CreatedAt,
			&i.BillingClientAccount.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindClientAccount = `-- name: BillingFindClientAccount :one
select
  client_accounts.id, client_accounts.client_id, client_accounts.credit_limit, client_accounts.available_credit, client_accounts.wallet_balance, client_accounts.currency, client_accounts.payment_terms_days, client_accounts.is_credit_approved, client_accounts.last_payment_date, client_accounts.created_at, client_accounts.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "billing"."client_accounts" as client_accounts
  inner join "crm"."companies" as client on client_accounts.client_id = client.id
where
  client_accounts.id = $1::uuid
`

type BillingFindClientAccountRow struct {
	BillingClientAccount BillingClientAccount
	CrmCompany           CrmCompany
}

func (q *Queries) BillingFindClientAccount(ctx context.Context, id pgtype.UUID) (BillingFindClientAccountRow, error) {
	row := q.db.QueryRow(ctx, billingFindClientAccount, id)
	var i BillingFindClientAccountRow
	err := row.Scan(
		&i.BillingClientAccount.ID,
		&i.BillingClientAccount.ClientID,
		&i.BillingClientAccount.CreditLimit,
		&i.BillingClientAccount.AvailableCredit,
		&i.BillingClientAccount.WalletBalance,
		&i.BillingClientAccount.Currency,
		&i.BillingClientAccount.PaymentTermsDays,
		&i.BillingClientAccount.IsCreditApproved,
		&i.BillingClientAccount.LastPaymentDate,
		&i.BillingClientAccount.CreatedAt,
		&i.BillingClientAccount.UpdatedAt,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
	)
	return i, err
}

const billingInsertClientAccount = `-- name: BillingInsertClientAccount :one
insert into "billing"."client_accounts"(client_id, credit_limit, available_credit, wallet_balance, currency, payment_terms_days, is_credit_approved, last_payment_date)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, client_id, credit_limit, available_credit, wallet_balance, currency, payment_terms_days, is_credit_approved, last_payment_date, created_at, updated_at
`

type BillingInsertClientAccountParams struct {
	ClientID         pgtype.UUID
	CreditLimit      pgtype.Numeric
	AvailableCredit  pgtype.Numeric
	WalletBalance    pgtype.Numeric
	Currency         pgtype.Text
	PaymentTermsDays pgtype.Int4
	IsCreditApproved pgtype.Bool
	LastPaymentDate  pgtype.Date
}

func (q *Queries) BillingInsertClientAccount(ctx context.Context, arg BillingInsertClientAccountParams) (BillingClientAccount, error) {
	row := q.db.QueryRow(ctx, billingInsertClientAccount,
		arg.ClientID,
		arg.CreditLimit,
		arg.AvailableCredit,
		arg.WalletBalance,
		arg.Currency,
		arg.PaymentTermsDays,
		arg.IsCreditApproved,
		arg.LastPaymentDate,
	)
	var i BillingClientAccount
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CreditLimit,
		&i.AvailableCredit,
		&i.WalletBalance,
		&i.Currency,
		&i.PaymentTermsDays,
		&i.IsCreditApproved,
		&i.LastPaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateClientAccount = `-- name: BillingPaginateClientAccount :many
select
  client_accounts.id, client_accounts.client_id, client_accounts.credit_limit, client_accounts.available_credit, client_accounts.wallet_balance, client_accounts.currency, client_accounts.payment_terms_days, client_accounts.is_credit_approved, client_accounts.last_payment_date, client_accounts.created_at, client_accounts.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "billing"."client_accounts" as client_accounts
  inner join "crm"."companies" as client on client_accounts.client_id = client.id
limit $2::int offset ($1::int - 1) * $2::int
`

type BillingPaginateClientAccountParams struct {
	Page    int32
	Perpage int32
}

type BillingPaginateClientAccountRow struct {
	BillingClientAccount BillingClientAccount
	CrmCompany           CrmCompany
}

func (q *Queries) BillingPaginateClientAccount(ctx context.Context, arg BillingPaginateClientAccountParams) ([]BillingPaginateClientAccountRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateClientAccount, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateClientAccountRow
	for rows.Next() {
		var i BillingPaginateClientAccountRow
		if err := rows.Scan(
			&i.BillingClientAccount.ID,
			&i.BillingClientAccount.ClientID,
			&i.BillingClientAccount.CreditLimit,
			&i.BillingClientAccount.AvailableCredit,
			&i.BillingClientAccount.WalletBalance,
			&i.BillingClientAccount.Currency,
			&i.BillingClientAccount.PaymentTermsDays,
			&i.BillingClientAccount.IsCreditApproved,
			&i.BillingClientAccount.LastPaymentDate,
			&i.BillingClientAccount.CreatedAt,
			&i.BillingClientAccount.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeClientAccount = `-- name: BillingRangeClientAccount :many
select
  client_accounts.id, client_accounts.client_id, client_accounts.credit_limit, client_accounts.available_credit, client_accounts.wallet_balance, client_accounts.currency, client_accounts.payment_terms_days, client_accounts.is_credit_approved, client_accounts.last_payment_date, client_accounts.created_at, client_accounts.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "billing"."client_accounts" as client_accounts
  inner join "crm"."companies" as client on client_accounts.client_id = client.id
where
  client_accounts.created_at >= $1::date
  and client_accounts.created_at <= $2::date
`

type BillingRangeClientAccountParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type BillingRangeClientAccountRow struct {
	BillingClientAccount BillingClientAccount
	CrmCompany           CrmCompany
}

func (q *Queries) BillingRangeClientAccount(ctx context.Context, arg BillingRangeClientAccountParams) ([]BillingRangeClientAccountRow, error) {
	rows, err := q.db.Query(ctx, billingRangeClientAccount, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeClientAccountRow
	for rows.Next() {
		var i BillingRangeClientAccountRow
		if err := rows.Scan(
			&i.BillingClientAccount.ID,
			&i.BillingClientAccount.ClientID,
			&i.BillingClientAccount.CreditLimit,
			&i.BillingClientAccount.AvailableCredit,
			&i.BillingClientAccount.WalletBalance,
			&i.BillingClientAccount.Currency,
			&i.BillingClientAccount.PaymentTermsDays,
			&i.BillingClientAccount.IsCreditApproved,
			&i.BillingClientAccount.LastPaymentDate,
			&i.BillingClientAccount.CreatedAt,
			&i.BillingClientAccount.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveClientAccount = `-- name: BillingRemoveClientAccount :exec
delete from "billing"."client_accounts"
where id = $1::uuid
`

func (q *Queries) BillingRemoveClientAccount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveClientAccount, id)
	return err
}

const billingUpdateClientAccount = `-- name: BillingUpdateClientAccount :one
update
  "billing"."client_accounts"
set
  client_id = case when $1::boolean then
    $2::uuid
  else
    client_id
  end,
  credit_limit = case when $3::boolean then
    $4::numeric
  else
    credit_limit
  end,
  available_credit = case when $5::boolean then
    $6::numeric
  else
    available_credit
  end,
  wallet_balance = case when $7::boolean then
    $8::numeric
  else
    wallet_balance
  end,
  currency = case when $9::boolean then
    $10::varchar
  else
    currency
  end,
  payment_terms_days = case when $11::boolean then
    $12::integer
  else
    payment_terms_days
  end,
  is_credit_approved = case when $13::boolean then
    $14::boolean
  else
    is_credit_approved
  end,
  last_payment_date = case when $15::boolean then
    $16::date
  else
    last_payment_date
  end
where
  id = $17::uuid
returning
  id, client_id, credit_limit, available_credit, wallet_balance, currency, payment_terms_days, is_credit_approved, last_payment_date, created_at, updated_at
`

type BillingUpdateClientAccountParams struct {
	SetClientID         bool
	ClientID            pgtype.UUID
	SetCreditLimit      bool
	CreditLimit         pgtype.Numeric
	SetAvailableCredit  bool
	AvailableCredit     pgtype.Numeric
	SetWalletBalance    bool
	WalletBalance       pgtype.Numeric
	SetCurrency         bool
	Currency            string
	SetPaymentTermsDays bool
	PaymentTermsDays    int32
	SetIsCreditApproved bool
	IsCreditApproved    bool
	SetLastPaymentDate  bool
	LastPaymentDate     pgtype.Date
	ID                  pgtype.UUID
}

func (q *Queries) BillingUpdateClientAccount(ctx context.Context, arg BillingUpdateClientAccountParams) (BillingClientAccount, error) {
	row := q.db.QueryRow(ctx, billingUpdateClientAccount,
		arg.SetClientID,
		arg.ClientID,
		arg.SetCreditLimit,
		arg.CreditLimit,
		arg.SetAvailableCredit,
		arg.AvailableCredit,
		arg.SetWalletBalance,
		arg.WalletBalance,
		arg.SetCurrency,
		arg.Currency,
		arg.SetPaymentTermsDays,
		arg.PaymentTermsDays,
		arg.SetIsCreditApproved,
		arg.IsCreditApproved,
		arg.SetLastPaymentDate,
		arg.LastPaymentDate,
		arg.ID,
	)
	var i BillingClientAccount
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CreditLimit,
		&i.AvailableCredit,
		&i.WalletBalance,
		&i.Currency,
		&i.PaymentTermsDays,
		&i.IsCreditApproved,
		&i.LastPaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
