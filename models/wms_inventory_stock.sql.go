// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_inventory_stock.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyInventoryStock = `-- name: WmsAnyInventoryStock :many
select
  inventory_stock.id, inventory_stock.location_id, inventory_stock.product_id, inventory_stock.batch_id, inventory_stock.quantity, inventory_stock.reserved_quantity, inventory_stock.available_quantity, inventory_stock.status, inventory_stock.last_counted_at, inventory_stock.last_movement_at, inventory_stock.created_at, inventory_stock.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."inventory_stock" as inventory_stock
  inner join "wms"."locations" as location on inventory_stock.location_id = location.id
  inner join "wms"."products" as product on inventory_stock.product_id = product.id
  left join "wms"."inventory_batches" as batch on inventory_stock.batch_id = batch.id
where
  inventory_stock.id = any ($1::uuid[])
`

type WmsAnyInventoryStockRow struct {
	WmsInventoryStock WmsInventoryStock
	WmsLocation       WmsLocation
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
}

func (q *Queries) WmsAnyInventoryStock(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyInventoryStockRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyInventoryStock, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyInventoryStockRow
	for rows.Next() {
		var i WmsAnyInventoryStockRow
		if err := rows.Scan(
			&i.WmsInventoryStock.ID,
			&i.WmsInventoryStock.LocationID,
			&i.WmsInventoryStock.ProductID,
			&i.WmsInventoryStock.BatchID,
			&i.WmsInventoryStock.Quantity,
			&i.WmsInventoryStock.ReservedQuantity,
			&i.WmsInventoryStock.AvailableQuantity,
			&i.WmsInventoryStock.Status,
			&i.WmsInventoryStock.LastCountedAt,
			&i.WmsInventoryStock.LastMovementAt,
			&i.WmsInventoryStock.CreatedAt,
			&i.WmsInventoryStock.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindInventoryStock = `-- name: WmsFindInventoryStock :one
select
  inventory_stock.id, inventory_stock.location_id, inventory_stock.product_id, inventory_stock.batch_id, inventory_stock.quantity, inventory_stock.reserved_quantity, inventory_stock.available_quantity, inventory_stock.status, inventory_stock.last_counted_at, inventory_stock.last_movement_at, inventory_stock.created_at, inventory_stock.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."inventory_stock" as inventory_stock
  inner join "wms"."locations" as location on inventory_stock.location_id = location.id
  inner join "wms"."products" as product on inventory_stock.product_id = product.id
  left join "wms"."inventory_batches" as batch on inventory_stock.batch_id = batch.id
where
  inventory_stock.id = $1::uuid
`

type WmsFindInventoryStockRow struct {
	WmsInventoryStock WmsInventoryStock
	WmsLocation       WmsLocation
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
}

func (q *Queries) WmsFindInventoryStock(ctx context.Context, id pgtype.UUID) (WmsFindInventoryStockRow, error) {
	row := q.db.QueryRow(ctx, wmsFindInventoryStock, id)
	var i WmsFindInventoryStockRow
	err := row.Scan(
		&i.WmsInventoryStock.ID,
		&i.WmsInventoryStock.LocationID,
		&i.WmsInventoryStock.ProductID,
		&i.WmsInventoryStock.BatchID,
		&i.WmsInventoryStock.Quantity,
		&i.WmsInventoryStock.ReservedQuantity,
		&i.WmsInventoryStock.AvailableQuantity,
		&i.WmsInventoryStock.Status,
		&i.WmsInventoryStock.LastCountedAt,
		&i.WmsInventoryStock.LastMovementAt,
		&i.WmsInventoryStock.CreatedAt,
		&i.WmsInventoryStock.UpdatedAt,
		&i.WmsLocation.ID,
		&i.WmsLocation.WarehouseID,
		&i.WmsLocation.ParentLocationID,
		&i.WmsLocation.Name,
		&i.WmsLocation.Barcode,
		&i.WmsLocation.Type,
		&i.WmsLocation.Level,
		&i.WmsLocation.Path,
		&i.WmsLocation.MaxWeight,
		&i.WmsLocation.MaxVolume,
		&i.WmsLocation.MaxPallets,
		&i.WmsLocation.XCoordinate,
		&i.WmsLocation.YCoordinate,
		&i.WmsLocation.ZCoordinate,
		&i.WmsLocation.IsPickable,
		&i.WmsLocation.IsReceivable,
		&i.WmsLocation.TemperatureControlled,
		&i.WmsLocation.HazmatApproved,
		&i.WmsLocation.IsActive,
		&i.WmsLocation.CreatedAt,
		&i.WmsLocation.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
		&i.WmsInventoryBatch.ID,
		&i.WmsInventoryBatch.ProductID,
		&i.WmsInventoryBatch.BatchNumber,
		&i.WmsInventoryBatch.ExpirationDate,
		&i.WmsInventoryBatch.CreatedAt,
		&i.WmsInventoryBatch.UpdatedAt,
	)
	return i, err
}

const wmsInsertInventoryStock = `-- name: WmsInsertInventoryStock :one
insert into "wms"."inventory_stock"(location_id, product_id, batch_id, quantity, reserved_quantity, status, last_counted_at, last_movement_at)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, location_id, product_id, batch_id, quantity, reserved_quantity, available_quantity, status, last_counted_at, last_movement_at, created_at, updated_at
`

type WmsInsertInventoryStockParams struct {
	LocationID       pgtype.UUID
	ProductID        pgtype.UUID
	BatchID          pgtype.UUID
	Quantity         int32
	ReservedQuantity int32
	Status           NullWmsInventoryStockStatusEnum
	LastCountedAt    pgtype.Timestamp
	LastMovementAt   pgtype.Timestamp
}

func (q *Queries) WmsInsertInventoryStock(ctx context.Context, arg WmsInsertInventoryStockParams) (WmsInventoryStock, error) {
	row := q.db.QueryRow(ctx, wmsInsertInventoryStock,
		arg.LocationID,
		arg.ProductID,
		arg.BatchID,
		arg.Quantity,
		arg.ReservedQuantity,
		arg.Status,
		arg.LastCountedAt,
		arg.LastMovementAt,
	)
	var i WmsInventoryStock
	err := row.Scan(
		&i.ID,
		&i.LocationID,
		&i.ProductID,
		&i.BatchID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.AvailableQuantity,
		&i.Status,
		&i.LastCountedAt,
		&i.LastMovementAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateInventoryStock = `-- name: WmsPaginateInventoryStock :many
select
  inventory_stock.id, inventory_stock.location_id, inventory_stock.product_id, inventory_stock.batch_id, inventory_stock.quantity, inventory_stock.reserved_quantity, inventory_stock.available_quantity, inventory_stock.status, inventory_stock.last_counted_at, inventory_stock.last_movement_at, inventory_stock.created_at, inventory_stock.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."inventory_stock" as inventory_stock
  inner join "wms"."locations" as location on inventory_stock.location_id = location.id
  inner join "wms"."products" as product on inventory_stock.product_id = product.id
  left join "wms"."inventory_batches" as batch on inventory_stock.batch_id = batch.id
where (location.name ilike $1::text
  or product.name ilike $1::text
  or batch.batch_number ilike $1::text
  or inventory_stock.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateInventoryStockParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginateInventoryStockRow struct {
	WmsInventoryStock WmsInventoryStock
	WmsLocation       WmsLocation
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
}

func (q *Queries) WmsPaginateInventoryStock(ctx context.Context, arg WmsPaginateInventoryStockParams) ([]WmsPaginateInventoryStockRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateInventoryStock, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateInventoryStockRow
	for rows.Next() {
		var i WmsPaginateInventoryStockRow
		if err := rows.Scan(
			&i.WmsInventoryStock.ID,
			&i.WmsInventoryStock.LocationID,
			&i.WmsInventoryStock.ProductID,
			&i.WmsInventoryStock.BatchID,
			&i.WmsInventoryStock.Quantity,
			&i.WmsInventoryStock.ReservedQuantity,
			&i.WmsInventoryStock.AvailableQuantity,
			&i.WmsInventoryStock.Status,
			&i.WmsInventoryStock.LastCountedAt,
			&i.WmsInventoryStock.LastMovementAt,
			&i.WmsInventoryStock.CreatedAt,
			&i.WmsInventoryStock.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeInventoryStock = `-- name: WmsRangeInventoryStock :many
select
  inventory_stock.id, inventory_stock.location_id, inventory_stock.product_id, inventory_stock.batch_id, inventory_stock.quantity, inventory_stock.reserved_quantity, inventory_stock.available_quantity, inventory_stock.status, inventory_stock.last_counted_at, inventory_stock.last_movement_at, inventory_stock.created_at, inventory_stock.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."inventory_stock" as inventory_stock
  inner join "wms"."locations" as location on inventory_stock.location_id = location.id
  inner join "wms"."products" as product on inventory_stock.product_id = product.id
  left join "wms"."inventory_batches" as batch on inventory_stock.batch_id = batch.id
where
  inventory_stock.created_at >= $1::date
  and inventory_stock.created_at <= $2::date
  and (location.name ilike $3::text
    or product.name ilike $3::text
    or batch.batch_number ilike $3::text
    or inventory_stock.status::text ilike $3::text
    or $3::text is null)
`

type WmsRangeInventoryStockParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangeInventoryStockRow struct {
	WmsInventoryStock WmsInventoryStock
	WmsLocation       WmsLocation
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
}

func (q *Queries) WmsRangeInventoryStock(ctx context.Context, arg WmsRangeInventoryStockParams) ([]WmsRangeInventoryStockRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeInventoryStock, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeInventoryStockRow
	for rows.Next() {
		var i WmsRangeInventoryStockRow
		if err := rows.Scan(
			&i.WmsInventoryStock.ID,
			&i.WmsInventoryStock.LocationID,
			&i.WmsInventoryStock.ProductID,
			&i.WmsInventoryStock.BatchID,
			&i.WmsInventoryStock.Quantity,
			&i.WmsInventoryStock.ReservedQuantity,
			&i.WmsInventoryStock.AvailableQuantity,
			&i.WmsInventoryStock.Status,
			&i.WmsInventoryStock.LastCountedAt,
			&i.WmsInventoryStock.LastMovementAt,
			&i.WmsInventoryStock.CreatedAt,
			&i.WmsInventoryStock.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveInventoryStock = `-- name: WmsRemoveInventoryStock :exec
delete from "wms"."inventory_stock"
where id = $1::uuid
`

func (q *Queries) WmsRemoveInventoryStock(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveInventoryStock, id)
	return err
}

const wmsUpdateInventoryStock = `-- name: WmsUpdateInventoryStock :one
update
  "wms"."inventory_stock"
set
  updated_at = now(),
  location_id = case when $1 is not null then
    $1::uuid
  else
    location_id
  end,
  product_id = case when $2 is not null then
    $2::uuid
  else
    product_id
  end,
  batch_id = case when $3 is not null then
    $3::uuid
  else
    batch_id
  end,
  quantity = case when $4 is not null then
    $4::integer
  else
    quantity
  end,
  reserved_quantity = case when $5 is not null then
    $5::integer
  else
    reserved_quantity
  end,
  status = case when $6 is not null then
    $6::wms.inventory_stock_status_enum
  else
    status
  end,
  last_counted_at = case when $7 is not null then
    $7::timestamp
  else
    last_counted_at
  end,
  last_movement_at = case when $8 is not null then
    $8::timestamp
  else
    last_movement_at
  end
where
  id = $9::uuid
returning
  id, location_id, product_id, batch_id, quantity, reserved_quantity, available_quantity, status, last_counted_at, last_movement_at, created_at, updated_at
`

type WmsUpdateInventoryStockParams struct {
	LocationID       pgtype.UUID
	ProductID        pgtype.UUID
	BatchID          pgtype.UUID
	Quantity         int32
	ReservedQuantity int32
	Status           NullWmsInventoryStockStatusEnum
	LastCountedAt    pgtype.Timestamp
	LastMovementAt   pgtype.Timestamp
	ID               pgtype.UUID
}

func (q *Queries) WmsUpdateInventoryStock(ctx context.Context, arg WmsUpdateInventoryStockParams) (WmsInventoryStock, error) {
	row := q.db.QueryRow(ctx, wmsUpdateInventoryStock,
		arg.LocationID,
		arg.ProductID,
		arg.BatchID,
		arg.Quantity,
		arg.ReservedQuantity,
		arg.Status,
		arg.LastCountedAt,
		arg.LastMovementAt,
		arg.ID,
	)
	var i WmsInventoryStock
	err := row.Scan(
		&i.ID,
		&i.LocationID,
		&i.ProductID,
		&i.BatchID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.AvailableQuantity,
		&i.Status,
		&i.LastCountedAt,
		&i.LastMovementAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
