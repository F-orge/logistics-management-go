// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_geofences.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyGeofence = `-- name: TmsAnyGeofence :many
select
  id, name, created_at, updated_at, longitude, latitude, geofence_events
from
  "tms"."geofences_view"
where
  id = any ($1::uuid[])
`

func (q *Queries) TmsAnyGeofence(ctx context.Context, ids []pgtype.UUID) ([]TmsGeofencesView, error) {
	rows, err := q.db.Query(ctx, tmsAnyGeofence, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsGeofencesView
	for rows.Next() {
		var i TmsGeofencesView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Longitude,
			&i.Latitude,
			&i.GeofenceEvents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindGeofence = `-- name: TmsFindGeofence :one
select
  id, name, created_at, updated_at, longitude, latitude, geofence_events
from
  "tms"."geofences_view"
where
  id = $1::uuid
`

func (q *Queries) TmsFindGeofence(ctx context.Context, id pgtype.UUID) (TmsGeofencesView, error) {
	row := q.db.QueryRow(ctx, tmsFindGeofence, id)
	var i TmsGeofencesView
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Longitude,
		&i.Latitude,
		&i.GeofenceEvents,
	)
	return i, err
}

const tmsInsertGeofence = `-- name: TmsInsertGeofence :one
insert into "tms"."geofences"(name, longitude, latitude)
  values ($1, $2, $3)
returning
  id, name, created_at, updated_at, longitude, latitude
`

type TmsInsertGeofenceParams struct {
	Name      string        `db:"name" json:"name"`
	Longitude pgtype.Float4 `db:"longitude" json:"longitude"`
	Latitude  pgtype.Float4 `db:"latitude" json:"latitude"`
}

func (q *Queries) TmsInsertGeofence(ctx context.Context, arg TmsInsertGeofenceParams) (TmsGeofence, error) {
	row := q.db.QueryRow(ctx, tmsInsertGeofence, arg.Name, arg.Longitude, arg.Latitude)
	var i TmsGeofence
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Longitude,
		&i.Latitude,
	)
	return i, err
}

const tmsPaginateGeofence = `-- name: TmsPaginateGeofence :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page,
  geofences.id, geofences.name, geofences.created_at, geofences.updated_at, geofences.longitude, geofences.latitude, geofences.geofence_events
from
  "tms"."geofences_view" as geofences
where (name ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type TmsPaginateGeofenceParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type TmsPaginateGeofenceRow struct {
	TotalItems       int64            `db:"total_items" json:"total_items"`
	TotalPages       float64          `db:"total_pages" json:"total_pages"`
	Page             int32            `db:"page" json:"page"`
	PerPage          int32            `db:"per_page" json:"per_page"`
	TmsGeofencesView TmsGeofencesView `db:"tms_geofences_view" json:"tms_geofences_view"`
}

func (q *Queries) TmsPaginateGeofence(ctx context.Context, arg TmsPaginateGeofenceParams) ([]TmsPaginateGeofenceRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateGeofence, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateGeofenceRow
	for rows.Next() {
		var i TmsPaginateGeofenceRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.TmsGeofencesView.ID,
			&i.TmsGeofencesView.Name,
			&i.TmsGeofencesView.CreatedAt,
			&i.TmsGeofencesView.UpdatedAt,
			&i.TmsGeofencesView.Longitude,
			&i.TmsGeofencesView.Latitude,
			&i.TmsGeofencesView.GeofenceEvents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeGeofence = `-- name: TmsRangeGeofence :many
select
  id, name, created_at, updated_at, longitude, latitude, geofence_events
from
  "tms"."geofences_view"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (name ilike $3::text
    or $3::text is null)
`

type TmsRangeGeofenceParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) TmsRangeGeofence(ctx context.Context, arg TmsRangeGeofenceParams) ([]TmsGeofencesView, error) {
	rows, err := q.db.Query(ctx, tmsRangeGeofence, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsGeofencesView
	for rows.Next() {
		var i TmsGeofencesView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Longitude,
			&i.Latitude,
			&i.GeofenceEvents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveGeofence = `-- name: TmsRemoveGeofence :exec
delete from "tms"."geofences"
where id = $1::uuid
`

func (q *Queries) TmsRemoveGeofence(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveGeofence, id)
	return err
}

const tmsUpdateGeofence = `-- name: TmsUpdateGeofence :one
update
  "tms"."geofences"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::varchar
  else
    name
  end,
  longitude = case when $2 is not null then
    $2::real
  else
    longitude
  end,
  latitude = case when $3 is not null then
    $3::real
  else
    latitude
  end
where
  id = $4::uuid
returning
  id, name, created_at, updated_at, longitude, latitude
`

type TmsUpdateGeofenceParams struct {
	Name      string        `db:"name" json:"name"`
	Longitude pgtype.Float4 `db:"longitude" json:"longitude"`
	Latitude  pgtype.Float4 `db:"latitude" json:"latitude"`
	ID        pgtype.UUID   `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateGeofence(ctx context.Context, arg TmsUpdateGeofenceParams) (TmsGeofence, error) {
	row := q.db.QueryRow(ctx, tmsUpdateGeofence,
		arg.Name,
		arg.Longitude,
		arg.Latitude,
		arg.ID,
	)
	var i TmsGeofence
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Longitude,
		&i.Latitude,
	)
	return i, err
}
