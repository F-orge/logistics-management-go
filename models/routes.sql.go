// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: routes.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addShipmentToRoute = `-- name: AddShipmentToRoute :one
insert into shipments_on_route (route, shipment)
values ($1, $2)
returning route, shipment
`

type AddShipmentToRouteParams struct {
	Route    pgtype.UUID
	Shipment pgtype.UUID
}

func (q *Queries) AddShipmentToRoute(ctx context.Context, arg AddShipmentToRouteParams) (ShipmentsOnRoute, error) {
	row := q.db.QueryRow(ctx, addShipmentToRoute, arg.Route, arg.Shipment)
	var i ShipmentsOnRoute
	err := row.Scan(&i.Route, &i.Shipment)
	return i, err
}

const createRoute = `-- name: CreateRoute :one
insert into routes (name, planned_start_time, planned_end_time, status)
values ($1, $2, $3, $4)
returning id, name, planned_start_time, planned_end_time, status, created, updated
`

type CreateRouteParams struct {
	Name             string
	PlannedStartTime pgtype.Timestamptz
	PlannedEndTime   pgtype.Timestamptz
	Status           string
}

func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) (Route, error) {
	row := q.db.QueryRow(ctx, createRoute,
		arg.Name,
		arg.PlannedStartTime,
		arg.PlannedEndTime,
		arg.Status,
	)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PlannedStartTime,
		&i.PlannedEndTime,
		&i.Status,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const createRouteSegment = `-- name: CreateRouteSegment :one
insert into route_segments (route, sequence_number, segment_type, address, longitude, latitude,
  instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated
`

type CreateRouteSegmentParams struct {
	Route                  pgtype.UUID
	SequenceNumber         int32
	SegmentType            string
	Address                pgtype.Text
	Longitude              pgtype.Numeric
	Latitude               pgtype.Numeric
	Instructions           pgtype.Text
	EstimatedArrivalTime   pgtype.Timestamptz
	ActualArrivalTime      pgtype.Timestamptz
	EstimatedDepartureTime pgtype.Timestamptz
	ActualDepartureTime    pgtype.Timestamptz
}

func (q *Queries) CreateRouteSegment(ctx context.Context, arg CreateRouteSegmentParams) (RouteSegment, error) {
	row := q.db.QueryRow(ctx, createRouteSegment,
		arg.Route,
		arg.SequenceNumber,
		arg.SegmentType,
		arg.Address,
		arg.Longitude,
		arg.Latitude,
		arg.Instructions,
		arg.EstimatedArrivalTime,
		arg.ActualArrivalTime,
		arg.EstimatedDepartureTime,
		arg.ActualDepartureTime,
	)
	var i RouteSegment
	err := row.Scan(
		&i.ID,
		&i.Route,
		&i.SequenceNumber,
		&i.SegmentType,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Instructions,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteRoute = `-- name: DeleteRoute :one
delete from routes where id = $1 returning id, name, planned_start_time, planned_end_time, status, created, updated
`

func (q *Queries) DeleteRoute(ctx context.Context, id pgtype.UUID) (Route, error) {
	row := q.db.QueryRow(ctx, deleteRoute, id)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PlannedStartTime,
		&i.PlannedEndTime,
		&i.Status,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteRouteSegment = `-- name: DeleteRouteSegment :one
delete from route_segments where id = $1 returning id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated
`

func (q *Queries) DeleteRouteSegment(ctx context.Context, id pgtype.UUID) (RouteSegment, error) {
	row := q.db.QueryRow(ctx, deleteRouteSegment, id)
	var i RouteSegment
	err := row.Scan(
		&i.ID,
		&i.Route,
		&i.SequenceNumber,
		&i.SegmentType,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Instructions,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getRouteByID = `-- name: GetRouteByID :one
select id, name, planned_start_time, planned_end_time, status, created, updated from routes where id = $1
`

func (q *Queries) GetRouteByID(ctx context.Context, id pgtype.UUID) (Route, error) {
	row := q.db.QueryRow(ctx, getRouteByID, id)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PlannedStartTime,
		&i.PlannedEndTime,
		&i.Status,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getRouteSegmentByID = `-- name: GetRouteSegmentByID :one
select id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated from route_segments where id = $1
`

func (q *Queries) GetRouteSegmentByID(ctx context.Context, id pgtype.UUID) (RouteSegment, error) {
	row := q.db.QueryRow(ctx, getRouteSegmentByID, id)
	var i RouteSegment
	err := row.Scan(
		&i.ID,
		&i.Route,
		&i.SequenceNumber,
		&i.SegmentType,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Instructions,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getRouteSegments = `-- name: GetRouteSegments :many
select id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated from route_segments where route = $1 order by sequence_number asc offset $2 limit $3
`

type GetRouteSegmentsParams struct {
	Route  pgtype.UUID
	Offset int32
	Limit  int32
}

func (q *Queries) GetRouteSegments(ctx context.Context, arg GetRouteSegmentsParams) ([]RouteSegment, error) {
	rows, err := q.db.Query(ctx, getRouteSegments, arg.Route, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RouteSegment
	for rows.Next() {
		var i RouteSegment
		if err := rows.Scan(
			&i.ID,
			&i.Route,
			&i.SequenceNumber,
			&i.SegmentType,
			&i.Address,
			&i.Longitude,
			&i.Latitude,
			&i.Instructions,
			&i.EstimatedArrivalTime,
			&i.ActualArrivalTime,
			&i.EstimatedDepartureTime,
			&i.ActualDepartureTime,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRouteSegmentsByType = `-- name: GetRouteSegmentsByType :many
select id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated from route_segments where segment_type = $1 order by sequence_number asc, created desc offset $2 limit $3
`

type GetRouteSegmentsByTypeParams struct {
	SegmentType string
	Offset      int32
	Limit       int32
}

func (q *Queries) GetRouteSegmentsByType(ctx context.Context, arg GetRouteSegmentsByTypeParams) ([]RouteSegment, error) {
	rows, err := q.db.Query(ctx, getRouteSegmentsByType, arg.SegmentType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RouteSegment
	for rows.Next() {
		var i RouteSegment
		if err := rows.Scan(
			&i.ID,
			&i.Route,
			&i.SequenceNumber,
			&i.SegmentType,
			&i.Address,
			&i.Longitude,
			&i.Latitude,
			&i.Instructions,
			&i.EstimatedArrivalTime,
			&i.ActualArrivalTime,
			&i.EstimatedDepartureTime,
			&i.ActualDepartureTime,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutes = `-- name: GetRoutes :many
select id, name, planned_start_time, planned_end_time, status, created, updated from routes order by created desc offset $1 limit $2
`

type GetRoutesParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetRoutes(ctx context.Context, arg GetRoutesParams) ([]Route, error) {
	rows, err := q.db.Query(ctx, getRoutes, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PlannedStartTime,
			&i.PlannedEndTime,
			&i.Status,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesByShipment = `-- name: GetRoutesByShipment :many
select r.id, r.name, r.planned_start_time, r.planned_end_time, r.status, r.created, r.updated from shipments_on_route sor
join routes r on sor.route = r.id
where sor.shipment = $1
order by r.created desc offset $2 limit $3
`

type GetRoutesByShipmentParams struct {
	Shipment pgtype.UUID
	Offset   int32
	Limit    int32
}

func (q *Queries) GetRoutesByShipment(ctx context.Context, arg GetRoutesByShipmentParams) ([]Route, error) {
	rows, err := q.db.Query(ctx, getRoutesByShipment, arg.Shipment, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PlannedStartTime,
			&i.PlannedEndTime,
			&i.Status,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesByStatus = `-- name: GetRoutesByStatus :many
select id, name, planned_start_time, planned_end_time, status, created, updated from routes where status = $1 order by created desc offset $2 limit $3
`

type GetRoutesByStatusParams struct {
	Status string
	Offset int32
	Limit  int32
}

func (q *Queries) GetRoutesByStatus(ctx context.Context, arg GetRoutesByStatusParams) ([]Route, error) {
	rows, err := q.db.Query(ctx, getRoutesByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PlannedStartTime,
			&i.PlannedEndTime,
			&i.Status,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShipmentsOnRoute = `-- name: GetShipmentsOnRoute :many
select s.id, s."order", s.tracking_number, s.carrier, s.status, s.estimated_delivery_date, s.actual_delivery_date, s.proof_of_delivery_image_url, s.driver, s.current_location_notes, s.department_assigned, s.created, s.updated from shipments_on_route sor
join shipments s on sor.shipment = s.id
where sor.route = $1
order by s.created desc offset $2 limit $3
`

type GetShipmentsOnRouteParams struct {
	Route  pgtype.UUID
	Offset int32
	Limit  int32
}

func (q *Queries) GetShipmentsOnRoute(ctx context.Context, arg GetShipmentsOnRouteParams) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, getShipmentsOnRoute, arg.Route, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shipment
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.TrackingNumber,
			&i.Carrier,
			&i.Status,
			&i.EstimatedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.ProofOfDeliveryImageUrl,
			&i.Driver,
			&i.CurrentLocationNotes,
			&i.DepartmentAssigned,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeShipmentFromRoute = `-- name: RemoveShipmentFromRoute :one
delete from shipments_on_route where route = $1 and shipment = $2 returning route, shipment
`

type RemoveShipmentFromRouteParams struct {
	Route    pgtype.UUID
	Shipment pgtype.UUID
}

func (q *Queries) RemoveShipmentFromRoute(ctx context.Context, arg RemoveShipmentFromRouteParams) (ShipmentsOnRoute, error) {
	row := q.db.QueryRow(ctx, removeShipmentFromRoute, arg.Route, arg.Shipment)
	var i ShipmentsOnRoute
	err := row.Scan(&i.Route, &i.Shipment)
	return i, err
}

const searchRouteSegments = `-- name: SearchRouteSegments :many
select id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated from route_segments where address ilike '%' || $1::text || '%' or
  instructions ilike '%' || $1::text || '%'
order by sequence_number asc, created desc offset $2::integer limit $3::integer
`

type SearchRouteSegmentsParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchRouteSegments(ctx context.Context, arg SearchRouteSegmentsParams) ([]RouteSegment, error) {
	rows, err := q.db.Query(ctx, searchRouteSegments, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RouteSegment
	for rows.Next() {
		var i RouteSegment
		if err := rows.Scan(
			&i.ID,
			&i.Route,
			&i.SequenceNumber,
			&i.SegmentType,
			&i.Address,
			&i.Longitude,
			&i.Latitude,
			&i.Instructions,
			&i.EstimatedArrivalTime,
			&i.ActualArrivalTime,
			&i.EstimatedDepartureTime,
			&i.ActualDepartureTime,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRoutes = `-- name: SearchRoutes :many
select id, name, planned_start_time, planned_end_time, status, created, updated from routes where name ilike '%' || $1::text || '%' or status ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchRoutesParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchRoutes(ctx context.Context, arg SearchRoutesParams) ([]Route, error) {
	rows, err := q.db.Query(ctx, searchRoutes, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PlannedStartTime,
			&i.PlannedEndTime,
			&i.Status,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoutePlannedEndTime = `-- name: UpdateRoutePlannedEndTime :one
update routes set planned_end_time = $1 where id = $2 returning id, name, planned_start_time, planned_end_time, status, created, updated
`

type UpdateRoutePlannedEndTimeParams struct {
	PlannedEndTime pgtype.Timestamptz
	ID             pgtype.UUID
}

func (q *Queries) UpdateRoutePlannedEndTime(ctx context.Context, arg UpdateRoutePlannedEndTimeParams) (Route, error) {
	row := q.db.QueryRow(ctx, updateRoutePlannedEndTime, arg.PlannedEndTime, arg.ID)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PlannedStartTime,
		&i.PlannedEndTime,
		&i.Status,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateRoutePlannedStartTime = `-- name: UpdateRoutePlannedStartTime :one
update routes set planned_start_time = $1 where id = $2 returning id, name, planned_start_time, planned_end_time, status, created, updated
`

type UpdateRoutePlannedStartTimeParams struct {
	PlannedStartTime pgtype.Timestamptz
	ID               pgtype.UUID
}

func (q *Queries) UpdateRoutePlannedStartTime(ctx context.Context, arg UpdateRoutePlannedStartTimeParams) (Route, error) {
	row := q.db.QueryRow(ctx, updateRoutePlannedStartTime, arg.PlannedStartTime, arg.ID)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PlannedStartTime,
		&i.PlannedEndTime,
		&i.Status,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateRouteSegmentActualArrivalTime = `-- name: UpdateRouteSegmentActualArrivalTime :one
update route_segments set actual_arrival_time = $1 where id = $2 returning id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated
`

type UpdateRouteSegmentActualArrivalTimeParams struct {
	ActualArrivalTime pgtype.Timestamptz
	ID                pgtype.UUID
}

func (q *Queries) UpdateRouteSegmentActualArrivalTime(ctx context.Context, arg UpdateRouteSegmentActualArrivalTimeParams) (RouteSegment, error) {
	row := q.db.QueryRow(ctx, updateRouteSegmentActualArrivalTime, arg.ActualArrivalTime, arg.ID)
	var i RouteSegment
	err := row.Scan(
		&i.ID,
		&i.Route,
		&i.SequenceNumber,
		&i.SegmentType,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Instructions,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateRouteSegmentActualDepartureTime = `-- name: UpdateRouteSegmentActualDepartureTime :one
update route_segments set actual_departure_time = $1 where id = $2 returning id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated
`

type UpdateRouteSegmentActualDepartureTimeParams struct {
	ActualDepartureTime pgtype.Timestamptz
	ID                  pgtype.UUID
}

func (q *Queries) UpdateRouteSegmentActualDepartureTime(ctx context.Context, arg UpdateRouteSegmentActualDepartureTimeParams) (RouteSegment, error) {
	row := q.db.QueryRow(ctx, updateRouteSegmentActualDepartureTime, arg.ActualDepartureTime, arg.ID)
	var i RouteSegment
	err := row.Scan(
		&i.ID,
		&i.Route,
		&i.SequenceNumber,
		&i.SegmentType,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Instructions,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateRouteSegmentEstimatedArrivalTime = `-- name: UpdateRouteSegmentEstimatedArrivalTime :one
update route_segments set estimated_arrival_time = $1 where id = $2 returning id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated
`

type UpdateRouteSegmentEstimatedArrivalTimeParams struct {
	EstimatedArrivalTime pgtype.Timestamptz
	ID                   pgtype.UUID
}

func (q *Queries) UpdateRouteSegmentEstimatedArrivalTime(ctx context.Context, arg UpdateRouteSegmentEstimatedArrivalTimeParams) (RouteSegment, error) {
	row := q.db.QueryRow(ctx, updateRouteSegmentEstimatedArrivalTime, arg.EstimatedArrivalTime, arg.ID)
	var i RouteSegment
	err := row.Scan(
		&i.ID,
		&i.Route,
		&i.SequenceNumber,
		&i.SegmentType,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Instructions,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateRouteSegmentEstimatedDepartureTime = `-- name: UpdateRouteSegmentEstimatedDepartureTime :one
update route_segments set estimated_departure_time = $1 where id = $2 returning id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated
`

type UpdateRouteSegmentEstimatedDepartureTimeParams struct {
	EstimatedDepartureTime pgtype.Timestamptz
	ID                     pgtype.UUID
}

func (q *Queries) UpdateRouteSegmentEstimatedDepartureTime(ctx context.Context, arg UpdateRouteSegmentEstimatedDepartureTimeParams) (RouteSegment, error) {
	row := q.db.QueryRow(ctx, updateRouteSegmentEstimatedDepartureTime, arg.EstimatedDepartureTime, arg.ID)
	var i RouteSegment
	err := row.Scan(
		&i.ID,
		&i.Route,
		&i.SequenceNumber,
		&i.SegmentType,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Instructions,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateRouteSegmentInstructions = `-- name: UpdateRouteSegmentInstructions :one
update route_segments set instructions = $1 where id = $2 returning id, route, sequence_number, segment_type, address, longitude, latitude, instructions, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created, updated
`

type UpdateRouteSegmentInstructionsParams struct {
	Instructions pgtype.Text
	ID           pgtype.UUID
}

func (q *Queries) UpdateRouteSegmentInstructions(ctx context.Context, arg UpdateRouteSegmentInstructionsParams) (RouteSegment, error) {
	row := q.db.QueryRow(ctx, updateRouteSegmentInstructions, arg.Instructions, arg.ID)
	var i RouteSegment
	err := row.Scan(
		&i.ID,
		&i.Route,
		&i.SequenceNumber,
		&i.SegmentType,
		&i.Address,
		&i.Longitude,
		&i.Latitude,
		&i.Instructions,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateRouteStatus = `-- name: UpdateRouteStatus :one
update routes set status = $1 where id = $2 returning id, name, planned_start_time, planned_end_time, status, created, updated
`

type UpdateRouteStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateRouteStatus(ctx context.Context, arg UpdateRouteStatusParams) (Route, error) {
	row := q.db.QueryRow(ctx, updateRouteStatus, arg.Status, arg.ID)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PlannedStartTime,
		&i.PlannedEndTime,
		&i.Status,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
