// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_vehicles.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyVehicle = `-- name: TmsAnyVehicle :many
select
  id, registration_number, model, capacity_volume, capacity_weight, status, created_at, updated_at, make, year, vin, current_mileage, last_maintenance_date, vehicle_maintenance, gps_pings, geofence_events
from
  "tms"."vehicles_view"
where
  id = any ($1::uuid[])
`

func (q *Queries) TmsAnyVehicle(ctx context.Context, ids []pgtype.UUID) ([]TmsVehiclesView, error) {
	rows, err := q.db.Query(ctx, tmsAnyVehicle, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsVehiclesView
	for rows.Next() {
		var i TmsVehiclesView
		if err := rows.Scan(
			&i.ID,
			&i.RegistrationNumber,
			&i.Model,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Make,
			&i.Year,
			&i.Vin,
			&i.CurrentMileage,
			&i.LastMaintenanceDate,
			&i.VehicleMaintenance,
			&i.GpsPings,
			&i.GeofenceEvents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindVehicle = `-- name: TmsFindVehicle :one
select
  id, registration_number, model, capacity_volume, capacity_weight, status, created_at, updated_at, make, year, vin, current_mileage, last_maintenance_date, vehicle_maintenance, gps_pings, geofence_events
from
  "tms"."vehicles_view"
where
  id = $1::uuid
`

func (q *Queries) TmsFindVehicle(ctx context.Context, id pgtype.UUID) (TmsVehiclesView, error) {
	row := q.db.QueryRow(ctx, tmsFindVehicle, id)
	var i TmsVehiclesView
	err := row.Scan(
		&i.ID,
		&i.RegistrationNumber,
		&i.Model,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Make,
		&i.Year,
		&i.Vin,
		&i.CurrentMileage,
		&i.LastMaintenanceDate,
		&i.VehicleMaintenance,
		&i.GpsPings,
		&i.GeofenceEvents,
	)
	return i, err
}

const tmsInsertVehicle = `-- name: TmsInsertVehicle :one
insert into "tms"."vehicles"(registration_number, model, capacity_volume, capacity_weight, status)
  values ($1, $2, $3, $4, $5)
returning
  id, registration_number, model, capacity_volume, capacity_weight, status, created_at, updated_at, make, year, vin, current_mileage, last_maintenance_date
`

type TmsInsertVehicleParams struct {
	RegistrationNumber string                   `db:"registration_number" fake:"{uuid}" json:"registration_number"`
	Model              pgtype.Text              `db:"model" fake:"{carmodel}" json:"model"`
	CapacityVolume     pgtype.Float4            `db:"capacity_volume" fake:"{float64range:10,100}" json:"capacity_volume"`
	CapacityWeight     pgtype.Float4            `db:"capacity_weight" fake:"{float64range:1000,5000}" json:"capacity_weight"`
	Status             NullTmsVehicleStatusEnum `db:"status" json:"status"`
}

func (q *Queries) TmsInsertVehicle(ctx context.Context, arg TmsInsertVehicleParams) (TmsVehicle, error) {
	row := q.db.QueryRow(ctx, tmsInsertVehicle,
		arg.RegistrationNumber,
		arg.Model,
		arg.CapacityVolume,
		arg.CapacityWeight,
		arg.Status,
	)
	var i TmsVehicle
	err := row.Scan(
		&i.ID,
		&i.RegistrationNumber,
		&i.Model,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Make,
		&i.Year,
		&i.Vin,
		&i.CurrentMileage,
		&i.LastMaintenanceDate,
	)
	return i, err
}

const tmsPaginateVehicle = `-- name: TmsPaginateVehicle :many
select
  id, registration_number, model, capacity_volume, capacity_weight, status, created_at, updated_at, make, year, vin, current_mileage, last_maintenance_date, vehicle_maintenance, gps_pings, geofence_events
from
  "tms"."vehicles_view" as vehicles
where (registration_number ilike $1::text
  or model ilike $1::text
  or status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateVehicleParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

func (q *Queries) TmsPaginateVehicle(ctx context.Context, arg TmsPaginateVehicleParams) ([]TmsVehiclesView, error) {
	rows, err := q.db.Query(ctx, tmsPaginateVehicle, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsVehiclesView
	for rows.Next() {
		var i TmsVehiclesView
		if err := rows.Scan(
			&i.ID,
			&i.RegistrationNumber,
			&i.Model,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Make,
			&i.Year,
			&i.Vin,
			&i.CurrentMileage,
			&i.LastMaintenanceDate,
			&i.VehicleMaintenance,
			&i.GpsPings,
			&i.GeofenceEvents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsPaginateVehicleMetadata = `-- name: TmsPaginateVehicleMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "tms"."vehicles_view" as vehicles
where (registration_number ilike $3::text
  or model ilike $3::text
  or status::text ilike $3::text
  or $3::text is null)
`

type TmsPaginateVehicleMetadataParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type TmsPaginateVehicleMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) TmsPaginateVehicleMetadata(ctx context.Context, arg TmsPaginateVehicleMetadataParams) (TmsPaginateVehicleMetadataRow, error) {
	row := q.db.QueryRow(ctx, tmsPaginateVehicleMetadata, arg.PerPage, arg.Page, arg.Search)
	var i TmsPaginateVehicleMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const tmsRangeVehicle = `-- name: TmsRangeVehicle :many
select
  id, registration_number, model, capacity_volume, capacity_weight, status, created_at, updated_at, make, year, vin, current_mileage, last_maintenance_date, vehicle_maintenance, gps_pings, geofence_events
from
  "tms"."vehicles_view"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (registration_number ilike $3::text
    or model ilike $3::text
    or status::text ilike $3::text
    or $3::text is null)
`

type TmsRangeVehicleParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) TmsRangeVehicle(ctx context.Context, arg TmsRangeVehicleParams) ([]TmsVehiclesView, error) {
	rows, err := q.db.Query(ctx, tmsRangeVehicle, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsVehiclesView
	for rows.Next() {
		var i TmsVehiclesView
		if err := rows.Scan(
			&i.ID,
			&i.RegistrationNumber,
			&i.Model,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Make,
			&i.Year,
			&i.Vin,
			&i.CurrentMileage,
			&i.LastMaintenanceDate,
			&i.VehicleMaintenance,
			&i.GpsPings,
			&i.GeofenceEvents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveVehicle = `-- name: TmsRemoveVehicle :exec
delete from "tms"."vehicles"
where id = $1::uuid
`

func (q *Queries) TmsRemoveVehicle(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveVehicle, id)
	return err
}

const tmsUpdateVehicle = `-- name: TmsUpdateVehicle :one
update
  "tms"."vehicles"
set
  updated_at = now(),
  registration_number = case when $1 is not null then
    $1::varchar
  else
    registration_number
  end,
  model = case when $2 is not null then
    $2::varchar
  else
    model
  end,
  capacity_volume = case when $3 is not null then
    $3::real
  else
    capacity_volume
  end,
  capacity_weight = case when $4 is not null then
    $4::real
  else
    capacity_weight
  end,
  status = case when $5 is not null then
    $5::tms.vehicle_status_enum
  else
    status
  end
where
  id = $6::uuid
returning
  id, registration_number, model, capacity_volume, capacity_weight, status, created_at, updated_at, make, year, vin, current_mileage, last_maintenance_date
`

type TmsUpdateVehicleParams struct {
	RegistrationNumber string                   `db:"registration_number" fake:"{uuid}" json:"registration_number"`
	Model              pgtype.Text              `db:"model" fake:"{carmodel}" json:"model"`
	CapacityVolume     pgtype.Float4            `db:"capacity_volume" fake:"{float64range:10,100}" json:"capacity_volume"`
	CapacityWeight     pgtype.Float4            `db:"capacity_weight" fake:"{float64range:1000,5000}" json:"capacity_weight"`
	Status             NullTmsVehicleStatusEnum `db:"status" json:"status"`
	ID                 pgtype.UUID              `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateVehicle(ctx context.Context, arg TmsUpdateVehicleParams) (TmsVehicle, error) {
	row := q.db.QueryRow(ctx, tmsUpdateVehicle,
		arg.RegistrationNumber,
		arg.Model,
		arg.CapacityVolume,
		arg.CapacityWeight,
		arg.Status,
		arg.ID,
	)
	var i TmsVehicle
	err := row.Scan(
		&i.ID,
		&i.RegistrationNumber,
		&i.Model,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Make,
		&i.Year,
		&i.Vin,
		&i.CurrentMileage,
		&i.LastMaintenanceDate,
	)
	return i, err
}
