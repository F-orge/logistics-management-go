// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_gps_pings.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyGpsPing = `-- name: TmsAnyGpsPing :many
select
  gps_pings.id, gps_pings.vehicle_id, gps_pings.latitude, gps_pings.longitude, gps_pings.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."gps_pings" as gps_pings
  inner join "tms"."vehicles" as vehicle on gps_pings.vehicle_id = vehicle.id
where
  gps_pings.id = any ($1::uuid[])
`

type TmsAnyGpsPingRow struct {
	ID         pgtype.UUID      `db:"id" json:"id"`
	VehicleID  pgtype.UUID      `db:"vehicle_id" json:"vehicle_id"`
	Latitude   float32          `db:"latitude" json:"latitude"`
	Longitude  float32          `db:"longitude" json:"longitude"`
	Timestamp  pgtype.Timestamp `db:"timestamp" json:"timestamp"`
	TmsVehicle TmsVehicle       `db:"tms_vehicle" json:"tms_vehicle"`
}

func (q *Queries) TmsAnyGpsPing(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyGpsPingRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyGpsPing, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyGpsPingRow
	for rows.Next() {
		var i TmsAnyGpsPingRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.Latitude,
			&i.Longitude,
			&i.Timestamp,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindGpsPing = `-- name: TmsFindGpsPing :one
select
  gps_pings.id, gps_pings.vehicle_id, gps_pings.latitude, gps_pings.longitude, gps_pings.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."gps_pings" as gps_pings
  inner join "tms"."vehicles" as vehicle on gps_pings.vehicle_id = vehicle.id
where
  gps_pings.id = $1::uuid
`

type TmsFindGpsPingRow struct {
	ID         pgtype.UUID      `db:"id" json:"id"`
	VehicleID  pgtype.UUID      `db:"vehicle_id" json:"vehicle_id"`
	Latitude   float32          `db:"latitude" json:"latitude"`
	Longitude  float32          `db:"longitude" json:"longitude"`
	Timestamp  pgtype.Timestamp `db:"timestamp" json:"timestamp"`
	TmsVehicle TmsVehicle       `db:"tms_vehicle" json:"tms_vehicle"`
}

func (q *Queries) TmsFindGpsPing(ctx context.Context, id pgtype.UUID) (TmsFindGpsPingRow, error) {
	row := q.db.QueryRow(ctx, tmsFindGpsPing, id)
	var i TmsFindGpsPingRow
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.Latitude,
		&i.Longitude,
		&i.Timestamp,
		&i.TmsVehicle.ID,
		&i.TmsVehicle.RegistrationNumber,
		&i.TmsVehicle.Model,
		&i.TmsVehicle.CapacityVolume,
		&i.TmsVehicle.CapacityWeight,
		&i.TmsVehicle.Status,
		&i.TmsVehicle.CreatedAt,
		&i.TmsVehicle.UpdatedAt,
		&i.TmsVehicle.Make,
		&i.TmsVehicle.Year,
		&i.TmsVehicle.Vin,
		&i.TmsVehicle.CurrentMileage,
		&i.TmsVehicle.LastMaintenanceDate,
	)
	return i, err
}

const tmsInsertGpsPing = `-- name: TmsInsertGpsPing :one
insert into "tms"."gps_pings"(vehicle_id, latitude, longitude, timestamp)
  values ($1, $2, $3, $4)
returning
  id, vehicle_id, latitude, longitude, timestamp
`

type TmsInsertGpsPingParams struct {
	VehicleID pgtype.UUID      `db:"vehicle_id" json:"vehicle_id"`
	Latitude  float32          `db:"latitude" json:"latitude"`
	Longitude float32          `db:"longitude" json:"longitude"`
	Timestamp pgtype.Timestamp `db:"timestamp" json:"timestamp"`
}

func (q *Queries) TmsInsertGpsPing(ctx context.Context, arg TmsInsertGpsPingParams) (TmsGpsPing, error) {
	row := q.db.QueryRow(ctx, tmsInsertGpsPing,
		arg.VehicleID,
		arg.Latitude,
		arg.Longitude,
		arg.Timestamp,
	)
	var i TmsGpsPing
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.Latitude,
		&i.Longitude,
		&i.Timestamp,
	)
	return i, err
}

const tmsPaginateGpsPing = `-- name: TmsPaginateGpsPing :many
select
  gps_pings.id, gps_pings.vehicle_id, gps_pings.latitude, gps_pings.longitude, gps_pings.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."gps_pings" as gps_pings
  inner join "tms"."vehicles" as vehicle on gps_pings.vehicle_id = vehicle.id
where (vehicle.registration_number ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateGpsPingParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type TmsPaginateGpsPingRow struct {
	ID         pgtype.UUID      `db:"id" json:"id"`
	VehicleID  pgtype.UUID      `db:"vehicle_id" json:"vehicle_id"`
	Latitude   float32          `db:"latitude" json:"latitude"`
	Longitude  float32          `db:"longitude" json:"longitude"`
	Timestamp  pgtype.Timestamp `db:"timestamp" json:"timestamp"`
	TmsVehicle TmsVehicle       `db:"tms_vehicle" json:"tms_vehicle"`
}

func (q *Queries) TmsPaginateGpsPing(ctx context.Context, arg TmsPaginateGpsPingParams) ([]TmsPaginateGpsPingRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateGpsPing, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateGpsPingRow
	for rows.Next() {
		var i TmsPaginateGpsPingRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.Latitude,
			&i.Longitude,
			&i.Timestamp,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsPaginateGpsPingMetadata = `-- name: TmsPaginateGpsPingMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "tms"."gps_pings" as gps_pings
`

type TmsPaginateGpsPingMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type TmsPaginateGpsPingMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) TmsPaginateGpsPingMetadata(ctx context.Context, arg TmsPaginateGpsPingMetadataParams) (TmsPaginateGpsPingMetadataRow, error) {
	row := q.db.QueryRow(ctx, tmsPaginateGpsPingMetadata, arg.PerPage, arg.Page)
	var i TmsPaginateGpsPingMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const tmsRangeGpsPing = `-- name: TmsRangeGpsPing :many
select
  gps_pings.id, gps_pings.vehicle_id, gps_pings.latitude, gps_pings.longitude, gps_pings.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."gps_pings" as gps_pings
  inner join "tms"."vehicles" as vehicle on gps_pings.vehicle_id = vehicle.id
where
  gps_pings.created_at >= $1::date
  and gps_pings.created_at <= $2::date
  and (vehicle.registration_number ilike $3::text
    or $3::text is null)
`

type TmsRangeGpsPingParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeGpsPingRow struct {
	ID         pgtype.UUID      `db:"id" json:"id"`
	VehicleID  pgtype.UUID      `db:"vehicle_id" json:"vehicle_id"`
	Latitude   float32          `db:"latitude" json:"latitude"`
	Longitude  float32          `db:"longitude" json:"longitude"`
	Timestamp  pgtype.Timestamp `db:"timestamp" json:"timestamp"`
	TmsVehicle TmsVehicle       `db:"tms_vehicle" json:"tms_vehicle"`
}

func (q *Queries) TmsRangeGpsPing(ctx context.Context, arg TmsRangeGpsPingParams) ([]TmsRangeGpsPingRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeGpsPing, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeGpsPingRow
	for rows.Next() {
		var i TmsRangeGpsPingRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.Latitude,
			&i.Longitude,
			&i.Timestamp,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveGpsPing = `-- name: TmsRemoveGpsPing :exec
delete from "tms"."gps_pings"
where id = $1::uuid
`

func (q *Queries) TmsRemoveGpsPing(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveGpsPing, id)
	return err
}

const tmsUpdateGpsPing = `-- name: TmsUpdateGpsPing :one
update
  "tms"."gps_pings"
set
  updated_at = now(),
  vehicle_id = case when $1 is not null then
    $1::uuid
  else
    vehicle_id
  end,
  latitude = case when $2 is not null then
    $2::real
  else
    latitude
  end,
  longitude = case when $3 is not null then
    $3::real
  else
    longitude
  end,
  timestamp = case when $4 is not null then
    $4::timestamp
  else
    timestamp
  end
where
  id = $5::uuid
returning
  id, vehicle_id, latitude, longitude, timestamp
`

type TmsUpdateGpsPingParams struct {
	VehicleID pgtype.UUID      `db:"vehicle_id" json:"vehicle_id"`
	Latitude  float32          `db:"latitude" json:"latitude"`
	Longitude float32          `db:"longitude" json:"longitude"`
	Timestamp pgtype.Timestamp `db:"timestamp" json:"timestamp"`
	ID        pgtype.UUID      `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateGpsPing(ctx context.Context, arg TmsUpdateGpsPingParams) (TmsGpsPing, error) {
	row := q.db.QueryRow(ctx, tmsUpdateGpsPing,
		arg.VehicleID,
		arg.Latitude,
		arg.Longitude,
		arg.Timestamp,
		arg.ID,
	)
	var i TmsGpsPing
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.Latitude,
		&i.Longitude,
		&i.Timestamp,
	)
	return i, err
}
