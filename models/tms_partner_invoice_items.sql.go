// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_partner_invoice_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyPartnerInvoiceItem = `-- name: TmsAnyPartnerInvoiceItem :many
select
  partner_invoice_items.id, partner_invoice_items.partner_invoice_id, partner_invoice_items.shipment_leg_id, partner_invoice_items.amount,
  partner_invoice.id, partner_invoice.carrier_id, partner_invoice.invoice_number, partner_invoice.invoice_date, partner_invoice.total_amount, partner_invoice.status, partner_invoice.created_at, partner_invoice.updated_at,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."partner_invoice_items" as partner_invoice_items
  inner join "tms"."partner_invoices" as partner_invoice on partner_invoice_items.partner_invoice_id = partner_invoice.id
  inner join "tms"."shipment_legs" as shipment_leg on partner_invoice_items.shipment_leg_id = shipment_leg.id
where
  partner_invoice_items.id = any ($1::uuid[])
`

type TmsAnyPartnerInvoiceItemRow struct {
	TmsPartnerInvoiceItem TmsPartnerInvoiceItem `db:"tms_partner_invoice_item" json:"tms_partner_invoice_item"`
	TmsPartnerInvoice     TmsPartnerInvoice     `db:"tms_partner_invoice" json:"tms_partner_invoice"`
	TmsShipmentLeg        TmsShipmentLeg        `db:"tms_shipment_leg" json:"tms_shipment_leg"`
}

func (q *Queries) TmsAnyPartnerInvoiceItem(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyPartnerInvoiceItemRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyPartnerInvoiceItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyPartnerInvoiceItemRow
	for rows.Next() {
		var i TmsAnyPartnerInvoiceItemRow
		if err := rows.Scan(
			&i.TmsPartnerInvoiceItem.ID,
			&i.TmsPartnerInvoiceItem.PartnerInvoiceID,
			&i.TmsPartnerInvoiceItem.ShipmentLegID,
			&i.TmsPartnerInvoiceItem.Amount,
			&i.TmsPartnerInvoice.ID,
			&i.TmsPartnerInvoice.CarrierID,
			&i.TmsPartnerInvoice.InvoiceNumber,
			&i.TmsPartnerInvoice.InvoiceDate,
			&i.TmsPartnerInvoice.TotalAmount,
			&i.TmsPartnerInvoice.Status,
			&i.TmsPartnerInvoice.CreatedAt,
			&i.TmsPartnerInvoice.UpdatedAt,
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindPartnerInvoiceItem = `-- name: TmsFindPartnerInvoiceItem :one
select
  partner_invoice_items.id, partner_invoice_items.partner_invoice_id, partner_invoice_items.shipment_leg_id, partner_invoice_items.amount,
  partner_invoice.id, partner_invoice.carrier_id, partner_invoice.invoice_number, partner_invoice.invoice_date, partner_invoice.total_amount, partner_invoice.status, partner_invoice.created_at, partner_invoice.updated_at,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."partner_invoice_items" as partner_invoice_items
  inner join "tms"."partner_invoices" as partner_invoice on partner_invoice_items.partner_invoice_id = partner_invoice.id
  inner join "tms"."shipment_legs" as shipment_leg on partner_invoice_items.shipment_leg_id = shipment_leg.id
where
  partner_invoice_items.id = $1::uuid
`

type TmsFindPartnerInvoiceItemRow struct {
	TmsPartnerInvoiceItem TmsPartnerInvoiceItem `db:"tms_partner_invoice_item" json:"tms_partner_invoice_item"`
	TmsPartnerInvoice     TmsPartnerInvoice     `db:"tms_partner_invoice" json:"tms_partner_invoice"`
	TmsShipmentLeg        TmsShipmentLeg        `db:"tms_shipment_leg" json:"tms_shipment_leg"`
}

func (q *Queries) TmsFindPartnerInvoiceItem(ctx context.Context, id pgtype.UUID) (TmsFindPartnerInvoiceItemRow, error) {
	row := q.db.QueryRow(ctx, tmsFindPartnerInvoiceItem, id)
	var i TmsFindPartnerInvoiceItemRow
	err := row.Scan(
		&i.TmsPartnerInvoiceItem.ID,
		&i.TmsPartnerInvoiceItem.PartnerInvoiceID,
		&i.TmsPartnerInvoiceItem.ShipmentLegID,
		&i.TmsPartnerInvoiceItem.Amount,
		&i.TmsPartnerInvoice.ID,
		&i.TmsPartnerInvoice.CarrierID,
		&i.TmsPartnerInvoice.InvoiceNumber,
		&i.TmsPartnerInvoice.InvoiceDate,
		&i.TmsPartnerInvoice.TotalAmount,
		&i.TmsPartnerInvoice.Status,
		&i.TmsPartnerInvoice.CreatedAt,
		&i.TmsPartnerInvoice.UpdatedAt,
		&i.TmsShipmentLeg.ID,
		&i.TmsShipmentLeg.ShipmentID,
		&i.TmsShipmentLeg.LegSequence,
		&i.TmsShipmentLeg.StartLocation,
		&i.TmsShipmentLeg.EndLocation,
		&i.TmsShipmentLeg.CarrierID,
		&i.TmsShipmentLeg.InternalTripID,
		&i.TmsShipmentLeg.Status,
		&i.TmsShipmentLeg.CreatedAt,
		&i.TmsShipmentLeg.UpdatedAt,
	)
	return i, err
}

const tmsInsertPartnerInvoiceItem = `-- name: TmsInsertPartnerInvoiceItem :one
insert into "tms"."partner_invoice_items"(partner_invoice_id, shipment_leg_id, amount)
  values ($1, $2, $3)
returning
  id, partner_invoice_id, shipment_leg_id, amount
`

type TmsInsertPartnerInvoiceItemParams struct {
	PartnerInvoiceID pgtype.UUID    `db:"partner_invoice_id" json:"partner_invoice_id"`
	ShipmentLegID    pgtype.UUID    `db:"shipment_leg_id" json:"shipment_leg_id"`
	Amount           pgtype.Numeric `db:"amount" json:"amount"`
}

func (q *Queries) TmsInsertPartnerInvoiceItem(ctx context.Context, arg TmsInsertPartnerInvoiceItemParams) (TmsPartnerInvoiceItem, error) {
	row := q.db.QueryRow(ctx, tmsInsertPartnerInvoiceItem, arg.PartnerInvoiceID, arg.ShipmentLegID, arg.Amount)
	var i TmsPartnerInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.PartnerInvoiceID,
		&i.ShipmentLegID,
		&i.Amount,
	)
	return i, err
}

const tmsPaginatePartnerInvoiceItem = `-- name: TmsPaginatePartnerInvoiceItem :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page,
  partner_invoice_items.id, partner_invoice_items.partner_invoice_id, partner_invoice_items.shipment_leg_id, partner_invoice_items.amount,
  partner_invoice.id, partner_invoice.carrier_id, partner_invoice.invoice_number, partner_invoice.invoice_date, partner_invoice.total_amount, partner_invoice.status, partner_invoice.created_at, partner_invoice.updated_at,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."partner_invoice_items" as partner_invoice_items
  inner join "tms"."partner_invoices" as partner_invoice on partner_invoice_items.partner_invoice_id = partner_invoice.id
  inner join "tms"."shipment_legs" as shipment_leg on partner_invoice_items.shipment_leg_id = shipment_leg.id
where (partner_invoice.invoice_number ilike $3::text
  or shipment_leg.start_location ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type TmsPaginatePartnerInvoiceItemParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type TmsPaginatePartnerInvoiceItemRow struct {
	TotalItems            int64                 `db:"total_items" json:"total_items"`
	TotalPages            float64               `db:"total_pages" json:"total_pages"`
	Page                  int32                 `db:"page" json:"page"`
	PerPage               int32                 `db:"per_page" json:"per_page"`
	TmsPartnerInvoiceItem TmsPartnerInvoiceItem `db:"tms_partner_invoice_item" json:"tms_partner_invoice_item"`
	TmsPartnerInvoice     TmsPartnerInvoice     `db:"tms_partner_invoice" json:"tms_partner_invoice"`
	TmsShipmentLeg        TmsShipmentLeg        `db:"tms_shipment_leg" json:"tms_shipment_leg"`
}

func (q *Queries) TmsPaginatePartnerInvoiceItem(ctx context.Context, arg TmsPaginatePartnerInvoiceItemParams) ([]TmsPaginatePartnerInvoiceItemRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginatePartnerInvoiceItem, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginatePartnerInvoiceItemRow
	for rows.Next() {
		var i TmsPaginatePartnerInvoiceItemRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.TmsPartnerInvoiceItem.ID,
			&i.TmsPartnerInvoiceItem.PartnerInvoiceID,
			&i.TmsPartnerInvoiceItem.ShipmentLegID,
			&i.TmsPartnerInvoiceItem.Amount,
			&i.TmsPartnerInvoice.ID,
			&i.TmsPartnerInvoice.CarrierID,
			&i.TmsPartnerInvoice.InvoiceNumber,
			&i.TmsPartnerInvoice.InvoiceDate,
			&i.TmsPartnerInvoice.TotalAmount,
			&i.TmsPartnerInvoice.Status,
			&i.TmsPartnerInvoice.CreatedAt,
			&i.TmsPartnerInvoice.UpdatedAt,
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangePartnerInvoiceItem = `-- name: TmsRangePartnerInvoiceItem :many
select
  partner_invoice_items.id, partner_invoice_items.partner_invoice_id, partner_invoice_items.shipment_leg_id, partner_invoice_items.amount,
  partner_invoice.id, partner_invoice.carrier_id, partner_invoice.invoice_number, partner_invoice.invoice_date, partner_invoice.total_amount, partner_invoice.status, partner_invoice.created_at, partner_invoice.updated_at,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."partner_invoice_items" as partner_invoice_items
  inner join "tms"."partner_invoices" as partner_invoice on partner_invoice_items.partner_invoice_id = partner_invoice.id
  inner join "tms"."shipment_legs" as shipment_leg on partner_invoice_items.shipment_leg_id = shipment_leg.id
where
  partner_invoice_items.created_at >= $1::date
  and partner_invoice_items.created_at <= $2::date
  and (partner_invoice.invoice_number ilike $3::text
    or shipment_leg.start_location ilike $3::text
    or $3::text is null)
`

type TmsRangePartnerInvoiceItemParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangePartnerInvoiceItemRow struct {
	TmsPartnerInvoiceItem TmsPartnerInvoiceItem `db:"tms_partner_invoice_item" json:"tms_partner_invoice_item"`
	TmsPartnerInvoice     TmsPartnerInvoice     `db:"tms_partner_invoice" json:"tms_partner_invoice"`
	TmsShipmentLeg        TmsShipmentLeg        `db:"tms_shipment_leg" json:"tms_shipment_leg"`
}

func (q *Queries) TmsRangePartnerInvoiceItem(ctx context.Context, arg TmsRangePartnerInvoiceItemParams) ([]TmsRangePartnerInvoiceItemRow, error) {
	rows, err := q.db.Query(ctx, tmsRangePartnerInvoiceItem, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangePartnerInvoiceItemRow
	for rows.Next() {
		var i TmsRangePartnerInvoiceItemRow
		if err := rows.Scan(
			&i.TmsPartnerInvoiceItem.ID,
			&i.TmsPartnerInvoiceItem.PartnerInvoiceID,
			&i.TmsPartnerInvoiceItem.ShipmentLegID,
			&i.TmsPartnerInvoiceItem.Amount,
			&i.TmsPartnerInvoice.ID,
			&i.TmsPartnerInvoice.CarrierID,
			&i.TmsPartnerInvoice.InvoiceNumber,
			&i.TmsPartnerInvoice.InvoiceDate,
			&i.TmsPartnerInvoice.TotalAmount,
			&i.TmsPartnerInvoice.Status,
			&i.TmsPartnerInvoice.CreatedAt,
			&i.TmsPartnerInvoice.UpdatedAt,
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemovePartnerInvoiceItem = `-- name: TmsRemovePartnerInvoiceItem :exec
delete from "tms"."partner_invoice_items"
where id = $1::uuid
`

func (q *Queries) TmsRemovePartnerInvoiceItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemovePartnerInvoiceItem, id)
	return err
}

const tmsUpdatePartnerInvoiceItem = `-- name: TmsUpdatePartnerInvoiceItem :one
update
  "tms"."partner_invoice_items"
set
  updated_at = now(),
  partner_invoice_id = case when $1 is not null then
    $1::uuid
  else
    partner_invoice_id
  end,
  shipment_leg_id = case when $2 is not null then
    $2::uuid
  else
    shipment_leg_id
  end,
  amount = case when $3 is not null then
    $3::numeric
  else
    amount
  end
where
  id = $4::uuid
returning
  id, partner_invoice_id, shipment_leg_id, amount
`

type TmsUpdatePartnerInvoiceItemParams struct {
	PartnerInvoiceID pgtype.UUID    `db:"partner_invoice_id" json:"partner_invoice_id"`
	ShipmentLegID    pgtype.UUID    `db:"shipment_leg_id" json:"shipment_leg_id"`
	Amount           pgtype.Numeric `db:"amount" json:"amount"`
	ID               pgtype.UUID    `db:"id" json:"id"`
}

func (q *Queries) TmsUpdatePartnerInvoiceItem(ctx context.Context, arg TmsUpdatePartnerInvoiceItemParams) (TmsPartnerInvoiceItem, error) {
	row := q.db.QueryRow(ctx, tmsUpdatePartnerInvoiceItem,
		arg.PartnerInvoiceID,
		arg.ShipmentLegID,
		arg.Amount,
		arg.ID,
	)
	var i TmsPartnerInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.PartnerInvoiceID,
		&i.ShipmentLegID,
		&i.Amount,
	)
	return i, err
}
