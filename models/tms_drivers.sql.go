// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_drivers.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyDriver = `-- name: TmsAnyDriver :many
select
  drivers.id, drivers.user_id, drivers.license_number, drivers.license_expiry_date, drivers.status, drivers.created_at, drivers.updated_at, drivers.contact_phone,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "tms"."drivers" as drivers
  inner join "public"."user" as users on drivers.user_id = users.id
where
  drivers.id = any ($1::uuid[])
`

type TmsAnyDriverRow struct {
	TmsDriver TmsDriver
	User      User
}

func (q *Queries) TmsAnyDriver(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyDriverRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyDriver, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyDriverRow
	for rows.Next() {
		var i TmsAnyDriverRow
		if err := rows.Scan(
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindDriver = `-- name: TmsFindDriver :one
select
  drivers.id, drivers.user_id, drivers.license_number, drivers.license_expiry_date, drivers.status, drivers.created_at, drivers.updated_at, drivers.contact_phone,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "tms"."drivers" as drivers
  inner join "public"."user" as users on drivers.user_id = users.id
where
  drivers.id = $1::uuid
`

type TmsFindDriverRow struct {
	TmsDriver TmsDriver
	User      User
}

func (q *Queries) TmsFindDriver(ctx context.Context, id pgtype.UUID) (TmsFindDriverRow, error) {
	row := q.db.QueryRow(ctx, tmsFindDriver, id)
	var i TmsFindDriverRow
	err := row.Scan(
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const tmsInsertDriver = `-- name: TmsInsertDriver :one
insert into "tms"."drivers"(user_id, license_number, license_expiry_date, status)
  values ($1, $2, $3, $4)
returning
  id, user_id, license_number, license_expiry_date, status, created_at, updated_at, contact_phone
`

type TmsInsertDriverParams struct {
	UserID            string
	LicenseNumber     string
	LicenseExpiryDate pgtype.Date
	Status            NullTmsDriverStatusEnum
}

func (q *Queries) TmsInsertDriver(ctx context.Context, arg TmsInsertDriverParams) (TmsDriver, error) {
	row := q.db.QueryRow(ctx, tmsInsertDriver,
		arg.UserID,
		arg.LicenseNumber,
		arg.LicenseExpiryDate,
		arg.Status,
	)
	var i TmsDriver
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LicenseNumber,
		&i.LicenseExpiryDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactPhone,
	)
	return i, err
}

const tmsPaginateDriver = `-- name: TmsPaginateDriver :many
select
  drivers.id, drivers.user_id, drivers.license_number, drivers.license_expiry_date, drivers.status, drivers.created_at, drivers.updated_at, drivers.contact_phone,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "tms"."drivers" as drivers
  inner join "public"."user" as users on drivers.user_id = users.id
where
  (users.name ilike $1::text
  or drivers.license_number ilike $1::text
  or drivers.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateDriverParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type TmsPaginateDriverRow struct {
	TmsDriver TmsDriver
	User      User
}

func (q *Queries) TmsPaginateDriver(ctx context.Context, arg TmsPaginateDriverParams) ([]TmsPaginateDriverRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateDriver, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateDriverRow
	for rows.Next() {
		var i TmsPaginateDriverRow
		if err := rows.Scan(
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeDriver = `-- name: TmsRangeDriver :many
select
  drivers.id, drivers.user_id, drivers.license_number, drivers.license_expiry_date, drivers.status, drivers.created_at, drivers.updated_at, drivers.contact_phone,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "tms"."drivers" as drivers
  inner join "public"."user" as users on drivers.user_id = users.id
where
  drivers.created_at >= $1::date
  and drivers.created_at <= $2::date
  and (users.name ilike $3::text
  or drivers.license_number ilike $3::text
  or drivers.status::text ilike $3::text
  or $3::text is null)
`

type TmsRangeDriverParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type TmsRangeDriverRow struct {
	TmsDriver TmsDriver
	User      User
}

func (q *Queries) TmsRangeDriver(ctx context.Context, arg TmsRangeDriverParams) ([]TmsRangeDriverRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeDriver, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeDriverRow
	for rows.Next() {
		var i TmsRangeDriverRow
		if err := rows.Scan(
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveDriver = `-- name: TmsRemoveDriver :exec
delete from "tms"."drivers"
where id = $1::uuid
`

func (q *Queries) TmsRemoveDriver(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveDriver, id)
	return err
}

const tmsUpdateDriver = `-- name: TmsUpdateDriver :one
update
  "tms"."drivers"
set
  updated_at = now(),
  user_id = case when $1::boolean then
    $2::text
  else
    user_id
  end,
  license_number = case when $3::boolean then
    $4::varchar
  else
    license_number
  end,
  license_expiry_date = case when $5::boolean then
    $6::date
  else
    license_expiry_date
  end,
  status = case when $7::boolean then
    $8::tms.driver_status_enum
  else
    status
  end
where
  id = $9::uuid
returning
  id, user_id, license_number, license_expiry_date, status, created_at, updated_at, contact_phone
`

type TmsUpdateDriverParams struct {
	SetUserID            bool
	UserID               string
	SetLicenseNumber     bool
	LicenseNumber        string
	SetLicenseExpiryDate bool
	LicenseExpiryDate    pgtype.Date
	SetStatus            bool
	Status               TmsDriverStatusEnum
	ID                   pgtype.UUID
}

func (q *Queries) TmsUpdateDriver(ctx context.Context, arg TmsUpdateDriverParams) (TmsDriver, error) {
	row := q.db.QueryRow(ctx, tmsUpdateDriver,
		arg.SetUserID,
		arg.UserID,
		arg.SetLicenseNumber,
		arg.LicenseNumber,
		arg.SetLicenseExpiryDate,
		arg.LicenseExpiryDate,
		arg.SetStatus,
		arg.Status,
		arg.ID,
	)
	var i TmsDriver
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LicenseNumber,
		&i.LicenseExpiryDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactPhone,
	)
	return i, err
}
