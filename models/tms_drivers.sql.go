// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_drivers.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyDriver = `-- name: TmsAnyDriver :many
select
  drivers.id, drivers.user_id, drivers.license_number, drivers.license_expiry_date, drivers.status, drivers.created_at, drivers.updated_at, drivers.contact_phone, drivers.driver_schedules, drivers.expenses, drivers.trips,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "tms"."drivers_view" as drivers
  inner join "public"."user" as users on drivers.user_id = users.id
where
  drivers.id = any ($1::uuid[])
`

type TmsAnyDriverRow struct {
	TmsDriversView TmsDriversView `db:"tms_drivers_view" json:"tms_drivers_view"`
	User           User           `db:"user" json:"user"`
}

func (q *Queries) TmsAnyDriver(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyDriverRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyDriver, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyDriverRow
	for rows.Next() {
		var i TmsAnyDriverRow
		if err := rows.Scan(
			&i.TmsDriversView.ID,
			&i.TmsDriversView.UserID,
			&i.TmsDriversView.LicenseNumber,
			&i.TmsDriversView.LicenseExpiryDate,
			&i.TmsDriversView.Status,
			&i.TmsDriversView.CreatedAt,
			&i.TmsDriversView.UpdatedAt,
			&i.TmsDriversView.ContactPhone,
			&i.TmsDriversView.DriverSchedules,
			&i.TmsDriversView.Expenses,
			&i.TmsDriversView.Trips,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindDriver = `-- name: TmsFindDriver :one
select
  drivers.id, drivers.user_id, drivers.license_number, drivers.license_expiry_date, drivers.status, drivers.created_at, drivers.updated_at, drivers.contact_phone, drivers.driver_schedules, drivers.expenses, drivers.trips,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "tms"."drivers_view" as drivers
  inner join "public"."user" as users on drivers.user_id = users.id
where
  drivers.id = $1::uuid
`

type TmsFindDriverRow struct {
	TmsDriversView TmsDriversView `db:"tms_drivers_view" json:"tms_drivers_view"`
	User           User           `db:"user" json:"user"`
}

func (q *Queries) TmsFindDriver(ctx context.Context, id pgtype.UUID) (TmsFindDriverRow, error) {
	row := q.db.QueryRow(ctx, tmsFindDriver, id)
	var i TmsFindDriverRow
	err := row.Scan(
		&i.TmsDriversView.ID,
		&i.TmsDriversView.UserID,
		&i.TmsDriversView.LicenseNumber,
		&i.TmsDriversView.LicenseExpiryDate,
		&i.TmsDriversView.Status,
		&i.TmsDriversView.CreatedAt,
		&i.TmsDriversView.UpdatedAt,
		&i.TmsDriversView.ContactPhone,
		&i.TmsDriversView.DriverSchedules,
		&i.TmsDriversView.Expenses,
		&i.TmsDriversView.Trips,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const tmsInsertDriver = `-- name: TmsInsertDriver :one
insert into "tms"."drivers"(user_id, license_number, license_expiry_date, status)
  values ($1, $2, $3, $4)
returning
  id, user_id, license_number, license_expiry_date, status, created_at, updated_at, contact_phone
`

type TmsInsertDriverParams struct {
	UserID            string                  `db:"user_id" json:"user_id"`
	LicenseNumber     string                  `db:"license_number" json:"license_number"`
	LicenseExpiryDate pgtype.Date             `db:"license_expiry_date" json:"license_expiry_date"`
	Status            NullTmsDriverStatusEnum `db:"status" json:"status"`
}

func (q *Queries) TmsInsertDriver(ctx context.Context, arg TmsInsertDriverParams) (TmsDriver, error) {
	row := q.db.QueryRow(ctx, tmsInsertDriver,
		arg.UserID,
		arg.LicenseNumber,
		arg.LicenseExpiryDate,
		arg.Status,
	)
	var i TmsDriver
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LicenseNumber,
		&i.LicenseExpiryDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactPhone,
	)
	return i, err
}

const tmsPaginateDriver = `-- name: TmsPaginateDriver :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page,
  drivers.id, drivers.user_id, drivers.license_number, drivers.license_expiry_date, drivers.status, drivers.created_at, drivers.updated_at, drivers.contact_phone, drivers.driver_schedules, drivers.expenses, drivers.trips,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "tms"."drivers_view" as drivers
  inner join "public"."user" as users on drivers.user_id = users.id
where (users.name ilike $3::text
  or drivers.license_number ilike $3::text
  or drivers.status::text ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type TmsPaginateDriverParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type TmsPaginateDriverRow struct {
	TotalItems     int64          `db:"total_items" json:"total_items"`
	TotalPages     float64        `db:"total_pages" json:"total_pages"`
	Page           int32          `db:"page" json:"page"`
	PerPage        int32          `db:"per_page" json:"per_page"`
	TmsDriversView TmsDriversView `db:"tms_drivers_view" json:"tms_drivers_view"`
	User           User           `db:"user" json:"user"`
}

func (q *Queries) TmsPaginateDriver(ctx context.Context, arg TmsPaginateDriverParams) ([]TmsPaginateDriverRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateDriver, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateDriverRow
	for rows.Next() {
		var i TmsPaginateDriverRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.TmsDriversView.ID,
			&i.TmsDriversView.UserID,
			&i.TmsDriversView.LicenseNumber,
			&i.TmsDriversView.LicenseExpiryDate,
			&i.TmsDriversView.Status,
			&i.TmsDriversView.CreatedAt,
			&i.TmsDriversView.UpdatedAt,
			&i.TmsDriversView.ContactPhone,
			&i.TmsDriversView.DriverSchedules,
			&i.TmsDriversView.Expenses,
			&i.TmsDriversView.Trips,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeDriver = `-- name: TmsRangeDriver :many
select
  drivers.id, drivers.user_id, drivers.license_number, drivers.license_expiry_date, drivers.status, drivers.created_at, drivers.updated_at, drivers.contact_phone, drivers.driver_schedules, drivers.expenses, drivers.trips,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "tms"."drivers_view" as drivers
  inner join "public"."user" as users on drivers.user_id = users.id
where
  drivers.created_at >= $1::date
  and drivers.created_at <= $2::date
  and (users.name ilike $3::text
    or drivers.license_number ilike $3::text
    or drivers.status::text ilike $3::text
    or $3::text is null)
`

type TmsRangeDriverParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeDriverRow struct {
	TmsDriversView TmsDriversView `db:"tms_drivers_view" json:"tms_drivers_view"`
	User           User           `db:"user" json:"user"`
}

func (q *Queries) TmsRangeDriver(ctx context.Context, arg TmsRangeDriverParams) ([]TmsRangeDriverRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeDriver, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeDriverRow
	for rows.Next() {
		var i TmsRangeDriverRow
		if err := rows.Scan(
			&i.TmsDriversView.ID,
			&i.TmsDriversView.UserID,
			&i.TmsDriversView.LicenseNumber,
			&i.TmsDriversView.LicenseExpiryDate,
			&i.TmsDriversView.Status,
			&i.TmsDriversView.CreatedAt,
			&i.TmsDriversView.UpdatedAt,
			&i.TmsDriversView.ContactPhone,
			&i.TmsDriversView.DriverSchedules,
			&i.TmsDriversView.Expenses,
			&i.TmsDriversView.Trips,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveDriver = `-- name: TmsRemoveDriver :exec
delete from "tms"."drivers"
where id = $1::uuid
`

func (q *Queries) TmsRemoveDriver(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveDriver, id)
	return err
}

const tmsUpdateDriver = `-- name: TmsUpdateDriver :one
update
  "tms"."drivers"
set
  updated_at = now(),
  user_id = case when $1 is not null then
    $1::text
  else
    user_id
  end,
  license_number = case when $2 is not null then
    $2::varchar
  else
    license_number
  end,
  license_expiry_date = case when $3 is not null then
    $3::date
  else
    license_expiry_date
  end,
  status = case when $4 is not null then
    $4::tms.driver_status_enum
  else
    status
  end
where
  id = $5::uuid
returning
  id, user_id, license_number, license_expiry_date, status, created_at, updated_at, contact_phone
`

type TmsUpdateDriverParams struct {
	UserID            string                  `db:"user_id" json:"user_id"`
	LicenseNumber     string                  `db:"license_number" json:"license_number"`
	LicenseExpiryDate pgtype.Date             `db:"license_expiry_date" json:"license_expiry_date"`
	Status            NullTmsDriverStatusEnum `db:"status" json:"status"`
	ID                pgtype.UUID             `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateDriver(ctx context.Context, arg TmsUpdateDriverParams) (TmsDriver, error) {
	row := q.db.QueryRow(ctx, tmsUpdateDriver,
		arg.UserID,
		arg.LicenseNumber,
		arg.LicenseExpiryDate,
		arg.Status,
		arg.ID,
	)
	var i TmsDriver
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LicenseNumber,
		&i.LicenseExpiryDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactPhone,
	)
	return i, err
}
