// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_interactions.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyInteraction = `-- name: CrmAnyInteraction :many
select
  interactions.id, interactions.contact_id, interactions.user_id, interactions.case_id, interactions.type, interactions.outcome, interactions.notes, interactions.interaction_date, interactions.created_at, interactions.updated_at,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at
from
  "crm"."interactions" as interactions
  inner join "crm"."contacts" as contact on interactions.contact_id = contact.id
  inner join "public"."user" as users on interactions.user_id = users.id
  left join "crm"."cases" as cases on interactions.case_id = cases.id
where
  interactions.id = any ($1::uuid[])
`

type CrmAnyInteractionRow struct {
	CrmInteraction CrmInteraction
	CrmContact     CrmContact
	User           User
	CrmCase        CrmCase
}

func (q *Queries) CrmAnyInteraction(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyInteractionRow, error) {
	rows, err := q.db.Query(ctx, crmAnyInteraction, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyInteractionRow
	for rows.Next() {
		var i CrmAnyInteractionRow
		if err := rows.Scan(
			&i.CrmInteraction.ID,
			&i.CrmInteraction.ContactID,
			&i.CrmInteraction.UserID,
			&i.CrmInteraction.CaseID,
			&i.CrmInteraction.Type,
			&i.CrmInteraction.Outcome,
			&i.CrmInteraction.Notes,
			&i.CrmInteraction.InteractionDate,
			&i.CrmInteraction.CreatedAt,
			&i.CrmInteraction.UpdatedAt,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmCase.ID,
			&i.CrmCase.CaseNumber,
			&i.CrmCase.Status,
			&i.CrmCase.Priority,
			&i.CrmCase.Type,
			&i.CrmCase.OwnerID,
			&i.CrmCase.ContactID,
			&i.CrmCase.Description,
			&i.CrmCase.CreatedAt,
			&i.CrmCase.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindInteraction = `-- name: CrmFindInteraction :one
select
  interactions.id, interactions.contact_id, interactions.user_id, interactions.case_id, interactions.type, interactions.outcome, interactions.notes, interactions.interaction_date, interactions.created_at, interactions.updated_at,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at
from
  "crm"."interactions" as interactions
  inner join "crm"."contacts" as contact on interactions.contact_id = contact.id
  inner join "public"."user" as users on interactions.user_id = users.id
  left join "crm"."cases" as cases on interactions.case_id = cases.id
where
  interactions.id = $1::uuid
`

type CrmFindInteractionRow struct {
	CrmInteraction CrmInteraction
	CrmContact     CrmContact
	User           User
	CrmCase        CrmCase
}

func (q *Queries) CrmFindInteraction(ctx context.Context, id pgtype.UUID) (CrmFindInteractionRow, error) {
	row := q.db.QueryRow(ctx, crmFindInteraction, id)
	var i CrmFindInteractionRow
	err := row.Scan(
		&i.CrmInteraction.ID,
		&i.CrmInteraction.ContactID,
		&i.CrmInteraction.UserID,
		&i.CrmInteraction.CaseID,
		&i.CrmInteraction.Type,
		&i.CrmInteraction.Outcome,
		&i.CrmInteraction.Notes,
		&i.CrmInteraction.InteractionDate,
		&i.CrmInteraction.CreatedAt,
		&i.CrmInteraction.UpdatedAt,
		&i.CrmContact.ID,
		&i.CrmContact.Name,
		&i.CrmContact.Email,
		&i.CrmContact.PhoneNumber,
		&i.CrmContact.JobTitle,
		&i.CrmContact.CompanyID,
		&i.CrmContact.OwnerID,
		&i.CrmContact.CreatedAt,
		&i.CrmContact.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
		&i.CrmCase.ID,
		&i.CrmCase.CaseNumber,
		&i.CrmCase.Status,
		&i.CrmCase.Priority,
		&i.CrmCase.Type,
		&i.CrmCase.OwnerID,
		&i.CrmCase.ContactID,
		&i.CrmCase.Description,
		&i.CrmCase.CreatedAt,
		&i.CrmCase.UpdatedAt,
	)
	return i, err
}

const crmInsertInteraction = `-- name: CrmInsertInteraction :one
insert into "crm"."interactions"(contact_id, user_id, case_id, type, outcome, notes, interaction_date)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, contact_id, user_id, case_id, type, outcome, notes, interaction_date, created_at, updated_at
`

type CrmInsertInteractionParams struct {
	ContactID       pgtype.UUID
	UserID          string
	CaseID          pgtype.UUID
	Type            NullCrmInteractionType
	Outcome         pgtype.Text
	Notes           pgtype.Text
	InteractionDate pgtype.Timestamptz
}

func (q *Queries) CrmInsertInteraction(ctx context.Context, arg CrmInsertInteractionParams) (CrmInteraction, error) {
	row := q.db.QueryRow(ctx, crmInsertInteraction,
		arg.ContactID,
		arg.UserID,
		arg.CaseID,
		arg.Type,
		arg.Outcome,
		arg.Notes,
		arg.InteractionDate,
	)
	var i CrmInteraction
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.UserID,
		&i.CaseID,
		&i.Type,
		&i.Outcome,
		&i.Notes,
		&i.InteractionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateInteraction = `-- name: CrmPaginateInteraction :many
select
  interactions.id, interactions.contact_id, interactions.user_id, interactions.case_id, interactions.type, interactions.outcome, interactions.notes, interactions.interaction_date, interactions.created_at, interactions.updated_at,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at
from
  "crm"."interactions" as interactions
  inner join "crm"."contacts" as contact on interactions.contact_id = contact.id
  inner join "public"."user" as users on interactions.user_id = users.id
  left join "crm"."cases" as cases on interactions.case_id = cases.id
where (contact.name ilike $1::text
  or users.name ilike $1::text
  or cases.case_number ilike $1::text
  or interactions.type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateInteractionParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type CrmPaginateInteractionRow struct {
	CrmInteraction CrmInteraction
	CrmContact     CrmContact
	User           User
	CrmCase        CrmCase
}

func (q *Queries) CrmPaginateInteraction(ctx context.Context, arg CrmPaginateInteractionParams) ([]CrmPaginateInteractionRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateInteraction, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateInteractionRow
	for rows.Next() {
		var i CrmPaginateInteractionRow
		if err := rows.Scan(
			&i.CrmInteraction.ID,
			&i.CrmInteraction.ContactID,
			&i.CrmInteraction.UserID,
			&i.CrmInteraction.CaseID,
			&i.CrmInteraction.Type,
			&i.CrmInteraction.Outcome,
			&i.CrmInteraction.Notes,
			&i.CrmInteraction.InteractionDate,
			&i.CrmInteraction.CreatedAt,
			&i.CrmInteraction.UpdatedAt,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmCase.ID,
			&i.CrmCase.CaseNumber,
			&i.CrmCase.Status,
			&i.CrmCase.Priority,
			&i.CrmCase.Type,
			&i.CrmCase.OwnerID,
			&i.CrmCase.ContactID,
			&i.CrmCase.Description,
			&i.CrmCase.CreatedAt,
			&i.CrmCase.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeInteraction = `-- name: CrmRangeInteraction :many
select
  interactions.id, interactions.contact_id, interactions.user_id, interactions.case_id, interactions.type, interactions.outcome, interactions.notes, interactions.interaction_date, interactions.created_at, interactions.updated_at,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at
from
  "crm"."interactions" as interactions
  inner join "crm"."contacts" as contact on interactions.contact_id = contact.id
  inner join "public"."user" as users on interactions.user_id = users.id
  left join "crm"."cases" as cases on interactions.case_id = cases.id
where
  interactions.created_at >= $1::date
  and interactions.created_at <= $2::date
  and (contact.name ilike $3::text
    or users.name ilike $3::text
    or cases.case_number ilike $3::text
    or interactions.type::text ilike $3::text
    or $3::text is null)
`

type CrmRangeInteractionParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type CrmRangeInteractionRow struct {
	CrmInteraction CrmInteraction
	CrmContact     CrmContact
	User           User
	CrmCase        CrmCase
}

func (q *Queries) CrmRangeInteraction(ctx context.Context, arg CrmRangeInteractionParams) ([]CrmRangeInteractionRow, error) {
	rows, err := q.db.Query(ctx, crmRangeInteraction, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeInteractionRow
	for rows.Next() {
		var i CrmRangeInteractionRow
		if err := rows.Scan(
			&i.CrmInteraction.ID,
			&i.CrmInteraction.ContactID,
			&i.CrmInteraction.UserID,
			&i.CrmInteraction.CaseID,
			&i.CrmInteraction.Type,
			&i.CrmInteraction.Outcome,
			&i.CrmInteraction.Notes,
			&i.CrmInteraction.InteractionDate,
			&i.CrmInteraction.CreatedAt,
			&i.CrmInteraction.UpdatedAt,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmCase.ID,
			&i.CrmCase.CaseNumber,
			&i.CrmCase.Status,
			&i.CrmCase.Priority,
			&i.CrmCase.Type,
			&i.CrmCase.OwnerID,
			&i.CrmCase.ContactID,
			&i.CrmCase.Description,
			&i.CrmCase.CreatedAt,
			&i.CrmCase.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveInteraction = `-- name: CrmRemoveInteraction :exec
delete from "crm"."interactions"
where id = $1::uuid
`

func (q *Queries) CrmRemoveInteraction(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveInteraction, id)
	return err
}

const crmUpdateInteraction = `-- name: CrmUpdateInteraction :one
update
  "crm"."interactions"
set
  updated_at = now(),
  contact_id = case when $1 is not null then
    $1::uuid
  else
    contact_id
  end,
  user_id = case when $2 is not null then
    $2::text
  else
    user_id
  end,
  case_id = case when $3 is not null then
    $3::uuid
  else
    case_id
  end,
  type = case when $4 is not null then
    $4::crm.interaction_type
  else
    type
  end,
  outcome = case when $5 is not null then
    $5::varchar
  else
    outcome
  end,
  notes = case when $6 is not null then
    $6::text
  else
    notes
  end,
  interaction_date = case when $7 is not null then
    $7::timestamptz
  else
    interaction_date
  end
where
  id = $8::uuid
returning
  id, contact_id, user_id, case_id, type, outcome, notes, interaction_date, created_at, updated_at
`

type CrmUpdateInteractionParams struct {
	ContactID       pgtype.UUID
	UserID          string
	CaseID          pgtype.UUID
	Type            NullCrmInteractionType
	Outcome         pgtype.Text
	Notes           pgtype.Text
	InteractionDate pgtype.Timestamptz
	ID              pgtype.UUID
}

func (q *Queries) CrmUpdateInteraction(ctx context.Context, arg CrmUpdateInteractionParams) (CrmInteraction, error) {
	row := q.db.QueryRow(ctx, crmUpdateInteraction,
		arg.ContactID,
		arg.UserID,
		arg.CaseID,
		arg.Type,
		arg.Outcome,
		arg.Notes,
		arg.InteractionDate,
		arg.ID,
	)
	var i CrmInteraction
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.UserID,
		&i.CaseID,
		&i.Type,
		&i.Outcome,
		&i.Notes,
		&i.InteractionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
