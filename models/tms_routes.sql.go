// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_routes.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyRoute = `-- name: TmsAnyRoute :many
select
  routes.id, routes.trip_id, routes.optimized_route_data, routes.total_distance, routes.total_duration, routes.created_at, routes.updated_at,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time
from
  "tms"."routes" as routes
  inner join "tms"."trips" as trip on routes.trip_id = trip.id
where
  routes.id = any ($1::uuid[])
`

type TmsAnyRouteRow struct {
	TmsRoute TmsRoute `db:"tms_route" json:"tms_route"`
	TmsTrip  TmsTrip  `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsAnyRoute(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyRouteRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyRoute, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyRouteRow
	for rows.Next() {
		var i TmsAnyRouteRow
		if err := rows.Scan(
			&i.TmsRoute.ID,
			&i.TmsRoute.TripID,
			&i.TmsRoute.OptimizedRouteData,
			&i.TmsRoute.TotalDistance,
			&i.TmsRoute.TotalDuration,
			&i.TmsRoute.CreatedAt,
			&i.TmsRoute.UpdatedAt,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindRoute = `-- name: TmsFindRoute :one
select
  routes.id, routes.trip_id, routes.optimized_route_data, routes.total_distance, routes.total_duration, routes.created_at, routes.updated_at,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time
from
  "tms"."routes" as routes
  inner join "tms"."trips" as trip on routes.trip_id = trip.id
where
  routes.id = $1::uuid
`

type TmsFindRouteRow struct {
	TmsRoute TmsRoute `db:"tms_route" json:"tms_route"`
	TmsTrip  TmsTrip  `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsFindRoute(ctx context.Context, id pgtype.UUID) (TmsFindRouteRow, error) {
	row := q.db.QueryRow(ctx, tmsFindRoute, id)
	var i TmsFindRouteRow
	err := row.Scan(
		&i.TmsRoute.ID,
		&i.TmsRoute.TripID,
		&i.TmsRoute.OptimizedRouteData,
		&i.TmsRoute.TotalDistance,
		&i.TmsRoute.TotalDuration,
		&i.TmsRoute.CreatedAt,
		&i.TmsRoute.UpdatedAt,
		&i.TmsTrip.ID,
		&i.TmsTrip.DriverID,
		&i.TmsTrip.VehicleID,
		&i.TmsTrip.Status,
		&i.TmsTrip.CreatedAt,
		&i.TmsTrip.UpdatedAt,
		&i.TmsTrip.EndLocation,
		&i.TmsTrip.EndTime,
		&i.TmsTrip.StartLocation,
		&i.TmsTrip.StartTime,
	)
	return i, err
}

const tmsInsertRoute = `-- name: TmsInsertRoute :one
insert into "tms"."routes"(trip_id, optimized_route_data, total_distance, total_duration)
  values ($1, $2, $3, $4)
returning
  id, trip_id, optimized_route_data, total_distance, total_duration, created_at, updated_at
`

type TmsInsertRouteParams struct {
	TripID             pgtype.UUID   `db:"trip_id" json:"trip_id"`
	OptimizedRouteData pgtype.Text   `db:"optimized_route_data" json:"optimized_route_data"`
	TotalDistance      pgtype.Float4 `db:"total_distance" json:"total_distance"`
	TotalDuration      pgtype.Float4 `db:"total_duration" json:"total_duration"`
}

func (q *Queries) TmsInsertRoute(ctx context.Context, arg TmsInsertRouteParams) (TmsRoute, error) {
	row := q.db.QueryRow(ctx, tmsInsertRoute,
		arg.TripID,
		arg.OptimizedRouteData,
		arg.TotalDistance,
		arg.TotalDuration,
	)
	var i TmsRoute
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.OptimizedRouteData,
		&i.TotalDistance,
		&i.TotalDuration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateRoute = `-- name: TmsPaginateRoute :many
select
  routes.id, routes.trip_id, routes.optimized_route_data, routes.total_distance, routes.total_duration, routes.created_at, routes.updated_at,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time
from
  "tms"."routes" as routes
  inner join "tms"."trips" as trip on routes.trip_id = trip.id
where (trip.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateRouteParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	Perpage int32       `db:"perpage" json:"perpage"`
}

type TmsPaginateRouteRow struct {
	TmsRoute TmsRoute `db:"tms_route" json:"tms_route"`
	TmsTrip  TmsTrip  `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsPaginateRoute(ctx context.Context, arg TmsPaginateRouteParams) ([]TmsPaginateRouteRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateRoute, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateRouteRow
	for rows.Next() {
		var i TmsPaginateRouteRow
		if err := rows.Scan(
			&i.TmsRoute.ID,
			&i.TmsRoute.TripID,
			&i.TmsRoute.OptimizedRouteData,
			&i.TmsRoute.TotalDistance,
			&i.TmsRoute.TotalDuration,
			&i.TmsRoute.CreatedAt,
			&i.TmsRoute.UpdatedAt,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeRoute = `-- name: TmsRangeRoute :many
select
  routes.id, routes.trip_id, routes.optimized_route_data, routes.total_distance, routes.total_duration, routes.created_at, routes.updated_at,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time
from
  "tms"."routes" as routes
  inner join "tms"."trips" as trip on routes.trip_id = trip.id
where
  routes.created_at >= $1::date
  and routes.created_at <= $2::date
  and (trip.status::text ilike $3::text
    or $3::text is null)
`

type TmsRangeRouteParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeRouteRow struct {
	TmsRoute TmsRoute `db:"tms_route" json:"tms_route"`
	TmsTrip  TmsTrip  `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsRangeRoute(ctx context.Context, arg TmsRangeRouteParams) ([]TmsRangeRouteRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeRoute, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeRouteRow
	for rows.Next() {
		var i TmsRangeRouteRow
		if err := rows.Scan(
			&i.TmsRoute.ID,
			&i.TmsRoute.TripID,
			&i.TmsRoute.OptimizedRouteData,
			&i.TmsRoute.TotalDistance,
			&i.TmsRoute.TotalDuration,
			&i.TmsRoute.CreatedAt,
			&i.TmsRoute.UpdatedAt,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveRoute = `-- name: TmsRemoveRoute :exec
delete from "tms"."routes"
where id = $1::uuid
`

func (q *Queries) TmsRemoveRoute(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveRoute, id)
	return err
}

const tmsUpdateRoute = `-- name: TmsUpdateRoute :one
update
  "tms"."routes"
set
  updated_at = now(),
  trip_id = case when $1 is not null then
    $1::uuid
  else
    trip_id
  end,
  optimized_route_data = case when $2 is not null then
    $2::text
  else
    optimized_route_data
  end,
  total_distance = case when $3 is not null then
    $3::real
  else
    total_distance
  end,
  total_duration = case when $4 is not null then
    $4::real
  else
    total_duration
  end
where
  id = $5::uuid
returning
  id, trip_id, optimized_route_data, total_distance, total_duration, created_at, updated_at
`

type TmsUpdateRouteParams struct {
	TripID             pgtype.UUID   `db:"trip_id" json:"trip_id"`
	OptimizedRouteData pgtype.Text   `db:"optimized_route_data" json:"optimized_route_data"`
	TotalDistance      pgtype.Float4 `db:"total_distance" json:"total_distance"`
	TotalDuration      pgtype.Float4 `db:"total_duration" json:"total_duration"`
	ID                 pgtype.UUID   `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateRoute(ctx context.Context, arg TmsUpdateRouteParams) (TmsRoute, error) {
	row := q.db.QueryRow(ctx, tmsUpdateRoute,
		arg.TripID,
		arg.OptimizedRouteData,
		arg.TotalDistance,
		arg.TotalDuration,
		arg.ID,
	)
	var i TmsRoute
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.OptimizedRouteData,
		&i.TotalDistance,
		&i.TotalDuration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
