// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: departments.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignUserToDepartment = `-- name: AssignUserToDepartment :one
insert into department_members (department_id, user_id, role)
values ($1, $2, $3)
returning department_id, user_id, role, created, updated
`

type AssignUserToDepartmentParams struct {
	DepartmentID pgtype.UUID
	UserID       pgtype.UUID
	Role         string
}

func (q *Queries) AssignUserToDepartment(ctx context.Context, arg AssignUserToDepartmentParams) (DepartmentMember, error) {
	row := q.db.QueryRow(ctx, assignUserToDepartment, arg.DepartmentID, arg.UserID, arg.Role)
	var i DepartmentMember
	err := row.Scan(
		&i.DepartmentID,
		&i.UserID,
		&i.Role,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const createDepartment = `-- name: CreateDepartment :one
insert into departments (name, description)
values ($1, $2)
returning id, name, description, created, updated
`

type CreateDepartmentParams struct {
	Name        string
	Description pgtype.Text
}

func (q *Queries) CreateDepartment(ctx context.Context, arg CreateDepartmentParams) (Department, error) {
	row := q.db.QueryRow(ctx, createDepartment, arg.Name, arg.Description)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteDepartment = `-- name: DeleteDepartment :one
delete from departments where id = $1 returning id, name, description, created, updated
`

func (q *Queries) DeleteDepartment(ctx context.Context, id pgtype.UUID) (Department, error) {
	row := q.db.QueryRow(ctx, deleteDepartment, id)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getDepartmentByID = `-- name: GetDepartmentByID :one
select id, name, description, created, updated from departments where id = $1
`

func (q *Queries) GetDepartmentByID(ctx context.Context, id pgtype.UUID) (Department, error) {
	row := q.db.QueryRow(ctx, getDepartmentByID, id)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getDepartmentMembers = `-- name: GetDepartmentMembers :many
select dm.department_id, dm.user_id, dm.role, dm.created, dm.updated, u.email, u.name from department_members dm
join auth.users u on dm.user_id = u.id
where dm.department_id = $1
order by dm.created desc offset $2 limit $3
`

type GetDepartmentMembersParams struct {
	DepartmentID pgtype.UUID
	Offset       int32
	Limit        int32
}

type GetDepartmentMembersRow struct {
	DepartmentID pgtype.UUID
	UserID       pgtype.UUID
	Role         string
	Created      pgtype.Timestamptz
	Updated      pgtype.Timestamptz
	Email        string
	Name         string
}

func (q *Queries) GetDepartmentMembers(ctx context.Context, arg GetDepartmentMembersParams) ([]GetDepartmentMembersRow, error) {
	rows, err := q.db.Query(ctx, getDepartmentMembers, arg.DepartmentID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDepartmentMembersRow
	for rows.Next() {
		var i GetDepartmentMembersRow
		if err := rows.Scan(
			&i.DepartmentID,
			&i.UserID,
			&i.Role,
			&i.Created,
			&i.Updated,
			&i.Email,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDepartments = `-- name: GetDepartments :many
select id, name, description, created, updated from departments order by created desc
`

func (q *Queries) GetDepartments(ctx context.Context) ([]Department, error) {
	rows, err := q.db.Query(ctx, getDepartments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateDepartment = `-- name: PaginateDepartment :many
select id, name, description, created, updated from departments order by created desc offset $1 limit $2
`

type PaginateDepartmentParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) PaginateDepartment(ctx context.Context, arg PaginateDepartmentParams) ([]Department, error) {
	rows, err := q.db.Query(ctx, paginateDepartment, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDepartments = `-- name: SearchDepartments :many
select id, name, description, created, updated from departments where name ilike '%' || $1::text || '%' or description ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchDepartmentsParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchDepartments(ctx context.Context, arg SearchDepartmentsParams) ([]Department, error) {
	rows, err := q.db.Query(ctx, searchDepartments, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDepartmentDescription = `-- name: UpdateDepartmentDescription :one
update departments set description = $1 where id = $2 returning id, name, description, created, updated
`

type UpdateDepartmentDescriptionParams struct {
	Description pgtype.Text
	ID          pgtype.UUID
}

func (q *Queries) UpdateDepartmentDescription(ctx context.Context, arg UpdateDepartmentDescriptionParams) (Department, error) {
	row := q.db.QueryRow(ctx, updateDepartmentDescription, arg.Description, arg.ID)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateDepartmentName = `-- name: UpdateDepartmentName :one
update departments set name = $1 where id = $2 returning id, name, description, created, updated
`

type UpdateDepartmentNameParams struct {
	Name string
	ID   pgtype.UUID
}

func (q *Queries) UpdateDepartmentName(ctx context.Context, arg UpdateDepartmentNameParams) (Department, error) {
	row := q.db.QueryRow(ctx, updateDepartmentName, arg.Name, arg.ID)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
