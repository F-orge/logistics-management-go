// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_notifications.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyNotification = `-- name: CrmAnyNotification :many
select
  notifications.id, notifications.user_id, notifications.message, notifications.is_read, notifications.created_at, notifications.updated_at, notifications.link,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "crm"."notifications" as notifications
  inner join "public"."user" as users on notifications.user_id = users.id
where
  notifications.id = any ($1::uuid[])
`

type CrmAnyNotificationRow struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	UserID    string             `db:"user_id" json:"user_id"`
	Message   string             `db:"message" fake:"{sentence}" json:"message"`
	IsRead    pgtype.Bool        `db:"is_read" json:"is_read"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Link      pgtype.Text        `db:"link" fake:"{url}" json:"link"`
	User      User               `db:"user" json:"user"`
}

func (q *Queries) CrmAnyNotification(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyNotificationRow, error) {
	rows, err := q.db.Query(ctx, crmAnyNotification, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyNotificationRow
	for rows.Next() {
		var i CrmAnyNotificationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Message,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Link,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindNotification = `-- name: CrmFindNotification :one
select
  notifications.id, notifications.user_id, notifications.message, notifications.is_read, notifications.created_at, notifications.updated_at, notifications.link,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "crm"."notifications" as notifications
  inner join "public"."user" as users on notifications.user_id = users.id
where
  notifications.id = $1::uuid
`

type CrmFindNotificationRow struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	UserID    string             `db:"user_id" json:"user_id"`
	Message   string             `db:"message" fake:"{sentence}" json:"message"`
	IsRead    pgtype.Bool        `db:"is_read" json:"is_read"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Link      pgtype.Text        `db:"link" fake:"{url}" json:"link"`
	User      User               `db:"user" json:"user"`
}

func (q *Queries) CrmFindNotification(ctx context.Context, id pgtype.UUID) (CrmFindNotificationRow, error) {
	row := q.db.QueryRow(ctx, crmFindNotification, id)
	var i CrmFindNotificationRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Message,
		&i.IsRead,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Link,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const crmInsertNotification = `-- name: CrmInsertNotification :one
insert into "crm"."notifications"(user_id, message, is_read, link)
  values ($1, $2, $3, $4)
returning
  id, user_id, message, is_read, created_at, updated_at, link
`

type CrmInsertNotificationParams struct {
	UserID  string      `db:"user_id" json:"user_id"`
	Message string      `db:"message" fake:"{sentence}" json:"message"`
	IsRead  pgtype.Bool `db:"is_read" json:"is_read"`
	Link    pgtype.Text `db:"link" fake:"{url}" json:"link"`
}

func (q *Queries) CrmInsertNotification(ctx context.Context, arg CrmInsertNotificationParams) (CrmNotification, error) {
	row := q.db.QueryRow(ctx, crmInsertNotification,
		arg.UserID,
		arg.Message,
		arg.IsRead,
		arg.Link,
	)
	var i CrmNotification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Message,
		&i.IsRead,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Link,
	)
	return i, err
}

const crmPaginateNotification = `-- name: CrmPaginateNotification :many
select
  notifications.id, notifications.user_id, notifications.message, notifications.is_read, notifications.created_at, notifications.updated_at, notifications.link,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "crm"."notifications" as notifications
  inner join "public"."user" as users on notifications.user_id = users.id
where (users.name ilike $1::text
  or notifications.message ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateNotificationParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type CrmPaginateNotificationRow struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	UserID    string             `db:"user_id" json:"user_id"`
	Message   string             `db:"message" fake:"{sentence}" json:"message"`
	IsRead    pgtype.Bool        `db:"is_read" json:"is_read"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Link      pgtype.Text        `db:"link" fake:"{url}" json:"link"`
	User      User               `db:"user" json:"user"`
}

func (q *Queries) CrmPaginateNotification(ctx context.Context, arg CrmPaginateNotificationParams) ([]CrmPaginateNotificationRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateNotification, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateNotificationRow
	for rows.Next() {
		var i CrmPaginateNotificationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Message,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Link,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmPaginateNotificationMetadata = `-- name: CrmPaginateNotificationMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "crm"."notifications" as notifications
`

type CrmPaginateNotificationMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type CrmPaginateNotificationMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) CrmPaginateNotificationMetadata(ctx context.Context, arg CrmPaginateNotificationMetadataParams) (CrmPaginateNotificationMetadataRow, error) {
	row := q.db.QueryRow(ctx, crmPaginateNotificationMetadata, arg.PerPage, arg.Page)
	var i CrmPaginateNotificationMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const crmRangeNotification = `-- name: CrmRangeNotification :many
select
  notifications.id, notifications.user_id, notifications.message, notifications.is_read, notifications.created_at, notifications.updated_at, notifications.link,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires
from
  "crm"."notifications" as notifications
  inner join "public"."user" as users on notifications.user_id = users.id
where
  notifications.created_at >= $1::date
  and notifications.created_at <= $2::date
  and (users.name ilike $3::text
    or notifications.message ilike $3::text
    or $3::text is null)
`

type CrmRangeNotificationParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type CrmRangeNotificationRow struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	UserID    string             `db:"user_id" json:"user_id"`
	Message   string             `db:"message" fake:"{sentence}" json:"message"`
	IsRead    pgtype.Bool        `db:"is_read" json:"is_read"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Link      pgtype.Text        `db:"link" fake:"{url}" json:"link"`
	User      User               `db:"user" json:"user"`
}

func (q *Queries) CrmRangeNotification(ctx context.Context, arg CrmRangeNotificationParams) ([]CrmRangeNotificationRow, error) {
	rows, err := q.db.Query(ctx, crmRangeNotification, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeNotificationRow
	for rows.Next() {
		var i CrmRangeNotificationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Message,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Link,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveNotification = `-- name: CrmRemoveNotification :exec
delete from "crm"."notifications"
where id = $1::uuid
`

func (q *Queries) CrmRemoveNotification(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveNotification, id)
	return err
}

const crmUpdateNotification = `-- name: CrmUpdateNotification :one
update
  "crm"."notifications"
set
  updated_at = now(),
  user_id = case when $1 is not null then
    $1::text
  else
    user_id
  end,
  message = case when $2 is not null then
    $2::text
  else
    message
  end,
  is_read = case when $3 is not null then
    $3::boolean
  else
    is_read
  end,
  link = case when $4 is not null then
    $4::varchar
  else
    link
  end
where
  id = $5::uuid
returning
  id, user_id, message, is_read, created_at, updated_at, link
`

type CrmUpdateNotificationParams struct {
	UserID  string      `db:"user_id" json:"user_id"`
	Message string      `db:"message" fake:"{sentence}" json:"message"`
	IsRead  pgtype.Bool `db:"is_read" json:"is_read"`
	Link    pgtype.Text `db:"link" fake:"{url}" json:"link"`
	ID      pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) CrmUpdateNotification(ctx context.Context, arg CrmUpdateNotificationParams) (CrmNotification, error) {
	row := q.db.QueryRow(ctx, crmUpdateNotification,
		arg.UserID,
		arg.Message,
		arg.IsRead,
		arg.Link,
		arg.ID,
	)
	var i CrmNotification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Message,
		&i.IsRead,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Link,
	)
	return i, err
}
