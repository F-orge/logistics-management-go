// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_rate_cards.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyRateCard = `-- name: BillingAnyRateCard :many
select
  rate_cards.id, rate_cards.name, rate_cards.service_type, rate_cards.is_active, rate_cards.valid_from, rate_cards.valid_to, rate_cards.description, rate_cards.created_by_user_id, rate_cards.created_at, rate_cards.updated_at, rate_cards.rate_rules,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."rate_cards_view" as rate_cards
  left join "public"."user" as created_by_user on rate_cards.created_by_user_id = created_by_user.id
where
  rate_cards.id = any ($1::uuid[])
`

type BillingAnyRateCardRow struct {
	ID              pgtype.UUID            `db:"id" json:"id"`
	Name            string                 `db:"name" json:"name"`
	ServiceType     BillingServiceTypeEnum `db:"service_type" json:"service_type"`
	IsActive        pgtype.Bool            `db:"is_active" json:"is_active"`
	ValidFrom       pgtype.Date            `db:"valid_from" json:"valid_from"`
	ValidTo         pgtype.Date            `db:"valid_to" json:"valid_to"`
	Description     pgtype.Text            `db:"description" json:"description"`
	CreatedByUserID pgtype.Text            `db:"created_by_user_id" json:"created_by_user_id"`
	CreatedAt       pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	RateRules       []BillingRateRule      `db:"rate_rules" json:"rate_rules"`
	User            User                   `db:"user" json:"user"`
}

func (q *Queries) BillingAnyRateCard(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyRateCardRow, error) {
	rows, err := q.db.Query(ctx, billingAnyRateCard, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyRateCardRow
	for rows.Next() {
		var i BillingAnyRateCardRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ServiceType,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Description,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RateRules,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindRateCard = `-- name: BillingFindRateCard :one
select
  rate_cards.id, rate_cards.name, rate_cards.service_type, rate_cards.is_active, rate_cards.valid_from, rate_cards.valid_to, rate_cards.description, rate_cards.created_by_user_id, rate_cards.created_at, rate_cards.updated_at, rate_cards.rate_rules,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."rate_cards_view" as rate_cards
  left join "public"."user" as created_by_user on rate_cards.created_by_user_id = created_by_user.id
where
  rate_cards.id = $1::uuid
`

type BillingFindRateCardRow struct {
	ID              pgtype.UUID            `db:"id" json:"id"`
	Name            string                 `db:"name" json:"name"`
	ServiceType     BillingServiceTypeEnum `db:"service_type" json:"service_type"`
	IsActive        pgtype.Bool            `db:"is_active" json:"is_active"`
	ValidFrom       pgtype.Date            `db:"valid_from" json:"valid_from"`
	ValidTo         pgtype.Date            `db:"valid_to" json:"valid_to"`
	Description     pgtype.Text            `db:"description" json:"description"`
	CreatedByUserID pgtype.Text            `db:"created_by_user_id" json:"created_by_user_id"`
	CreatedAt       pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	RateRules       []BillingRateRule      `db:"rate_rules" json:"rate_rules"`
	User            User                   `db:"user" json:"user"`
}

func (q *Queries) BillingFindRateCard(ctx context.Context, id pgtype.UUID) (BillingFindRateCardRow, error) {
	row := q.db.QueryRow(ctx, billingFindRateCard, id)
	var i BillingFindRateCardRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ServiceType,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RateRules,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertRateCard = `-- name: BillingInsertRateCard :one
insert into "billing"."rate_cards"(name, service_type, is_active, valid_from, valid_to, description, created_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, name, service_type, is_active, valid_from, valid_to, description, created_by_user_id, created_at, updated_at
`

type BillingInsertRateCardParams struct {
	Name            string                 `db:"name" json:"name"`
	ServiceType     BillingServiceTypeEnum `db:"service_type" json:"service_type"`
	IsActive        pgtype.Bool            `db:"is_active" json:"is_active"`
	ValidFrom       pgtype.Date            `db:"valid_from" json:"valid_from"`
	ValidTo         pgtype.Date            `db:"valid_to" json:"valid_to"`
	Description     pgtype.Text            `db:"description" json:"description"`
	CreatedByUserID pgtype.Text            `db:"created_by_user_id" json:"created_by_user_id"`
}

func (q *Queries) BillingInsertRateCard(ctx context.Context, arg BillingInsertRateCardParams) (BillingRateCard, error) {
	row := q.db.QueryRow(ctx, billingInsertRateCard,
		arg.Name,
		arg.ServiceType,
		arg.IsActive,
		arg.ValidFrom,
		arg.ValidTo,
		arg.Description,
		arg.CreatedByUserID,
	)
	var i BillingRateCard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ServiceType,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateRateCard = `-- name: BillingPaginateRateCard :many
select
  rate_cards.id, rate_cards.name, rate_cards.service_type, rate_cards.is_active, rate_cards.valid_from, rate_cards.valid_to, rate_cards.description, rate_cards.created_by_user_id, rate_cards.created_at, rate_cards.updated_at, rate_cards.rate_rules,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."rate_cards_view" as rate_cards
  left join "public"."user" as created_by_user on rate_cards.created_by_user_id = created_by_user.id
where (rate_cards.name ilike $1::text
  or rate_cards.service_type::text ilike $1::text
  or created_by_user.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateRateCardParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type BillingPaginateRateCardRow struct {
	ID              pgtype.UUID            `db:"id" json:"id"`
	Name            string                 `db:"name" json:"name"`
	ServiceType     BillingServiceTypeEnum `db:"service_type" json:"service_type"`
	IsActive        pgtype.Bool            `db:"is_active" json:"is_active"`
	ValidFrom       pgtype.Date            `db:"valid_from" json:"valid_from"`
	ValidTo         pgtype.Date            `db:"valid_to" json:"valid_to"`
	Description     pgtype.Text            `db:"description" json:"description"`
	CreatedByUserID pgtype.Text            `db:"created_by_user_id" json:"created_by_user_id"`
	CreatedAt       pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	RateRules       []BillingRateRule      `db:"rate_rules" json:"rate_rules"`
	User            User                   `db:"user" json:"user"`
}

func (q *Queries) BillingPaginateRateCard(ctx context.Context, arg BillingPaginateRateCardParams) ([]BillingPaginateRateCardRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateRateCard, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateRateCardRow
	for rows.Next() {
		var i BillingPaginateRateCardRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ServiceType,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Description,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RateRules,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingPaginateRateCardMetadata = `-- name: BillingPaginateRateCardMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "billing"."rate_cards_view" as rate_cards
`

type BillingPaginateRateCardMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type BillingPaginateRateCardMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) BillingPaginateRateCardMetadata(ctx context.Context, arg BillingPaginateRateCardMetadataParams) (BillingPaginateRateCardMetadataRow, error) {
	row := q.db.QueryRow(ctx, billingPaginateRateCardMetadata, arg.PerPage, arg.Page)
	var i BillingPaginateRateCardMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const billingRangeRateCard = `-- name: BillingRangeRateCard :many
select
  rate_cards.id, rate_cards.name, rate_cards.service_type, rate_cards.is_active, rate_cards.valid_from, rate_cards.valid_to, rate_cards.description, rate_cards.created_by_user_id, rate_cards.created_at, rate_cards.updated_at, rate_cards.rate_rules,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."rate_cards_view" as rate_cards
  left join "public"."user" as created_by_user on rate_cards.created_by_user_id = created_by_user.id
where
  rate_cards.created_at >= $1::date
  and rate_cards.created_at <= $2::date
  and (rate_cards.name ilike $3::text
    or rate_cards.service_type::text ilike $3::text
    or created_by_user.name ilike $3::text
    or $3::text is null)
`

type BillingRangeRateCardParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type BillingRangeRateCardRow struct {
	ID              pgtype.UUID            `db:"id" json:"id"`
	Name            string                 `db:"name" json:"name"`
	ServiceType     BillingServiceTypeEnum `db:"service_type" json:"service_type"`
	IsActive        pgtype.Bool            `db:"is_active" json:"is_active"`
	ValidFrom       pgtype.Date            `db:"valid_from" json:"valid_from"`
	ValidTo         pgtype.Date            `db:"valid_to" json:"valid_to"`
	Description     pgtype.Text            `db:"description" json:"description"`
	CreatedByUserID pgtype.Text            `db:"created_by_user_id" json:"created_by_user_id"`
	CreatedAt       pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	RateRules       []BillingRateRule      `db:"rate_rules" json:"rate_rules"`
	User            User                   `db:"user" json:"user"`
}

func (q *Queries) BillingRangeRateCard(ctx context.Context, arg BillingRangeRateCardParams) ([]BillingRangeRateCardRow, error) {
	rows, err := q.db.Query(ctx, billingRangeRateCard, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeRateCardRow
	for rows.Next() {
		var i BillingRangeRateCardRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ServiceType,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Description,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RateRules,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveRateCard = `-- name: BillingRemoveRateCard :exec
delete from "billing"."rate_cards"
where id = $1::uuid
`

func (q *Queries) BillingRemoveRateCard(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveRateCard, id)
	return err
}

const billingUpdateRateCard = `-- name: BillingUpdateRateCard :one
update
  "billing"."rate_cards"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::varchar
  else
    name
  end,
  service_type = case when $2 is not null then
    $2::billing.service_type_enum
  else
    service_type
  end,
  is_active = case when $3 is not null then
    $3::boolean
  else
    is_active
  end,
  valid_from = case when $4 is not null then
    $4::date
  else
    valid_from
  end,
  valid_to = case when $5 is not null then
    $5::date
  else
    valid_to
  end,
  description = case when $6 is not null then
    $6::text
  else
    description
  end,
  created_by_user_id = case when $7 is not null then
    $7::text
  else
    created_by_user_id
  end
where
  id = $8::uuid
returning
  id, name, service_type, is_active, valid_from, valid_to, description, created_by_user_id, created_at, updated_at
`

type BillingUpdateRateCardParams struct {
	Name            string                 `db:"name" json:"name"`
	ServiceType     BillingServiceTypeEnum `db:"service_type" json:"service_type"`
	IsActive        pgtype.Bool            `db:"is_active" json:"is_active"`
	ValidFrom       pgtype.Date            `db:"valid_from" json:"valid_from"`
	ValidTo         pgtype.Date            `db:"valid_to" json:"valid_to"`
	Description     pgtype.Text            `db:"description" json:"description"`
	CreatedByUserID pgtype.Text            `db:"created_by_user_id" json:"created_by_user_id"`
	ID              pgtype.UUID            `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateRateCard(ctx context.Context, arg BillingUpdateRateCardParams) (BillingRateCard, error) {
	row := q.db.QueryRow(ctx, billingUpdateRateCard,
		arg.Name,
		arg.ServiceType,
		arg.IsActive,
		arg.ValidFrom,
		arg.ValidTo,
		arg.Description,
		arg.CreatedByUserID,
		arg.ID,
	)
	var i BillingRateCard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ServiceType,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
