// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_rate_cards.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyRateCard = `-- name: BillingAnyRateCard :many
select
  rate_cards.id, rate_cards.name, rate_cards.service_type, rate_cards.is_active, rate_cards.valid_from, rate_cards.valid_to, rate_cards.description, rate_cards.created_by_user_id, rate_cards.created_at, rate_cards.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."rate_cards" as rate_cards
  left join "public"."user" as created_by_user on rate_cards.created_by_user_id = created_by_user.id
where
  rate_cards.id = any ($1::uuid[])
`

type BillingAnyRateCardRow struct {
	BillingRateCard BillingRateCard
	User            User
}

func (q *Queries) BillingAnyRateCard(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyRateCardRow, error) {
	rows, err := q.db.Query(ctx, billingAnyRateCard, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyRateCardRow
	for rows.Next() {
		var i BillingAnyRateCardRow
		if err := rows.Scan(
			&i.BillingRateCard.ID,
			&i.BillingRateCard.Name,
			&i.BillingRateCard.ServiceType,
			&i.BillingRateCard.IsActive,
			&i.BillingRateCard.ValidFrom,
			&i.BillingRateCard.ValidTo,
			&i.BillingRateCard.Description,
			&i.BillingRateCard.CreatedByUserID,
			&i.BillingRateCard.CreatedAt,
			&i.BillingRateCard.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindRateCard = `-- name: BillingFindRateCard :one
select
  rate_cards.id, rate_cards.name, rate_cards.service_type, rate_cards.is_active, rate_cards.valid_from, rate_cards.valid_to, rate_cards.description, rate_cards.created_by_user_id, rate_cards.created_at, rate_cards.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."rate_cards" as rate_cards
  left join "public"."user" as created_by_user on rate_cards.created_by_user_id = created_by_user.id
where
  rate_cards.id = $1::uuid
`

type BillingFindRateCardRow struct {
	BillingRateCard BillingRateCard
	User            User
}

func (q *Queries) BillingFindRateCard(ctx context.Context, id pgtype.UUID) (BillingFindRateCardRow, error) {
	row := q.db.QueryRow(ctx, billingFindRateCard, id)
	var i BillingFindRateCardRow
	err := row.Scan(
		&i.BillingRateCard.ID,
		&i.BillingRateCard.Name,
		&i.BillingRateCard.ServiceType,
		&i.BillingRateCard.IsActive,
		&i.BillingRateCard.ValidFrom,
		&i.BillingRateCard.ValidTo,
		&i.BillingRateCard.Description,
		&i.BillingRateCard.CreatedByUserID,
		&i.BillingRateCard.CreatedAt,
		&i.BillingRateCard.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertRateCard = `-- name: BillingInsertRateCard :one
insert into "billing"."rate_cards"(name, service_type, is_active, valid_from, valid_to, description, created_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, name, service_type, is_active, valid_from, valid_to, description, created_by_user_id, created_at, updated_at
`

type BillingInsertRateCardParams struct {
	Name            string
	ServiceType     BillingServiceTypeEnum
	IsActive        pgtype.Bool
	ValidFrom       pgtype.Date
	ValidTo         pgtype.Date
	Description     pgtype.Text
	CreatedByUserID pgtype.Text
}

func (q *Queries) BillingInsertRateCard(ctx context.Context, arg BillingInsertRateCardParams) (BillingRateCard, error) {
	row := q.db.QueryRow(ctx, billingInsertRateCard,
		arg.Name,
		arg.ServiceType,
		arg.IsActive,
		arg.ValidFrom,
		arg.ValidTo,
		arg.Description,
		arg.CreatedByUserID,
	)
	var i BillingRateCard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ServiceType,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateRateCard = `-- name: BillingPaginateRateCard :many
select
  rate_cards.id, rate_cards.name, rate_cards.service_type, rate_cards.is_active, rate_cards.valid_from, rate_cards.valid_to, rate_cards.description, rate_cards.created_by_user_id, rate_cards.created_at, rate_cards.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."rate_cards" as rate_cards
  left join "public"."user" as created_by_user on rate_cards.created_by_user_id = created_by_user.id
where
  (rate_cards.name ilike $1::text
  or rate_cards.service_type::text ilike $1::text
  or created_by_user.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateRateCardParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type BillingPaginateRateCardRow struct {
	BillingRateCard BillingRateCard
	User            User
}

func (q *Queries) BillingPaginateRateCard(ctx context.Context, arg BillingPaginateRateCardParams) ([]BillingPaginateRateCardRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateRateCard, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateRateCardRow
	for rows.Next() {
		var i BillingPaginateRateCardRow
		if err := rows.Scan(
			&i.BillingRateCard.ID,
			&i.BillingRateCard.Name,
			&i.BillingRateCard.ServiceType,
			&i.BillingRateCard.IsActive,
			&i.BillingRateCard.ValidFrom,
			&i.BillingRateCard.ValidTo,
			&i.BillingRateCard.Description,
			&i.BillingRateCard.CreatedByUserID,
			&i.BillingRateCard.CreatedAt,
			&i.BillingRateCard.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeRateCard = `-- name: BillingRangeRateCard :many
select
  rate_cards.id, rate_cards.name, rate_cards.service_type, rate_cards.is_active, rate_cards.valid_from, rate_cards.valid_to, rate_cards.description, rate_cards.created_by_user_id, rate_cards.created_at, rate_cards.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."rate_cards" as rate_cards
  left join "public"."user" as created_by_user on rate_cards.created_by_user_id = created_by_user.id
where
  rate_cards.created_at >= $1::date
  and rate_cards.created_at <= $2::date
  and (rate_cards.name ilike $3::text
  or rate_cards.service_type::text ilike $3::text
  or created_by_user.name ilike $3::text
  or $3::text is null)
`

type BillingRangeRateCardParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type BillingRangeRateCardRow struct {
	BillingRateCard BillingRateCard
	User            User
}

func (q *Queries) BillingRangeRateCard(ctx context.Context, arg BillingRangeRateCardParams) ([]BillingRangeRateCardRow, error) {
	rows, err := q.db.Query(ctx, billingRangeRateCard, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeRateCardRow
	for rows.Next() {
		var i BillingRangeRateCardRow
		if err := rows.Scan(
			&i.BillingRateCard.ID,
			&i.BillingRateCard.Name,
			&i.BillingRateCard.ServiceType,
			&i.BillingRateCard.IsActive,
			&i.BillingRateCard.ValidFrom,
			&i.BillingRateCard.ValidTo,
			&i.BillingRateCard.Description,
			&i.BillingRateCard.CreatedByUserID,
			&i.BillingRateCard.CreatedAt,
			&i.BillingRateCard.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveRateCard = `-- name: BillingRemoveRateCard :exec
delete from "billing"."rate_cards"
where id = $1::uuid
`

func (q *Queries) BillingRemoveRateCard(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveRateCard, id)
	return err
}

const billingUpdateRateCard = `-- name: BillingUpdateRateCard :one
update
  "billing"."rate_cards"
set
  name = case when $1::boolean then
    $2::varchar
  else
    name
  end,
  service_type = case when $3::boolean then
    $4::billing.service_type_enum
  else
    service_type
  end,
  is_active = case when $5::boolean then
    $6::boolean
  else
    is_active
  end,
  valid_from = case when $7::boolean then
    $8::date
  else
    valid_from
  end,
  valid_to = case when $9::boolean then
    $10::date
  else
    valid_to
  end,
  description = case when $11::boolean then
    $12::text
  else
    description
  end,
  created_by_user_id = case when $13::boolean then
    $14::text
  else
    created_by_user_id
  end
where
  id = $15::uuid
returning
  id, name, service_type, is_active, valid_from, valid_to, description, created_by_user_id, created_at, updated_at
`

type BillingUpdateRateCardParams struct {
	SetName            bool
	Name               string
	SetServiceType     bool
	ServiceType        BillingServiceTypeEnum
	SetIsActive        bool
	IsActive           bool
	SetValidFrom       bool
	ValidFrom          pgtype.Date
	SetValidTo         bool
	ValidTo            pgtype.Date
	SetDescription     bool
	Description        string
	SetCreatedByUserID bool
	CreatedByUserID    string
	ID                 pgtype.UUID
}

func (q *Queries) BillingUpdateRateCard(ctx context.Context, arg BillingUpdateRateCardParams) (BillingRateCard, error) {
	row := q.db.QueryRow(ctx, billingUpdateRateCard,
		arg.SetName,
		arg.Name,
		arg.SetServiceType,
		arg.ServiceType,
		arg.SetIsActive,
		arg.IsActive,
		arg.SetValidFrom,
		arg.ValidFrom,
		arg.SetValidTo,
		arg.ValidTo,
		arg.SetDescription,
		arg.Description,
		arg.SetCreatedByUserID,
		arg.CreatedByUserID,
		arg.ID,
	)
	var i BillingRateCard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ServiceType,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
