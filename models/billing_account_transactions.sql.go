// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_account_transactions.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyAccountTransaction = `-- name: BillingAnyAccountTransaction :many
select
  account_transactions.id, account_transactions.client_account_id, account_transactions.type, account_transactions.amount, account_transactions.running_balance, account_transactions.source_record_id, account_transactions.source_record_type, account_transactions.description, account_transactions.reference_number, account_transactions.transaction_date, account_transactions.processed_by_user_id, account_transactions.created_at, account_transactions.updated_at,
  client_account.id, client_account.client_id, client_account.credit_limit, client_account.available_credit, client_account.wallet_balance, client_account.currency, client_account.payment_terms_days, client_account.is_credit_approved, client_account.last_payment_date, client_account.created_at, client_account.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."account_transactions" as account_transactions
  inner join "billing"."client_accounts" as client_account on account_transactions.client_account_id = client_account.id
  left join "public"."user" as processed_by_user on account_transactions.processed_by_user_id = processed_by_user.id
where
  account_transactions.id = any ($1::uuid[])
`

type BillingAnyAccountTransactionRow struct {
	BillingAccountTransaction BillingAccountTransaction
	BillingClientAccount      BillingClientAccount
	User                      User
}

func (q *Queries) BillingAnyAccountTransaction(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyAccountTransactionRow, error) {
	rows, err := q.db.Query(ctx, billingAnyAccountTransaction, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyAccountTransactionRow
	for rows.Next() {
		var i BillingAnyAccountTransactionRow
		if err := rows.Scan(
			&i.BillingAccountTransaction.ID,
			&i.BillingAccountTransaction.ClientAccountID,
			&i.BillingAccountTransaction.Type,
			&i.BillingAccountTransaction.Amount,
			&i.BillingAccountTransaction.RunningBalance,
			&i.BillingAccountTransaction.SourceRecordID,
			&i.BillingAccountTransaction.SourceRecordType,
			&i.BillingAccountTransaction.Description,
			&i.BillingAccountTransaction.ReferenceNumber,
			&i.BillingAccountTransaction.TransactionDate,
			&i.BillingAccountTransaction.ProcessedByUserID,
			&i.BillingAccountTransaction.CreatedAt,
			&i.BillingAccountTransaction.UpdatedAt,
			&i.BillingClientAccount.ID,
			&i.BillingClientAccount.ClientID,
			&i.BillingClientAccount.CreditLimit,
			&i.BillingClientAccount.AvailableCredit,
			&i.BillingClientAccount.WalletBalance,
			&i.BillingClientAccount.Currency,
			&i.BillingClientAccount.PaymentTermsDays,
			&i.BillingClientAccount.IsCreditApproved,
			&i.BillingClientAccount.LastPaymentDate,
			&i.BillingClientAccount.CreatedAt,
			&i.BillingClientAccount.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindAccountTransaction = `-- name: BillingFindAccountTransaction :one
select
  account_transactions.id, account_transactions.client_account_id, account_transactions.type, account_transactions.amount, account_transactions.running_balance, account_transactions.source_record_id, account_transactions.source_record_type, account_transactions.description, account_transactions.reference_number, account_transactions.transaction_date, account_transactions.processed_by_user_id, account_transactions.created_at, account_transactions.updated_at,
  client_account.id, client_account.client_id, client_account.credit_limit, client_account.available_credit, client_account.wallet_balance, client_account.currency, client_account.payment_terms_days, client_account.is_credit_approved, client_account.last_payment_date, client_account.created_at, client_account.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."account_transactions" as account_transactions
  inner join "billing"."client_accounts" as client_account on account_transactions.client_account_id = client_account.id
  left join "public"."user" as processed_by_user on account_transactions.processed_by_user_id = processed_by_user.id
where
  account_transactions.id = $1::uuid
`

type BillingFindAccountTransactionRow struct {
	BillingAccountTransaction BillingAccountTransaction
	BillingClientAccount      BillingClientAccount
	User                      User
}

func (q *Queries) BillingFindAccountTransaction(ctx context.Context, id pgtype.UUID) (BillingFindAccountTransactionRow, error) {
	row := q.db.QueryRow(ctx, billingFindAccountTransaction, id)
	var i BillingFindAccountTransactionRow
	err := row.Scan(
		&i.BillingAccountTransaction.ID,
		&i.BillingAccountTransaction.ClientAccountID,
		&i.BillingAccountTransaction.Type,
		&i.BillingAccountTransaction.Amount,
		&i.BillingAccountTransaction.RunningBalance,
		&i.BillingAccountTransaction.SourceRecordID,
		&i.BillingAccountTransaction.SourceRecordType,
		&i.BillingAccountTransaction.Description,
		&i.BillingAccountTransaction.ReferenceNumber,
		&i.BillingAccountTransaction.TransactionDate,
		&i.BillingAccountTransaction.ProcessedByUserID,
		&i.BillingAccountTransaction.CreatedAt,
		&i.BillingAccountTransaction.UpdatedAt,
		&i.BillingClientAccount.ID,
		&i.BillingClientAccount.ClientID,
		&i.BillingClientAccount.CreditLimit,
		&i.BillingClientAccount.AvailableCredit,
		&i.BillingClientAccount.WalletBalance,
		&i.BillingClientAccount.Currency,
		&i.BillingClientAccount.PaymentTermsDays,
		&i.BillingClientAccount.IsCreditApproved,
		&i.BillingClientAccount.LastPaymentDate,
		&i.BillingClientAccount.CreatedAt,
		&i.BillingClientAccount.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertAccountTransaction = `-- name: BillingInsertAccountTransaction :one
insert into "billing"."account_transactions"(client_account_id, type, amount, running_balance, source_record_id, source_record_type, description, reference_number, transaction_date, processed_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning
  id, client_account_id, type, amount, running_balance, source_record_id, source_record_type, description, reference_number, transaction_date, processed_by_user_id, created_at, updated_at
`

type BillingInsertAccountTransactionParams struct {
	ClientAccountID   pgtype.UUID
	Type              BillingTransactionTypeEnum
	Amount            pgtype.Numeric
	RunningBalance    pgtype.Numeric
	SourceRecordID    pgtype.UUID
	SourceRecordType  pgtype.Text
	Description       pgtype.Text
	ReferenceNumber   pgtype.Text
	TransactionDate   pgtype.Timestamp
	ProcessedByUserID pgtype.Text
}

func (q *Queries) BillingInsertAccountTransaction(ctx context.Context, arg BillingInsertAccountTransactionParams) (BillingAccountTransaction, error) {
	row := q.db.QueryRow(ctx, billingInsertAccountTransaction,
		arg.ClientAccountID,
		arg.Type,
		arg.Amount,
		arg.RunningBalance,
		arg.SourceRecordID,
		arg.SourceRecordType,
		arg.Description,
		arg.ReferenceNumber,
		arg.TransactionDate,
		arg.ProcessedByUserID,
	)
	var i BillingAccountTransaction
	err := row.Scan(
		&i.ID,
		&i.ClientAccountID,
		&i.Type,
		&i.Amount,
		&i.RunningBalance,
		&i.SourceRecordID,
		&i.SourceRecordType,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.ProcessedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateAccountTransaction = `-- name: BillingPaginateAccountTransaction :many
select
  account_transactions.id, account_transactions.client_account_id, account_transactions.type, account_transactions.amount, account_transactions.running_balance, account_transactions.source_record_id, account_transactions.source_record_type, account_transactions.description, account_transactions.reference_number, account_transactions.transaction_date, account_transactions.processed_by_user_id, account_transactions.created_at, account_transactions.updated_at,
  client_account.id, client_account.client_id, client_account.credit_limit, client_account.available_credit, client_account.wallet_balance, client_account.currency, client_account.payment_terms_days, client_account.is_credit_approved, client_account.last_payment_date, client_account.created_at, client_account.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."account_transactions" as account_transactions
  inner join "billing"."client_accounts" as client_account on account_transactions.client_account_id = client_account.id
  inner join "crm"."companies" as client on client_account.client_id = client.id
  left join "public"."user" as processed_by_user on account_transactions.processed_by_user_id = processed_by_user.id
where
  (client.name ilike $1::text
  or processed_by_user.name ilike $1::text
  or account_transactions.type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateAccountTransactionParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type BillingPaginateAccountTransactionRow struct {
	BillingAccountTransaction BillingAccountTransaction
	BillingClientAccount      BillingClientAccount
	User                      User
}

func (q *Queries) BillingPaginateAccountTransaction(ctx context.Context, arg BillingPaginateAccountTransactionParams) ([]BillingPaginateAccountTransactionRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateAccountTransaction, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateAccountTransactionRow
	for rows.Next() {
		var i BillingPaginateAccountTransactionRow
		if err := rows.Scan(
			&i.BillingAccountTransaction.ID,
			&i.BillingAccountTransaction.ClientAccountID,
			&i.BillingAccountTransaction.Type,
			&i.BillingAccountTransaction.Amount,
			&i.BillingAccountTransaction.RunningBalance,
			&i.BillingAccountTransaction.SourceRecordID,
			&i.BillingAccountTransaction.SourceRecordType,
			&i.BillingAccountTransaction.Description,
			&i.BillingAccountTransaction.ReferenceNumber,
			&i.BillingAccountTransaction.TransactionDate,
			&i.BillingAccountTransaction.ProcessedByUserID,
			&i.BillingAccountTransaction.CreatedAt,
			&i.BillingAccountTransaction.UpdatedAt,
			&i.BillingClientAccount.ID,
			&i.BillingClientAccount.ClientID,
			&i.BillingClientAccount.CreditLimit,
			&i.BillingClientAccount.AvailableCredit,
			&i.BillingClientAccount.WalletBalance,
			&i.BillingClientAccount.Currency,
			&i.BillingClientAccount.PaymentTermsDays,
			&i.BillingClientAccount.IsCreditApproved,
			&i.BillingClientAccount.LastPaymentDate,
			&i.BillingClientAccount.CreatedAt,
			&i.BillingClientAccount.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeAccountTransaction = `-- name: BillingRangeAccountTransaction :many
select
  account_transactions.id, account_transactions.client_account_id, account_transactions.type, account_transactions.amount, account_transactions.running_balance, account_transactions.source_record_id, account_transactions.source_record_type, account_transactions.description, account_transactions.reference_number, account_transactions.transaction_date, account_transactions.processed_by_user_id, account_transactions.created_at, account_transactions.updated_at,
  client_account.id, client_account.client_id, client_account.credit_limit, client_account.available_credit, client_account.wallet_balance, client_account.currency, client_account.payment_terms_days, client_account.is_credit_approved, client_account.last_payment_date, client_account.created_at, client_account.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."account_transactions" as account_transactions
  inner join "billing"."client_accounts" as client_account on account_transactions.client_account_id = client_account.id
  left join "public"."user" as processed_by_user on account_transactions.processed_by_user_id = processed_by_user.id
where
  account_transactions.created_at >= $1::date
  and account_transactions.created_at <= $2::date
  and (client.name ilike $3::text
  or processed_by_user.name ilike $3::text
  or account_transactions.type::text ilike $3::text
  or $3::text is null)
`

type BillingRangeAccountTransactionParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type BillingRangeAccountTransactionRow struct {
	BillingAccountTransaction BillingAccountTransaction
	BillingClientAccount      BillingClientAccount
	User                      User
}

func (q *Queries) BillingRangeAccountTransaction(ctx context.Context, arg BillingRangeAccountTransactionParams) ([]BillingRangeAccountTransactionRow, error) {
	rows, err := q.db.Query(ctx, billingRangeAccountTransaction, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeAccountTransactionRow
	for rows.Next() {
		var i BillingRangeAccountTransactionRow
		if err := rows.Scan(
			&i.BillingAccountTransaction.ID,
			&i.BillingAccountTransaction.ClientAccountID,
			&i.BillingAccountTransaction.Type,
			&i.BillingAccountTransaction.Amount,
			&i.BillingAccountTransaction.RunningBalance,
			&i.BillingAccountTransaction.SourceRecordID,
			&i.BillingAccountTransaction.SourceRecordType,
			&i.BillingAccountTransaction.Description,
			&i.BillingAccountTransaction.ReferenceNumber,
			&i.BillingAccountTransaction.TransactionDate,
			&i.BillingAccountTransaction.ProcessedByUserID,
			&i.BillingAccountTransaction.CreatedAt,
			&i.BillingAccountTransaction.UpdatedAt,
			&i.BillingClientAccount.ID,
			&i.BillingClientAccount.ClientID,
			&i.BillingClientAccount.CreditLimit,
			&i.BillingClientAccount.AvailableCredit,
			&i.BillingClientAccount.WalletBalance,
			&i.BillingClientAccount.Currency,
			&i.BillingClientAccount.PaymentTermsDays,
			&i.BillingClientAccount.IsCreditApproved,
			&i.BillingClientAccount.LastPaymentDate,
			&i.BillingClientAccount.CreatedAt,
			&i.BillingClientAccount.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveAccountTransaction = `-- name: BillingRemoveAccountTransaction :exec
delete from "billing"."account_transactions"
where id = $1::uuid
`

func (q *Queries) BillingRemoveAccountTransaction(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveAccountTransaction, id)
	return err
}

const billingUpdateAccountTransaction = `-- name: BillingUpdateAccountTransaction :one
update
  "billing"."account_transactions"
set
  client_account_id = case when $1::boolean then
    $2::uuid
  else
    client_account_id
  end,
  type = case when $3::boolean then
    $4::billing.transaction_type_enum
  else
    type
  end,
  amount = case when $5::boolean then
    $6::numeric
  else
    amount
  end,
  running_balance = case when $7::boolean then
    $8::numeric
  else
    running_balance
  end,
  source_record_id = case when $9::boolean then
    $10::uuid
  else
    source_record_id
  end,
  source_record_type = case when $11::boolean then
    $12::varchar
  else
    source_record_type
  end,
  description = case when $13::boolean then
    $14::text
  else
    description
  end,
  reference_number = case when $15::boolean then
    $16::varchar
  else
    reference_number
  end,
  transaction_date = case when $17::boolean then
    $18::timestamp
  else
    transaction_date
  end,
  processed_by_user_id = case when $19::boolean then
    $20::text
  else
    processed_by_user_id
  end
where
  id = $21::uuid
returning
  id, client_account_id, type, amount, running_balance, source_record_id, source_record_type, description, reference_number, transaction_date, processed_by_user_id, created_at, updated_at
`

type BillingUpdateAccountTransactionParams struct {
	SetClientAccountID   bool
	ClientAccountID      pgtype.UUID
	SetType              bool
	Type                 BillingTransactionTypeEnum
	SetAmount            bool
	Amount               pgtype.Numeric
	SetRunningBalance    bool
	RunningBalance       pgtype.Numeric
	SetSourceRecordID    bool
	SourceRecordID       pgtype.UUID
	SetSourceRecordType  bool
	SourceRecordType     string
	SetDescription       bool
	Description          string
	SetReferenceNumber   bool
	ReferenceNumber      string
	SetTransactionDate   bool
	TransactionDate      pgtype.Timestamp
	SetProcessedByUserID bool
	ProcessedByUserID    string
	ID                   pgtype.UUID
}

func (q *Queries) BillingUpdateAccountTransaction(ctx context.Context, arg BillingUpdateAccountTransactionParams) (BillingAccountTransaction, error) {
	row := q.db.QueryRow(ctx, billingUpdateAccountTransaction,
		arg.SetClientAccountID,
		arg.ClientAccountID,
		arg.SetType,
		arg.Type,
		arg.SetAmount,
		arg.Amount,
		arg.SetRunningBalance,
		arg.RunningBalance,
		arg.SetSourceRecordID,
		arg.SourceRecordID,
		arg.SetSourceRecordType,
		arg.SourceRecordType,
		arg.SetDescription,
		arg.Description,
		arg.SetReferenceNumber,
		arg.ReferenceNumber,
		arg.SetTransactionDate,
		arg.TransactionDate,
		arg.SetProcessedByUserID,
		arg.ProcessedByUserID,
		arg.ID,
	)
	var i BillingAccountTransaction
	err := row.Scan(
		&i.ID,
		&i.ClientAccountID,
		&i.Type,
		&i.Amount,
		&i.RunningBalance,
		&i.SourceRecordID,
		&i.SourceRecordType,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.ProcessedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
