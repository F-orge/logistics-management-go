// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_account_transactions.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyAccountTransaction = `-- name: BillingAnyAccountTransaction :many
select
  account_transactions.id, account_transactions.client_account_id, account_transactions.type, account_transactions.amount, account_transactions.running_balance, account_transactions.source_record_id, account_transactions.source_record_type, account_transactions.description, account_transactions.reference_number, account_transactions.transaction_date, account_transactions.processed_by_user_id, account_transactions.created_at, account_transactions.updated_at,
  client_account.id, client_account.client_id, client_account.credit_limit, client_account.available_credit, client_account.wallet_balance, client_account.currency, client_account.payment_terms_days, client_account.is_credit_approved, client_account.last_payment_date, client_account.created_at, client_account.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."account_transactions" as account_transactions
  inner join "billing"."client_accounts" as client_account on account_transactions.client_account_id = client_account.id
  left join "public"."user" as processed_by_user on account_transactions.processed_by_user_id = processed_by_user.id
where
  account_transactions.id = any ($1::uuid[])
`

type BillingAnyAccountTransactionRow struct {
	ID                   pgtype.UUID                `db:"id" json:"id"`
	ClientAccountID      pgtype.UUID                `db:"client_account_id" json:"client_account_id"`
	Type                 BillingTransactionTypeEnum `db:"type" json:"type"`
	Amount               pgtype.Numeric             `db:"amount" fake:"{price:-1000,1000}" json:"amount"`
	RunningBalance       pgtype.Numeric             `db:"running_balance" fake:"{price:0,20000}" json:"running_balance"`
	SourceRecordID       pgtype.UUID                `db:"source_record_id" json:"source_record_id"`
	SourceRecordType     pgtype.Text                `db:"source_record_type" fake:"{randomstring:[invoice,payment]}" json:"source_record_type"`
	Description          pgtype.Text                `db:"description" fake:"{sentence}" json:"description"`
	ReferenceNumber      pgtype.Text                `db:"reference_number" fake:"{uuid}" json:"reference_number"`
	TransactionDate      pgtype.Timestamp           `db:"transaction_date" fake:"{date}" json:"transaction_date"`
	ProcessedByUserID    pgtype.Text                `db:"processed_by_user_id" json:"processed_by_user_id"`
	CreatedAt            pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	BillingClientAccount BillingClientAccount       `db:"billing_client_account" json:"billing_client_account"`
	User                 User                       `db:"user" json:"user"`
}

func (q *Queries) BillingAnyAccountTransaction(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyAccountTransactionRow, error) {
	rows, err := q.db.Query(ctx, billingAnyAccountTransaction, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyAccountTransactionRow
	for rows.Next() {
		var i BillingAnyAccountTransactionRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientAccountID,
			&i.Type,
			&i.Amount,
			&i.RunningBalance,
			&i.SourceRecordID,
			&i.SourceRecordType,
			&i.Description,
			&i.ReferenceNumber,
			&i.TransactionDate,
			&i.ProcessedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BillingClientAccount.ID,
			&i.BillingClientAccount.ClientID,
			&i.BillingClientAccount.CreditLimit,
			&i.BillingClientAccount.AvailableCredit,
			&i.BillingClientAccount.WalletBalance,
			&i.BillingClientAccount.Currency,
			&i.BillingClientAccount.PaymentTermsDays,
			&i.BillingClientAccount.IsCreditApproved,
			&i.BillingClientAccount.LastPaymentDate,
			&i.BillingClientAccount.CreatedAt,
			&i.BillingClientAccount.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindAccountTransaction = `-- name: BillingFindAccountTransaction :one
select
  account_transactions.id, account_transactions.client_account_id, account_transactions.type, account_transactions.amount, account_transactions.running_balance, account_transactions.source_record_id, account_transactions.source_record_type, account_transactions.description, account_transactions.reference_number, account_transactions.transaction_date, account_transactions.processed_by_user_id, account_transactions.created_at, account_transactions.updated_at,
  client_account.id, client_account.client_id, client_account.credit_limit, client_account.available_credit, client_account.wallet_balance, client_account.currency, client_account.payment_terms_days, client_account.is_credit_approved, client_account.last_payment_date, client_account.created_at, client_account.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."account_transactions" as account_transactions
  inner join "billing"."client_accounts" as client_account on account_transactions.client_account_id = client_account.id
  left join "public"."user" as processed_by_user on account_transactions.processed_by_user_id = processed_by_user.id
where
  account_transactions.id = $1::uuid
`

type BillingFindAccountTransactionRow struct {
	ID                   pgtype.UUID                `db:"id" json:"id"`
	ClientAccountID      pgtype.UUID                `db:"client_account_id" json:"client_account_id"`
	Type                 BillingTransactionTypeEnum `db:"type" json:"type"`
	Amount               pgtype.Numeric             `db:"amount" fake:"{price:-1000,1000}" json:"amount"`
	RunningBalance       pgtype.Numeric             `db:"running_balance" fake:"{price:0,20000}" json:"running_balance"`
	SourceRecordID       pgtype.UUID                `db:"source_record_id" json:"source_record_id"`
	SourceRecordType     pgtype.Text                `db:"source_record_type" fake:"{randomstring:[invoice,payment]}" json:"source_record_type"`
	Description          pgtype.Text                `db:"description" fake:"{sentence}" json:"description"`
	ReferenceNumber      pgtype.Text                `db:"reference_number" fake:"{uuid}" json:"reference_number"`
	TransactionDate      pgtype.Timestamp           `db:"transaction_date" fake:"{date}" json:"transaction_date"`
	ProcessedByUserID    pgtype.Text                `db:"processed_by_user_id" json:"processed_by_user_id"`
	CreatedAt            pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	BillingClientAccount BillingClientAccount       `db:"billing_client_account" json:"billing_client_account"`
	User                 User                       `db:"user" json:"user"`
}

func (q *Queries) BillingFindAccountTransaction(ctx context.Context, id pgtype.UUID) (BillingFindAccountTransactionRow, error) {
	row := q.db.QueryRow(ctx, billingFindAccountTransaction, id)
	var i BillingFindAccountTransactionRow
	err := row.Scan(
		&i.ID,
		&i.ClientAccountID,
		&i.Type,
		&i.Amount,
		&i.RunningBalance,
		&i.SourceRecordID,
		&i.SourceRecordType,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.ProcessedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BillingClientAccount.ID,
		&i.BillingClientAccount.ClientID,
		&i.BillingClientAccount.CreditLimit,
		&i.BillingClientAccount.AvailableCredit,
		&i.BillingClientAccount.WalletBalance,
		&i.BillingClientAccount.Currency,
		&i.BillingClientAccount.PaymentTermsDays,
		&i.BillingClientAccount.IsCreditApproved,
		&i.BillingClientAccount.LastPaymentDate,
		&i.BillingClientAccount.CreatedAt,
		&i.BillingClientAccount.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertAccountTransaction = `-- name: BillingInsertAccountTransaction :one
insert into "billing"."account_transactions"(client_account_id, type, amount, running_balance, source_record_id, source_record_type, description, reference_number, transaction_date, processed_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning
  id, client_account_id, type, amount, running_balance, source_record_id, source_record_type, description, reference_number, transaction_date, processed_by_user_id, created_at, updated_at
`

type BillingInsertAccountTransactionParams struct {
	ClientAccountID   pgtype.UUID                `db:"client_account_id" json:"client_account_id"`
	Type              BillingTransactionTypeEnum `db:"type" json:"type"`
	Amount            pgtype.Numeric             `db:"amount" fake:"{price:-1000,1000}" json:"amount"`
	RunningBalance    pgtype.Numeric             `db:"running_balance" fake:"{price:0,20000}" json:"running_balance"`
	SourceRecordID    pgtype.UUID                `db:"source_record_id" json:"source_record_id"`
	SourceRecordType  pgtype.Text                `db:"source_record_type" fake:"{randomstring:[invoice,payment]}" json:"source_record_type"`
	Description       pgtype.Text                `db:"description" fake:"{sentence}" json:"description"`
	ReferenceNumber   pgtype.Text                `db:"reference_number" fake:"{uuid}" json:"reference_number"`
	TransactionDate   pgtype.Timestamp           `db:"transaction_date" fake:"{date}" json:"transaction_date"`
	ProcessedByUserID pgtype.Text                `db:"processed_by_user_id" json:"processed_by_user_id"`
}

func (q *Queries) BillingInsertAccountTransaction(ctx context.Context, arg BillingInsertAccountTransactionParams) (BillingAccountTransaction, error) {
	row := q.db.QueryRow(ctx, billingInsertAccountTransaction,
		arg.ClientAccountID,
		arg.Type,
		arg.Amount,
		arg.RunningBalance,
		arg.SourceRecordID,
		arg.SourceRecordType,
		arg.Description,
		arg.ReferenceNumber,
		arg.TransactionDate,
		arg.ProcessedByUserID,
	)
	var i BillingAccountTransaction
	err := row.Scan(
		&i.ID,
		&i.ClientAccountID,
		&i.Type,
		&i.Amount,
		&i.RunningBalance,
		&i.SourceRecordID,
		&i.SourceRecordType,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.ProcessedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateAccountTransaction = `-- name: BillingPaginateAccountTransaction :many
select
  account_transactions.id, account_transactions.client_account_id, account_transactions.type, account_transactions.amount, account_transactions.running_balance, account_transactions.source_record_id, account_transactions.source_record_type, account_transactions.description, account_transactions.reference_number, account_transactions.transaction_date, account_transactions.processed_by_user_id, account_transactions.created_at, account_transactions.updated_at,
  client_account.id, client_account.client_id, client_account.credit_limit, client_account.available_credit, client_account.wallet_balance, client_account.currency, client_account.payment_terms_days, client_account.is_credit_approved, client_account.last_payment_date, client_account.created_at, client_account.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."account_transactions" as account_transactions
  inner join "billing"."client_accounts" as client_account on account_transactions.client_account_id = client_account.id
  inner join "crm"."companies" as client on client_account.client_id = client.id
  left join "public"."user" as processed_by_user on account_transactions.processed_by_user_id = processed_by_user.id
where (client.name ilike $1::text
  or processed_by_user.name ilike $1::text
  or account_transactions.type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateAccountTransactionParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type BillingPaginateAccountTransactionRow struct {
	ID                   pgtype.UUID                `db:"id" json:"id"`
	ClientAccountID      pgtype.UUID                `db:"client_account_id" json:"client_account_id"`
	Type                 BillingTransactionTypeEnum `db:"type" json:"type"`
	Amount               pgtype.Numeric             `db:"amount" fake:"{price:-1000,1000}" json:"amount"`
	RunningBalance       pgtype.Numeric             `db:"running_balance" fake:"{price:0,20000}" json:"running_balance"`
	SourceRecordID       pgtype.UUID                `db:"source_record_id" json:"source_record_id"`
	SourceRecordType     pgtype.Text                `db:"source_record_type" fake:"{randomstring:[invoice,payment]}" json:"source_record_type"`
	Description          pgtype.Text                `db:"description" fake:"{sentence}" json:"description"`
	ReferenceNumber      pgtype.Text                `db:"reference_number" fake:"{uuid}" json:"reference_number"`
	TransactionDate      pgtype.Timestamp           `db:"transaction_date" fake:"{date}" json:"transaction_date"`
	ProcessedByUserID    pgtype.Text                `db:"processed_by_user_id" json:"processed_by_user_id"`
	CreatedAt            pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	BillingClientAccount BillingClientAccount       `db:"billing_client_account" json:"billing_client_account"`
	User                 User                       `db:"user" json:"user"`
}

func (q *Queries) BillingPaginateAccountTransaction(ctx context.Context, arg BillingPaginateAccountTransactionParams) ([]BillingPaginateAccountTransactionRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateAccountTransaction, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateAccountTransactionRow
	for rows.Next() {
		var i BillingPaginateAccountTransactionRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientAccountID,
			&i.Type,
			&i.Amount,
			&i.RunningBalance,
			&i.SourceRecordID,
			&i.SourceRecordType,
			&i.Description,
			&i.ReferenceNumber,
			&i.TransactionDate,
			&i.ProcessedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BillingClientAccount.ID,
			&i.BillingClientAccount.ClientID,
			&i.BillingClientAccount.CreditLimit,
			&i.BillingClientAccount.AvailableCredit,
			&i.BillingClientAccount.WalletBalance,
			&i.BillingClientAccount.Currency,
			&i.BillingClientAccount.PaymentTermsDays,
			&i.BillingClientAccount.IsCreditApproved,
			&i.BillingClientAccount.LastPaymentDate,
			&i.BillingClientAccount.CreatedAt,
			&i.BillingClientAccount.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingPaginateAccountTransactionMetadata = `-- name: BillingPaginateAccountTransactionMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "billing"."account_transactions" as account_transactions
`

type BillingPaginateAccountTransactionMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type BillingPaginateAccountTransactionMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) BillingPaginateAccountTransactionMetadata(ctx context.Context, arg BillingPaginateAccountTransactionMetadataParams) (BillingPaginateAccountTransactionMetadataRow, error) {
	row := q.db.QueryRow(ctx, billingPaginateAccountTransactionMetadata, arg.PerPage, arg.Page)
	var i BillingPaginateAccountTransactionMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const billingRangeAccountTransaction = `-- name: BillingRangeAccountTransaction :many
select
  account_transactions.id, account_transactions.client_account_id, account_transactions.type, account_transactions.amount, account_transactions.running_balance, account_transactions.source_record_id, account_transactions.source_record_type, account_transactions.description, account_transactions.reference_number, account_transactions.transaction_date, account_transactions.processed_by_user_id, account_transactions.created_at, account_transactions.updated_at,
  client_account.id, client_account.client_id, client_account.credit_limit, client_account.available_credit, client_account.wallet_balance, client_account.currency, client_account.payment_terms_days, client_account.is_credit_approved, client_account.last_payment_date, client_account.created_at, client_account.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."account_transactions" as account_transactions
  inner join "billing"."client_accounts" as client_account on account_transactions.client_account_id = client_account.id
  left join "public"."user" as processed_by_user on account_transactions.processed_by_user_id = processed_by_user.id
where
  account_transactions.created_at >= $1::date
  and account_transactions.created_at <= $2::date
  and (client.name ilike $3::text
    or processed_by_user.name ilike $3::text
    or account_transactions.type::text ilike $3::text
    or $3::text is null)
`

type BillingRangeAccountTransactionParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type BillingRangeAccountTransactionRow struct {
	ID                   pgtype.UUID                `db:"id" json:"id"`
	ClientAccountID      pgtype.UUID                `db:"client_account_id" json:"client_account_id"`
	Type                 BillingTransactionTypeEnum `db:"type" json:"type"`
	Amount               pgtype.Numeric             `db:"amount" fake:"{price:-1000,1000}" json:"amount"`
	RunningBalance       pgtype.Numeric             `db:"running_balance" fake:"{price:0,20000}" json:"running_balance"`
	SourceRecordID       pgtype.UUID                `db:"source_record_id" json:"source_record_id"`
	SourceRecordType     pgtype.Text                `db:"source_record_type" fake:"{randomstring:[invoice,payment]}" json:"source_record_type"`
	Description          pgtype.Text                `db:"description" fake:"{sentence}" json:"description"`
	ReferenceNumber      pgtype.Text                `db:"reference_number" fake:"{uuid}" json:"reference_number"`
	TransactionDate      pgtype.Timestamp           `db:"transaction_date" fake:"{date}" json:"transaction_date"`
	ProcessedByUserID    pgtype.Text                `db:"processed_by_user_id" json:"processed_by_user_id"`
	CreatedAt            pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	BillingClientAccount BillingClientAccount       `db:"billing_client_account" json:"billing_client_account"`
	User                 User                       `db:"user" json:"user"`
}

func (q *Queries) BillingRangeAccountTransaction(ctx context.Context, arg BillingRangeAccountTransactionParams) ([]BillingRangeAccountTransactionRow, error) {
	rows, err := q.db.Query(ctx, billingRangeAccountTransaction, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeAccountTransactionRow
	for rows.Next() {
		var i BillingRangeAccountTransactionRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientAccountID,
			&i.Type,
			&i.Amount,
			&i.RunningBalance,
			&i.SourceRecordID,
			&i.SourceRecordType,
			&i.Description,
			&i.ReferenceNumber,
			&i.TransactionDate,
			&i.ProcessedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BillingClientAccount.ID,
			&i.BillingClientAccount.ClientID,
			&i.BillingClientAccount.CreditLimit,
			&i.BillingClientAccount.AvailableCredit,
			&i.BillingClientAccount.WalletBalance,
			&i.BillingClientAccount.Currency,
			&i.BillingClientAccount.PaymentTermsDays,
			&i.BillingClientAccount.IsCreditApproved,
			&i.BillingClientAccount.LastPaymentDate,
			&i.BillingClientAccount.CreatedAt,
			&i.BillingClientAccount.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveAccountTransaction = `-- name: BillingRemoveAccountTransaction :exec
delete from "billing"."account_transactions"
where id = $1::uuid
`

func (q *Queries) BillingRemoveAccountTransaction(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveAccountTransaction, id)
	return err
}

const billingUpdateAccountTransaction = `-- name: BillingUpdateAccountTransaction :one
update
  "billing"."account_transactions"
set
  updated_at = now(),
  client_account_id = case when $1 is not null then
    $1::uuid
  else
    client_account_id
  end,
  type = case when $2 is not null then
    $2::billing.transaction_type_enum
  else
    type
  end,
  amount = case when $3 is not null then
    $3::numeric
  else
    amount
  end,
  running_balance = case when $4 is not null then
    $4::numeric
  else
    running_balance
  end,
  source_record_id = case when $5 is not null then
    $5::uuid
  else
    source_record_id
  end,
  source_record_type = case when $6 is not null then
    $6::varchar
  else
    source_record_type
  end,
  description = case when $7 is not null then
    $7::text
  else
    description
  end,
  reference_number = case when $8 is not null then
    $8::varchar
  else
    reference_number
  end,
  transaction_date = case when $9 is not null then
    $9::timestamp
  else
    transaction_date
  end,
  processed_by_user_id = case when $10 is not null then
    $10::text
  else
    processed_by_user_id
  end
where
  id = $11::uuid
returning
  id, client_account_id, type, amount, running_balance, source_record_id, source_record_type, description, reference_number, transaction_date, processed_by_user_id, created_at, updated_at
`

type BillingUpdateAccountTransactionParams struct {
	ClientAccountID   pgtype.UUID                `db:"client_account_id" json:"client_account_id"`
	Type              BillingTransactionTypeEnum `db:"type" json:"type"`
	Amount            pgtype.Numeric             `db:"amount" fake:"{price:-1000,1000}" json:"amount"`
	RunningBalance    pgtype.Numeric             `db:"running_balance" fake:"{price:0,20000}" json:"running_balance"`
	SourceRecordID    pgtype.UUID                `db:"source_record_id" json:"source_record_id"`
	SourceRecordType  pgtype.Text                `db:"source_record_type" fake:"{randomstring:[invoice,payment]}" json:"source_record_type"`
	Description       pgtype.Text                `db:"description" fake:"{sentence}" json:"description"`
	ReferenceNumber   pgtype.Text                `db:"reference_number" fake:"{uuid}" json:"reference_number"`
	TransactionDate   pgtype.Timestamp           `db:"transaction_date" fake:"{date}" json:"transaction_date"`
	ProcessedByUserID pgtype.Text                `db:"processed_by_user_id" json:"processed_by_user_id"`
	ID                pgtype.UUID                `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateAccountTransaction(ctx context.Context, arg BillingUpdateAccountTransactionParams) (BillingAccountTransaction, error) {
	row := q.db.QueryRow(ctx, billingUpdateAccountTransaction,
		arg.ClientAccountID,
		arg.Type,
		arg.Amount,
		arg.RunningBalance,
		arg.SourceRecordID,
		arg.SourceRecordType,
		arg.Description,
		arg.ReferenceNumber,
		arg.TransactionDate,
		arg.ProcessedByUserID,
		arg.ID,
	)
	var i BillingAccountTransaction
	err := row.Scan(
		&i.ID,
		&i.ClientAccountID,
		&i.Type,
		&i.Amount,
		&i.RunningBalance,
		&i.SourceRecordID,
		&i.SourceRecordType,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.ProcessedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
