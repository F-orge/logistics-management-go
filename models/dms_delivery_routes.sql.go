// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dms_delivery_routes.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dmsAnyDeliveryRoute = `-- name: DmsAnyDeliveryRoute :many
select
  delivery_routes.id, delivery_routes.driver_id, delivery_routes.route_date, delivery_routes.status, delivery_routes.optimized_route_data, delivery_routes.total_distance_km, delivery_routes.estimated_duration_minutes, delivery_routes.actual_duration_minutes, delivery_routes.started_at, delivery_routes.completed_at, delivery_routes.created_at, delivery_routes.updated_at, delivery_routes.delivery_tasks,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."delivery_routes_view" as delivery_routes
  inner join "tms"."drivers" as driver on delivery_routes.driver_id = driver.id
where
  delivery_routes.id = any ($1::uuid[])
`

type DmsAnyDeliveryRouteRow struct {
	DmsDeliveryRoutesView DmsDeliveryRoutesView
	TmsDriver             TmsDriver
}

func (q *Queries) DmsAnyDeliveryRoute(ctx context.Context, ids []pgtype.UUID) ([]DmsAnyDeliveryRouteRow, error) {
	rows, err := q.db.Query(ctx, dmsAnyDeliveryRoute, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsAnyDeliveryRouteRow
	for rows.Next() {
		var i DmsAnyDeliveryRouteRow
		if err := rows.Scan(
			&i.DmsDeliveryRoutesView.ID,
			&i.DmsDeliveryRoutesView.DriverID,
			&i.DmsDeliveryRoutesView.RouteDate,
			&i.DmsDeliveryRoutesView.Status,
			&i.DmsDeliveryRoutesView.OptimizedRouteData,
			&i.DmsDeliveryRoutesView.TotalDistanceKm,
			&i.DmsDeliveryRoutesView.EstimatedDurationMinutes,
			&i.DmsDeliveryRoutesView.ActualDurationMinutes,
			&i.DmsDeliveryRoutesView.StartedAt,
			&i.DmsDeliveryRoutesView.CompletedAt,
			&i.DmsDeliveryRoutesView.CreatedAt,
			&i.DmsDeliveryRoutesView.UpdatedAt,
			&i.DmsDeliveryRoutesView.DeliveryTasks,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsFindDeliveryRoute = `-- name: DmsFindDeliveryRoute :one
select
  delivery_routes.id, delivery_routes.driver_id, delivery_routes.route_date, delivery_routes.status, delivery_routes.optimized_route_data, delivery_routes.total_distance_km, delivery_routes.estimated_duration_minutes, delivery_routes.actual_duration_minutes, delivery_routes.started_at, delivery_routes.completed_at, delivery_routes.created_at, delivery_routes.updated_at, delivery_routes.delivery_tasks,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."delivery_routes_view" as delivery_routes
  inner join "tms"."drivers" as driver on delivery_routes.driver_id = driver.id
where
  delivery_routes.id = $1::uuid
`

type DmsFindDeliveryRouteRow struct {
	DmsDeliveryRoutesView DmsDeliveryRoutesView
	TmsDriver             TmsDriver
}

func (q *Queries) DmsFindDeliveryRoute(ctx context.Context, id pgtype.UUID) (DmsFindDeliveryRouteRow, error) {
	row := q.db.QueryRow(ctx, dmsFindDeliveryRoute, id)
	var i DmsFindDeliveryRouteRow
	err := row.Scan(
		&i.DmsDeliveryRoutesView.ID,
		&i.DmsDeliveryRoutesView.DriverID,
		&i.DmsDeliveryRoutesView.RouteDate,
		&i.DmsDeliveryRoutesView.Status,
		&i.DmsDeliveryRoutesView.OptimizedRouteData,
		&i.DmsDeliveryRoutesView.TotalDistanceKm,
		&i.DmsDeliveryRoutesView.EstimatedDurationMinutes,
		&i.DmsDeliveryRoutesView.ActualDurationMinutes,
		&i.DmsDeliveryRoutesView.StartedAt,
		&i.DmsDeliveryRoutesView.CompletedAt,
		&i.DmsDeliveryRoutesView.CreatedAt,
		&i.DmsDeliveryRoutesView.UpdatedAt,
		&i.DmsDeliveryRoutesView.DeliveryTasks,
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
	)
	return i, err
}

const dmsInsertDeliveryRoute = `-- name: DmsInsertDeliveryRoute :one
insert into "dms"."delivery_routes"(driver_id, route_date, status, optimized_route_data, total_distance_km, estimated_duration_minutes, started_at, completed_at)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, driver_id, route_date, status, optimized_route_data, total_distance_km, estimated_duration_minutes, actual_duration_minutes, started_at, completed_at, created_at, updated_at
`

type DmsInsertDeliveryRouteParams struct {
	DriverID                 pgtype.UUID
	RouteDate                pgtype.Date
	Status                   NullDmsDeliveryRouteStatusEnum
	OptimizedRouteData       pgtype.Text
	TotalDistanceKm          pgtype.Float4
	EstimatedDurationMinutes pgtype.Int4
	StartedAt                pgtype.Timestamp
	CompletedAt              pgtype.Timestamp
}

func (q *Queries) DmsInsertDeliveryRoute(ctx context.Context, arg DmsInsertDeliveryRouteParams) (DmsDeliveryRoute, error) {
	row := q.db.QueryRow(ctx, dmsInsertDeliveryRoute,
		arg.DriverID,
		arg.RouteDate,
		arg.Status,
		arg.OptimizedRouteData,
		arg.TotalDistanceKm,
		arg.EstimatedDurationMinutes,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i DmsDeliveryRoute
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.RouteDate,
		&i.Status,
		&i.OptimizedRouteData,
		&i.TotalDistanceKm,
		&i.EstimatedDurationMinutes,
		&i.ActualDurationMinutes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dmsPaginateDeliveryRoute = `-- name: DmsPaginateDeliveryRoute :many
select
  delivery_routes.id, delivery_routes.driver_id, delivery_routes.route_date, delivery_routes.status, delivery_routes.optimized_route_data, delivery_routes.total_distance_km, delivery_routes.estimated_duration_minutes, delivery_routes.actual_duration_minutes, delivery_routes.started_at, delivery_routes.completed_at, delivery_routes.created_at, delivery_routes.updated_at, delivery_routes.delivery_tasks,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."delivery_routes_view" as delivery_routes
  inner join "tms"."drivers" as driver on delivery_routes.driver_id = driver.id
where (driver.name ilike $1::text
  or delivery_routes.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type DmsPaginateDeliveryRouteParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type DmsPaginateDeliveryRouteRow struct {
	DmsDeliveryRoutesView DmsDeliveryRoutesView
	TmsDriver             TmsDriver
}

func (q *Queries) DmsPaginateDeliveryRoute(ctx context.Context, arg DmsPaginateDeliveryRouteParams) ([]DmsPaginateDeliveryRouteRow, error) {
	rows, err := q.db.Query(ctx, dmsPaginateDeliveryRoute, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsPaginateDeliveryRouteRow
	for rows.Next() {
		var i DmsPaginateDeliveryRouteRow
		if err := rows.Scan(
			&i.DmsDeliveryRoutesView.ID,
			&i.DmsDeliveryRoutesView.DriverID,
			&i.DmsDeliveryRoutesView.RouteDate,
			&i.DmsDeliveryRoutesView.Status,
			&i.DmsDeliveryRoutesView.OptimizedRouteData,
			&i.DmsDeliveryRoutesView.TotalDistanceKm,
			&i.DmsDeliveryRoutesView.EstimatedDurationMinutes,
			&i.DmsDeliveryRoutesView.ActualDurationMinutes,
			&i.DmsDeliveryRoutesView.StartedAt,
			&i.DmsDeliveryRoutesView.CompletedAt,
			&i.DmsDeliveryRoutesView.CreatedAt,
			&i.DmsDeliveryRoutesView.UpdatedAt,
			&i.DmsDeliveryRoutesView.DeliveryTasks,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRangeDeliveryRoute = `-- name: DmsRangeDeliveryRoute :many
select
  delivery_routes.id, delivery_routes.driver_id, delivery_routes.route_date, delivery_routes.status, delivery_routes.optimized_route_data, delivery_routes.total_distance_km, delivery_routes.estimated_duration_minutes, delivery_routes.actual_duration_minutes, delivery_routes.started_at, delivery_routes.completed_at, delivery_routes.created_at, delivery_routes.updated_at, delivery_routes.delivery_tasks,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."delivery_routes_view" as delivery_routes
  inner join "tms"."drivers" as driver on delivery_routes.driver_id = driver.id
where
  delivery_routes.created_at >= $1::date
  and delivery_routes.created_at <= $2::date
  and (driver.name ilike $3::text
    or delivery_routes.status::text ilike $3::text
    or $3::text is null)
`

type DmsRangeDeliveryRouteParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type DmsRangeDeliveryRouteRow struct {
	DmsDeliveryRoutesView DmsDeliveryRoutesView
	TmsDriver             TmsDriver
}

func (q *Queries) DmsRangeDeliveryRoute(ctx context.Context, arg DmsRangeDeliveryRouteParams) ([]DmsRangeDeliveryRouteRow, error) {
	rows, err := q.db.Query(ctx, dmsRangeDeliveryRoute, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsRangeDeliveryRouteRow
	for rows.Next() {
		var i DmsRangeDeliveryRouteRow
		if err := rows.Scan(
			&i.DmsDeliveryRoutesView.ID,
			&i.DmsDeliveryRoutesView.DriverID,
			&i.DmsDeliveryRoutesView.RouteDate,
			&i.DmsDeliveryRoutesView.Status,
			&i.DmsDeliveryRoutesView.OptimizedRouteData,
			&i.DmsDeliveryRoutesView.TotalDistanceKm,
			&i.DmsDeliveryRoutesView.EstimatedDurationMinutes,
			&i.DmsDeliveryRoutesView.ActualDurationMinutes,
			&i.DmsDeliveryRoutesView.StartedAt,
			&i.DmsDeliveryRoutesView.CompletedAt,
			&i.DmsDeliveryRoutesView.CreatedAt,
			&i.DmsDeliveryRoutesView.UpdatedAt,
			&i.DmsDeliveryRoutesView.DeliveryTasks,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRemoveDeliveryRoute = `-- name: DmsRemoveDeliveryRoute :exec
delete from "dms"."delivery_routes"
where id = $1::uuid
`

func (q *Queries) DmsRemoveDeliveryRoute(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, dmsRemoveDeliveryRoute, id)
	return err
}

const dmsUpdateDeliveryRoute = `-- name: DmsUpdateDeliveryRoute :one
update
  "dms"."delivery_routes"
set
  updated_at = now(),
  driver_id = case when $1 is not null then
    $1::uuid
  else
    driver_id
  end,
  route_date = case when $2 is not null then
    $2::date
  else
    route_date
  end,
  status = case when $3 is not null then
    $3::dms.delivery_route_status_enum
  else
    status
  end,
  optimized_route_data = case when $4 is not null then
    $4::text
  else
    optimized_route_data
  end,
  total_distance_km = case when $5 is not null then
    $5::real
  else
    total_distance_km
  end,
  estimated_duration_minutes = case when $6 is not null then
    $6::integer
  else
    estimated_duration_minutes
  end,
  started_at = case when $7 is not null then
    $7::timestamp
  else
    started_at
  end,
  completed_at = case when $8 is not null then
    $8::timestamp
  else
    completed_at
  end
where
  id = $9::uuid
returning
  id, driver_id, route_date, status, optimized_route_data, total_distance_km, estimated_duration_minutes, actual_duration_minutes, started_at, completed_at, created_at, updated_at
`

type DmsUpdateDeliveryRouteParams struct {
	DriverID                 pgtype.UUID
	RouteDate                pgtype.Date
	Status                   NullDmsDeliveryRouteStatusEnum
	OptimizedRouteData       pgtype.Text
	TotalDistanceKm          pgtype.Float4
	EstimatedDurationMinutes pgtype.Int4
	StartedAt                pgtype.Timestamp
	CompletedAt              pgtype.Timestamp
	ID                       pgtype.UUID
}

func (q *Queries) DmsUpdateDeliveryRoute(ctx context.Context, arg DmsUpdateDeliveryRouteParams) (DmsDeliveryRoute, error) {
	row := q.db.QueryRow(ctx, dmsUpdateDeliveryRoute,
		arg.DriverID,
		arg.RouteDate,
		arg.Status,
		arg.OptimizedRouteData,
		arg.TotalDistanceKm,
		arg.EstimatedDurationMinutes,
		arg.StartedAt,
		arg.CompletedAt,
		arg.ID,
	)
	var i DmsDeliveryRoute
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.RouteDate,
		&i.Status,
		&i.OptimizedRouteData,
		&i.TotalDistanceKm,
		&i.EstimatedDurationMinutes,
		&i.ActualDurationMinutes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
