// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dms_delivery_routes.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dmsAnyDeliveryRoute = `-- name: DmsAnyDeliveryRoute :many
select
  delivery_routes.id, delivery_routes.driver_id, delivery_routes.route_date, delivery_routes.status, delivery_routes.optimized_route_data, delivery_routes.total_distance_km, delivery_routes.estimated_duration_minutes, delivery_routes.actual_duration_minutes, delivery_routes.started_at, delivery_routes.completed_at, delivery_routes.created_at, delivery_routes.updated_at, delivery_routes.delivery_tasks,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."delivery_routes_view" as delivery_routes
  inner join "tms"."drivers" as driver on delivery_routes.driver_id = driver.id
where
  delivery_routes.id = any ($1::uuid[])
`

type DmsAnyDeliveryRouteRow struct {
	ID                       pgtype.UUID                    `db:"id" json:"id"`
	DriverID                 pgtype.UUID                    `db:"driver_id" json:"driver_id"`
	RouteDate                pgtype.Date                    `db:"route_date" json:"route_date"`
	Status                   NullDmsDeliveryRouteStatusEnum `db:"status" json:"status"`
	OptimizedRouteData       pgtype.Text                    `db:"optimized_route_data" json:"optimized_route_data"`
	TotalDistanceKm          pgtype.Float4                  `db:"total_distance_km" json:"total_distance_km"`
	EstimatedDurationMinutes pgtype.Int4                    `db:"estimated_duration_minutes" json:"estimated_duration_minutes"`
	ActualDurationMinutes    pgtype.Int4                    `db:"actual_duration_minutes" json:"actual_duration_minutes"`
	StartedAt                pgtype.Timestamp               `db:"started_at" json:"started_at"`
	CompletedAt              pgtype.Timestamp               `db:"completed_at" json:"completed_at"`
	CreatedAt                pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt                pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	DeliveryTasks            []DmsDeliveryTasksView         `db:"delivery_tasks" json:"delivery_tasks"`
	TmsDriver                TmsDriver                      `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) DmsAnyDeliveryRoute(ctx context.Context, ids []pgtype.UUID) ([]DmsAnyDeliveryRouteRow, error) {
	rows, err := q.db.Query(ctx, dmsAnyDeliveryRoute, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsAnyDeliveryRouteRow
	for rows.Next() {
		var i DmsAnyDeliveryRouteRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.RouteDate,
			&i.Status,
			&i.OptimizedRouteData,
			&i.TotalDistanceKm,
			&i.EstimatedDurationMinutes,
			&i.ActualDurationMinutes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeliveryTasks,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsFindDeliveryRoute = `-- name: DmsFindDeliveryRoute :one
select
  delivery_routes.id, delivery_routes.driver_id, delivery_routes.route_date, delivery_routes.status, delivery_routes.optimized_route_data, delivery_routes.total_distance_km, delivery_routes.estimated_duration_minutes, delivery_routes.actual_duration_minutes, delivery_routes.started_at, delivery_routes.completed_at, delivery_routes.created_at, delivery_routes.updated_at, delivery_routes.delivery_tasks,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."delivery_routes_view" as delivery_routes
  inner join "tms"."drivers" as driver on delivery_routes.driver_id = driver.id
where
  delivery_routes.id = $1::uuid
`

type DmsFindDeliveryRouteRow struct {
	ID                       pgtype.UUID                    `db:"id" json:"id"`
	DriverID                 pgtype.UUID                    `db:"driver_id" json:"driver_id"`
	RouteDate                pgtype.Date                    `db:"route_date" json:"route_date"`
	Status                   NullDmsDeliveryRouteStatusEnum `db:"status" json:"status"`
	OptimizedRouteData       pgtype.Text                    `db:"optimized_route_data" json:"optimized_route_data"`
	TotalDistanceKm          pgtype.Float4                  `db:"total_distance_km" json:"total_distance_km"`
	EstimatedDurationMinutes pgtype.Int4                    `db:"estimated_duration_minutes" json:"estimated_duration_minutes"`
	ActualDurationMinutes    pgtype.Int4                    `db:"actual_duration_minutes" json:"actual_duration_minutes"`
	StartedAt                pgtype.Timestamp               `db:"started_at" json:"started_at"`
	CompletedAt              pgtype.Timestamp               `db:"completed_at" json:"completed_at"`
	CreatedAt                pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt                pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	DeliveryTasks            []DmsDeliveryTasksView         `db:"delivery_tasks" json:"delivery_tasks"`
	TmsDriver                TmsDriver                      `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) DmsFindDeliveryRoute(ctx context.Context, id pgtype.UUID) (DmsFindDeliveryRouteRow, error) {
	row := q.db.QueryRow(ctx, dmsFindDeliveryRoute, id)
	var i DmsFindDeliveryRouteRow
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.RouteDate,
		&i.Status,
		&i.OptimizedRouteData,
		&i.TotalDistanceKm,
		&i.EstimatedDurationMinutes,
		&i.ActualDurationMinutes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeliveryTasks,
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
	)
	return i, err
}

const dmsInsertDeliveryRoute = `-- name: DmsInsertDeliveryRoute :one
insert into "dms"."delivery_routes"(driver_id, route_date, status, optimized_route_data, total_distance_km, estimated_duration_minutes, started_at, completed_at)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, driver_id, route_date, status, optimized_route_data, total_distance_km, estimated_duration_minutes, actual_duration_minutes, started_at, completed_at, created_at, updated_at
`

type DmsInsertDeliveryRouteParams struct {
	DriverID                 pgtype.UUID                    `db:"driver_id" json:"driver_id"`
	RouteDate                pgtype.Date                    `db:"route_date" json:"route_date"`
	Status                   NullDmsDeliveryRouteStatusEnum `db:"status" json:"status"`
	OptimizedRouteData       pgtype.Text                    `db:"optimized_route_data" json:"optimized_route_data"`
	TotalDistanceKm          pgtype.Float4                  `db:"total_distance_km" json:"total_distance_km"`
	EstimatedDurationMinutes pgtype.Int4                    `db:"estimated_duration_minutes" json:"estimated_duration_minutes"`
	StartedAt                pgtype.Timestamp               `db:"started_at" json:"started_at"`
	CompletedAt              pgtype.Timestamp               `db:"completed_at" json:"completed_at"`
}

func (q *Queries) DmsInsertDeliveryRoute(ctx context.Context, arg DmsInsertDeliveryRouteParams) (DmsDeliveryRoute, error) {
	row := q.db.QueryRow(ctx, dmsInsertDeliveryRoute,
		arg.DriverID,
		arg.RouteDate,
		arg.Status,
		arg.OptimizedRouteData,
		arg.TotalDistanceKm,
		arg.EstimatedDurationMinutes,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i DmsDeliveryRoute
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.RouteDate,
		&i.Status,
		&i.OptimizedRouteData,
		&i.TotalDistanceKm,
		&i.EstimatedDurationMinutes,
		&i.ActualDurationMinutes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dmsPaginateDeliveryRoute = `-- name: DmsPaginateDeliveryRoute :many
select
  delivery_routes.id, delivery_routes.driver_id, delivery_routes.route_date, delivery_routes.status, delivery_routes.optimized_route_data, delivery_routes.total_distance_km, delivery_routes.estimated_duration_minutes, delivery_routes.actual_duration_minutes, delivery_routes.started_at, delivery_routes.completed_at, delivery_routes.created_at, delivery_routes.updated_at, delivery_routes.delivery_tasks,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."delivery_routes_view" as delivery_routes
  inner join "tms"."drivers" as driver on delivery_routes.driver_id = driver.id
where (driver.name ilike $1::text
  or delivery_routes.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type DmsPaginateDeliveryRouteParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type DmsPaginateDeliveryRouteRow struct {
	ID                       pgtype.UUID                    `db:"id" json:"id"`
	DriverID                 pgtype.UUID                    `db:"driver_id" json:"driver_id"`
	RouteDate                pgtype.Date                    `db:"route_date" json:"route_date"`
	Status                   NullDmsDeliveryRouteStatusEnum `db:"status" json:"status"`
	OptimizedRouteData       pgtype.Text                    `db:"optimized_route_data" json:"optimized_route_data"`
	TotalDistanceKm          pgtype.Float4                  `db:"total_distance_km" json:"total_distance_km"`
	EstimatedDurationMinutes pgtype.Int4                    `db:"estimated_duration_minutes" json:"estimated_duration_minutes"`
	ActualDurationMinutes    pgtype.Int4                    `db:"actual_duration_minutes" json:"actual_duration_minutes"`
	StartedAt                pgtype.Timestamp               `db:"started_at" json:"started_at"`
	CompletedAt              pgtype.Timestamp               `db:"completed_at" json:"completed_at"`
	CreatedAt                pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt                pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	DeliveryTasks            []DmsDeliveryTasksView         `db:"delivery_tasks" json:"delivery_tasks"`
	TmsDriver                TmsDriver                      `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) DmsPaginateDeliveryRoute(ctx context.Context, arg DmsPaginateDeliveryRouteParams) ([]DmsPaginateDeliveryRouteRow, error) {
	rows, err := q.db.Query(ctx, dmsPaginateDeliveryRoute, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsPaginateDeliveryRouteRow
	for rows.Next() {
		var i DmsPaginateDeliveryRouteRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.RouteDate,
			&i.Status,
			&i.OptimizedRouteData,
			&i.TotalDistanceKm,
			&i.EstimatedDurationMinutes,
			&i.ActualDurationMinutes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeliveryTasks,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsPaginateDeliveryRouteMetadata = `-- name: DmsPaginateDeliveryRouteMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "dms"."delivery_routes_view" as delivery_routes
`

type DmsPaginateDeliveryRouteMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type DmsPaginateDeliveryRouteMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) DmsPaginateDeliveryRouteMetadata(ctx context.Context, arg DmsPaginateDeliveryRouteMetadataParams) (DmsPaginateDeliveryRouteMetadataRow, error) {
	row := q.db.QueryRow(ctx, dmsPaginateDeliveryRouteMetadata, arg.PerPage, arg.Page)
	var i DmsPaginateDeliveryRouteMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const dmsRangeDeliveryRoute = `-- name: DmsRangeDeliveryRoute :many
select
  delivery_routes.id, delivery_routes.driver_id, delivery_routes.route_date, delivery_routes.status, delivery_routes.optimized_route_data, delivery_routes.total_distance_km, delivery_routes.estimated_duration_minutes, delivery_routes.actual_duration_minutes, delivery_routes.started_at, delivery_routes.completed_at, delivery_routes.created_at, delivery_routes.updated_at, delivery_routes.delivery_tasks,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."delivery_routes_view" as delivery_routes
  inner join "tms"."drivers" as driver on delivery_routes.driver_id = driver.id
where
  delivery_routes.created_at >= $1::date
  and delivery_routes.created_at <= $2::date
  and (driver.name ilike $3::text
    or delivery_routes.status::text ilike $3::text
    or $3::text is null)
`

type DmsRangeDeliveryRouteParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type DmsRangeDeliveryRouteRow struct {
	ID                       pgtype.UUID                    `db:"id" json:"id"`
	DriverID                 pgtype.UUID                    `db:"driver_id" json:"driver_id"`
	RouteDate                pgtype.Date                    `db:"route_date" json:"route_date"`
	Status                   NullDmsDeliveryRouteStatusEnum `db:"status" json:"status"`
	OptimizedRouteData       pgtype.Text                    `db:"optimized_route_data" json:"optimized_route_data"`
	TotalDistanceKm          pgtype.Float4                  `db:"total_distance_km" json:"total_distance_km"`
	EstimatedDurationMinutes pgtype.Int4                    `db:"estimated_duration_minutes" json:"estimated_duration_minutes"`
	ActualDurationMinutes    pgtype.Int4                    `db:"actual_duration_minutes" json:"actual_duration_minutes"`
	StartedAt                pgtype.Timestamp               `db:"started_at" json:"started_at"`
	CompletedAt              pgtype.Timestamp               `db:"completed_at" json:"completed_at"`
	CreatedAt                pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt                pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	DeliveryTasks            []DmsDeliveryTasksView         `db:"delivery_tasks" json:"delivery_tasks"`
	TmsDriver                TmsDriver                      `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) DmsRangeDeliveryRoute(ctx context.Context, arg DmsRangeDeliveryRouteParams) ([]DmsRangeDeliveryRouteRow, error) {
	rows, err := q.db.Query(ctx, dmsRangeDeliveryRoute, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsRangeDeliveryRouteRow
	for rows.Next() {
		var i DmsRangeDeliveryRouteRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.RouteDate,
			&i.Status,
			&i.OptimizedRouteData,
			&i.TotalDistanceKm,
			&i.EstimatedDurationMinutes,
			&i.ActualDurationMinutes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeliveryTasks,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRemoveDeliveryRoute = `-- name: DmsRemoveDeliveryRoute :exec
delete from "dms"."delivery_routes"
where id = $1::uuid
`

func (q *Queries) DmsRemoveDeliveryRoute(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, dmsRemoveDeliveryRoute, id)
	return err
}

const dmsUpdateDeliveryRoute = `-- name: DmsUpdateDeliveryRoute :one
update
  "dms"."delivery_routes"
set
  updated_at = now(),
  driver_id = case when $1 is not null then
    $1::uuid
  else
    driver_id
  end,
  route_date = case when $2 is not null then
    $2::date
  else
    route_date
  end,
  status = case when $3 is not null then
    $3::dms.delivery_route_status_enum
  else
    status
  end,
  optimized_route_data = case when $4 is not null then
    $4::text
  else
    optimized_route_data
  end,
  total_distance_km = case when $5 is not null then
    $5::real
  else
    total_distance_km
  end,
  estimated_duration_minutes = case when $6 is not null then
    $6::integer
  else
    estimated_duration_minutes
  end,
  started_at = case when $7 is not null then
    $7::timestamp
  else
    started_at
  end,
  completed_at = case when $8 is not null then
    $8::timestamp
  else
    completed_at
  end
where
  id = $9::uuid
returning
  id, driver_id, route_date, status, optimized_route_data, total_distance_km, estimated_duration_minutes, actual_duration_minutes, started_at, completed_at, created_at, updated_at
`

type DmsUpdateDeliveryRouteParams struct {
	DriverID                 pgtype.UUID                    `db:"driver_id" json:"driver_id"`
	RouteDate                pgtype.Date                    `db:"route_date" json:"route_date"`
	Status                   NullDmsDeliveryRouteStatusEnum `db:"status" json:"status"`
	OptimizedRouteData       pgtype.Text                    `db:"optimized_route_data" json:"optimized_route_data"`
	TotalDistanceKm          pgtype.Float4                  `db:"total_distance_km" json:"total_distance_km"`
	EstimatedDurationMinutes pgtype.Int4                    `db:"estimated_duration_minutes" json:"estimated_duration_minutes"`
	StartedAt                pgtype.Timestamp               `db:"started_at" json:"started_at"`
	CompletedAt              pgtype.Timestamp               `db:"completed_at" json:"completed_at"`
	ID                       pgtype.UUID                    `db:"id" json:"id"`
}

func (q *Queries) DmsUpdateDeliveryRoute(ctx context.Context, arg DmsUpdateDeliveryRouteParams) (DmsDeliveryRoute, error) {
	row := q.db.QueryRow(ctx, dmsUpdateDeliveryRoute,
		arg.DriverID,
		arg.RouteDate,
		arg.Status,
		arg.OptimizedRouteData,
		arg.TotalDistanceKm,
		arg.EstimatedDurationMinutes,
		arg.StartedAt,
		arg.CompletedAt,
		arg.ID,
	)
	var i DmsDeliveryRoute
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.RouteDate,
		&i.Status,
		&i.OptimizedRouteData,
		&i.TotalDistanceKm,
		&i.EstimatedDurationMinutes,
		&i.ActualDurationMinutes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
