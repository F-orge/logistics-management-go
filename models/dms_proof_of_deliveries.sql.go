// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dms_proof_of_deliveries.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dmsAnyProofOfDelivery = `-- name: DmsAnyProofOfDelivery :many
select
  proof_of_deliveries.id, proof_of_deliveries.delivery_task_id, proof_of_deliveries.type, proof_of_deliveries.file_path, proof_of_deliveries.signature_data, proof_of_deliveries.recipient_name, proof_of_deliveries.verification_code, proof_of_deliveries.latitude, proof_of_deliveries.longitude, proof_of_deliveries.timestamp, proof_of_deliveries.created_at, proof_of_deliveries.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."proof_of_deliveries" as proof_of_deliveries
  inner join "dms"."delivery_tasks" as delivery_task on proof_of_deliveries.delivery_task_id = delivery_task.id
where
  proof_of_deliveries.id = any ($1::uuid[])
`

type DmsAnyProofOfDeliveryRow struct {
	DmsProofOfDelivery DmsProofOfDelivery `db:"dms_proof_of_delivery" json:"dms_proof_of_delivery"`
	DmsDeliveryTask    DmsDeliveryTask    `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsAnyProofOfDelivery(ctx context.Context, ids []pgtype.UUID) ([]DmsAnyProofOfDeliveryRow, error) {
	rows, err := q.db.Query(ctx, dmsAnyProofOfDelivery, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsAnyProofOfDeliveryRow
	for rows.Next() {
		var i DmsAnyProofOfDeliveryRow
		if err := rows.Scan(
			&i.DmsProofOfDelivery.ID,
			&i.DmsProofOfDelivery.DeliveryTaskID,
			&i.DmsProofOfDelivery.Type,
			&i.DmsProofOfDelivery.FilePath,
			&i.DmsProofOfDelivery.SignatureData,
			&i.DmsProofOfDelivery.RecipientName,
			&i.DmsProofOfDelivery.VerificationCode,
			&i.DmsProofOfDelivery.Latitude,
			&i.DmsProofOfDelivery.Longitude,
			&i.DmsProofOfDelivery.Timestamp,
			&i.DmsProofOfDelivery.CreatedAt,
			&i.DmsProofOfDelivery.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsFindProofOfDelivery = `-- name: DmsFindProofOfDelivery :one
select
  proof_of_deliveries.id, proof_of_deliveries.delivery_task_id, proof_of_deliveries.type, proof_of_deliveries.file_path, proof_of_deliveries.signature_data, proof_of_deliveries.recipient_name, proof_of_deliveries.verification_code, proof_of_deliveries.latitude, proof_of_deliveries.longitude, proof_of_deliveries.timestamp, proof_of_deliveries.created_at, proof_of_deliveries.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."proof_of_deliveries" as proof_of_deliveries
  inner join "dms"."delivery_tasks" as delivery_task on proof_of_deliveries.delivery_task_id = delivery_task.id
where
  proof_of_deliveries.id = $1::uuid
`

type DmsFindProofOfDeliveryRow struct {
	DmsProofOfDelivery DmsProofOfDelivery `db:"dms_proof_of_delivery" json:"dms_proof_of_delivery"`
	DmsDeliveryTask    DmsDeliveryTask    `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsFindProofOfDelivery(ctx context.Context, id pgtype.UUID) (DmsFindProofOfDeliveryRow, error) {
	row := q.db.QueryRow(ctx, dmsFindProofOfDelivery, id)
	var i DmsFindProofOfDeliveryRow
	err := row.Scan(
		&i.DmsProofOfDelivery.ID,
		&i.DmsProofOfDelivery.DeliveryTaskID,
		&i.DmsProofOfDelivery.Type,
		&i.DmsProofOfDelivery.FilePath,
		&i.DmsProofOfDelivery.SignatureData,
		&i.DmsProofOfDelivery.RecipientName,
		&i.DmsProofOfDelivery.VerificationCode,
		&i.DmsProofOfDelivery.Latitude,
		&i.DmsProofOfDelivery.Longitude,
		&i.DmsProofOfDelivery.Timestamp,
		&i.DmsProofOfDelivery.CreatedAt,
		&i.DmsProofOfDelivery.UpdatedAt,
		&i.DmsDeliveryTask.ID,
		&i.DmsDeliveryTask.PackageID,
		&i.DmsDeliveryTask.DeliveryRouteID,
		&i.DmsDeliveryTask.RouteSequence,
		&i.DmsDeliveryTask.DeliveryAddress,
		&i.DmsDeliveryTask.RecipientName,
		&i.DmsDeliveryTask.RecipientPhone,
		&i.DmsDeliveryTask.DeliveryInstructions,
		&i.DmsDeliveryTask.EstimatedArrivalTime,
		&i.DmsDeliveryTask.ActualArrivalTime,
		&i.DmsDeliveryTask.DeliveryTime,
		&i.DmsDeliveryTask.Status,
		&i.DmsDeliveryTask.FailureReason,
		&i.DmsDeliveryTask.AttemptCount,
		&i.DmsDeliveryTask.CreatedAt,
		&i.DmsDeliveryTask.UpdatedAt,
	)
	return i, err
}

const dmsInsertProofOfDelivery = `-- name: DmsInsertProofOfDelivery :one
insert into "dms"."proof_of_deliveries"(delivery_task_id, type, file_path, signature_data, recipient_name, verification_code, latitude, longitude, timestamp)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning
  id, delivery_task_id, type, file_path, signature_data, recipient_name, verification_code, latitude, longitude, timestamp, created_at, updated_at
`

type DmsInsertProofOfDeliveryParams struct {
	DeliveryTaskID   pgtype.UUID                `db:"delivery_task_id" json:"delivery_task_id"`
	Type             DmsProofOfDeliveryTypeEnum `db:"type" json:"type"`
	FilePath         pgtype.Text                `db:"file_path" json:"file_path"`
	SignatureData    pgtype.Text                `db:"signature_data" json:"signature_data"`
	RecipientName    pgtype.Text                `db:"recipient_name" json:"recipient_name"`
	VerificationCode pgtype.Text                `db:"verification_code" json:"verification_code"`
	Latitude         pgtype.Float4              `db:"latitude" json:"latitude"`
	Longitude        pgtype.Float4              `db:"longitude" json:"longitude"`
	Timestamp        pgtype.Timestamp           `db:"timestamp" json:"timestamp"`
}

func (q *Queries) DmsInsertProofOfDelivery(ctx context.Context, arg DmsInsertProofOfDeliveryParams) (DmsProofOfDelivery, error) {
	row := q.db.QueryRow(ctx, dmsInsertProofOfDelivery,
		arg.DeliveryTaskID,
		arg.Type,
		arg.FilePath,
		arg.SignatureData,
		arg.RecipientName,
		arg.VerificationCode,
		arg.Latitude,
		arg.Longitude,
		arg.Timestamp,
	)
	var i DmsProofOfDelivery
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.Type,
		&i.FilePath,
		&i.SignatureData,
		&i.RecipientName,
		&i.VerificationCode,
		&i.Latitude,
		&i.Longitude,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dmsPaginateProofOfDelivery = `-- name: DmsPaginateProofOfDelivery :many
select
  proof_of_deliveries.id, proof_of_deliveries.delivery_task_id, proof_of_deliveries.type, proof_of_deliveries.file_path, proof_of_deliveries.signature_data, proof_of_deliveries.recipient_name, proof_of_deliveries.verification_code, proof_of_deliveries.latitude, proof_of_deliveries.longitude, proof_of_deliveries.timestamp, proof_of_deliveries.created_at, proof_of_deliveries.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."proof_of_deliveries" as proof_of_deliveries
  inner join "dms"."delivery_tasks" as delivery_task on proof_of_deliveries.delivery_task_id = delivery_task.id
where (proof_of_deliveries.recipient_name ilike $1::text
  or proof_of_deliveries.type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type DmsPaginateProofOfDeliveryParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type DmsPaginateProofOfDeliveryRow struct {
	DmsProofOfDelivery DmsProofOfDelivery `db:"dms_proof_of_delivery" json:"dms_proof_of_delivery"`
	DmsDeliveryTask    DmsDeliveryTask    `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsPaginateProofOfDelivery(ctx context.Context, arg DmsPaginateProofOfDeliveryParams) ([]DmsPaginateProofOfDeliveryRow, error) {
	rows, err := q.db.Query(ctx, dmsPaginateProofOfDelivery, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsPaginateProofOfDeliveryRow
	for rows.Next() {
		var i DmsPaginateProofOfDeliveryRow
		if err := rows.Scan(
			&i.DmsProofOfDelivery.ID,
			&i.DmsProofOfDelivery.DeliveryTaskID,
			&i.DmsProofOfDelivery.Type,
			&i.DmsProofOfDelivery.FilePath,
			&i.DmsProofOfDelivery.SignatureData,
			&i.DmsProofOfDelivery.RecipientName,
			&i.DmsProofOfDelivery.VerificationCode,
			&i.DmsProofOfDelivery.Latitude,
			&i.DmsProofOfDelivery.Longitude,
			&i.DmsProofOfDelivery.Timestamp,
			&i.DmsProofOfDelivery.CreatedAt,
			&i.DmsProofOfDelivery.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRangeProofOfDelivery = `-- name: DmsRangeProofOfDelivery :many
select
  proof_of_deliveries.id, proof_of_deliveries.delivery_task_id, proof_of_deliveries.type, proof_of_deliveries.file_path, proof_of_deliveries.signature_data, proof_of_deliveries.recipient_name, proof_of_deliveries.verification_code, proof_of_deliveries.latitude, proof_of_deliveries.longitude, proof_of_deliveries.timestamp, proof_of_deliveries.created_at, proof_of_deliveries.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."proof_of_deliveries" as proof_of_deliveries
  inner join "dms"."delivery_tasks" as delivery_task on proof_of_deliveries.delivery_task_id = delivery_task.id
where
  proof_of_deliveries.created_at >= $1::date
  and proof_of_deliveries.created_at <= $2::date
  and (proof_of_deliveries.recipient_name ilike $3::text
    or proof_of_deliveries.type::text ilike $3::text
    or $3::text is null)
`

type DmsRangeProofOfDeliveryParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type DmsRangeProofOfDeliveryRow struct {
	DmsProofOfDelivery DmsProofOfDelivery `db:"dms_proof_of_delivery" json:"dms_proof_of_delivery"`
	DmsDeliveryTask    DmsDeliveryTask    `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsRangeProofOfDelivery(ctx context.Context, arg DmsRangeProofOfDeliveryParams) ([]DmsRangeProofOfDeliveryRow, error) {
	rows, err := q.db.Query(ctx, dmsRangeProofOfDelivery, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsRangeProofOfDeliveryRow
	for rows.Next() {
		var i DmsRangeProofOfDeliveryRow
		if err := rows.Scan(
			&i.DmsProofOfDelivery.ID,
			&i.DmsProofOfDelivery.DeliveryTaskID,
			&i.DmsProofOfDelivery.Type,
			&i.DmsProofOfDelivery.FilePath,
			&i.DmsProofOfDelivery.SignatureData,
			&i.DmsProofOfDelivery.RecipientName,
			&i.DmsProofOfDelivery.VerificationCode,
			&i.DmsProofOfDelivery.Latitude,
			&i.DmsProofOfDelivery.Longitude,
			&i.DmsProofOfDelivery.Timestamp,
			&i.DmsProofOfDelivery.CreatedAt,
			&i.DmsProofOfDelivery.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRemoveProofOfDelivery = `-- name: DmsRemoveProofOfDelivery :exec
delete from "dms"."proof_of_deliveries"
where id = $1::uuid
`

func (q *Queries) DmsRemoveProofOfDelivery(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, dmsRemoveProofOfDelivery, id)
	return err
}

const dmsUpdateProofOfDelivery = `-- name: DmsUpdateProofOfDelivery :one
update
  "dms"."proof_of_deliveries"
set
  updated_at = now(),
  delivery_task_id = case when $1 is not null then
    $1::uuid
  else
    delivery_task_id
  end,
  type = case when $2 is not null then
    $2::dms.proof_of_delivery_type_enum
  else
    type
  end,
  file_path = case when $3 is not null then
    $3::varchar
  else
    file_path
  end,
  signature_data = case when $4 is not null then
    $4::text
  else
    signature_data
  end,
  recipient_name = case when $5 is not null then
    $5::varchar
  else
    recipient_name
  end,
  verification_code = case when $6 is not null then
    $6::varchar
  else
    verification_code
  end,
  latitude = case when $7 is not null then
    $7::real
  else
    latitude
  end,
  longitude = case when $8 is not null then
    $8::real
  else
    longitude
  end,
  timestamp = case when $9 is not null then
    $9::timestamp
  else
    timestamp
  end
where
  id = $10::uuid
returning
  id, delivery_task_id, type, file_path, signature_data, recipient_name, verification_code, latitude, longitude, timestamp, created_at, updated_at
`

type DmsUpdateProofOfDeliveryParams struct {
	DeliveryTaskID   pgtype.UUID                `db:"delivery_task_id" json:"delivery_task_id"`
	Type             DmsProofOfDeliveryTypeEnum `db:"type" json:"type"`
	FilePath         pgtype.Text                `db:"file_path" json:"file_path"`
	SignatureData    pgtype.Text                `db:"signature_data" json:"signature_data"`
	RecipientName    pgtype.Text                `db:"recipient_name" json:"recipient_name"`
	VerificationCode pgtype.Text                `db:"verification_code" json:"verification_code"`
	Latitude         pgtype.Float4              `db:"latitude" json:"latitude"`
	Longitude        pgtype.Float4              `db:"longitude" json:"longitude"`
	Timestamp        pgtype.Timestamp           `db:"timestamp" json:"timestamp"`
	ID               pgtype.UUID                `db:"id" json:"id"`
}

func (q *Queries) DmsUpdateProofOfDelivery(ctx context.Context, arg DmsUpdateProofOfDeliveryParams) (DmsProofOfDelivery, error) {
	row := q.db.QueryRow(ctx, dmsUpdateProofOfDelivery,
		arg.DeliveryTaskID,
		arg.Type,
		arg.FilePath,
		arg.SignatureData,
		arg.RecipientName,
		arg.VerificationCode,
		arg.Latitude,
		arg.Longitude,
		arg.Timestamp,
		arg.ID,
	)
	var i DmsProofOfDelivery
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.Type,
		&i.FilePath,
		&i.SignatureData,
		&i.RecipientName,
		&i.VerificationCode,
		&i.Latitude,
		&i.Longitude,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
