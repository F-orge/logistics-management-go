// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_quotes.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyQuote = `-- name: BillingAnyQuote :many
select
  quotes.id, quotes.client_id, quotes.origin_details, quotes.destination_details, quotes.weight, quotes.length, quotes.width, quotes.height, quotes.volume, quotes.quoted_price, quotes.service_level, quotes.expires_at, quotes.status, quotes.quote_number, quotes.notes, quotes.created_by_user_id, quotes.created_at, quotes.updated_at, quotes.invoices,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."quotes_view" as quotes
  left join "crm"."companies" as client on quotes.client_id = client.id
  left join "public"."user" as created_by_user on quotes.created_by_user_id = created_by_user.id
where
  quotes.id = any ($1::uuid[])
`

type BillingAnyQuoteRow struct {
	BillingQuotesView BillingQuotesView `db:"billing_quotes_view" json:"billing_quotes_view"`
	CrmCompany        CrmCompany        `db:"crm_company" json:"crm_company"`
	User              User              `db:"user" json:"user"`
}

func (q *Queries) BillingAnyQuote(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyQuoteRow, error) {
	rows, err := q.db.Query(ctx, billingAnyQuote, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyQuoteRow
	for rows.Next() {
		var i BillingAnyQuoteRow
		if err := rows.Scan(
			&i.BillingQuotesView.ID,
			&i.BillingQuotesView.ClientID,
			&i.BillingQuotesView.OriginDetails,
			&i.BillingQuotesView.DestinationDetails,
			&i.BillingQuotesView.Weight,
			&i.BillingQuotesView.Length,
			&i.BillingQuotesView.Width,
			&i.BillingQuotesView.Height,
			&i.BillingQuotesView.Volume,
			&i.BillingQuotesView.QuotedPrice,
			&i.BillingQuotesView.ServiceLevel,
			&i.BillingQuotesView.ExpiresAt,
			&i.BillingQuotesView.Status,
			&i.BillingQuotesView.QuoteNumber,
			&i.BillingQuotesView.Notes,
			&i.BillingQuotesView.CreatedByUserID,
			&i.BillingQuotesView.CreatedAt,
			&i.BillingQuotesView.UpdatedAt,
			&i.BillingQuotesView.Invoices,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindQuote = `-- name: BillingFindQuote :one
select
  quotes.id, quotes.client_id, quotes.origin_details, quotes.destination_details, quotes.weight, quotes.length, quotes.width, quotes.height, quotes.volume, quotes.quoted_price, quotes.service_level, quotes.expires_at, quotes.status, quotes.quote_number, quotes.notes, quotes.created_by_user_id, quotes.created_at, quotes.updated_at, quotes.invoices,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."quotes_view" as quotes
  left join "crm"."companies" as client on quotes.client_id = client.id
  left join "public"."user" as created_by_user on quotes.created_by_user_id = created_by_user.id
where
  quotes.id = $1::uuid
`

type BillingFindQuoteRow struct {
	BillingQuotesView BillingQuotesView `db:"billing_quotes_view" json:"billing_quotes_view"`
	CrmCompany        CrmCompany        `db:"crm_company" json:"crm_company"`
	User              User              `db:"user" json:"user"`
}

func (q *Queries) BillingFindQuote(ctx context.Context, id pgtype.UUID) (BillingFindQuoteRow, error) {
	row := q.db.QueryRow(ctx, billingFindQuote, id)
	var i BillingFindQuoteRow
	err := row.Scan(
		&i.BillingQuotesView.ID,
		&i.BillingQuotesView.ClientID,
		&i.BillingQuotesView.OriginDetails,
		&i.BillingQuotesView.DestinationDetails,
		&i.BillingQuotesView.Weight,
		&i.BillingQuotesView.Length,
		&i.BillingQuotesView.Width,
		&i.BillingQuotesView.Height,
		&i.BillingQuotesView.Volume,
		&i.BillingQuotesView.QuotedPrice,
		&i.BillingQuotesView.ServiceLevel,
		&i.BillingQuotesView.ExpiresAt,
		&i.BillingQuotesView.Status,
		&i.BillingQuotesView.QuoteNumber,
		&i.BillingQuotesView.Notes,
		&i.BillingQuotesView.CreatedByUserID,
		&i.BillingQuotesView.CreatedAt,
		&i.BillingQuotesView.UpdatedAt,
		&i.BillingQuotesView.Invoices,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertQuote = `-- name: BillingInsertQuote :one
insert into "billing"."quotes"(client_id, origin_details, destination_details, weight, length, width, height, quoted_price, service_level, expires_at, status, quote_number, notes, created_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
returning
  id, client_id, origin_details, destination_details, weight, length, width, height, volume, quoted_price, service_level, expires_at, status, quote_number, notes, created_by_user_id, created_at, updated_at
`

type BillingInsertQuoteParams struct {
	ClientID           pgtype.UUID                `db:"client_id" json:"client_id"`
	OriginDetails      string                     `db:"origin_details" json:"origin_details"`
	DestinationDetails string                     `db:"destination_details" json:"destination_details"`
	Weight             pgtype.Numeric             `db:"weight" json:"weight"`
	Length             pgtype.Numeric             `db:"length" json:"length"`
	Width              pgtype.Numeric             `db:"width" json:"width"`
	Height             pgtype.Numeric             `db:"height" json:"height"`
	QuotedPrice        pgtype.Numeric             `db:"quoted_price" json:"quoted_price"`
	ServiceLevel       pgtype.Text                `db:"service_level" json:"service_level"`
	ExpiresAt          pgtype.Timestamp           `db:"expires_at" json:"expires_at"`
	Status             NullBillingQuoteStatusEnum `db:"status" json:"status"`
	QuoteNumber        pgtype.Text                `db:"quote_number" json:"quote_number"`
	Notes              pgtype.Text                `db:"notes" json:"notes"`
	CreatedByUserID    pgtype.Text                `db:"created_by_user_id" json:"created_by_user_id"`
}

func (q *Queries) BillingInsertQuote(ctx context.Context, arg BillingInsertQuoteParams) (BillingQuote, error) {
	row := q.db.QueryRow(ctx, billingInsertQuote,
		arg.ClientID,
		arg.OriginDetails,
		arg.DestinationDetails,
		arg.Weight,
		arg.Length,
		arg.Width,
		arg.Height,
		arg.QuotedPrice,
		arg.ServiceLevel,
		arg.ExpiresAt,
		arg.Status,
		arg.QuoteNumber,
		arg.Notes,
		arg.CreatedByUserID,
	)
	var i BillingQuote
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.OriginDetails,
		&i.DestinationDetails,
		&i.Weight,
		&i.Length,
		&i.Width,
		&i.Height,
		&i.Volume,
		&i.QuotedPrice,
		&i.ServiceLevel,
		&i.ExpiresAt,
		&i.Status,
		&i.QuoteNumber,
		&i.Notes,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateQuote = `-- name: BillingPaginateQuote :many
select
  quotes.id, quotes.client_id, quotes.origin_details, quotes.destination_details, quotes.weight, quotes.length, quotes.width, quotes.height, quotes.volume, quotes.quoted_price, quotes.service_level, quotes.expires_at, quotes.status, quotes.quote_number, quotes.notes, quotes.created_by_user_id, quotes.created_at, quotes.updated_at, quotes.invoices,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."quotes_view" as quotes
  left join "crm"."companies" as client on quotes.client_id = client.id
  left join "public"."user" as created_by_user on quotes.created_by_user_id = created_by_user.id
where (client.name ilike $1::text
  or quotes.quote_number ilike $1::text
  or quotes.service_level ilike $1::text
  or quotes.status::text ilike $1::text
  or created_by_user.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateQuoteParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type BillingPaginateQuoteRow struct {
	BillingQuotesView BillingQuotesView `db:"billing_quotes_view" json:"billing_quotes_view"`
	CrmCompany        CrmCompany        `db:"crm_company" json:"crm_company"`
	User              User              `db:"user" json:"user"`
}

func (q *Queries) BillingPaginateQuote(ctx context.Context, arg BillingPaginateQuoteParams) ([]BillingPaginateQuoteRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateQuote, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateQuoteRow
	for rows.Next() {
		var i BillingPaginateQuoteRow
		if err := rows.Scan(
			&i.BillingQuotesView.ID,
			&i.BillingQuotesView.ClientID,
			&i.BillingQuotesView.OriginDetails,
			&i.BillingQuotesView.DestinationDetails,
			&i.BillingQuotesView.Weight,
			&i.BillingQuotesView.Length,
			&i.BillingQuotesView.Width,
			&i.BillingQuotesView.Height,
			&i.BillingQuotesView.Volume,
			&i.BillingQuotesView.QuotedPrice,
			&i.BillingQuotesView.ServiceLevel,
			&i.BillingQuotesView.ExpiresAt,
			&i.BillingQuotesView.Status,
			&i.BillingQuotesView.QuoteNumber,
			&i.BillingQuotesView.Notes,
			&i.BillingQuotesView.CreatedByUserID,
			&i.BillingQuotesView.CreatedAt,
			&i.BillingQuotesView.UpdatedAt,
			&i.BillingQuotesView.Invoices,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeQuote = `-- name: BillingRangeQuote :many
select
  quotes.id, quotes.client_id, quotes.origin_details, quotes.destination_details, quotes.weight, quotes.length, quotes.width, quotes.height, quotes.volume, quotes.quoted_price, quotes.service_level, quotes.expires_at, quotes.status, quotes.quote_number, quotes.notes, quotes.created_by_user_id, quotes.created_at, quotes.updated_at, quotes.invoices,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."quotes_view" as quotes
  left join "crm"."companies" as client on quotes.client_id = client.id
  left join "public"."user" as created_by_user on quotes.created_by_user_id = created_by_user.id
where
  quotes.created_at >= $1::date
  and quotes.created_at <= $2::date
  and (client.name ilike $3::text
    or quotes.quote_number ilike $3::text
    or quotes.service_level ilike $3::text
    or quotes.status::text ilike $3::text
    or created_by_user.name ilike $3::text
    or $3::text is null)
`

type BillingRangeQuoteParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type BillingRangeQuoteRow struct {
	BillingQuotesView BillingQuotesView `db:"billing_quotes_view" json:"billing_quotes_view"`
	CrmCompany        CrmCompany        `db:"crm_company" json:"crm_company"`
	User              User              `db:"user" json:"user"`
}

func (q *Queries) BillingRangeQuote(ctx context.Context, arg BillingRangeQuoteParams) ([]BillingRangeQuoteRow, error) {
	rows, err := q.db.Query(ctx, billingRangeQuote, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeQuoteRow
	for rows.Next() {
		var i BillingRangeQuoteRow
		if err := rows.Scan(
			&i.BillingQuotesView.ID,
			&i.BillingQuotesView.ClientID,
			&i.BillingQuotesView.OriginDetails,
			&i.BillingQuotesView.DestinationDetails,
			&i.BillingQuotesView.Weight,
			&i.BillingQuotesView.Length,
			&i.BillingQuotesView.Width,
			&i.BillingQuotesView.Height,
			&i.BillingQuotesView.Volume,
			&i.BillingQuotesView.QuotedPrice,
			&i.BillingQuotesView.ServiceLevel,
			&i.BillingQuotesView.ExpiresAt,
			&i.BillingQuotesView.Status,
			&i.BillingQuotesView.QuoteNumber,
			&i.BillingQuotesView.Notes,
			&i.BillingQuotesView.CreatedByUserID,
			&i.BillingQuotesView.CreatedAt,
			&i.BillingQuotesView.UpdatedAt,
			&i.BillingQuotesView.Invoices,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveQuote = `-- name: BillingRemoveQuote :exec
delete from "billing"."quotes"
where id = $1::uuid
`

func (q *Queries) BillingRemoveQuote(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveQuote, id)
	return err
}

const billingUpdateQuote = `-- name: BillingUpdateQuote :one
update
  "billing"."quotes"
set
  updated_at = now(),
  client_id = case when $1 is not null then
    $1::uuid
  else
    client_id
  end,
  origin_details = case when $2 is not null then
    $2::text
  else
    origin_details
  end,
  destination_details = case when $3 is not null then
    $3::text
  else
    destination_details
  end,
  weight = case when $4 is not null then
    $4::numeric
  else
    weight
  end,
  length = case when $5 is not null then
    $5::numeric
  else
    length
  end,
  width = case when $6 is not null then
    $6::numeric
  else
    width
  end,
  height = case when $7 is not null then
    $7::numeric
  else
    height
  end,
  quoted_price = case when $8 is not null then
    $8::numeric
  else
    quoted_price
  end,
  service_level = case when $9 is not null then
    $9::varchar
  else
    service_level
  end,
  expires_at = case when $10 is not null then
    $10::timestamp
  else
    expires_at
  end,
  status = case when $11 is not null then
    $11::billing.quote_status_enum
  else
    status
  end,
  quote_number = case when $12 is not null then
    $12::varchar
  else
    quote_number
  end,
  notes = case when $13 is not null then
    $13::text
  else
    notes
  end,
  created_by_user_id = case when $14 is not null then
    $14::text
  else
    created_by_user_id
  end
where
  id = $15::uuid
returning
  id, client_id, origin_details, destination_details, weight, length, width, height, volume, quoted_price, service_level, expires_at, status, quote_number, notes, created_by_user_id, created_at, updated_at
`

type BillingUpdateQuoteParams struct {
	ClientID           pgtype.UUID                `db:"client_id" json:"client_id"`
	OriginDetails      string                     `db:"origin_details" json:"origin_details"`
	DestinationDetails string                     `db:"destination_details" json:"destination_details"`
	Weight             pgtype.Numeric             `db:"weight" json:"weight"`
	Length             pgtype.Numeric             `db:"length" json:"length"`
	Width              pgtype.Numeric             `db:"width" json:"width"`
	Height             pgtype.Numeric             `db:"height" json:"height"`
	QuotedPrice        pgtype.Numeric             `db:"quoted_price" json:"quoted_price"`
	ServiceLevel       pgtype.Text                `db:"service_level" json:"service_level"`
	ExpiresAt          pgtype.Timestamp           `db:"expires_at" json:"expires_at"`
	Status             NullBillingQuoteStatusEnum `db:"status" json:"status"`
	QuoteNumber        pgtype.Text                `db:"quote_number" json:"quote_number"`
	Notes              pgtype.Text                `db:"notes" json:"notes"`
	CreatedByUserID    pgtype.Text                `db:"created_by_user_id" json:"created_by_user_id"`
	ID                 pgtype.UUID                `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateQuote(ctx context.Context, arg BillingUpdateQuoteParams) (BillingQuote, error) {
	row := q.db.QueryRow(ctx, billingUpdateQuote,
		arg.ClientID,
		arg.OriginDetails,
		arg.DestinationDetails,
		arg.Weight,
		arg.Length,
		arg.Width,
		arg.Height,
		arg.QuotedPrice,
		arg.ServiceLevel,
		arg.ExpiresAt,
		arg.Status,
		arg.QuoteNumber,
		arg.Notes,
		arg.CreatedByUserID,
		arg.ID,
	)
	var i BillingQuote
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.OriginDetails,
		&i.DestinationDetails,
		&i.Weight,
		&i.Length,
		&i.Width,
		&i.Height,
		&i.Volume,
		&i.QuotedPrice,
		&i.ServiceLevel,
		&i.ExpiresAt,
		&i.Status,
		&i.QuoteNumber,
		&i.Notes,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
