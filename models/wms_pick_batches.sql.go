// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_pick_batches.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyPickBatch = `-- name: WmsAnyPickBatch :many
select
  pick_batches.id, pick_batches.batch_number, pick_batches.warehouse_id, pick_batches.status, pick_batches.strategy, pick_batches.priority, pick_batches.assigned_user_id, pick_batches.wave_id, pick_batches.zone_restrictions, pick_batches.estimated_duration, pick_batches.actual_duration, pick_batches.total_items, pick_batches.completed_items, pick_batches.started_at, pick_batches.completed_at, pick_batches.created_at, pick_batches.updated_at, pick_batches.pick_batch_items,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  assigned_user.id, assigned_user.name, assigned_user.email, assigned_user.email_verified, assigned_user.image, assigned_user.created_at, assigned_user.updated_at, assigned_user.role, assigned_user.banned, assigned_user.ban_reason, assigned_user.ban_expires
from
  "wms"."pick_batches_view" as pick_batches
  inner join "wms"."warehouses" as warehouse on pick_batches.warehouse_id = warehouse.id
  left join "public"."user" as assigned_user on pick_batches.assigned_user_id = assigned_user.id
where
  pick_batches.id = any ($1::uuid[])
`

type WmsAnyPickBatchRow struct {
	ID                pgtype.UUID                `db:"id" json:"id"`
	BatchNumber       string                     `db:"batch_number" json:"batch_number"`
	WarehouseID       pgtype.UUID                `db:"warehouse_id" json:"warehouse_id"`
	Status            NullWmsPickBatchStatusEnum `db:"status" json:"status"`
	Strategy          WmsPickStrategyEnum        `db:"strategy" json:"strategy"`
	Priority          pgtype.Int4                `db:"priority" json:"priority"`
	AssignedUserID    pgtype.Text                `db:"assigned_user_id" json:"assigned_user_id"`
	WaveID            pgtype.Text                `db:"wave_id" json:"wave_id"`
	ZoneRestrictions  []string                   `db:"zone_restrictions" json:"zone_restrictions"`
	EstimatedDuration pgtype.Int4                `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4                `db:"actual_duration" json:"actual_duration"`
	TotalItems        pgtype.Int4                `db:"total_items" json:"total_items"`
	CompletedItems    pgtype.Int4                `db:"completed_items" json:"completed_items"`
	StartedAt         pgtype.Timestamp           `db:"started_at" json:"started_at"`
	CompletedAt       pgtype.Timestamp           `db:"completed_at" json:"completed_at"`
	CreatedAt         pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	PickBatchItems    []WmsPickBatchItem         `db:"pick_batch_items" json:"pick_batch_items"`
	WmsWarehouse      WmsWarehouse               `db:"wms_warehouse" json:"wms_warehouse"`
	User              User                       `db:"user" json:"user"`
}

func (q *Queries) WmsAnyPickBatch(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyPickBatchRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyPickBatch, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyPickBatchRow
	for rows.Next() {
		var i WmsAnyPickBatchRow
		if err := rows.Scan(
			&i.ID,
			&i.BatchNumber,
			&i.WarehouseID,
			&i.Status,
			&i.Strategy,
			&i.Priority,
			&i.AssignedUserID,
			&i.WaveID,
			&i.ZoneRestrictions,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.TotalItems,
			&i.CompletedItems,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PickBatchItems,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindPickBatch = `-- name: WmsFindPickBatch :one
select
  pick_batches.id, pick_batches.batch_number, pick_batches.warehouse_id, pick_batches.status, pick_batches.strategy, pick_batches.priority, pick_batches.assigned_user_id, pick_batches.wave_id, pick_batches.zone_restrictions, pick_batches.estimated_duration, pick_batches.actual_duration, pick_batches.total_items, pick_batches.completed_items, pick_batches.started_at, pick_batches.completed_at, pick_batches.created_at, pick_batches.updated_at, pick_batches.pick_batch_items,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  assigned_user.id, assigned_user.name, assigned_user.email, assigned_user.email_verified, assigned_user.image, assigned_user.created_at, assigned_user.updated_at, assigned_user.role, assigned_user.banned, assigned_user.ban_reason, assigned_user.ban_expires
from
  "wms"."pick_batches_view" as pick_batches
  inner join "wms"."warehouses" as warehouse on pick_batches.warehouse_id = warehouse.id
  left join "public"."user" as assigned_user on pick_batches.assigned_user_id = assigned_user.id
where
  pick_batches.id = $1::uuid
`

type WmsFindPickBatchRow struct {
	ID                pgtype.UUID                `db:"id" json:"id"`
	BatchNumber       string                     `db:"batch_number" json:"batch_number"`
	WarehouseID       pgtype.UUID                `db:"warehouse_id" json:"warehouse_id"`
	Status            NullWmsPickBatchStatusEnum `db:"status" json:"status"`
	Strategy          WmsPickStrategyEnum        `db:"strategy" json:"strategy"`
	Priority          pgtype.Int4                `db:"priority" json:"priority"`
	AssignedUserID    pgtype.Text                `db:"assigned_user_id" json:"assigned_user_id"`
	WaveID            pgtype.Text                `db:"wave_id" json:"wave_id"`
	ZoneRestrictions  []string                   `db:"zone_restrictions" json:"zone_restrictions"`
	EstimatedDuration pgtype.Int4                `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4                `db:"actual_duration" json:"actual_duration"`
	TotalItems        pgtype.Int4                `db:"total_items" json:"total_items"`
	CompletedItems    pgtype.Int4                `db:"completed_items" json:"completed_items"`
	StartedAt         pgtype.Timestamp           `db:"started_at" json:"started_at"`
	CompletedAt       pgtype.Timestamp           `db:"completed_at" json:"completed_at"`
	CreatedAt         pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	PickBatchItems    []WmsPickBatchItem         `db:"pick_batch_items" json:"pick_batch_items"`
	WmsWarehouse      WmsWarehouse               `db:"wms_warehouse" json:"wms_warehouse"`
	User              User                       `db:"user" json:"user"`
}

func (q *Queries) WmsFindPickBatch(ctx context.Context, id pgtype.UUID) (WmsFindPickBatchRow, error) {
	row := q.db.QueryRow(ctx, wmsFindPickBatch, id)
	var i WmsFindPickBatchRow
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.WarehouseID,
		&i.Status,
		&i.Strategy,
		&i.Priority,
		&i.AssignedUserID,
		&i.WaveID,
		&i.ZoneRestrictions,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.TotalItems,
		&i.CompletedItems,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PickBatchItems,
		&i.WmsWarehouse.ID,
		&i.WmsWarehouse.Name,
		&i.WmsWarehouse.Address,
		&i.WmsWarehouse.City,
		&i.WmsWarehouse.State,
		&i.WmsWarehouse.PostalCode,
		&i.WmsWarehouse.Country,
		&i.WmsWarehouse.Timezone,
		&i.WmsWarehouse.ContactPerson,
		&i.WmsWarehouse.ContactEmail,
		&i.WmsWarehouse.ContactPhone,
		&i.WmsWarehouse.IsActive,
		&i.WmsWarehouse.CreatedAt,
		&i.WmsWarehouse.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const wmsInsertPickBatch = `-- name: WmsInsertPickBatch :one
insert into "wms"."pick_batches"(batch_number, warehouse_id, status, strategy, priority, assigned_user_id, wave_id, zone_restrictions, estimated_duration, actual_duration, total_items, completed_items, started_at, completed_at)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
returning
  id, batch_number, warehouse_id, status, strategy, priority, assigned_user_id, wave_id, zone_restrictions, estimated_duration, actual_duration, total_items, completed_items, started_at, completed_at, created_at, updated_at
`

type WmsInsertPickBatchParams struct {
	BatchNumber       string                     `db:"batch_number" fake:"{uuid}" json:"batch_number"`
	WarehouseID       pgtype.UUID                `db:"warehouse_id" json:"warehouse_id"`
	Status            NullWmsPickBatchStatusEnum `db:"status" json:"status"`
	Strategy          WmsPickStrategyEnum        `db:"strategy" json:"strategy"`
	Priority          pgtype.Int4                `db:"priority" fake:"{number:1,100}" json:"priority"`
	AssignedUserID    pgtype.Text                `db:"assigned_user_id" json:"assigned_user_id"`
	WaveID            pgtype.Text                `db:"wave_id" fake:"{uuid}" json:"wave_id"`
	ZoneRestrictions  []string                   `db:"zone_restrictions" json:"zone_restrictions"`
	EstimatedDuration pgtype.Int4                `db:"estimated_duration" fake:"{number:30,120}" json:"estimated_duration"`
	ActualDuration    pgtype.Int4                `db:"actual_duration" fake:"{number:30,120}" json:"actual_duration"`
	TotalItems        pgtype.Int4                `db:"total_items" fake:"{number:10,100}" json:"total_items"`
	CompletedItems    pgtype.Int4                `db:"completed_items" fake:"{number:0,10}" json:"completed_items"`
	StartedAt         pgtype.Timestamp           `db:"started_at" fake:"{date}" json:"started_at"`
	CompletedAt       pgtype.Timestamp           `db:"completed_at" fake:"{date}" json:"completed_at"`
}

func (q *Queries) WmsInsertPickBatch(ctx context.Context, arg WmsInsertPickBatchParams) (WmsPickBatch, error) {
	row := q.db.QueryRow(ctx, wmsInsertPickBatch,
		arg.BatchNumber,
		arg.WarehouseID,
		arg.Status,
		arg.Strategy,
		arg.Priority,
		arg.AssignedUserID,
		arg.WaveID,
		arg.ZoneRestrictions,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.TotalItems,
		arg.CompletedItems,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i WmsPickBatch
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.WarehouseID,
		&i.Status,
		&i.Strategy,
		&i.Priority,
		&i.AssignedUserID,
		&i.WaveID,
		&i.ZoneRestrictions,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.TotalItems,
		&i.CompletedItems,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginatePickBatch = `-- name: WmsPaginatePickBatch :many
select
  pick_batches.id, pick_batches.batch_number, pick_batches.warehouse_id, pick_batches.status, pick_batches.strategy, pick_batches.priority, pick_batches.assigned_user_id, pick_batches.wave_id, pick_batches.zone_restrictions, pick_batches.estimated_duration, pick_batches.actual_duration, pick_batches.total_items, pick_batches.completed_items, pick_batches.started_at, pick_batches.completed_at, pick_batches.created_at, pick_batches.updated_at, pick_batches.pick_batch_items,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  assigned_user.id, assigned_user.name, assigned_user.email, assigned_user.email_verified, assigned_user.image, assigned_user.created_at, assigned_user.updated_at, assigned_user.role, assigned_user.banned, assigned_user.ban_reason, assigned_user.ban_expires
from
  "wms"."pick_batches_view" as pick_batches
  inner join "wms"."warehouses" as warehouse on pick_batches.warehouse_id = warehouse.id
  left join "public"."user" as assigned_user on pick_batches.assigned_user_id = assigned_user.id
where (warehouse.name ilike $1::text
  or pick_batches.batch_number ilike $1::text
  or pick_batches.status::text ilike $1::text
  or assigned_user.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginatePickBatchParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type WmsPaginatePickBatchRow struct {
	ID                pgtype.UUID                `db:"id" json:"id"`
	BatchNumber       string                     `db:"batch_number" json:"batch_number"`
	WarehouseID       pgtype.UUID                `db:"warehouse_id" json:"warehouse_id"`
	Status            NullWmsPickBatchStatusEnum `db:"status" json:"status"`
	Strategy          WmsPickStrategyEnum        `db:"strategy" json:"strategy"`
	Priority          pgtype.Int4                `db:"priority" json:"priority"`
	AssignedUserID    pgtype.Text                `db:"assigned_user_id" json:"assigned_user_id"`
	WaveID            pgtype.Text                `db:"wave_id" json:"wave_id"`
	ZoneRestrictions  []string                   `db:"zone_restrictions" json:"zone_restrictions"`
	EstimatedDuration pgtype.Int4                `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4                `db:"actual_duration" json:"actual_duration"`
	TotalItems        pgtype.Int4                `db:"total_items" json:"total_items"`
	CompletedItems    pgtype.Int4                `db:"completed_items" json:"completed_items"`
	StartedAt         pgtype.Timestamp           `db:"started_at" json:"started_at"`
	CompletedAt       pgtype.Timestamp           `db:"completed_at" json:"completed_at"`
	CreatedAt         pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	PickBatchItems    []WmsPickBatchItem         `db:"pick_batch_items" json:"pick_batch_items"`
	WmsWarehouse      WmsWarehouse               `db:"wms_warehouse" json:"wms_warehouse"`
	User              User                       `db:"user" json:"user"`
}

func (q *Queries) WmsPaginatePickBatch(ctx context.Context, arg WmsPaginatePickBatchParams) ([]WmsPaginatePickBatchRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginatePickBatch, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginatePickBatchRow
	for rows.Next() {
		var i WmsPaginatePickBatchRow
		if err := rows.Scan(
			&i.ID,
			&i.BatchNumber,
			&i.WarehouseID,
			&i.Status,
			&i.Strategy,
			&i.Priority,
			&i.AssignedUserID,
			&i.WaveID,
			&i.ZoneRestrictions,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.TotalItems,
			&i.CompletedItems,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PickBatchItems,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsPaginatePickBatchMetadata = `-- name: WmsPaginatePickBatchMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "wms"."pick_batches_view" as pick_batches
`

type WmsPaginatePickBatchMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type WmsPaginatePickBatchMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) WmsPaginatePickBatchMetadata(ctx context.Context, arg WmsPaginatePickBatchMetadataParams) (WmsPaginatePickBatchMetadataRow, error) {
	row := q.db.QueryRow(ctx, wmsPaginatePickBatchMetadata, arg.PerPage, arg.Page)
	var i WmsPaginatePickBatchMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const wmsRangePickBatch = `-- name: WmsRangePickBatch :many
select
  pick_batches.id, pick_batches.batch_number, pick_batches.warehouse_id, pick_batches.status, pick_batches.strategy, pick_batches.priority, pick_batches.assigned_user_id, pick_batches.wave_id, pick_batches.zone_restrictions, pick_batches.estimated_duration, pick_batches.actual_duration, pick_batches.total_items, pick_batches.completed_items, pick_batches.started_at, pick_batches.completed_at, pick_batches.created_at, pick_batches.updated_at, pick_batches.pick_batch_items,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  assigned_user.id, assigned_user.name, assigned_user.email, assigned_user.email_verified, assigned_user.image, assigned_user.created_at, assigned_user.updated_at, assigned_user.role, assigned_user.banned, assigned_user.ban_reason, assigned_user.ban_expires
from
  "wms"."pick_batches_view" as pick_batches
  inner join "wms"."warehouses" as warehouse on pick_batches.warehouse_id = warehouse.id
  left join "public"."user" as assigned_user on pick_batches.assigned_user_id = assigned_user.id
where
  pick_batches.created_at >= $1::date
  and pick_batches.created_at <= $2::date
  and (warehouse.name ilike $3::text
    or pick_batches.batch_number ilike $3::text
    or pick_batches.status::text ilike $3::text
    or assigned_user.name ilike $3::text
    or $3::text is null)
`

type WmsRangePickBatchParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangePickBatchRow struct {
	ID                pgtype.UUID                `db:"id" json:"id"`
	BatchNumber       string                     `db:"batch_number" json:"batch_number"`
	WarehouseID       pgtype.UUID                `db:"warehouse_id" json:"warehouse_id"`
	Status            NullWmsPickBatchStatusEnum `db:"status" json:"status"`
	Strategy          WmsPickStrategyEnum        `db:"strategy" json:"strategy"`
	Priority          pgtype.Int4                `db:"priority" json:"priority"`
	AssignedUserID    pgtype.Text                `db:"assigned_user_id" json:"assigned_user_id"`
	WaveID            pgtype.Text                `db:"wave_id" json:"wave_id"`
	ZoneRestrictions  []string                   `db:"zone_restrictions" json:"zone_restrictions"`
	EstimatedDuration pgtype.Int4                `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4                `db:"actual_duration" json:"actual_duration"`
	TotalItems        pgtype.Int4                `db:"total_items" json:"total_items"`
	CompletedItems    pgtype.Int4                `db:"completed_items" json:"completed_items"`
	StartedAt         pgtype.Timestamp           `db:"started_at" json:"started_at"`
	CompletedAt       pgtype.Timestamp           `db:"completed_at" json:"completed_at"`
	CreatedAt         pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	PickBatchItems    []WmsPickBatchItem         `db:"pick_batch_items" json:"pick_batch_items"`
	WmsWarehouse      WmsWarehouse               `db:"wms_warehouse" json:"wms_warehouse"`
	User              User                       `db:"user" json:"user"`
}

func (q *Queries) WmsRangePickBatch(ctx context.Context, arg WmsRangePickBatchParams) ([]WmsRangePickBatchRow, error) {
	rows, err := q.db.Query(ctx, wmsRangePickBatch, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangePickBatchRow
	for rows.Next() {
		var i WmsRangePickBatchRow
		if err := rows.Scan(
			&i.ID,
			&i.BatchNumber,
			&i.WarehouseID,
			&i.Status,
			&i.Strategy,
			&i.Priority,
			&i.AssignedUserID,
			&i.WaveID,
			&i.ZoneRestrictions,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.TotalItems,
			&i.CompletedItems,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PickBatchItems,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemovePickBatch = `-- name: WmsRemovePickBatch :exec
delete from "wms"."pick_batches"
where id = $1::uuid
`

func (q *Queries) WmsRemovePickBatch(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemovePickBatch, id)
	return err
}

const wmsUpdatePickBatch = `-- name: WmsUpdatePickBatch :one
update
  "wms"."pick_batches"
set
  updated_at = now(),
  batch_number = case when $1 is not null then
    $1::varchar
  else
    batch_number
  end,
  warehouse_id = case when $2 is not null then
    $2::uuid
  else
    warehouse_id
  end,
  status = case when $3 is not null then
    $3::wms.pick_batch_status_enum
  else
    status
  end,
  strategy = case when $4 is not null then
    $4::wms.pick_strategy_enum
  else
    strategy
  end,
  priority = case when $5 is not null then
    $5::integer
  else
    priority
  end,
  assigned_user_id = case when $6 is not null then
    $6::text
  else
    assigned_user_id
  end,
  wave_id = case when $7 is not null then
    $7::varchar
  else
    wave_id
  end,
  zone_restrictions = case when $8 is not null then
    $8::text[]
  else
    zone_restrictions
  end,
  estimated_duration = case when $9 is not null then
    $9::integer
  else
    estimated_duration
  end,
  actual_duration = case when $10 is not null then
    $10::integer
  else
    actual_duration
  end,
  total_items = case when $11 is not null then
    $11::integer
  else
    total_items
  end,
  completed_items = case when $12 is not null then
    $12::integer
  else
    completed_items
  end,
  started_at = case when $13 is not null then
    $13::timestamp
  else
    started_at
  end,
  completed_at = case when $14 is not null then
    $14::timestamp
  else
    completed_at
  end
where
  id = $15::uuid
returning
  id, batch_number, warehouse_id, status, strategy, priority, assigned_user_id, wave_id, zone_restrictions, estimated_duration, actual_duration, total_items, completed_items, started_at, completed_at, created_at, updated_at
`

type WmsUpdatePickBatchParams struct {
	BatchNumber       string                     `db:"batch_number" fake:"{uuid}" json:"batch_number"`
	WarehouseID       pgtype.UUID                `db:"warehouse_id" json:"warehouse_id"`
	Status            NullWmsPickBatchStatusEnum `db:"status" json:"status"`
	Strategy          WmsPickStrategyEnum        `db:"strategy" json:"strategy"`
	Priority          pgtype.Int4                `db:"priority" fake:"{number:1,100}" json:"priority"`
	AssignedUserID    pgtype.Text                `db:"assigned_user_id" json:"assigned_user_id"`
	WaveID            pgtype.Text                `db:"wave_id" fake:"{uuid}" json:"wave_id"`
	ZoneRestrictions  []string                   `db:"zone_restrictions" json:"zone_restrictions"`
	EstimatedDuration pgtype.Int4                `db:"estimated_duration" fake:"{number:30,120}" json:"estimated_duration"`
	ActualDuration    pgtype.Int4                `db:"actual_duration" fake:"{number:30,120}" json:"actual_duration"`
	TotalItems        pgtype.Int4                `db:"total_items" fake:"{number:10,100}" json:"total_items"`
	CompletedItems    pgtype.Int4                `db:"completed_items" fake:"{number:0,10}" json:"completed_items"`
	StartedAt         pgtype.Timestamp           `db:"started_at" fake:"{date}" json:"started_at"`
	CompletedAt       pgtype.Timestamp           `db:"completed_at" fake:"{date}" json:"completed_at"`
	ID                pgtype.UUID                `db:"id" json:"id"`
}

func (q *Queries) WmsUpdatePickBatch(ctx context.Context, arg WmsUpdatePickBatchParams) (WmsPickBatch, error) {
	row := q.db.QueryRow(ctx, wmsUpdatePickBatch,
		arg.BatchNumber,
		arg.WarehouseID,
		arg.Status,
		arg.Strategy,
		arg.Priority,
		arg.AssignedUserID,
		arg.WaveID,
		arg.ZoneRestrictions,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.TotalItems,
		arg.CompletedItems,
		arg.StartedAt,
		arg.CompletedAt,
		arg.ID,
	)
	var i WmsPickBatch
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.WarehouseID,
		&i.Status,
		&i.Strategy,
		&i.Priority,
		&i.AssignedUserID,
		&i.WaveID,
		&i.ZoneRestrictions,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.TotalItems,
		&i.CompletedItems,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
