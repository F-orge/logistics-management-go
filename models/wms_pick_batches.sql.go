// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_pick_batches.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyPickBatch = `-- name: WmsAnyPickBatch :many
select
  pick_batches.id, pick_batches.batch_number, pick_batches.warehouse_id, pick_batches.status, pick_batches.strategy, pick_batches.priority, pick_batches.assigned_user_id, pick_batches.wave_id, pick_batches.zone_restrictions, pick_batches.estimated_duration, pick_batches.actual_duration, pick_batches.total_items, pick_batches.completed_items, pick_batches.started_at, pick_batches.completed_at, pick_batches.created_at, pick_batches.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  assigned_user.id, assigned_user.name, assigned_user.email, assigned_user.email_verified, assigned_user.image, assigned_user.created_at, assigned_user.updated_at, assigned_user.role, assigned_user.banned, assigned_user.ban_reason, assigned_user.ban_expires
from
  "wms"."pick_batches" as pick_batches
  inner join "wms"."warehouses" as warehouse on pick_batches.warehouse_id = warehouse.id
  left join "public"."user" as assigned_user on pick_batches.assigned_user_id = assigned_user.id
where
  pick_batches.id = any ($1::uuid[])
`

type WmsAnyPickBatchRow struct {
	WmsPickBatch WmsPickBatch
	WmsWarehouse WmsWarehouse
	User         User
}

func (q *Queries) WmsAnyPickBatch(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyPickBatchRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyPickBatch, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyPickBatchRow
	for rows.Next() {
		var i WmsAnyPickBatchRow
		if err := rows.Scan(
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindPickBatch = `-- name: WmsFindPickBatch :one
select
  pick_batches.id, pick_batches.batch_number, pick_batches.warehouse_id, pick_batches.status, pick_batches.strategy, pick_batches.priority, pick_batches.assigned_user_id, pick_batches.wave_id, pick_batches.zone_restrictions, pick_batches.estimated_duration, pick_batches.actual_duration, pick_batches.total_items, pick_batches.completed_items, pick_batches.started_at, pick_batches.completed_at, pick_batches.created_at, pick_batches.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  assigned_user.id, assigned_user.name, assigned_user.email, assigned_user.email_verified, assigned_user.image, assigned_user.created_at, assigned_user.updated_at, assigned_user.role, assigned_user.banned, assigned_user.ban_reason, assigned_user.ban_expires
from
  "wms"."pick_batches" as pick_batches
  inner join "wms"."warehouses" as warehouse on pick_batches.warehouse_id = warehouse.id
  left join "public"."user" as assigned_user on pick_batches.assigned_user_id = assigned_user.id
where
  pick_batches.id = $1::uuid
`

type WmsFindPickBatchRow struct {
	WmsPickBatch WmsPickBatch
	WmsWarehouse WmsWarehouse
	User         User
}

func (q *Queries) WmsFindPickBatch(ctx context.Context, id pgtype.UUID) (WmsFindPickBatchRow, error) {
	row := q.db.QueryRow(ctx, wmsFindPickBatch, id)
	var i WmsFindPickBatchRow
	err := row.Scan(
		&i.WmsPickBatch.ID,
		&i.WmsPickBatch.BatchNumber,
		&i.WmsPickBatch.WarehouseID,
		&i.WmsPickBatch.Status,
		&i.WmsPickBatch.Strategy,
		&i.WmsPickBatch.Priority,
		&i.WmsPickBatch.AssignedUserID,
		&i.WmsPickBatch.WaveID,
		&i.WmsPickBatch.ZoneRestrictions,
		&i.WmsPickBatch.EstimatedDuration,
		&i.WmsPickBatch.ActualDuration,
		&i.WmsPickBatch.TotalItems,
		&i.WmsPickBatch.CompletedItems,
		&i.WmsPickBatch.StartedAt,
		&i.WmsPickBatch.CompletedAt,
		&i.WmsPickBatch.CreatedAt,
		&i.WmsPickBatch.UpdatedAt,
		&i.WmsWarehouse.ID,
		&i.WmsWarehouse.Name,
		&i.WmsWarehouse.Address,
		&i.WmsWarehouse.City,
		&i.WmsWarehouse.State,
		&i.WmsWarehouse.PostalCode,
		&i.WmsWarehouse.Country,
		&i.WmsWarehouse.Timezone,
		&i.WmsWarehouse.ContactPerson,
		&i.WmsWarehouse.ContactEmail,
		&i.WmsWarehouse.ContactPhone,
		&i.WmsWarehouse.IsActive,
		&i.WmsWarehouse.CreatedAt,
		&i.WmsWarehouse.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const wmsInsertPickBatch = `-- name: WmsInsertPickBatch :one
insert into "wms"."pick_batches"(batch_number, warehouse_id, status, strategy, priority, assigned_user_id, wave_id, zone_restrictions, estimated_duration, actual_duration, total_items, completed_items, started_at, completed_at)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
returning
  id, batch_number, warehouse_id, status, strategy, priority, assigned_user_id, wave_id, zone_restrictions, estimated_duration, actual_duration, total_items, completed_items, started_at, completed_at, created_at, updated_at
`

type WmsInsertPickBatchParams struct {
	BatchNumber       string
	WarehouseID       pgtype.UUID
	Status            NullWmsPickBatchStatusEnum
	Strategy          WmsPickStrategyEnum
	Priority          pgtype.Int4
	AssignedUserID    pgtype.Text
	WaveID            pgtype.Text
	ZoneRestrictions  []string
	EstimatedDuration pgtype.Int4
	ActualDuration    pgtype.Int4
	TotalItems        pgtype.Int4
	CompletedItems    pgtype.Int4
	StartedAt         pgtype.Timestamp
	CompletedAt       pgtype.Timestamp
}

func (q *Queries) WmsInsertPickBatch(ctx context.Context, arg WmsInsertPickBatchParams) (WmsPickBatch, error) {
	row := q.db.QueryRow(ctx, wmsInsertPickBatch,
		arg.BatchNumber,
		arg.WarehouseID,
		arg.Status,
		arg.Strategy,
		arg.Priority,
		arg.AssignedUserID,
		arg.WaveID,
		arg.ZoneRestrictions,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.TotalItems,
		arg.CompletedItems,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i WmsPickBatch
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.WarehouseID,
		&i.Status,
		&i.Strategy,
		&i.Priority,
		&i.AssignedUserID,
		&i.WaveID,
		&i.ZoneRestrictions,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.TotalItems,
		&i.CompletedItems,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginatePickBatch = `-- name: WmsPaginatePickBatch :many
select
  pick_batches.id, pick_batches.batch_number, pick_batches.warehouse_id, pick_batches.status, pick_batches.strategy, pick_batches.priority, pick_batches.assigned_user_id, pick_batches.wave_id, pick_batches.zone_restrictions, pick_batches.estimated_duration, pick_batches.actual_duration, pick_batches.total_items, pick_batches.completed_items, pick_batches.started_at, pick_batches.completed_at, pick_batches.created_at, pick_batches.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  assigned_user.id, assigned_user.name, assigned_user.email, assigned_user.email_verified, assigned_user.image, assigned_user.created_at, assigned_user.updated_at, assigned_user.role, assigned_user.banned, assigned_user.ban_reason, assigned_user.ban_expires
from
  "wms"."pick_batches" as pick_batches
  inner join "wms"."warehouses" as warehouse on pick_batches.warehouse_id = warehouse.id
  left join "public"."user" as assigned_user on pick_batches.assigned_user_id = assigned_user.id
where (warehouse.name ilike $1::text
  or pick_batches.batch_number ilike $1::text
  or pick_batches.status::text ilike $1::text
  or assigned_user.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginatePickBatchParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginatePickBatchRow struct {
	WmsPickBatch WmsPickBatch
	WmsWarehouse WmsWarehouse
	User         User
}

func (q *Queries) WmsPaginatePickBatch(ctx context.Context, arg WmsPaginatePickBatchParams) ([]WmsPaginatePickBatchRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginatePickBatch, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginatePickBatchRow
	for rows.Next() {
		var i WmsPaginatePickBatchRow
		if err := rows.Scan(
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangePickBatch = `-- name: WmsRangePickBatch :many
select
  pick_batches.id, pick_batches.batch_number, pick_batches.warehouse_id, pick_batches.status, pick_batches.strategy, pick_batches.priority, pick_batches.assigned_user_id, pick_batches.wave_id, pick_batches.zone_restrictions, pick_batches.estimated_duration, pick_batches.actual_duration, pick_batches.total_items, pick_batches.completed_items, pick_batches.started_at, pick_batches.completed_at, pick_batches.created_at, pick_batches.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  assigned_user.id, assigned_user.name, assigned_user.email, assigned_user.email_verified, assigned_user.image, assigned_user.created_at, assigned_user.updated_at, assigned_user.role, assigned_user.banned, assigned_user.ban_reason, assigned_user.ban_expires
from
  "wms"."pick_batches" as pick_batches
  inner join "wms"."warehouses" as warehouse on pick_batches.warehouse_id = warehouse.id
  left join "public"."user" as assigned_user on pick_batches.assigned_user_id = assigned_user.id
where
  pick_batches.created_at >= $1::date
  and pick_batches.created_at <= $2::date
  and (warehouse.name ilike $3::text
    or pick_batches.batch_number ilike $3::text
    or pick_batches.status::text ilike $3::text
    or assigned_user.name ilike $3::text
    or $3::text is null)
`

type WmsRangePickBatchParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangePickBatchRow struct {
	WmsPickBatch WmsPickBatch
	WmsWarehouse WmsWarehouse
	User         User
}

func (q *Queries) WmsRangePickBatch(ctx context.Context, arg WmsRangePickBatchParams) ([]WmsRangePickBatchRow, error) {
	rows, err := q.db.Query(ctx, wmsRangePickBatch, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangePickBatchRow
	for rows.Next() {
		var i WmsRangePickBatchRow
		if err := rows.Scan(
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemovePickBatch = `-- name: WmsRemovePickBatch :exec
delete from "wms"."pick_batches"
where id = $1::uuid
`

func (q *Queries) WmsRemovePickBatch(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemovePickBatch, id)
	return err
}

const wmsUpdatePickBatch = `-- name: WmsUpdatePickBatch :one
update
  "wms"."pick_batches"
set
  updated_at = now(),
  batch_number = case when $1 is not null then
    $1::varchar
  else
    batch_number
  end,
  warehouse_id = case when $2 is not null then
    $2::uuid
  else
    warehouse_id
  end,
  status = case when $3 is not null then
    $3::wms.pick_batch_status_enum
  else
    status
  end,
  strategy = case when $4 is not null then
    $4::wms.pick_strategy_enum
  else
    strategy
  end,
  priority = case when $5 is not null then
    $5::integer
  else
    priority
  end,
  assigned_user_id = case when $6 is not null then
    $6::text
  else
    assigned_user_id
  end,
  wave_id = case when $7 is not null then
    $7::varchar
  else
    wave_id
  end,
  zone_restrictions = case when $8 is not null then
    $8::text[]
  else
    zone_restrictions
  end,
  estimated_duration = case when $9 is not null then
    $9::integer
  else
    estimated_duration
  end,
  actual_duration = case when $10 is not null then
    $10::integer
  else
    actual_duration
  end,
  total_items = case when $11 is not null then
    $11::integer
  else
    total_items
  end,
  completed_items = case when $12 is not null then
    $12::integer
  else
    completed_items
  end,
  started_at = case when $13 is not null then
    $13::timestamp
  else
    started_at
  end,
  completed_at = case when $14 is not null then
    $14::timestamp
  else
    completed_at
  end
where
  id = $15::uuid
returning
  id, batch_number, warehouse_id, status, strategy, priority, assigned_user_id, wave_id, zone_restrictions, estimated_duration, actual_duration, total_items, completed_items, started_at, completed_at, created_at, updated_at
`

type WmsUpdatePickBatchParams struct {
	BatchNumber       string
	WarehouseID       pgtype.UUID
	Status            NullWmsPickBatchStatusEnum
	Strategy          WmsPickStrategyEnum
	Priority          pgtype.Int4
	AssignedUserID    pgtype.Text
	WaveID            pgtype.Text
	ZoneRestrictions  []string
	EstimatedDuration pgtype.Int4
	ActualDuration    pgtype.Int4
	TotalItems        pgtype.Int4
	CompletedItems    pgtype.Int4
	StartedAt         pgtype.Timestamp
	CompletedAt       pgtype.Timestamp
	ID                pgtype.UUID
}

func (q *Queries) WmsUpdatePickBatch(ctx context.Context, arg WmsUpdatePickBatchParams) (WmsPickBatch, error) {
	row := q.db.QueryRow(ctx, wmsUpdatePickBatch,
		arg.BatchNumber,
		arg.WarehouseID,
		arg.Status,
		arg.Strategy,
		arg.Priority,
		arg.AssignedUserID,
		arg.WaveID,
		arg.ZoneRestrictions,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.TotalItems,
		arg.CompletedItems,
		arg.StartedAt,
		arg.CompletedAt,
		arg.ID,
	)
	var i WmsPickBatch
	err := row.Scan(
		&i.ID,
		&i.BatchNumber,
		&i.WarehouseID,
		&i.Status,
		&i.Strategy,
		&i.Priority,
		&i.AssignedUserID,
		&i.WaveID,
		&i.ZoneRestrictions,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.TotalItems,
		&i.CompletedItems,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
