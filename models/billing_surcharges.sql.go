// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_surcharges.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnySurcharge = `-- name: BillingAnySurcharge :many
select
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
from
  "billing"."surcharges"
where
  id = any ($1::uuid[])
`

func (q *Queries) BillingAnySurcharge(ctx context.Context, ids []pgtype.UUID) ([]BillingSurcharge, error) {
	rows, err := q.db.Query(ctx, billingAnySurcharge, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingSurcharge
	for rows.Next() {
		var i BillingSurcharge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Amount,
			&i.CalculationMethod,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindSurcharge = `-- name: BillingFindSurcharge :one
select
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
from
  "billing"."surcharges"
where
  id = $1::uuid
`

func (q *Queries) BillingFindSurcharge(ctx context.Context, id pgtype.UUID) (BillingSurcharge, error) {
	row := q.db.QueryRow(ctx, billingFindSurcharge, id)
	var i BillingSurcharge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.CalculationMethod,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingInsertSurcharge = `-- name: BillingInsertSurcharge :one
insert into "billing"."surcharges"(name, type, amount, calculation_method, is_active, valid_from, valid_to, description)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
`

type BillingInsertSurchargeParams struct {
	Name              string
	Type              string
	Amount            pgtype.Numeric
	CalculationMethod BillingSurchargeCalculationMethodEnum
	IsActive          pgtype.Bool
	ValidFrom         pgtype.Date
	ValidTo           pgtype.Date
	Description       pgtype.Text
}

func (q *Queries) BillingInsertSurcharge(ctx context.Context, arg BillingInsertSurchargeParams) (BillingSurcharge, error) {
	row := q.db.QueryRow(ctx, billingInsertSurcharge,
		arg.Name,
		arg.Type,
		arg.Amount,
		arg.CalculationMethod,
		arg.IsActive,
		arg.ValidFrom,
		arg.ValidTo,
		arg.Description,
	)
	var i BillingSurcharge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.CalculationMethod,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateSurcharge = `-- name: BillingPaginateSurcharge :many
select
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
from
  "billing"."surcharges"
limit $2::int offset ($1::int - 1) * $2::int
`

type BillingPaginateSurchargeParams struct {
	Page    int32
	Perpage int32
}

func (q *Queries) BillingPaginateSurcharge(ctx context.Context, arg BillingPaginateSurchargeParams) ([]BillingSurcharge, error) {
	rows, err := q.db.Query(ctx, billingPaginateSurcharge, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingSurcharge
	for rows.Next() {
		var i BillingSurcharge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Amount,
			&i.CalculationMethod,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeSurcharge = `-- name: BillingRangeSurcharge :many
select
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
from
  "billing"."surcharges"
where
  created_at >= $1::date
  and created_at <= $2::date
`

type BillingRangeSurchargeParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

func (q *Queries) BillingRangeSurcharge(ctx context.Context, arg BillingRangeSurchargeParams) ([]BillingSurcharge, error) {
	rows, err := q.db.Query(ctx, billingRangeSurcharge, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingSurcharge
	for rows.Next() {
		var i BillingSurcharge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Amount,
			&i.CalculationMethod,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveSurcharge = `-- name: BillingRemoveSurcharge :exec
delete from "billing"."surcharges"
where id = $1::uuid
`

func (q *Queries) BillingRemoveSurcharge(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveSurcharge, id)
	return err
}

const billingUpdateSurcharge = `-- name: BillingUpdateSurcharge :one
update
  "billing"."surcharges"
set
  name = case when $1::boolean then
    $2::varchar
  else
    name
  end,
  type = case when $3::boolean then
    $4::varchar
  else
    type
  end,
  amount = case when $5::boolean then
    $6::numeric
  else
    amount
  end,
  calculation_method = case when $7::boolean then
    $8::billing.surcharge_calculation_method_enum
  else
    calculation_method
  end,
  is_active = case when $9::boolean then
    $10::boolean
  else
    is_active
  end,
  valid_from = case when $11::boolean then
    $12::date
  else
    valid_from
  end,
  valid_to = case when $13::boolean then
    $14::date
  else
    valid_to
  end,
  description = case when $15::boolean then
    $16::text
  else
    description
  end
where
  id = $17::uuid
returning
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
`

type BillingUpdateSurchargeParams struct {
	SetName              bool
	Name                 string
	SetType              bool
	Type                 string
	SetAmount            bool
	Amount               pgtype.Numeric
	SetCalculationMethod bool
	CalculationMethod    BillingSurchargeCalculationMethodEnum
	SetIsActive          bool
	IsActive             bool
	SetValidFrom         bool
	ValidFrom            pgtype.Date
	SetValidTo           bool
	ValidTo              pgtype.Date
	SetDescription       bool
	Description          string
	ID                   pgtype.UUID
}

func (q *Queries) BillingUpdateSurcharge(ctx context.Context, arg BillingUpdateSurchargeParams) (BillingSurcharge, error) {
	row := q.db.QueryRow(ctx, billingUpdateSurcharge,
		arg.SetName,
		arg.Name,
		arg.SetType,
		arg.Type,
		arg.SetAmount,
		arg.Amount,
		arg.SetCalculationMethod,
		arg.CalculationMethod,
		arg.SetIsActive,
		arg.IsActive,
		arg.SetValidFrom,
		arg.ValidFrom,
		arg.SetValidTo,
		arg.ValidTo,
		arg.SetDescription,
		arg.Description,
		arg.ID,
	)
	var i BillingSurcharge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.CalculationMethod,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
