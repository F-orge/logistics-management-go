// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_surcharges.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnySurcharge = `-- name: BillingAnySurcharge :many
select
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
from
  "billing"."surcharges"
where
  id = any ($1::uuid[])
`

func (q *Queries) BillingAnySurcharge(ctx context.Context, ids []pgtype.UUID) ([]BillingSurcharge, error) {
	rows, err := q.db.Query(ctx, billingAnySurcharge, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingSurcharge
	for rows.Next() {
		var i BillingSurcharge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Amount,
			&i.CalculationMethod,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindSurcharge = `-- name: BillingFindSurcharge :one
select
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
from
  "billing"."surcharges"
where
  id = $1::uuid
`

func (q *Queries) BillingFindSurcharge(ctx context.Context, id pgtype.UUID) (BillingSurcharge, error) {
	row := q.db.QueryRow(ctx, billingFindSurcharge, id)
	var i BillingSurcharge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.CalculationMethod,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingInsertSurcharge = `-- name: BillingInsertSurcharge :one
insert into "billing"."surcharges"(name, type, amount, calculation_method, is_active, valid_from, valid_to, description)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
`

type BillingInsertSurchargeParams struct {
	Name              string                                `db:"name" json:"name"`
	Type              string                                `db:"type" json:"type"`
	Amount            pgtype.Numeric                        `db:"amount" json:"amount"`
	CalculationMethod BillingSurchargeCalculationMethodEnum `db:"calculation_method" json:"calculation_method"`
	IsActive          pgtype.Bool                           `db:"is_active" json:"is_active"`
	ValidFrom         pgtype.Date                           `db:"valid_from" json:"valid_from"`
	ValidTo           pgtype.Date                           `db:"valid_to" json:"valid_to"`
	Description       pgtype.Text                           `db:"description" json:"description"`
}

func (q *Queries) BillingInsertSurcharge(ctx context.Context, arg BillingInsertSurchargeParams) (BillingSurcharge, error) {
	row := q.db.QueryRow(ctx, billingInsertSurcharge,
		arg.Name,
		arg.Type,
		arg.Amount,
		arg.CalculationMethod,
		arg.IsActive,
		arg.ValidFrom,
		arg.ValidTo,
		arg.Description,
	)
	var i BillingSurcharge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.CalculationMethod,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateSurcharge = `-- name: BillingPaginateSurcharge :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page,
  surcharges.id, surcharges.name, surcharges.type, surcharges.amount, surcharges.calculation_method, surcharges.is_active, surcharges.valid_from, surcharges.valid_to, surcharges.description, surcharges.created_at, surcharges.updated_at
from
  "billing"."surcharges" as surcharges
where (name ilike $3::text
  or type ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type BillingPaginateSurchargeParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type BillingPaginateSurchargeRow struct {
	TotalItems       int64            `db:"total_items" json:"total_items"`
	TotalPages       float64          `db:"total_pages" json:"total_pages"`
	Page             int32            `db:"page" json:"page"`
	PerPage          int32            `db:"per_page" json:"per_page"`
	BillingSurcharge BillingSurcharge `db:"billing_surcharge" json:"billing_surcharge"`
}

func (q *Queries) BillingPaginateSurcharge(ctx context.Context, arg BillingPaginateSurchargeParams) ([]BillingPaginateSurchargeRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateSurcharge, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateSurchargeRow
	for rows.Next() {
		var i BillingPaginateSurchargeRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.BillingSurcharge.ID,
			&i.BillingSurcharge.Name,
			&i.BillingSurcharge.Type,
			&i.BillingSurcharge.Amount,
			&i.BillingSurcharge.CalculationMethod,
			&i.BillingSurcharge.IsActive,
			&i.BillingSurcharge.ValidFrom,
			&i.BillingSurcharge.ValidTo,
			&i.BillingSurcharge.Description,
			&i.BillingSurcharge.CreatedAt,
			&i.BillingSurcharge.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeSurcharge = `-- name: BillingRangeSurcharge :many
select
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
from
  "billing"."surcharges"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (name ilike $3::text
    or type ilike $3::text
    or $3::text is null)
`

type BillingRangeSurchargeParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) BillingRangeSurcharge(ctx context.Context, arg BillingRangeSurchargeParams) ([]BillingSurcharge, error) {
	rows, err := q.db.Query(ctx, billingRangeSurcharge, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingSurcharge
	for rows.Next() {
		var i BillingSurcharge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Amount,
			&i.CalculationMethod,
			&i.IsActive,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveSurcharge = `-- name: BillingRemoveSurcharge :exec
delete from "billing"."surcharges"
where id = $1::uuid
`

func (q *Queries) BillingRemoveSurcharge(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveSurcharge, id)
	return err
}

const billingUpdateSurcharge = `-- name: BillingUpdateSurcharge :one
update
  "billing"."surcharges"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::varchar
  else
    name
  end,
  type = case when $2 is not null then
    $2::varchar
  else
    type
  end,
  amount = case when $3 is not null then
    $3::numeric
  else
    amount
  end,
  calculation_method = case when $4 is not null then
    $4::billing.surcharge_calculation_method_enum
  else
    calculation_method
  end,
  is_active = case when $5 is not null then
    $5::boolean
  else
    is_active
  end,
  valid_from = case when $6 is not null then
    $6::date
  else
    valid_from
  end,
  valid_to = case when $7 is not null then
    $7::date
  else
    valid_to
  end,
  description = case when $8 is not null then
    $8::text
  else
    description
  end
where
  id = $9::uuid
returning
  id, name, type, amount, calculation_method, is_active, valid_from, valid_to, description, created_at, updated_at
`

type BillingUpdateSurchargeParams struct {
	Name              string                                `db:"name" json:"name"`
	Type              string                                `db:"type" json:"type"`
	Amount            pgtype.Numeric                        `db:"amount" json:"amount"`
	CalculationMethod BillingSurchargeCalculationMethodEnum `db:"calculation_method" json:"calculation_method"`
	IsActive          pgtype.Bool                           `db:"is_active" json:"is_active"`
	ValidFrom         pgtype.Date                           `db:"valid_from" json:"valid_from"`
	ValidTo           pgtype.Date                           `db:"valid_to" json:"valid_to"`
	Description       pgtype.Text                           `db:"description" json:"description"`
	ID                pgtype.UUID                           `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateSurcharge(ctx context.Context, arg BillingUpdateSurchargeParams) (BillingSurcharge, error) {
	row := q.db.QueryRow(ctx, billingUpdateSurcharge,
		arg.Name,
		arg.Type,
		arg.Amount,
		arg.CalculationMethod,
		arg.IsActive,
		arg.ValidFrom,
		arg.ValidTo,
		arg.Description,
		arg.ID,
	)
	var i BillingSurcharge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.CalculationMethod,
		&i.IsActive,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
