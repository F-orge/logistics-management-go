// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_partner_invoices.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyPartnerInvoice = `-- name: TmsAnyPartnerInvoice :many
select
  partner_invoices.id, partner_invoices.carrier_id, partner_invoices.invoice_number, partner_invoices.invoice_date, partner_invoices.total_amount, partner_invoices.status, partner_invoices.created_at, partner_invoices.updated_at, partner_invoices.partner_invoice_items,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone
from
  "tms"."partner_invoices_view" as partner_invoices
  inner join "tms"."carriers" as carrier on partner_invoices.carrier_id = carrier.id
where
  partner_invoices.id = any ($1::uuid[])
`

type TmsAnyPartnerInvoiceRow struct {
	TmsPartnerInvoicesView TmsPartnerInvoicesView `db:"tms_partner_invoices_view" json:"tms_partner_invoices_view"`
	TmsCarrier             TmsCarrier             `db:"tms_carrier" json:"tms_carrier"`
}

func (q *Queries) TmsAnyPartnerInvoice(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyPartnerInvoiceRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyPartnerInvoice, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyPartnerInvoiceRow
	for rows.Next() {
		var i TmsAnyPartnerInvoiceRow
		if err := rows.Scan(
			&i.TmsPartnerInvoicesView.ID,
			&i.TmsPartnerInvoicesView.CarrierID,
			&i.TmsPartnerInvoicesView.InvoiceNumber,
			&i.TmsPartnerInvoicesView.InvoiceDate,
			&i.TmsPartnerInvoicesView.TotalAmount,
			&i.TmsPartnerInvoicesView.Status,
			&i.TmsPartnerInvoicesView.CreatedAt,
			&i.TmsPartnerInvoicesView.UpdatedAt,
			&i.TmsPartnerInvoicesView.PartnerInvoiceItems,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindPartnerInvoice = `-- name: TmsFindPartnerInvoice :one
select
  partner_invoices.id, partner_invoices.carrier_id, partner_invoices.invoice_number, partner_invoices.invoice_date, partner_invoices.total_amount, partner_invoices.status, partner_invoices.created_at, partner_invoices.updated_at, partner_invoices.partner_invoice_items,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone
from
  "tms"."partner_invoices_view" as partner_invoices
  inner join "tms"."carriers" as carrier on partner_invoices.carrier_id = carrier.id
where
  partner_invoices.id = $1::uuid
`

type TmsFindPartnerInvoiceRow struct {
	TmsPartnerInvoicesView TmsPartnerInvoicesView `db:"tms_partner_invoices_view" json:"tms_partner_invoices_view"`
	TmsCarrier             TmsCarrier             `db:"tms_carrier" json:"tms_carrier"`
}

func (q *Queries) TmsFindPartnerInvoice(ctx context.Context, id pgtype.UUID) (TmsFindPartnerInvoiceRow, error) {
	row := q.db.QueryRow(ctx, tmsFindPartnerInvoice, id)
	var i TmsFindPartnerInvoiceRow
	err := row.Scan(
		&i.TmsPartnerInvoicesView.ID,
		&i.TmsPartnerInvoicesView.CarrierID,
		&i.TmsPartnerInvoicesView.InvoiceNumber,
		&i.TmsPartnerInvoicesView.InvoiceDate,
		&i.TmsPartnerInvoicesView.TotalAmount,
		&i.TmsPartnerInvoicesView.Status,
		&i.TmsPartnerInvoicesView.CreatedAt,
		&i.TmsPartnerInvoicesView.UpdatedAt,
		&i.TmsPartnerInvoicesView.PartnerInvoiceItems,
		&i.TmsCarrier.ID,
		&i.TmsCarrier.Name,
		&i.TmsCarrier.ContactDetails,
		&i.TmsCarrier.ServicesOffered,
		&i.TmsCarrier.CreatedAt,
		&i.TmsCarrier.UpdatedAt,
		&i.TmsCarrier.ContactPerson,
		&i.TmsCarrier.ContactEmail,
		&i.TmsCarrier.ContactPhone,
	)
	return i, err
}

const tmsInsertPartnerInvoice = `-- name: TmsInsertPartnerInvoice :one
insert into "tms"."partner_invoices"(carrier_id, invoice_number, invoice_date, total_amount, status)
  values ($1, $2, $3, $4, $5)
returning
  id, carrier_id, invoice_number, invoice_date, total_amount, status, created_at, updated_at
`

type TmsInsertPartnerInvoiceParams struct {
	CarrierID     pgtype.UUID                     `db:"carrier_id" json:"carrier_id"`
	InvoiceNumber string                          `db:"invoice_number" json:"invoice_number"`
	InvoiceDate   pgtype.Date                     `db:"invoice_date" json:"invoice_date"`
	TotalAmount   pgtype.Numeric                  `db:"total_amount" json:"total_amount"`
	Status        NullTmsPartnerInvoiceStatusEnum `db:"status" json:"status"`
}

func (q *Queries) TmsInsertPartnerInvoice(ctx context.Context, arg TmsInsertPartnerInvoiceParams) (TmsPartnerInvoice, error) {
	row := q.db.QueryRow(ctx, tmsInsertPartnerInvoice,
		arg.CarrierID,
		arg.InvoiceNumber,
		arg.InvoiceDate,
		arg.TotalAmount,
		arg.Status,
	)
	var i TmsPartnerInvoice
	err := row.Scan(
		&i.ID,
		&i.CarrierID,
		&i.InvoiceNumber,
		&i.InvoiceDate,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginatePartnerInvoice = `-- name: TmsPaginatePartnerInvoice :many
select
  partner_invoices.id, partner_invoices.carrier_id, partner_invoices.invoice_number, partner_invoices.invoice_date, partner_invoices.total_amount, partner_invoices.status, partner_invoices.created_at, partner_invoices.updated_at, partner_invoices.partner_invoice_items,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone
from
  "tms"."partner_invoices_view" as partner_invoices
  inner join "tms"."carriers" as carrier on partner_invoices.carrier_id = carrier.id
where (carrier.name ilike $1::text
  or partner_invoices.invoice_number ilike $1::text
  or partner_invoices.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginatePartnerInvoiceParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	Perpage int32       `db:"perpage" json:"perpage"`
}

type TmsPaginatePartnerInvoiceRow struct {
	TmsPartnerInvoicesView TmsPartnerInvoicesView `db:"tms_partner_invoices_view" json:"tms_partner_invoices_view"`
	TmsCarrier             TmsCarrier             `db:"tms_carrier" json:"tms_carrier"`
}

func (q *Queries) TmsPaginatePartnerInvoice(ctx context.Context, arg TmsPaginatePartnerInvoiceParams) ([]TmsPaginatePartnerInvoiceRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginatePartnerInvoice, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginatePartnerInvoiceRow
	for rows.Next() {
		var i TmsPaginatePartnerInvoiceRow
		if err := rows.Scan(
			&i.TmsPartnerInvoicesView.ID,
			&i.TmsPartnerInvoicesView.CarrierID,
			&i.TmsPartnerInvoicesView.InvoiceNumber,
			&i.TmsPartnerInvoicesView.InvoiceDate,
			&i.TmsPartnerInvoicesView.TotalAmount,
			&i.TmsPartnerInvoicesView.Status,
			&i.TmsPartnerInvoicesView.CreatedAt,
			&i.TmsPartnerInvoicesView.UpdatedAt,
			&i.TmsPartnerInvoicesView.PartnerInvoiceItems,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangePartnerInvoice = `-- name: TmsRangePartnerInvoice :many
select
  partner_invoices.id, partner_invoices.carrier_id, partner_invoices.invoice_number, partner_invoices.invoice_date, partner_invoices.total_amount, partner_invoices.status, partner_invoices.created_at, partner_invoices.updated_at, partner_invoices.partner_invoice_items,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone
from
  "tms"."partner_invoices_view" as partner_invoices
  inner join "tms"."carriers" as carrier on partner_invoices.carrier_id = carrier.id
where
  partner_invoices.invoice_date >= $1::date
  and partner_invoices.invoice_date <= $2::date
  and (carrier.name ilike $3::text
    or partner_invoices.invoice_number ilike $3::text
    or partner_invoices.status::text ilike $3::text
    or $3::text is null)
`

type TmsRangePartnerInvoiceParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangePartnerInvoiceRow struct {
	TmsPartnerInvoicesView TmsPartnerInvoicesView `db:"tms_partner_invoices_view" json:"tms_partner_invoices_view"`
	TmsCarrier             TmsCarrier             `db:"tms_carrier" json:"tms_carrier"`
}

func (q *Queries) TmsRangePartnerInvoice(ctx context.Context, arg TmsRangePartnerInvoiceParams) ([]TmsRangePartnerInvoiceRow, error) {
	rows, err := q.db.Query(ctx, tmsRangePartnerInvoice, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangePartnerInvoiceRow
	for rows.Next() {
		var i TmsRangePartnerInvoiceRow
		if err := rows.Scan(
			&i.TmsPartnerInvoicesView.ID,
			&i.TmsPartnerInvoicesView.CarrierID,
			&i.TmsPartnerInvoicesView.InvoiceNumber,
			&i.TmsPartnerInvoicesView.InvoiceDate,
			&i.TmsPartnerInvoicesView.TotalAmount,
			&i.TmsPartnerInvoicesView.Status,
			&i.TmsPartnerInvoicesView.CreatedAt,
			&i.TmsPartnerInvoicesView.UpdatedAt,
			&i.TmsPartnerInvoicesView.PartnerInvoiceItems,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemovePartnerInvoice = `-- name: TmsRemovePartnerInvoice :exec
delete from "tms"."partner_invoices"
where id = $1::uuid
`

func (q *Queries) TmsRemovePartnerInvoice(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemovePartnerInvoice, id)
	return err
}

const tmsUpdatePartnerInvoice = `-- name: TmsUpdatePartnerInvoice :one
update
  "tms"."partner_invoices"
set
  updated_at = now(),
  carrier_id = case when $1 is not null then
    $1::uuid
  else
    carrier_id
  end,
  invoice_number = case when $2 is not null then
    $2::varchar
  else
    invoice_number
  end,
  invoice_date = case when $3 is not null then
    $3::date
  else
    invoice_date
  end,
  total_amount = case when $4 is not null then
    $4::numeric
  else
    total_amount
  end,
  status = case when $5 is not null then
    $5::tms.partner_invoice_status_enum
  else
    status
  end
where
  id = $6::uuid
returning
  id, carrier_id, invoice_number, invoice_date, total_amount, status, created_at, updated_at
`

type TmsUpdatePartnerInvoiceParams struct {
	CarrierID     pgtype.UUID                     `db:"carrier_id" json:"carrier_id"`
	InvoiceNumber string                          `db:"invoice_number" json:"invoice_number"`
	InvoiceDate   pgtype.Date                     `db:"invoice_date" json:"invoice_date"`
	TotalAmount   pgtype.Numeric                  `db:"total_amount" json:"total_amount"`
	Status        NullTmsPartnerInvoiceStatusEnum `db:"status" json:"status"`
	ID            pgtype.UUID                     `db:"id" json:"id"`
}

func (q *Queries) TmsUpdatePartnerInvoice(ctx context.Context, arg TmsUpdatePartnerInvoiceParams) (TmsPartnerInvoice, error) {
	row := q.db.QueryRow(ctx, tmsUpdatePartnerInvoice,
		arg.CarrierID,
		arg.InvoiceNumber,
		arg.InvoiceDate,
		arg.TotalAmount,
		arg.Status,
		arg.ID,
	)
	var i TmsPartnerInvoice
	err := row.Scan(
		&i.ID,
		&i.CarrierID,
		&i.InvoiceNumber,
		&i.InvoiceDate,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
