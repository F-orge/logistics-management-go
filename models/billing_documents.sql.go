// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_documents.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyDocument = `-- name: BillingAnyDocument :many
select
  documents.id, documents.record_id, documents.record_type, documents.document_type, documents.file_path, documents.file_name, documents.file_size, documents.mime_type, documents.uploaded_by_user_id, documents.created_at, documents.updated_at,
  uploaded_by_user.id, uploaded_by_user.name, uploaded_by_user.email, uploaded_by_user.email_verified, uploaded_by_user.image, uploaded_by_user.created_at, uploaded_by_user.updated_at, uploaded_by_user.role, uploaded_by_user.banned, uploaded_by_user.ban_reason, uploaded_by_user.ban_expires
from
  "billing"."documents" as documents
  left join "public"."user" as uploaded_by_user on documents.uploaded_by_user_id = uploaded_by_user.id
where
  documents.id = any ($1::uuid[])
`

type BillingAnyDocumentRow struct {
	BillingDocument BillingDocument
	User            User
}

func (q *Queries) BillingAnyDocument(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyDocumentRow, error) {
	rows, err := q.db.Query(ctx, billingAnyDocument, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyDocumentRow
	for rows.Next() {
		var i BillingAnyDocumentRow
		if err := rows.Scan(
			&i.BillingDocument.ID,
			&i.BillingDocument.RecordID,
			&i.BillingDocument.RecordType,
			&i.BillingDocument.DocumentType,
			&i.BillingDocument.FilePath,
			&i.BillingDocument.FileName,
			&i.BillingDocument.FileSize,
			&i.BillingDocument.MimeType,
			&i.BillingDocument.UploadedByUserID,
			&i.BillingDocument.CreatedAt,
			&i.BillingDocument.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindDocument = `-- name: BillingFindDocument :one
select
  documents.id, documents.record_id, documents.record_type, documents.document_type, documents.file_path, documents.file_name, documents.file_size, documents.mime_type, documents.uploaded_by_user_id, documents.created_at, documents.updated_at,
  uploaded_by_user.id, uploaded_by_user.name, uploaded_by_user.email, uploaded_by_user.email_verified, uploaded_by_user.image, uploaded_by_user.created_at, uploaded_by_user.updated_at, uploaded_by_user.role, uploaded_by_user.banned, uploaded_by_user.ban_reason, uploaded_by_user.ban_expires
from
  "billing"."documents" as documents
  left join "public"."user" as uploaded_by_user on documents.uploaded_by_user_id = uploaded_by_user.id
where
  documents.id = $1::uuid
`

type BillingFindDocumentRow struct {
	BillingDocument BillingDocument
	User            User
}

func (q *Queries) BillingFindDocument(ctx context.Context, id pgtype.UUID) (BillingFindDocumentRow, error) {
	row := q.db.QueryRow(ctx, billingFindDocument, id)
	var i BillingFindDocumentRow
	err := row.Scan(
		&i.BillingDocument.ID,
		&i.BillingDocument.RecordID,
		&i.BillingDocument.RecordType,
		&i.BillingDocument.DocumentType,
		&i.BillingDocument.FilePath,
		&i.BillingDocument.FileName,
		&i.BillingDocument.FileSize,
		&i.BillingDocument.MimeType,
		&i.BillingDocument.UploadedByUserID,
		&i.BillingDocument.CreatedAt,
		&i.BillingDocument.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertDocument = `-- name: BillingInsertDocument :one
insert into "billing"."documents"(record_id, record_type, document_type, file_path, file_name, file_size, mime_type, uploaded_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, record_id, record_type, document_type, file_path, file_name, file_size, mime_type, uploaded_by_user_id, created_at, updated_at
`

type BillingInsertDocumentParams struct {
	RecordID         pgtype.UUID
	RecordType       string
	DocumentType     BillingDocumentTypeEnum
	FilePath         string
	FileName         string
	FileSize         pgtype.Int4
	MimeType         pgtype.Text
	UploadedByUserID pgtype.Text
}

func (q *Queries) BillingInsertDocument(ctx context.Context, arg BillingInsertDocumentParams) (BillingDocument, error) {
	row := q.db.QueryRow(ctx, billingInsertDocument,
		arg.RecordID,
		arg.RecordType,
		arg.DocumentType,
		arg.FilePath,
		arg.FileName,
		arg.FileSize,
		arg.MimeType,
		arg.UploadedByUserID,
	)
	var i BillingDocument
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.DocumentType,
		&i.FilePath,
		&i.FileName,
		&i.FileSize,
		&i.MimeType,
		&i.UploadedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateDocument = `-- name: BillingPaginateDocument :many
select
  documents.id, documents.record_id, documents.record_type, documents.document_type, documents.file_path, documents.file_name, documents.file_size, documents.mime_type, documents.uploaded_by_user_id, documents.created_at, documents.updated_at,
  uploaded_by_user.id, uploaded_by_user.name, uploaded_by_user.email, uploaded_by_user.email_verified, uploaded_by_user.image, uploaded_by_user.created_at, uploaded_by_user.updated_at, uploaded_by_user.role, uploaded_by_user.banned, uploaded_by_user.ban_reason, uploaded_by_user.ban_expires
from
  "billing"."documents" as documents
  left join "public"."user" as uploaded_by_user on documents.uploaded_by_user_id = uploaded_by_user.id
where
  (documents.file_name ilike $1::text
  or documents.record_type ilike $1::text
  or documents.document_type::text ilike $1::text
  or uploaded_by_user.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateDocumentParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type BillingPaginateDocumentRow struct {
	BillingDocument BillingDocument
	User            User
}

func (q *Queries) BillingPaginateDocument(ctx context.Context, arg BillingPaginateDocumentParams) ([]BillingPaginateDocumentRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateDocument, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateDocumentRow
	for rows.Next() {
		var i BillingPaginateDocumentRow
		if err := rows.Scan(
			&i.BillingDocument.ID,
			&i.BillingDocument.RecordID,
			&i.BillingDocument.RecordType,
			&i.BillingDocument.DocumentType,
			&i.BillingDocument.FilePath,
			&i.BillingDocument.FileName,
			&i.BillingDocument.FileSize,
			&i.BillingDocument.MimeType,
			&i.BillingDocument.UploadedByUserID,
			&i.BillingDocument.CreatedAt,
			&i.BillingDocument.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeDocument = `-- name: BillingRangeDocument :many
select
  documents.id, documents.record_id, documents.record_type, documents.document_type, documents.file_path, documents.file_name, documents.file_size, documents.mime_type, documents.uploaded_by_user_id, documents.created_at, documents.updated_at,
  uploaded_by_user.id, uploaded_by_user.name, uploaded_by_user.email, uploaded_by_user.email_verified, uploaded_by_user.image, uploaded_by_user.created_at, uploaded_by_user.updated_at, uploaded_by_user.role, uploaded_by_user.banned, uploaded_by_user.ban_reason, uploaded_by_user.ban_expires
from
  "billing"."documents" as documents
  left join "public"."user" as uploaded_by_user on documents.uploaded_by_user_id = uploaded_by_user.id
where
  documents.created_at >= $1::date
  and documents.created_at <= $2::date
  and (documents.file_name ilike $3::text
  or documents.record_type ilike $3::text
  or documents.document_type::text ilike $3::text
  or uploaded_by_user.name ilike $3::text
  or $3::text is null)
`

type BillingRangeDocumentParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type BillingRangeDocumentRow struct {
	BillingDocument BillingDocument
	User            User
}

func (q *Queries) BillingRangeDocument(ctx context.Context, arg BillingRangeDocumentParams) ([]BillingRangeDocumentRow, error) {
	rows, err := q.db.Query(ctx, billingRangeDocument, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeDocumentRow
	for rows.Next() {
		var i BillingRangeDocumentRow
		if err := rows.Scan(
			&i.BillingDocument.ID,
			&i.BillingDocument.RecordID,
			&i.BillingDocument.RecordType,
			&i.BillingDocument.DocumentType,
			&i.BillingDocument.FilePath,
			&i.BillingDocument.FileName,
			&i.BillingDocument.FileSize,
			&i.BillingDocument.MimeType,
			&i.BillingDocument.UploadedByUserID,
			&i.BillingDocument.CreatedAt,
			&i.BillingDocument.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveDocument = `-- name: BillingRemoveDocument :exec
delete from "billing"."documents"
where id = $1::uuid
`

func (q *Queries) BillingRemoveDocument(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveDocument, id)
	return err
}

const billingUpdateDocument = `-- name: BillingUpdateDocument :one
update
  "billing"."documents"
set
  updated_at = now(),
  record_id = case when $1::boolean then
    $2::uuid
  else
    record_id
  end,
  record_type = case when $3::boolean then
    $4::varchar
  else
    record_type
  end,
  document_type = case when $5::boolean then
    $6::billing.document_type_enum
  else
    document_type
  end,
  file_path = case when $7::boolean then
    $8::varchar
  else
    file_path
  end,
  file_name = case when $9::boolean then
    $10::varchar
  else
    file_name
  end,
  file_size = case when $11::boolean then
    $12::integer
  else
    file_size
  end,
  mime_type = case when $13::boolean then
    $14::varchar
  else
    mime_type
  end,
  uploaded_by_user_id = case when $15::boolean then
    $16::text
  else
    uploaded_by_user_id
  end
where
  id = $17::uuid
returning
  id, record_id, record_type, document_type, file_path, file_name, file_size, mime_type, uploaded_by_user_id, created_at, updated_at
`

type BillingUpdateDocumentParams struct {
	SetRecordID         bool
	RecordID            pgtype.UUID
	SetRecordType       bool
	RecordType          string
	SetDocumentType     bool
	DocumentType        BillingDocumentTypeEnum
	SetFilePath         bool
	FilePath            string
	SetFileName         bool
	FileName            string
	SetFileSize         bool
	FileSize            int32
	SetMimeType         bool
	MimeType            string
	SetUploadedByUserID bool
	UploadedByUserID    string
	ID                  pgtype.UUID
}

func (q *Queries) BillingUpdateDocument(ctx context.Context, arg BillingUpdateDocumentParams) (BillingDocument, error) {
	row := q.db.QueryRow(ctx, billingUpdateDocument,
		arg.SetRecordID,
		arg.RecordID,
		arg.SetRecordType,
		arg.RecordType,
		arg.SetDocumentType,
		arg.DocumentType,
		arg.SetFilePath,
		arg.FilePath,
		arg.SetFileName,
		arg.FileName,
		arg.SetFileSize,
		arg.FileSize,
		arg.SetMimeType,
		arg.MimeType,
		arg.SetUploadedByUserID,
		arg.UploadedByUserID,
		arg.ID,
	)
	var i BillingDocument
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.DocumentType,
		&i.FilePath,
		&i.FileName,
		&i.FileSize,
		&i.MimeType,
		&i.UploadedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
