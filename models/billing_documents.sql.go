// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_documents.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyDocument = `-- name: BillingAnyDocument :many
select
  documents.id, documents.record_id, documents.record_type, documents.document_type, documents.file_path, documents.file_name, documents.file_size, documents.mime_type, documents.uploaded_by_user_id, documents.created_at, documents.updated_at,
  uploaded_by_user.id, uploaded_by_user.name, uploaded_by_user.email, uploaded_by_user.email_verified, uploaded_by_user.image, uploaded_by_user.created_at, uploaded_by_user.updated_at, uploaded_by_user.role, uploaded_by_user.banned, uploaded_by_user.ban_reason, uploaded_by_user.ban_expires
from
  "billing"."documents" as documents
  left join "public"."user" as uploaded_by_user on documents.uploaded_by_user_id = uploaded_by_user.id
where
  documents.id = any ($1::uuid[])
`

type BillingAnyDocumentRow struct {
	BillingDocument BillingDocument `db:"billing_document" json:"billing_document"`
	User            User            `db:"user" json:"user"`
}

func (q *Queries) BillingAnyDocument(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyDocumentRow, error) {
	rows, err := q.db.Query(ctx, billingAnyDocument, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyDocumentRow
	for rows.Next() {
		var i BillingAnyDocumentRow
		if err := rows.Scan(
			&i.BillingDocument.ID,
			&i.BillingDocument.RecordID,
			&i.BillingDocument.RecordType,
			&i.BillingDocument.DocumentType,
			&i.BillingDocument.FilePath,
			&i.BillingDocument.FileName,
			&i.BillingDocument.FileSize,
			&i.BillingDocument.MimeType,
			&i.BillingDocument.UploadedByUserID,
			&i.BillingDocument.CreatedAt,
			&i.BillingDocument.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindDocument = `-- name: BillingFindDocument :one
select
  documents.id, documents.record_id, documents.record_type, documents.document_type, documents.file_path, documents.file_name, documents.file_size, documents.mime_type, documents.uploaded_by_user_id, documents.created_at, documents.updated_at,
  uploaded_by_user.id, uploaded_by_user.name, uploaded_by_user.email, uploaded_by_user.email_verified, uploaded_by_user.image, uploaded_by_user.created_at, uploaded_by_user.updated_at, uploaded_by_user.role, uploaded_by_user.banned, uploaded_by_user.ban_reason, uploaded_by_user.ban_expires
from
  "billing"."documents" as documents
  left join "public"."user" as uploaded_by_user on documents.uploaded_by_user_id = uploaded_by_user.id
where
  documents.id = $1::uuid
`

type BillingFindDocumentRow struct {
	BillingDocument BillingDocument `db:"billing_document" json:"billing_document"`
	User            User            `db:"user" json:"user"`
}

func (q *Queries) BillingFindDocument(ctx context.Context, id pgtype.UUID) (BillingFindDocumentRow, error) {
	row := q.db.QueryRow(ctx, billingFindDocument, id)
	var i BillingFindDocumentRow
	err := row.Scan(
		&i.BillingDocument.ID,
		&i.BillingDocument.RecordID,
		&i.BillingDocument.RecordType,
		&i.BillingDocument.DocumentType,
		&i.BillingDocument.FilePath,
		&i.BillingDocument.FileName,
		&i.BillingDocument.FileSize,
		&i.BillingDocument.MimeType,
		&i.BillingDocument.UploadedByUserID,
		&i.BillingDocument.CreatedAt,
		&i.BillingDocument.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertDocument = `-- name: BillingInsertDocument :one
insert into "billing"."documents"(record_id, record_type, document_type, file_path, file_name, file_size, mime_type, uploaded_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, record_id, record_type, document_type, file_path, file_name, file_size, mime_type, uploaded_by_user_id, created_at, updated_at
`

type BillingInsertDocumentParams struct {
	RecordID         pgtype.UUID             `db:"record_id" json:"record_id"`
	RecordType       string                  `db:"record_type" json:"record_type"`
	DocumentType     BillingDocumentTypeEnum `db:"document_type" json:"document_type"`
	FilePath         string                  `db:"file_path" json:"file_path"`
	FileName         string                  `db:"file_name" json:"file_name"`
	FileSize         pgtype.Int4             `db:"file_size" json:"file_size"`
	MimeType         pgtype.Text             `db:"mime_type" json:"mime_type"`
	UploadedByUserID pgtype.Text             `db:"uploaded_by_user_id" json:"uploaded_by_user_id"`
}

func (q *Queries) BillingInsertDocument(ctx context.Context, arg BillingInsertDocumentParams) (BillingDocument, error) {
	row := q.db.QueryRow(ctx, billingInsertDocument,
		arg.RecordID,
		arg.RecordType,
		arg.DocumentType,
		arg.FilePath,
		arg.FileName,
		arg.FileSize,
		arg.MimeType,
		arg.UploadedByUserID,
	)
	var i BillingDocument
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.DocumentType,
		&i.FilePath,
		&i.FileName,
		&i.FileSize,
		&i.MimeType,
		&i.UploadedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateDocument = `-- name: BillingPaginateDocument :many
select
  documents.id, documents.record_id, documents.record_type, documents.document_type, documents.file_path, documents.file_name, documents.file_size, documents.mime_type, documents.uploaded_by_user_id, documents.created_at, documents.updated_at,
  uploaded_by_user.id, uploaded_by_user.name, uploaded_by_user.email, uploaded_by_user.email_verified, uploaded_by_user.image, uploaded_by_user.created_at, uploaded_by_user.updated_at, uploaded_by_user.role, uploaded_by_user.banned, uploaded_by_user.ban_reason, uploaded_by_user.ban_expires
from
  "billing"."documents" as documents
  left join "public"."user" as uploaded_by_user on documents.uploaded_by_user_id = uploaded_by_user.id
where (documents.file_name ilike $1::text
  or documents.record_type ilike $1::text
  or documents.document_type::text ilike $1::text
  or uploaded_by_user.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateDocumentParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	Perpage int32       `db:"perpage" json:"perpage"`
}

type BillingPaginateDocumentRow struct {
	BillingDocument BillingDocument `db:"billing_document" json:"billing_document"`
	User            User            `db:"user" json:"user"`
}

func (q *Queries) BillingPaginateDocument(ctx context.Context, arg BillingPaginateDocumentParams) ([]BillingPaginateDocumentRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateDocument, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateDocumentRow
	for rows.Next() {
		var i BillingPaginateDocumentRow
		if err := rows.Scan(
			&i.BillingDocument.ID,
			&i.BillingDocument.RecordID,
			&i.BillingDocument.RecordType,
			&i.BillingDocument.DocumentType,
			&i.BillingDocument.FilePath,
			&i.BillingDocument.FileName,
			&i.BillingDocument.FileSize,
			&i.BillingDocument.MimeType,
			&i.BillingDocument.UploadedByUserID,
			&i.BillingDocument.CreatedAt,
			&i.BillingDocument.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeDocument = `-- name: BillingRangeDocument :many
select
  documents.id, documents.record_id, documents.record_type, documents.document_type, documents.file_path, documents.file_name, documents.file_size, documents.mime_type, documents.uploaded_by_user_id, documents.created_at, documents.updated_at,
  uploaded_by_user.id, uploaded_by_user.name, uploaded_by_user.email, uploaded_by_user.email_verified, uploaded_by_user.image, uploaded_by_user.created_at, uploaded_by_user.updated_at, uploaded_by_user.role, uploaded_by_user.banned, uploaded_by_user.ban_reason, uploaded_by_user.ban_expires
from
  "billing"."documents" as documents
  left join "public"."user" as uploaded_by_user on documents.uploaded_by_user_id = uploaded_by_user.id
where
  documents.created_at >= $1::date
  and documents.created_at <= $2::date
  and (documents.file_name ilike $3::text
    or documents.record_type ilike $3::text
    or documents.document_type::text ilike $3::text
    or uploaded_by_user.name ilike $3::text
    or $3::text is null)
`

type BillingRangeDocumentParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type BillingRangeDocumentRow struct {
	BillingDocument BillingDocument `db:"billing_document" json:"billing_document"`
	User            User            `db:"user" json:"user"`
}

func (q *Queries) BillingRangeDocument(ctx context.Context, arg BillingRangeDocumentParams) ([]BillingRangeDocumentRow, error) {
	rows, err := q.db.Query(ctx, billingRangeDocument, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeDocumentRow
	for rows.Next() {
		var i BillingRangeDocumentRow
		if err := rows.Scan(
			&i.BillingDocument.ID,
			&i.BillingDocument.RecordID,
			&i.BillingDocument.RecordType,
			&i.BillingDocument.DocumentType,
			&i.BillingDocument.FilePath,
			&i.BillingDocument.FileName,
			&i.BillingDocument.FileSize,
			&i.BillingDocument.MimeType,
			&i.BillingDocument.UploadedByUserID,
			&i.BillingDocument.CreatedAt,
			&i.BillingDocument.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveDocument = `-- name: BillingRemoveDocument :exec
delete from "billing"."documents"
where id = $1::uuid
`

func (q *Queries) BillingRemoveDocument(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveDocument, id)
	return err
}

const billingUpdateDocument = `-- name: BillingUpdateDocument :one
update
  "billing"."documents"
set
  updated_at = now(),
  record_id = case when $1 is not null then
    $1::uuid
  else
    record_id
  end,
  record_type = case when $2 is not null then
    $2::varchar
  else
    record_type
  end,
  document_type = case when $3 is not null then
    $3::billing.document_type_enum
  else
    document_type
  end,
  file_path = case when $4 is not null then
    $4::varchar
  else
    file_path
  end,
  file_name = case when $5 is not null then
    $5::varchar
  else
    file_name
  end,
  file_size = case when $6 is not null then
    $6::integer
  else
    file_size
  end,
  mime_type = case when $7 is not null then
    $7::varchar
  else
    mime_type
  end,
  uploaded_by_user_id = case when $8 is not null then
    $8::text
  else
    uploaded_by_user_id
  end
where
  id = $9::uuid
returning
  id, record_id, record_type, document_type, file_path, file_name, file_size, mime_type, uploaded_by_user_id, created_at, updated_at
`

type BillingUpdateDocumentParams struct {
	RecordID         pgtype.UUID             `db:"record_id" json:"record_id"`
	RecordType       string                  `db:"record_type" json:"record_type"`
	DocumentType     BillingDocumentTypeEnum `db:"document_type" json:"document_type"`
	FilePath         string                  `db:"file_path" json:"file_path"`
	FileName         string                  `db:"file_name" json:"file_name"`
	FileSize         pgtype.Int4             `db:"file_size" json:"file_size"`
	MimeType         pgtype.Text             `db:"mime_type" json:"mime_type"`
	UploadedByUserID pgtype.Text             `db:"uploaded_by_user_id" json:"uploaded_by_user_id"`
	ID               pgtype.UUID             `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateDocument(ctx context.Context, arg BillingUpdateDocumentParams) (BillingDocument, error) {
	row := q.db.QueryRow(ctx, billingUpdateDocument,
		arg.RecordID,
		arg.RecordType,
		arg.DocumentType,
		arg.FilePath,
		arg.FileName,
		arg.FileSize,
		arg.MimeType,
		arg.UploadedByUserID,
		arg.ID,
	)
	var i BillingDocument
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.DocumentType,
		&i.FilePath,
		&i.FileName,
		&i.FileSize,
		&i.MimeType,
		&i.UploadedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
