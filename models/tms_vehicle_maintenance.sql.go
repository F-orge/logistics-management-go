// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_vehicle_maintenance.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyVehicleMaintenance = `-- name: TmsAnyVehicleMaintenance :many
select
  vehicle_maintenance.id, vehicle_maintenance.vehicle_id, vehicle_maintenance.service_date, vehicle_maintenance.service_type, vehicle_maintenance.cost, vehicle_maintenance.notes, vehicle_maintenance.created_at, vehicle_maintenance.updated_at,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."vehicle_maintenance" as vehicle_maintenance
  inner join "tms"."vehicles" as vehicle on vehicle_maintenance.vehicle_id = vehicle.id
where
  vehicle_maintenance.id = any ($1::uuid[])
`

type TmsAnyVehicleMaintenanceRow struct {
	TmsVehicleMaintenance TmsVehicleMaintenance
	TmsVehicle            TmsVehicle
}

func (q *Queries) TmsAnyVehicleMaintenance(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyVehicleMaintenanceRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyVehicleMaintenance, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyVehicleMaintenanceRow
	for rows.Next() {
		var i TmsAnyVehicleMaintenanceRow
		if err := rows.Scan(
			&i.TmsVehicleMaintenance.ID,
			&i.TmsVehicleMaintenance.VehicleID,
			&i.TmsVehicleMaintenance.ServiceDate,
			&i.TmsVehicleMaintenance.ServiceType,
			&i.TmsVehicleMaintenance.Cost,
			&i.TmsVehicleMaintenance.Notes,
			&i.TmsVehicleMaintenance.CreatedAt,
			&i.TmsVehicleMaintenance.UpdatedAt,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindVehicleMaintenance = `-- name: TmsFindVehicleMaintenance :one
select
  vehicle_maintenance.id, vehicle_maintenance.vehicle_id, vehicle_maintenance.service_date, vehicle_maintenance.service_type, vehicle_maintenance.cost, vehicle_maintenance.notes, vehicle_maintenance.created_at, vehicle_maintenance.updated_at,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."vehicle_maintenance" as vehicle_maintenance
  inner join "tms"."vehicles" as vehicle on vehicle_maintenance.vehicle_id = vehicle.id
where
  vehicle_maintenance.id = $1::uuid
`

type TmsFindVehicleMaintenanceRow struct {
	TmsVehicleMaintenance TmsVehicleMaintenance
	TmsVehicle            TmsVehicle
}

func (q *Queries) TmsFindVehicleMaintenance(ctx context.Context, id pgtype.UUID) (TmsFindVehicleMaintenanceRow, error) {
	row := q.db.QueryRow(ctx, tmsFindVehicleMaintenance, id)
	var i TmsFindVehicleMaintenanceRow
	err := row.Scan(
		&i.TmsVehicleMaintenance.ID,
		&i.TmsVehicleMaintenance.VehicleID,
		&i.TmsVehicleMaintenance.ServiceDate,
		&i.TmsVehicleMaintenance.ServiceType,
		&i.TmsVehicleMaintenance.Cost,
		&i.TmsVehicleMaintenance.Notes,
		&i.TmsVehicleMaintenance.CreatedAt,
		&i.TmsVehicleMaintenance.UpdatedAt,
		&i.TmsVehicle.ID,
		&i.TmsVehicle.RegistrationNumber,
		&i.TmsVehicle.Model,
		&i.TmsVehicle.CapacityVolume,
		&i.TmsVehicle.CapacityWeight,
		&i.TmsVehicle.Status,
		&i.TmsVehicle.CreatedAt,
		&i.TmsVehicle.UpdatedAt,
		&i.TmsVehicle.Make,
		&i.TmsVehicle.Year,
		&i.TmsVehicle.Vin,
		&i.TmsVehicle.CurrentMileage,
		&i.TmsVehicle.LastMaintenanceDate,
	)
	return i, err
}

const tmsInsertVehicleMaintenance = `-- name: TmsInsertVehicleMaintenance :one
insert into "tms"."vehicle_maintenance"(vehicle_id, service_date, service_type, cost, notes)
  values ($1, $2, $3, $4, $5)
returning
  id, vehicle_id, service_date, service_type, cost, notes, created_at, updated_at
`

type TmsInsertVehicleMaintenanceParams struct {
	VehicleID   pgtype.UUID
	ServiceDate pgtype.Date
	ServiceType NullTmsVehicleServiceTypeEnum
	Cost        pgtype.Numeric
	Notes       pgtype.Text
}

func (q *Queries) TmsInsertVehicleMaintenance(ctx context.Context, arg TmsInsertVehicleMaintenanceParams) (TmsVehicleMaintenance, error) {
	row := q.db.QueryRow(ctx, tmsInsertVehicleMaintenance,
		arg.VehicleID,
		arg.ServiceDate,
		arg.ServiceType,
		arg.Cost,
		arg.Notes,
	)
	var i TmsVehicleMaintenance
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.ServiceDate,
		&i.ServiceType,
		&i.Cost,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateVehicleMaintenance = `-- name: TmsPaginateVehicleMaintenance :many
select
  vehicle_maintenance.id, vehicle_maintenance.vehicle_id, vehicle_maintenance.service_date, vehicle_maintenance.service_type, vehicle_maintenance.cost, vehicle_maintenance.notes, vehicle_maintenance.created_at, vehicle_maintenance.updated_at,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."vehicle_maintenance" as vehicle_maintenance
  inner join "tms"."vehicles" as vehicle on vehicle_maintenance.vehicle_id = vehicle.id
where
  (vehicle.registration_number ilike $1::text
  or vehicle_maintenance.service_type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateVehicleMaintenanceParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type TmsPaginateVehicleMaintenanceRow struct {
	TmsVehicleMaintenance TmsVehicleMaintenance
	TmsVehicle            TmsVehicle
}

func (q *Queries) TmsPaginateVehicleMaintenance(ctx context.Context, arg TmsPaginateVehicleMaintenanceParams) ([]TmsPaginateVehicleMaintenanceRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateVehicleMaintenance, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateVehicleMaintenanceRow
	for rows.Next() {
		var i TmsPaginateVehicleMaintenanceRow
		if err := rows.Scan(
			&i.TmsVehicleMaintenance.ID,
			&i.TmsVehicleMaintenance.VehicleID,
			&i.TmsVehicleMaintenance.ServiceDate,
			&i.TmsVehicleMaintenance.ServiceType,
			&i.TmsVehicleMaintenance.Cost,
			&i.TmsVehicleMaintenance.Notes,
			&i.TmsVehicleMaintenance.CreatedAt,
			&i.TmsVehicleMaintenance.UpdatedAt,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeVehicleMaintenance = `-- name: TmsRangeVehicleMaintenance :many
select
  vehicle_maintenance.id, vehicle_maintenance.vehicle_id, vehicle_maintenance.service_date, vehicle_maintenance.service_type, vehicle_maintenance.cost, vehicle_maintenance.notes, vehicle_maintenance.created_at, vehicle_maintenance.updated_at,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."vehicle_maintenance" as vehicle_maintenance
  inner join "tms"."vehicles" as vehicle on vehicle_maintenance.vehicle_id = vehicle.id
where
  vehicle_maintenance.created_at >= $1::date
  and vehicle_maintenance.created_at <= $2::date
  and (vehicle.registration_number ilike $3::text
  or vehicle_maintenance.service_type::text ilike $3::text
  or $3::text is null)
`

type TmsRangeVehicleMaintenanceParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type TmsRangeVehicleMaintenanceRow struct {
	TmsVehicleMaintenance TmsVehicleMaintenance
	TmsVehicle            TmsVehicle
}

func (q *Queries) TmsRangeVehicleMaintenance(ctx context.Context, arg TmsRangeVehicleMaintenanceParams) ([]TmsRangeVehicleMaintenanceRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeVehicleMaintenance, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeVehicleMaintenanceRow
	for rows.Next() {
		var i TmsRangeVehicleMaintenanceRow
		if err := rows.Scan(
			&i.TmsVehicleMaintenance.ID,
			&i.TmsVehicleMaintenance.VehicleID,
			&i.TmsVehicleMaintenance.ServiceDate,
			&i.TmsVehicleMaintenance.ServiceType,
			&i.TmsVehicleMaintenance.Cost,
			&i.TmsVehicleMaintenance.Notes,
			&i.TmsVehicleMaintenance.CreatedAt,
			&i.TmsVehicleMaintenance.UpdatedAt,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveVehicleMaintenance = `-- name: TmsRemoveVehicleMaintenance :exec
delete from "tms"."vehicle_maintenance"
where id = $1::uuid
`

func (q *Queries) TmsRemoveVehicleMaintenance(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveVehicleMaintenance, id)
	return err
}

const tmsUpdateVehicleMaintenance = `-- name: TmsUpdateVehicleMaintenance :one
update
  "tms"."vehicle_maintenance"
set
  vehicle_id = case when $1::boolean then
    $2::uuid
  else
    vehicle_id
  end,
  service_date = case when $3::boolean then
    $4::date
  else
    service_date
  end,
  service_type = case when $5::boolean then
    $6::tms.vehicle_service_type_enum
  else
    service_type
  end,
  cost = case when $7::boolean then
    $8::numeric
  else
    cost
  end,
  notes = case when $9::boolean then
    $10::text
  else
    notes
  end
where
  id = $11::uuid
returning
  id, vehicle_id, service_date, service_type, cost, notes, created_at, updated_at
`

type TmsUpdateVehicleMaintenanceParams struct {
	SetVehicleID   bool
	VehicleID      pgtype.UUID
	SetServiceDate bool
	ServiceDate    pgtype.Date
	SetServiceType bool
	ServiceType    TmsVehicleServiceTypeEnum
	SetCost        bool
	Cost           pgtype.Numeric
	SetNotes       bool
	Notes          string
	ID             pgtype.UUID
}

func (q *Queries) TmsUpdateVehicleMaintenance(ctx context.Context, arg TmsUpdateVehicleMaintenanceParams) (TmsVehicleMaintenance, error) {
	row := q.db.QueryRow(ctx, tmsUpdateVehicleMaintenance,
		arg.SetVehicleID,
		arg.VehicleID,
		arg.SetServiceDate,
		arg.ServiceDate,
		arg.SetServiceType,
		arg.ServiceType,
		arg.SetCost,
		arg.Cost,
		arg.SetNotes,
		arg.Notes,
		arg.ID,
	)
	var i TmsVehicleMaintenance
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.ServiceDate,
		&i.ServiceType,
		&i.Cost,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
