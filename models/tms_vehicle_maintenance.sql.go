// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_vehicle_maintenance.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyVehicleMaintenance = `-- name: TmsAnyVehicleMaintenance :many
select
  vehicle_maintenance.id, vehicle_maintenance.vehicle_id, vehicle_maintenance.service_date, vehicle_maintenance.service_type, vehicle_maintenance.cost, vehicle_maintenance.notes, vehicle_maintenance.created_at, vehicle_maintenance.updated_at,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."vehicle_maintenance" as vehicle_maintenance
  inner join "tms"."vehicles" as vehicle on vehicle_maintenance.vehicle_id = vehicle.id
where
  vehicle_maintenance.id = any ($1::uuid[])
`

type TmsAnyVehicleMaintenanceRow struct {
	ID          pgtype.UUID                   `db:"id" json:"id"`
	VehicleID   pgtype.UUID                   `db:"vehicle_id" json:"vehicle_id"`
	ServiceDate pgtype.Date                   `db:"service_date" json:"service_date"`
	ServiceType NullTmsVehicleServiceTypeEnum `db:"service_type" json:"service_type"`
	Cost        pgtype.Numeric                `db:"cost" json:"cost"`
	Notes       pgtype.Text                   `db:"notes" json:"notes"`
	CreatedAt   pgtype.Timestamp              `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp              `db:"updated_at" json:"updated_at"`
	TmsVehicle  TmsVehicle                    `db:"tms_vehicle" json:"tms_vehicle"`
}

func (q *Queries) TmsAnyVehicleMaintenance(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyVehicleMaintenanceRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyVehicleMaintenance, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyVehicleMaintenanceRow
	for rows.Next() {
		var i TmsAnyVehicleMaintenanceRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.ServiceDate,
			&i.ServiceType,
			&i.Cost,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindVehicleMaintenance = `-- name: TmsFindVehicleMaintenance :one
select
  vehicle_maintenance.id, vehicle_maintenance.vehicle_id, vehicle_maintenance.service_date, vehicle_maintenance.service_type, vehicle_maintenance.cost, vehicle_maintenance.notes, vehicle_maintenance.created_at, vehicle_maintenance.updated_at,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."vehicle_maintenance" as vehicle_maintenance
  inner join "tms"."vehicles" as vehicle on vehicle_maintenance.vehicle_id = vehicle.id
where
  vehicle_maintenance.id = $1::uuid
`

type TmsFindVehicleMaintenanceRow struct {
	ID          pgtype.UUID                   `db:"id" json:"id"`
	VehicleID   pgtype.UUID                   `db:"vehicle_id" json:"vehicle_id"`
	ServiceDate pgtype.Date                   `db:"service_date" json:"service_date"`
	ServiceType NullTmsVehicleServiceTypeEnum `db:"service_type" json:"service_type"`
	Cost        pgtype.Numeric                `db:"cost" json:"cost"`
	Notes       pgtype.Text                   `db:"notes" json:"notes"`
	CreatedAt   pgtype.Timestamp              `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp              `db:"updated_at" json:"updated_at"`
	TmsVehicle  TmsVehicle                    `db:"tms_vehicle" json:"tms_vehicle"`
}

func (q *Queries) TmsFindVehicleMaintenance(ctx context.Context, id pgtype.UUID) (TmsFindVehicleMaintenanceRow, error) {
	row := q.db.QueryRow(ctx, tmsFindVehicleMaintenance, id)
	var i TmsFindVehicleMaintenanceRow
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.ServiceDate,
		&i.ServiceType,
		&i.Cost,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TmsVehicle.ID,
		&i.TmsVehicle.RegistrationNumber,
		&i.TmsVehicle.Model,
		&i.TmsVehicle.CapacityVolume,
		&i.TmsVehicle.CapacityWeight,
		&i.TmsVehicle.Status,
		&i.TmsVehicle.CreatedAt,
		&i.TmsVehicle.UpdatedAt,
		&i.TmsVehicle.Make,
		&i.TmsVehicle.Year,
		&i.TmsVehicle.Vin,
		&i.TmsVehicle.CurrentMileage,
		&i.TmsVehicle.LastMaintenanceDate,
	)
	return i, err
}

const tmsInsertVehicleMaintenance = `-- name: TmsInsertVehicleMaintenance :one
insert into "tms"."vehicle_maintenance"(vehicle_id, service_date, service_type, cost, notes)
  values ($1, $2, $3, $4, $5)
returning
  id, vehicle_id, service_date, service_type, cost, notes, created_at, updated_at
`

type TmsInsertVehicleMaintenanceParams struct {
	VehicleID   pgtype.UUID                   `db:"vehicle_id" json:"vehicle_id"`
	ServiceDate pgtype.Date                   `db:"service_date" json:"service_date"`
	ServiceType NullTmsVehicleServiceTypeEnum `db:"service_type" json:"service_type"`
	Cost        pgtype.Numeric                `db:"cost" json:"cost"`
	Notes       pgtype.Text                   `db:"notes" json:"notes"`
}

func (q *Queries) TmsInsertVehicleMaintenance(ctx context.Context, arg TmsInsertVehicleMaintenanceParams) (TmsVehicleMaintenance, error) {
	row := q.db.QueryRow(ctx, tmsInsertVehicleMaintenance,
		arg.VehicleID,
		arg.ServiceDate,
		arg.ServiceType,
		arg.Cost,
		arg.Notes,
	)
	var i TmsVehicleMaintenance
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.ServiceDate,
		&i.ServiceType,
		&i.Cost,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateVehicleMaintenance = `-- name: TmsPaginateVehicleMaintenance :many
select
  vehicle_maintenance.id, vehicle_maintenance.vehicle_id, vehicle_maintenance.service_date, vehicle_maintenance.service_type, vehicle_maintenance.cost, vehicle_maintenance.notes, vehicle_maintenance.created_at, vehicle_maintenance.updated_at,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."vehicle_maintenance" as vehicle_maintenance
  inner join "tms"."vehicles" as vehicle on vehicle_maintenance.vehicle_id = vehicle.id
where (vehicle.registration_number ilike $1::text
  or vehicle_maintenance.service_type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateVehicleMaintenanceParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type TmsPaginateVehicleMaintenanceRow struct {
	ID          pgtype.UUID                   `db:"id" json:"id"`
	VehicleID   pgtype.UUID                   `db:"vehicle_id" json:"vehicle_id"`
	ServiceDate pgtype.Date                   `db:"service_date" json:"service_date"`
	ServiceType NullTmsVehicleServiceTypeEnum `db:"service_type" json:"service_type"`
	Cost        pgtype.Numeric                `db:"cost" json:"cost"`
	Notes       pgtype.Text                   `db:"notes" json:"notes"`
	CreatedAt   pgtype.Timestamp              `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp              `db:"updated_at" json:"updated_at"`
	TmsVehicle  TmsVehicle                    `db:"tms_vehicle" json:"tms_vehicle"`
}

func (q *Queries) TmsPaginateVehicleMaintenance(ctx context.Context, arg TmsPaginateVehicleMaintenanceParams) ([]TmsPaginateVehicleMaintenanceRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateVehicleMaintenance, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateVehicleMaintenanceRow
	for rows.Next() {
		var i TmsPaginateVehicleMaintenanceRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.ServiceDate,
			&i.ServiceType,
			&i.Cost,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsPaginateVehicleMaintenanceMetadata = `-- name: TmsPaginateVehicleMaintenanceMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "tms"."vehicle_maintenance" as vehicle_maintenance
  inner join "tms"."vehicles" as vehicle on vehicle_maintenance.vehicle_id = vehicle.id
where (vehicle.registration_number ilike $3::text
  or vehicle_maintenance.service_type::text ilike $3::text
  or $3::text is null)
`

type TmsPaginateVehicleMaintenanceMetadataParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type TmsPaginateVehicleMaintenanceMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) TmsPaginateVehicleMaintenanceMetadata(ctx context.Context, arg TmsPaginateVehicleMaintenanceMetadataParams) (TmsPaginateVehicleMaintenanceMetadataRow, error) {
	row := q.db.QueryRow(ctx, tmsPaginateVehicleMaintenanceMetadata, arg.PerPage, arg.Page, arg.Search)
	var i TmsPaginateVehicleMaintenanceMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const tmsRangeVehicleMaintenance = `-- name: TmsRangeVehicleMaintenance :many
select
  vehicle_maintenance.id, vehicle_maintenance.vehicle_id, vehicle_maintenance.service_date, vehicle_maintenance.service_type, vehicle_maintenance.cost, vehicle_maintenance.notes, vehicle_maintenance.created_at, vehicle_maintenance.updated_at,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date
from
  "tms"."vehicle_maintenance" as vehicle_maintenance
  inner join "tms"."vehicles" as vehicle on vehicle_maintenance.vehicle_id = vehicle.id
where
  vehicle_maintenance.created_at >= $1::date
  and vehicle_maintenance.created_at <= $2::date
  and (vehicle.registration_number ilike $3::text
    or vehicle_maintenance.service_type::text ilike $3::text
    or $3::text is null)
`

type TmsRangeVehicleMaintenanceParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeVehicleMaintenanceRow struct {
	ID          pgtype.UUID                   `db:"id" json:"id"`
	VehicleID   pgtype.UUID                   `db:"vehicle_id" json:"vehicle_id"`
	ServiceDate pgtype.Date                   `db:"service_date" json:"service_date"`
	ServiceType NullTmsVehicleServiceTypeEnum `db:"service_type" json:"service_type"`
	Cost        pgtype.Numeric                `db:"cost" json:"cost"`
	Notes       pgtype.Text                   `db:"notes" json:"notes"`
	CreatedAt   pgtype.Timestamp              `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp              `db:"updated_at" json:"updated_at"`
	TmsVehicle  TmsVehicle                    `db:"tms_vehicle" json:"tms_vehicle"`
}

func (q *Queries) TmsRangeVehicleMaintenance(ctx context.Context, arg TmsRangeVehicleMaintenanceParams) ([]TmsRangeVehicleMaintenanceRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeVehicleMaintenance, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeVehicleMaintenanceRow
	for rows.Next() {
		var i TmsRangeVehicleMaintenanceRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.ServiceDate,
			&i.ServiceType,
			&i.Cost,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveVehicleMaintenance = `-- name: TmsRemoveVehicleMaintenance :exec
delete from "tms"."vehicle_maintenance"
where id = $1::uuid
`

func (q *Queries) TmsRemoveVehicleMaintenance(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveVehicleMaintenance, id)
	return err
}

const tmsUpdateVehicleMaintenance = `-- name: TmsUpdateVehicleMaintenance :one
update
  "tms"."vehicle_maintenance"
set
  updated_at = now(),
  vehicle_id = case when $1 is not null then
    $1::uuid
  else
    vehicle_id
  end,
  service_date = case when $2 is not null then
    $2::date
  else
    service_date
  end,
  service_type = case when $3 is not null then
    $3::tms.vehicle_service_type_enum
  else
    service_type
  end,
  cost = case when $4 is not null then
    $4::numeric
  else
    cost
  end,
  notes = case when $5 is not null then
    $5::text
  else
    notes
  end
where
  id = $6::uuid
returning
  id, vehicle_id, service_date, service_type, cost, notes, created_at, updated_at
`

type TmsUpdateVehicleMaintenanceParams struct {
	VehicleID   pgtype.UUID                   `db:"vehicle_id" json:"vehicle_id"`
	ServiceDate pgtype.Date                   `db:"service_date" json:"service_date"`
	ServiceType NullTmsVehicleServiceTypeEnum `db:"service_type" json:"service_type"`
	Cost        pgtype.Numeric                `db:"cost" json:"cost"`
	Notes       pgtype.Text                   `db:"notes" json:"notes"`
	ID          pgtype.UUID                   `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateVehicleMaintenance(ctx context.Context, arg TmsUpdateVehicleMaintenanceParams) (TmsVehicleMaintenance, error) {
	row := q.db.QueryRow(ctx, tmsUpdateVehicleMaintenance,
		arg.VehicleID,
		arg.ServiceDate,
		arg.ServiceType,
		arg.Cost,
		arg.Notes,
		arg.ID,
	)
	var i TmsVehicleMaintenance
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.ServiceDate,
		&i.ServiceType,
		&i.Cost,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
