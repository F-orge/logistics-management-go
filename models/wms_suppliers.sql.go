// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_suppliers.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnySupplier = `-- name: WmsAnySupplier :many
select
  id, name, contact_person, email, phone_number, created_at, updated_at
from
  "wms"."suppliers"
where
  id = any ($1::uuid[])
`

func (q *Queries) WmsAnySupplier(ctx context.Context, ids []pgtype.UUID) ([]WmsSupplier, error) {
	rows, err := q.db.Query(ctx, wmsAnySupplier, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsSupplier
	for rows.Next() {
		var i WmsSupplier
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContactPerson,
			&i.Email,
			&i.PhoneNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindSupplier = `-- name: WmsFindSupplier :one
select
  id, name, contact_person, email, phone_number, created_at, updated_at
from
  "wms"."suppliers"
where
  id = $1::uuid
`

func (q *Queries) WmsFindSupplier(ctx context.Context, id pgtype.UUID) (WmsSupplier, error) {
	row := q.db.QueryRow(ctx, wmsFindSupplier, id)
	var i WmsSupplier
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactPerson,
		&i.Email,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsInsertSupplier = `-- name: WmsInsertSupplier :one
insert into "wms"."suppliers"(name, contact_person, email, phone_number)
  values ($1, $2, $3, $4)
returning
  id, name, contact_person, email, phone_number, created_at, updated_at
`

type WmsInsertSupplierParams struct {
	Name          string
	ContactPerson pgtype.Text
	Email         pgtype.Text
	PhoneNumber   pgtype.Text
}

func (q *Queries) WmsInsertSupplier(ctx context.Context, arg WmsInsertSupplierParams) (WmsSupplier, error) {
	row := q.db.QueryRow(ctx, wmsInsertSupplier,
		arg.Name,
		arg.ContactPerson,
		arg.Email,
		arg.PhoneNumber,
	)
	var i WmsSupplier
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactPerson,
		&i.Email,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateSupplier = `-- name: WmsPaginateSupplier :many
select
  id, name, contact_person, email, phone_number, created_at, updated_at
from
  "wms"."suppliers"
where
  (name ilike $1::text
  or email ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateSupplierParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

func (q *Queries) WmsPaginateSupplier(ctx context.Context, arg WmsPaginateSupplierParams) ([]WmsSupplier, error) {
	rows, err := q.db.Query(ctx, wmsPaginateSupplier, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsSupplier
	for rows.Next() {
		var i WmsSupplier
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContactPerson,
			&i.Email,
			&i.PhoneNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeSupplier = `-- name: WmsRangeSupplier :many
select
  id, name, contact_person, email, phone_number, created_at, updated_at
from
  "wms"."suppliers"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (name ilike $3::text
  or email ilike $3::text
  or $3::text is null)
`

type WmsRangeSupplierParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

func (q *Queries) WmsRangeSupplier(ctx context.Context, arg WmsRangeSupplierParams) ([]WmsSupplier, error) {
	rows, err := q.db.Query(ctx, wmsRangeSupplier, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsSupplier
	for rows.Next() {
		var i WmsSupplier
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContactPerson,
			&i.Email,
			&i.PhoneNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveSupplier = `-- name: WmsRemoveSupplier :exec
delete from "wms"."suppliers"
where id = $1::uuid
`

func (q *Queries) WmsRemoveSupplier(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveSupplier, id)
	return err
}

const wmsUpdateSupplier = `-- name: WmsUpdateSupplier :one
update
  "wms"."suppliers"
set
  updated_at = now(),
  name = case when $1::boolean then
    $2::varchar
  else
    name
  end,
  contact_person = case when $3::boolean then
    $4::varchar
  else
    contact_person
  end,
  email = case when $5::boolean then
    $6::varchar
  else
    email
  end,
  phone_number = case when $7::boolean then
    $8::varchar
  else
    phone_number
  end
where
  id = $9::uuid
returning
  id, name, contact_person, email, phone_number, created_at, updated_at
`

type WmsUpdateSupplierParams struct {
	SetName          bool
	Name             string
	SetContactPerson bool
	ContactPerson    string
	SetEmail         bool
	Email            string
	SetPhoneNumber   bool
	PhoneNumber      string
	ID               pgtype.UUID
}

func (q *Queries) WmsUpdateSupplier(ctx context.Context, arg WmsUpdateSupplierParams) (WmsSupplier, error) {
	row := q.db.QueryRow(ctx, wmsUpdateSupplier,
		arg.SetName,
		arg.Name,
		arg.SetContactPerson,
		arg.ContactPerson,
		arg.SetEmail,
		arg.Email,
		arg.SetPhoneNumber,
		arg.PhoneNumber,
		arg.ID,
	)
	var i WmsSupplier
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactPerson,
		&i.Email,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
