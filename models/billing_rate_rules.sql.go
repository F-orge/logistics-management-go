// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_rate_rules.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyRateRule = `-- name: BillingAnyRateRule :many
select
  rate_rules.id, rate_rules.rate_card_id, rate_rules.condition, rate_rules.value, rate_rules.price, rate_rules.pricing_model, rate_rules.min_value, rate_rules.max_value, rate_rules.priority, rate_rules.is_active, rate_rules.created_at, rate_rules.updated_at,
  rate_card.id, rate_card.name, rate_card.service_type, rate_card.is_active, rate_card.valid_from, rate_card.valid_to, rate_card.description, rate_card.created_by_user_id, rate_card.created_at, rate_card.updated_at
from
  "billing"."rate_rules" as rate_rules
  inner join "billing"."rate_cards" as rate_card on rate_rules.rate_card_id = rate_card.id
where
  rate_rules.id = any ($1::uuid[])
`

type BillingAnyRateRuleRow struct {
	BillingRateRule BillingRateRule
	BillingRateCard BillingRateCard
}

func (q *Queries) BillingAnyRateRule(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyRateRuleRow, error) {
	rows, err := q.db.Query(ctx, billingAnyRateRule, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyRateRuleRow
	for rows.Next() {
		var i BillingAnyRateRuleRow
		if err := rows.Scan(
			&i.BillingRateRule.ID,
			&i.BillingRateRule.RateCardID,
			&i.BillingRateRule.Condition,
			&i.BillingRateRule.Value,
			&i.BillingRateRule.Price,
			&i.BillingRateRule.PricingModel,
			&i.BillingRateRule.MinValue,
			&i.BillingRateRule.MaxValue,
			&i.BillingRateRule.Priority,
			&i.BillingRateRule.IsActive,
			&i.BillingRateRule.CreatedAt,
			&i.BillingRateRule.UpdatedAt,
			&i.BillingRateCard.ID,
			&i.BillingRateCard.Name,
			&i.BillingRateCard.ServiceType,
			&i.BillingRateCard.IsActive,
			&i.BillingRateCard.ValidFrom,
			&i.BillingRateCard.ValidTo,
			&i.BillingRateCard.Description,
			&i.BillingRateCard.CreatedByUserID,
			&i.BillingRateCard.CreatedAt,
			&i.BillingRateCard.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindRateRule = `-- name: BillingFindRateRule :one
select
  rate_rules.id, rate_rules.rate_card_id, rate_rules.condition, rate_rules.value, rate_rules.price, rate_rules.pricing_model, rate_rules.min_value, rate_rules.max_value, rate_rules.priority, rate_rules.is_active, rate_rules.created_at, rate_rules.updated_at,
  rate_card.id, rate_card.name, rate_card.service_type, rate_card.is_active, rate_card.valid_from, rate_card.valid_to, rate_card.description, rate_card.created_by_user_id, rate_card.created_at, rate_card.updated_at
from
  "billing"."rate_rules" as rate_rules
  inner join "billing"."rate_cards" as rate_card on rate_rules.rate_card_id = rate_card.id
where
  rate_rules.id = $1::uuid
`

type BillingFindRateRuleRow struct {
	BillingRateRule BillingRateRule
	BillingRateCard BillingRateCard
}

func (q *Queries) BillingFindRateRule(ctx context.Context, id pgtype.UUID) (BillingFindRateRuleRow, error) {
	row := q.db.QueryRow(ctx, billingFindRateRule, id)
	var i BillingFindRateRuleRow
	err := row.Scan(
		&i.BillingRateRule.ID,
		&i.BillingRateRule.RateCardID,
		&i.BillingRateRule.Condition,
		&i.BillingRateRule.Value,
		&i.BillingRateRule.Price,
		&i.BillingRateRule.PricingModel,
		&i.BillingRateRule.MinValue,
		&i.BillingRateRule.MaxValue,
		&i.BillingRateRule.Priority,
		&i.BillingRateRule.IsActive,
		&i.BillingRateRule.CreatedAt,
		&i.BillingRateRule.UpdatedAt,
		&i.BillingRateCard.ID,
		&i.BillingRateCard.Name,
		&i.BillingRateCard.ServiceType,
		&i.BillingRateCard.IsActive,
		&i.BillingRateCard.ValidFrom,
		&i.BillingRateCard.ValidTo,
		&i.BillingRateCard.Description,
		&i.BillingRateCard.CreatedByUserID,
		&i.BillingRateCard.CreatedAt,
		&i.BillingRateCard.UpdatedAt,
	)
	return i, err
}

const billingInsertRateRule = `-- name: BillingInsertRateRule :one
insert into "billing"."rate_rules"(rate_card_id, condition, value, price, pricing_model, min_value, max_value, priority, is_active)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning
  id, rate_card_id, condition, value, price, pricing_model, min_value, max_value, priority, is_active, created_at, updated_at
`

type BillingInsertRateRuleParams struct {
	RateCardID   pgtype.UUID
	Condition    string
	Value        string
	Price        pgtype.Numeric
	PricingModel BillingPricingModelEnum
	MinValue     pgtype.Numeric
	MaxValue     pgtype.Numeric
	Priority     pgtype.Int4
	IsActive     pgtype.Bool
}

func (q *Queries) BillingInsertRateRule(ctx context.Context, arg BillingInsertRateRuleParams) (BillingRateRule, error) {
	row := q.db.QueryRow(ctx, billingInsertRateRule,
		arg.RateCardID,
		arg.Condition,
		arg.Value,
		arg.Price,
		arg.PricingModel,
		arg.MinValue,
		arg.MaxValue,
		arg.Priority,
		arg.IsActive,
	)
	var i BillingRateRule
	err := row.Scan(
		&i.ID,
		&i.RateCardID,
		&i.Condition,
		&i.Value,
		&i.Price,
		&i.PricingModel,
		&i.MinValue,
		&i.MaxValue,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateRateRule = `-- name: BillingPaginateRateRule :many
select
  rate_rules.id, rate_rules.rate_card_id, rate_rules.condition, rate_rules.value, rate_rules.price, rate_rules.pricing_model, rate_rules.min_value, rate_rules.max_value, rate_rules.priority, rate_rules.is_active, rate_rules.created_at, rate_rules.updated_at,
  rate_card.id, rate_card.name, rate_card.service_type, rate_card.is_active, rate_card.valid_from, rate_card.valid_to, rate_card.description, rate_card.created_by_user_id, rate_card.created_at, rate_card.updated_at
from
  "billing"."rate_rules" as rate_rules
  inner join "billing"."rate_cards" as rate_card on rate_rules.rate_card_id = rate_card.id
where
  (rate_card.name ilike $1::text
  or rate_rules.condition ilike $1::text
  or rate_rules.value ilike $1::text
  or rate_rules.pricing_model::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateRateRuleParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type BillingPaginateRateRuleRow struct {
	BillingRateRule BillingRateRule
	BillingRateCard BillingRateCard
}

func (q *Queries) BillingPaginateRateRule(ctx context.Context, arg BillingPaginateRateRuleParams) ([]BillingPaginateRateRuleRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateRateRule, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateRateRuleRow
	for rows.Next() {
		var i BillingPaginateRateRuleRow
		if err := rows.Scan(
			&i.BillingRateRule.ID,
			&i.BillingRateRule.RateCardID,
			&i.BillingRateRule.Condition,
			&i.BillingRateRule.Value,
			&i.BillingRateRule.Price,
			&i.BillingRateRule.PricingModel,
			&i.BillingRateRule.MinValue,
			&i.BillingRateRule.MaxValue,
			&i.BillingRateRule.Priority,
			&i.BillingRateRule.IsActive,
			&i.BillingRateRule.CreatedAt,
			&i.BillingRateRule.UpdatedAt,
			&i.BillingRateCard.ID,
			&i.BillingRateCard.Name,
			&i.BillingRateCard.ServiceType,
			&i.BillingRateCard.IsActive,
			&i.BillingRateCard.ValidFrom,
			&i.BillingRateCard.ValidTo,
			&i.BillingRateCard.Description,
			&i.BillingRateCard.CreatedByUserID,
			&i.BillingRateCard.CreatedAt,
			&i.BillingRateCard.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeRateRule = `-- name: BillingRangeRateRule :many
select
  rate_rules.id, rate_rules.rate_card_id, rate_rules.condition, rate_rules.value, rate_rules.price, rate_rules.pricing_model, rate_rules.min_value, rate_rules.max_value, rate_rules.priority, rate_rules.is_active, rate_rules.created_at, rate_rules.updated_at,
  rate_card.id, rate_card.name, rate_card.service_type, rate_card.is_active, rate_card.valid_from, rate_card.valid_to, rate_card.description, rate_card.created_by_user_id, rate_card.created_at, rate_card.updated_at
from
  "billing"."rate_rules" as rate_rules
  inner join "billing"."rate_cards" as rate_card on rate_rules.rate_card_id = rate_card.id
where
  rate_rules.created_at >= $1::date
  and rate_rules.created_at <= $2::date
  and (rate_card.name ilike $3::text
  or rate_rules.condition ilike $3::text
  or rate_rules.value ilike $3::text
  or rate_rules.pricing_model::text ilike $3::text
  or $3::text is null)
`

type BillingRangeRateRuleParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type BillingRangeRateRuleRow struct {
	BillingRateRule BillingRateRule
	BillingRateCard BillingRateCard
}

func (q *Queries) BillingRangeRateRule(ctx context.Context, arg BillingRangeRateRuleParams) ([]BillingRangeRateRuleRow, error) {
	rows, err := q.db.Query(ctx, billingRangeRateRule, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeRateRuleRow
	for rows.Next() {
		var i BillingRangeRateRuleRow
		if err := rows.Scan(
			&i.BillingRateRule.ID,
			&i.BillingRateRule.RateCardID,
			&i.BillingRateRule.Condition,
			&i.BillingRateRule.Value,
			&i.BillingRateRule.Price,
			&i.BillingRateRule.PricingModel,
			&i.BillingRateRule.MinValue,
			&i.BillingRateRule.MaxValue,
			&i.BillingRateRule.Priority,
			&i.BillingRateRule.IsActive,
			&i.BillingRateRule.CreatedAt,
			&i.BillingRateRule.UpdatedAt,
			&i.BillingRateCard.ID,
			&i.BillingRateCard.Name,
			&i.BillingRateCard.ServiceType,
			&i.BillingRateCard.IsActive,
			&i.BillingRateCard.ValidFrom,
			&i.BillingRateCard.ValidTo,
			&i.BillingRateCard.Description,
			&i.BillingRateCard.CreatedByUserID,
			&i.BillingRateCard.CreatedAt,
			&i.BillingRateCard.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveRateRule = `-- name: BillingRemoveRateRule :exec
delete from "billing"."rate_rules"
where id = $1::uuid
`

func (q *Queries) BillingRemoveRateRule(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveRateRule, id)
	return err
}

const billingUpdateRateRule = `-- name: BillingUpdateRateRule :one
update
  "billing"."rate_rules"
set
  updated_at = now(),
  rate_card_id = case when $1::boolean then
    $2::uuid
  else
    rate_card_id
  end,
  condition = case when $3::boolean then
    $4::varchar
  else
    condition
  end,
  value = case when $5::boolean then
    $6::varchar
  else
    value
  end,
  price = case when $7::boolean then
    $8::numeric
  else
    price
  end,
  pricing_model = case when $9::boolean then
    $10::billing.pricing_model_enum
  else
    pricing_model
  end,
  min_value = case when $11::boolean then
    $12::numeric
  else
    min_value
  end,
  max_value = case when $13::boolean then
    $14::numeric
  else
    max_value
  end,
  priority = case when $15::boolean then
    $16::integer
  else
    priority
  end,
  is_active = case when $17::boolean then
    $18::boolean
  else
    is_active
  end
where
  id = $19::uuid
returning
  id, rate_card_id, condition, value, price, pricing_model, min_value, max_value, priority, is_active, created_at, updated_at
`

type BillingUpdateRateRuleParams struct {
	SetRateCardID   bool
	RateCardID      pgtype.UUID
	SetCondition    bool
	Condition       string
	SetValue        bool
	Value           string
	SetPrice        bool
	Price           pgtype.Numeric
	SetPricingModel bool
	PricingModel    BillingPricingModelEnum
	SetMinValue     bool
	MinValue        pgtype.Numeric
	SetMaxValue     bool
	MaxValue        pgtype.Numeric
	SetPriority     bool
	Priority        int32
	SetIsActive     bool
	IsActive        bool
	ID              pgtype.UUID
}

func (q *Queries) BillingUpdateRateRule(ctx context.Context, arg BillingUpdateRateRuleParams) (BillingRateRule, error) {
	row := q.db.QueryRow(ctx, billingUpdateRateRule,
		arg.SetRateCardID,
		arg.RateCardID,
		arg.SetCondition,
		arg.Condition,
		arg.SetValue,
		arg.Value,
		arg.SetPrice,
		arg.Price,
		arg.SetPricingModel,
		arg.PricingModel,
		arg.SetMinValue,
		arg.MinValue,
		arg.SetMaxValue,
		arg.MaxValue,
		arg.SetPriority,
		arg.Priority,
		arg.SetIsActive,
		arg.IsActive,
		arg.ID,
	)
	var i BillingRateRule
	err := row.Scan(
		&i.ID,
		&i.RateCardID,
		&i.Condition,
		&i.Value,
		&i.Price,
		&i.PricingModel,
		&i.MinValue,
		&i.MaxValue,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
