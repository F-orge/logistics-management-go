// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_payments.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyPayment = `-- name: BillingAnyPayment :many
select
  payments.id, payments.invoice_id, payments.amount, payments.payment_method, payments.transaction_id, payments.gateway_reference, payments.status, payments.payment_date, payments.processed_at, payments.currency, payments.exchange_rate, payments.fees, payments.net_amount, payments.notes, payments.processed_by_user_id, payments.created_at, payments.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."payments" as payments
  inner join "billing"."invoices" as invoice on payments.invoice_id = invoice.id
  left join "public"."user" as processed_by_user on payments.processed_by_user_id = processed_by_user.id
where
  payments.id = any ($1::uuid[])
`

type BillingAnyPaymentRow struct {
	BillingPayment BillingPayment
	BillingInvoice BillingInvoice
	User           User
}

func (q *Queries) BillingAnyPayment(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyPaymentRow, error) {
	rows, err := q.db.Query(ctx, billingAnyPayment, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyPaymentRow
	for rows.Next() {
		var i BillingAnyPaymentRow
		if err := rows.Scan(
			&i.BillingPayment.ID,
			&i.BillingPayment.InvoiceID,
			&i.BillingPayment.Amount,
			&i.BillingPayment.PaymentMethod,
			&i.BillingPayment.TransactionID,
			&i.BillingPayment.GatewayReference,
			&i.BillingPayment.Status,
			&i.BillingPayment.PaymentDate,
			&i.BillingPayment.ProcessedAt,
			&i.BillingPayment.Currency,
			&i.BillingPayment.ExchangeRate,
			&i.BillingPayment.Fees,
			&i.BillingPayment.NetAmount,
			&i.BillingPayment.Notes,
			&i.BillingPayment.ProcessedByUserID,
			&i.BillingPayment.CreatedAt,
			&i.BillingPayment.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindPayment = `-- name: BillingFindPayment :one
select
  payments.id, payments.invoice_id, payments.amount, payments.payment_method, payments.transaction_id, payments.gateway_reference, payments.status, payments.payment_date, payments.processed_at, payments.currency, payments.exchange_rate, payments.fees, payments.net_amount, payments.notes, payments.processed_by_user_id, payments.created_at, payments.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."payments" as payments
  inner join "billing"."invoices" as invoice on payments.invoice_id = invoice.id
  left join "public"."user" as processed_by_user on payments.processed_by_user_id = processed_by_user.id
where
  payments.id = $1::uuid
`

type BillingFindPaymentRow struct {
	BillingPayment BillingPayment
	BillingInvoice BillingInvoice
	User           User
}

func (q *Queries) BillingFindPayment(ctx context.Context, id pgtype.UUID) (BillingFindPaymentRow, error) {
	row := q.db.QueryRow(ctx, billingFindPayment, id)
	var i BillingFindPaymentRow
	err := row.Scan(
		&i.BillingPayment.ID,
		&i.BillingPayment.InvoiceID,
		&i.BillingPayment.Amount,
		&i.BillingPayment.PaymentMethod,
		&i.BillingPayment.TransactionID,
		&i.BillingPayment.GatewayReference,
		&i.BillingPayment.Status,
		&i.BillingPayment.PaymentDate,
		&i.BillingPayment.ProcessedAt,
		&i.BillingPayment.Currency,
		&i.BillingPayment.ExchangeRate,
		&i.BillingPayment.Fees,
		&i.BillingPayment.NetAmount,
		&i.BillingPayment.Notes,
		&i.BillingPayment.ProcessedByUserID,
		&i.BillingPayment.CreatedAt,
		&i.BillingPayment.UpdatedAt,
		&i.BillingInvoice.ID,
		&i.BillingInvoice.ClientID,
		&i.BillingInvoice.QuoteID,
		&i.BillingInvoice.InvoiceNumber,
		&i.BillingInvoice.Status,
		&i.BillingInvoice.IssueDate,
		&i.BillingInvoice.DueDate,
		&i.BillingInvoice.TotalAmount,
		&i.BillingInvoice.AmountPaid,
		&i.BillingInvoice.AmountOutstanding,
		&i.BillingInvoice.Currency,
		&i.BillingInvoice.TaxAmount,
		&i.BillingInvoice.DiscountAmount,
		&i.BillingInvoice.Subtotal,
		&i.BillingInvoice.PaymentTerms,
		&i.BillingInvoice.Notes,
		&i.BillingInvoice.SentAt,
		&i.BillingInvoice.PaidAt,
		&i.BillingInvoice.CreatedByUserID,
		&i.BillingInvoice.CreatedAt,
		&i.BillingInvoice.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertPayment = `-- name: BillingInsertPayment :one
insert into "billing"."payments"(invoice_id, amount, payment_method, transaction_id, gateway_reference, status, payment_date, processed_at, currency, exchange_rate, fees, notes, processed_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
returning
  id, invoice_id, amount, payment_method, transaction_id, gateway_reference, status, payment_date, processed_at, currency, exchange_rate, fees, net_amount, notes, processed_by_user_id, created_at, updated_at
`

type BillingInsertPaymentParams struct {
	InvoiceID         pgtype.UUID
	Amount            pgtype.Numeric
	PaymentMethod     BillingPaymentMethodEnum
	TransactionID     pgtype.Text
	GatewayReference  pgtype.Text
	Status            NullBillingPaymentStatusEnum
	PaymentDate       pgtype.Timestamp
	ProcessedAt       pgtype.Timestamp
	Currency          pgtype.Text
	ExchangeRate      pgtype.Numeric
	Fees              pgtype.Numeric
	Notes             pgtype.Text
	ProcessedByUserID pgtype.Text
}

func (q *Queries) BillingInsertPayment(ctx context.Context, arg BillingInsertPaymentParams) (BillingPayment, error) {
	row := q.db.QueryRow(ctx, billingInsertPayment,
		arg.InvoiceID,
		arg.Amount,
		arg.PaymentMethod,
		arg.TransactionID,
		arg.GatewayReference,
		arg.Status,
		arg.PaymentDate,
		arg.ProcessedAt,
		arg.Currency,
		arg.ExchangeRate,
		arg.Fees,
		arg.Notes,
		arg.ProcessedByUserID,
	)
	var i BillingPayment
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Amount,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.GatewayReference,
		&i.Status,
		&i.PaymentDate,
		&i.ProcessedAt,
		&i.Currency,
		&i.ExchangeRate,
		&i.Fees,
		&i.NetAmount,
		&i.Notes,
		&i.ProcessedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginatePayment = `-- name: BillingPaginatePayment :many
select
  payments.id, payments.invoice_id, payments.amount, payments.payment_method, payments.transaction_id, payments.gateway_reference, payments.status, payments.payment_date, payments.processed_at, payments.currency, payments.exchange_rate, payments.fees, payments.net_amount, payments.notes, payments.processed_by_user_id, payments.created_at, payments.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."payments" as payments
  inner join "billing"."invoices" as invoice on payments.invoice_id = invoice.id
  left join "public"."user" as processed_by_user on payments.processed_by_user_id = processed_by_user.id
limit $2::int offset ($1::int - 1) * $2::int
`

type BillingPaginatePaymentParams struct {
	Page    int32
	Perpage int32
}

type BillingPaginatePaymentRow struct {
	BillingPayment BillingPayment
	BillingInvoice BillingInvoice
	User           User
}

func (q *Queries) BillingPaginatePayment(ctx context.Context, arg BillingPaginatePaymentParams) ([]BillingPaginatePaymentRow, error) {
	rows, err := q.db.Query(ctx, billingPaginatePayment, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginatePaymentRow
	for rows.Next() {
		var i BillingPaginatePaymentRow
		if err := rows.Scan(
			&i.BillingPayment.ID,
			&i.BillingPayment.InvoiceID,
			&i.BillingPayment.Amount,
			&i.BillingPayment.PaymentMethod,
			&i.BillingPayment.TransactionID,
			&i.BillingPayment.GatewayReference,
			&i.BillingPayment.Status,
			&i.BillingPayment.PaymentDate,
			&i.BillingPayment.ProcessedAt,
			&i.BillingPayment.Currency,
			&i.BillingPayment.ExchangeRate,
			&i.BillingPayment.Fees,
			&i.BillingPayment.NetAmount,
			&i.BillingPayment.Notes,
			&i.BillingPayment.ProcessedByUserID,
			&i.BillingPayment.CreatedAt,
			&i.BillingPayment.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangePayment = `-- name: BillingRangePayment :many
select
  payments.id, payments.invoice_id, payments.amount, payments.payment_method, payments.transaction_id, payments.gateway_reference, payments.status, payments.payment_date, payments.processed_at, payments.currency, payments.exchange_rate, payments.fees, payments.net_amount, payments.notes, payments.processed_by_user_id, payments.created_at, payments.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."payments" as payments
  inner join "billing"."invoices" as invoice on payments.invoice_id = invoice.id
  left join "public"."user" as processed_by_user on payments.processed_by_user_id = processed_by_user.id
where
  payments.created_at >= $1::date
  and payments.created_at <= $2::date
`

type BillingRangePaymentParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type BillingRangePaymentRow struct {
	BillingPayment BillingPayment
	BillingInvoice BillingInvoice
	User           User
}

func (q *Queries) BillingRangePayment(ctx context.Context, arg BillingRangePaymentParams) ([]BillingRangePaymentRow, error) {
	rows, err := q.db.Query(ctx, billingRangePayment, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangePaymentRow
	for rows.Next() {
		var i BillingRangePaymentRow
		if err := rows.Scan(
			&i.BillingPayment.ID,
			&i.BillingPayment.InvoiceID,
			&i.BillingPayment.Amount,
			&i.BillingPayment.PaymentMethod,
			&i.BillingPayment.TransactionID,
			&i.BillingPayment.GatewayReference,
			&i.BillingPayment.Status,
			&i.BillingPayment.PaymentDate,
			&i.BillingPayment.ProcessedAt,
			&i.BillingPayment.Currency,
			&i.BillingPayment.ExchangeRate,
			&i.BillingPayment.Fees,
			&i.BillingPayment.NetAmount,
			&i.BillingPayment.Notes,
			&i.BillingPayment.ProcessedByUserID,
			&i.BillingPayment.CreatedAt,
			&i.BillingPayment.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemovePayment = `-- name: BillingRemovePayment :exec
delete from "billing"."payments"
where id = $1::uuid
`

func (q *Queries) BillingRemovePayment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemovePayment, id)
	return err
}

const billingUpdatePayment = `-- name: BillingUpdatePayment :one
update
  "billing"."payments"
set
  invoice_id = case when $1::boolean then
    $2::uuid
  else
    invoice_id
  end,
  amount = case when $3::boolean then
    $4::numeric
  else
    amount
  end,
  payment_method = case when $5::boolean then
    $6::billing.payment_method_enum
  else
    payment_method
  end,
  transaction_id = case when $7::boolean then
    $8::varchar
  else
    transaction_id
  end,
  gateway_reference = case when $9::boolean then
    $10::varchar
  else
    gateway_reference
  end,
  status = case when $11::boolean then
    $12::billing.payment_status_enum
  else
    status
  end,
  payment_date = case when $13::boolean then
    $14::timestamp
  else
    payment_date
  end,
  processed_at = case when $15::boolean then
    $16::timestamp
  else
    processed_at
  end,
  currency = case when $17::boolean then
    $18::varchar
  else
    currency
  end,
  exchange_rate = case when $19::boolean then
    $20::numeric
  else
    exchange_rate
  end,
  fees = case when $21::boolean then
    $22::numeric
  else
    fees
  end,
  notes = case when $23::boolean then
    $24::text
  else
    notes
  end,
  processed_by_user_id = case when $25::boolean then
    $26::text
  else
    processed_by_user_id
  end
where
  id = $27::uuid
returning
  id, invoice_id, amount, payment_method, transaction_id, gateway_reference, status, payment_date, processed_at, currency, exchange_rate, fees, net_amount, notes, processed_by_user_id, created_at, updated_at
`

type BillingUpdatePaymentParams struct {
	SetInvoiceID         bool
	InvoiceID            pgtype.UUID
	SetAmount            bool
	Amount               pgtype.Numeric
	SetPaymentMethod     bool
	PaymentMethod        BillingPaymentMethodEnum
	SetTransactionID     bool
	TransactionID        string
	SetGatewayReference  bool
	GatewayReference     string
	SetStatus            bool
	Status               BillingPaymentStatusEnum
	SetPaymentDate       bool
	PaymentDate          pgtype.Timestamp
	SetProcessedAt       bool
	ProcessedAt          pgtype.Timestamp
	SetCurrency          bool
	Currency             string
	SetExchangeRate      bool
	ExchangeRate         pgtype.Numeric
	SetFees              bool
	Fees                 pgtype.Numeric
	SetNotes             bool
	Notes                string
	SetProcessedByUserID bool
	ProcessedByUserID    string
	ID                   pgtype.UUID
}

func (q *Queries) BillingUpdatePayment(ctx context.Context, arg BillingUpdatePaymentParams) (BillingPayment, error) {
	row := q.db.QueryRow(ctx, billingUpdatePayment,
		arg.SetInvoiceID,
		arg.InvoiceID,
		arg.SetAmount,
		arg.Amount,
		arg.SetPaymentMethod,
		arg.PaymentMethod,
		arg.SetTransactionID,
		arg.TransactionID,
		arg.SetGatewayReference,
		arg.GatewayReference,
		arg.SetStatus,
		arg.Status,
		arg.SetPaymentDate,
		arg.PaymentDate,
		arg.SetProcessedAt,
		arg.ProcessedAt,
		arg.SetCurrency,
		arg.Currency,
		arg.SetExchangeRate,
		arg.ExchangeRate,
		arg.SetFees,
		arg.Fees,
		arg.SetNotes,
		arg.Notes,
		arg.SetProcessedByUserID,
		arg.ProcessedByUserID,
		arg.ID,
	)
	var i BillingPayment
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Amount,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.GatewayReference,
		&i.Status,
		&i.PaymentDate,
		&i.ProcessedAt,
		&i.Currency,
		&i.ExchangeRate,
		&i.Fees,
		&i.NetAmount,
		&i.Notes,
		&i.ProcessedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
