// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_payments.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyPayment = `-- name: BillingAnyPayment :many
select
  payments.id, payments.invoice_id, payments.amount, payments.payment_method, payments.transaction_id, payments.gateway_reference, payments.status, payments.payment_date, payments.processed_at, payments.currency, payments.exchange_rate, payments.fees, payments.net_amount, payments.notes, payments.processed_by_user_id, payments.created_at, payments.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."payments" as payments
  inner join "billing"."invoices" as invoice on payments.invoice_id = invoice.id
  left join "public"."user" as processed_by_user on payments.processed_by_user_id = processed_by_user.id
where
  payments.id = any ($1::uuid[])
`

type BillingAnyPaymentRow struct {
	BillingPayment BillingPayment `db:"billing_payment" json:"billing_payment"`
	BillingInvoice BillingInvoice `db:"billing_invoice" json:"billing_invoice"`
	User           User           `db:"user" json:"user"`
}

func (q *Queries) BillingAnyPayment(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyPaymentRow, error) {
	rows, err := q.db.Query(ctx, billingAnyPayment, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyPaymentRow
	for rows.Next() {
		var i BillingAnyPaymentRow
		if err := rows.Scan(
			&i.BillingPayment.ID,
			&i.BillingPayment.InvoiceID,
			&i.BillingPayment.Amount,
			&i.BillingPayment.PaymentMethod,
			&i.BillingPayment.TransactionID,
			&i.BillingPayment.GatewayReference,
			&i.BillingPayment.Status,
			&i.BillingPayment.PaymentDate,
			&i.BillingPayment.ProcessedAt,
			&i.BillingPayment.Currency,
			&i.BillingPayment.ExchangeRate,
			&i.BillingPayment.Fees,
			&i.BillingPayment.NetAmount,
			&i.BillingPayment.Notes,
			&i.BillingPayment.ProcessedByUserID,
			&i.BillingPayment.CreatedAt,
			&i.BillingPayment.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindPayment = `-- name: BillingFindPayment :one
select
  payments.id, payments.invoice_id, payments.amount, payments.payment_method, payments.transaction_id, payments.gateway_reference, payments.status, payments.payment_date, payments.processed_at, payments.currency, payments.exchange_rate, payments.fees, payments.net_amount, payments.notes, payments.processed_by_user_id, payments.created_at, payments.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."payments" as payments
  inner join "billing"."invoices" as invoice on payments.invoice_id = invoice.id
  left join "public"."user" as processed_by_user on payments.processed_by_user_id = processed_by_user.id
where
  payments.id = $1::uuid
`

type BillingFindPaymentRow struct {
	BillingPayment BillingPayment `db:"billing_payment" json:"billing_payment"`
	BillingInvoice BillingInvoice `db:"billing_invoice" json:"billing_invoice"`
	User           User           `db:"user" json:"user"`
}

func (q *Queries) BillingFindPayment(ctx context.Context, id pgtype.UUID) (BillingFindPaymentRow, error) {
	row := q.db.QueryRow(ctx, billingFindPayment, id)
	var i BillingFindPaymentRow
	err := row.Scan(
		&i.BillingPayment.ID,
		&i.BillingPayment.InvoiceID,
		&i.BillingPayment.Amount,
		&i.BillingPayment.PaymentMethod,
		&i.BillingPayment.TransactionID,
		&i.BillingPayment.GatewayReference,
		&i.BillingPayment.Status,
		&i.BillingPayment.PaymentDate,
		&i.BillingPayment.ProcessedAt,
		&i.BillingPayment.Currency,
		&i.BillingPayment.ExchangeRate,
		&i.BillingPayment.Fees,
		&i.BillingPayment.NetAmount,
		&i.BillingPayment.Notes,
		&i.BillingPayment.ProcessedByUserID,
		&i.BillingPayment.CreatedAt,
		&i.BillingPayment.UpdatedAt,
		&i.BillingInvoice.ID,
		&i.BillingInvoice.ClientID,
		&i.BillingInvoice.QuoteID,
		&i.BillingInvoice.InvoiceNumber,
		&i.BillingInvoice.Status,
		&i.BillingInvoice.IssueDate,
		&i.BillingInvoice.DueDate,
		&i.BillingInvoice.TotalAmount,
		&i.BillingInvoice.AmountPaid,
		&i.BillingInvoice.AmountOutstanding,
		&i.BillingInvoice.Currency,
		&i.BillingInvoice.TaxAmount,
		&i.BillingInvoice.DiscountAmount,
		&i.BillingInvoice.Subtotal,
		&i.BillingInvoice.PaymentTerms,
		&i.BillingInvoice.Notes,
		&i.BillingInvoice.SentAt,
		&i.BillingInvoice.PaidAt,
		&i.BillingInvoice.CreatedByUserID,
		&i.BillingInvoice.CreatedAt,
		&i.BillingInvoice.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertPayment = `-- name: BillingInsertPayment :one
insert into "billing"."payments"(invoice_id, amount, payment_method, transaction_id, gateway_reference, status, payment_date, processed_at, currency, exchange_rate, fees, notes, processed_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
returning
  id, invoice_id, amount, payment_method, transaction_id, gateway_reference, status, payment_date, processed_at, currency, exchange_rate, fees, net_amount, notes, processed_by_user_id, created_at, updated_at
`

type BillingInsertPaymentParams struct {
	InvoiceID         pgtype.UUID                  `db:"invoice_id" json:"invoice_id"`
	Amount            pgtype.Numeric               `db:"amount" json:"amount"`
	PaymentMethod     BillingPaymentMethodEnum     `db:"payment_method" json:"payment_method"`
	TransactionID     pgtype.Text                  `db:"transaction_id" json:"transaction_id"`
	GatewayReference  pgtype.Text                  `db:"gateway_reference" json:"gateway_reference"`
	Status            NullBillingPaymentStatusEnum `db:"status" json:"status"`
	PaymentDate       pgtype.Timestamp             `db:"payment_date" json:"payment_date"`
	ProcessedAt       pgtype.Timestamp             `db:"processed_at" json:"processed_at"`
	Currency          pgtype.Text                  `db:"currency" json:"currency"`
	ExchangeRate      pgtype.Numeric               `db:"exchange_rate" json:"exchange_rate"`
	Fees              pgtype.Numeric               `db:"fees" json:"fees"`
	Notes             pgtype.Text                  `db:"notes" json:"notes"`
	ProcessedByUserID pgtype.Text                  `db:"processed_by_user_id" json:"processed_by_user_id"`
}

func (q *Queries) BillingInsertPayment(ctx context.Context, arg BillingInsertPaymentParams) (BillingPayment, error) {
	row := q.db.QueryRow(ctx, billingInsertPayment,
		arg.InvoiceID,
		arg.Amount,
		arg.PaymentMethod,
		arg.TransactionID,
		arg.GatewayReference,
		arg.Status,
		arg.PaymentDate,
		arg.ProcessedAt,
		arg.Currency,
		arg.ExchangeRate,
		arg.Fees,
		arg.Notes,
		arg.ProcessedByUserID,
	)
	var i BillingPayment
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Amount,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.GatewayReference,
		&i.Status,
		&i.PaymentDate,
		&i.ProcessedAt,
		&i.Currency,
		&i.ExchangeRate,
		&i.Fees,
		&i.NetAmount,
		&i.Notes,
		&i.ProcessedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginatePayment = `-- name: BillingPaginatePayment :many
select
  payments.id, payments.invoice_id, payments.amount, payments.payment_method, payments.transaction_id, payments.gateway_reference, payments.status, payments.payment_date, payments.processed_at, payments.currency, payments.exchange_rate, payments.fees, payments.net_amount, payments.notes, payments.processed_by_user_id, payments.created_at, payments.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."payments" as payments
  inner join "billing"."invoices" as invoice on payments.invoice_id = invoice.id
  left join "public"."user" as processed_by_user on payments.processed_by_user_id = processed_by_user.id
where (invoice.invoice_number ilike $1::text
  or payments.payment_method::text ilike $1::text
  or payments.status::text ilike $1::text
  or processed_by_user.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginatePaymentParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type BillingPaginatePaymentRow struct {
	BillingPayment BillingPayment `db:"billing_payment" json:"billing_payment"`
	BillingInvoice BillingInvoice `db:"billing_invoice" json:"billing_invoice"`
	User           User           `db:"user" json:"user"`
}

func (q *Queries) BillingPaginatePayment(ctx context.Context, arg BillingPaginatePaymentParams) ([]BillingPaginatePaymentRow, error) {
	rows, err := q.db.Query(ctx, billingPaginatePayment, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginatePaymentRow
	for rows.Next() {
		var i BillingPaginatePaymentRow
		if err := rows.Scan(
			&i.BillingPayment.ID,
			&i.BillingPayment.InvoiceID,
			&i.BillingPayment.Amount,
			&i.BillingPayment.PaymentMethod,
			&i.BillingPayment.TransactionID,
			&i.BillingPayment.GatewayReference,
			&i.BillingPayment.Status,
			&i.BillingPayment.PaymentDate,
			&i.BillingPayment.ProcessedAt,
			&i.BillingPayment.Currency,
			&i.BillingPayment.ExchangeRate,
			&i.BillingPayment.Fees,
			&i.BillingPayment.NetAmount,
			&i.BillingPayment.Notes,
			&i.BillingPayment.ProcessedByUserID,
			&i.BillingPayment.CreatedAt,
			&i.BillingPayment.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangePayment = `-- name: BillingRangePayment :many
select
  payments.id, payments.invoice_id, payments.amount, payments.payment_method, payments.transaction_id, payments.gateway_reference, payments.status, payments.payment_date, payments.processed_at, payments.currency, payments.exchange_rate, payments.fees, payments.net_amount, payments.notes, payments.processed_by_user_id, payments.created_at, payments.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  processed_by_user.id, processed_by_user.name, processed_by_user.email, processed_by_user.email_verified, processed_by_user.image, processed_by_user.created_at, processed_by_user.updated_at, processed_by_user.role, processed_by_user.banned, processed_by_user.ban_reason, processed_by_user.ban_expires
from
  "billing"."payments" as payments
  inner join "billing"."invoices" as invoice on payments.invoice_id = invoice.id
  left join "public"."user" as processed_by_user on payments.processed_by_user_id = processed_by_user.id
where
  payments.created_at >= $1::date
  and payments.created_at <= $2::date
  and (invoice.invoice_number ilike $3::text
    or payments.payment_method::text ilike $3::text
    or payments.status::text ilike $3::text
    or processed_by_user.name ilike $3::text
    or $3::text is null)
`

type BillingRangePaymentParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type BillingRangePaymentRow struct {
	BillingPayment BillingPayment `db:"billing_payment" json:"billing_payment"`
	BillingInvoice BillingInvoice `db:"billing_invoice" json:"billing_invoice"`
	User           User           `db:"user" json:"user"`
}

func (q *Queries) BillingRangePayment(ctx context.Context, arg BillingRangePaymentParams) ([]BillingRangePaymentRow, error) {
	rows, err := q.db.Query(ctx, billingRangePayment, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangePaymentRow
	for rows.Next() {
		var i BillingRangePaymentRow
		if err := rows.Scan(
			&i.BillingPayment.ID,
			&i.BillingPayment.InvoiceID,
			&i.BillingPayment.Amount,
			&i.BillingPayment.PaymentMethod,
			&i.BillingPayment.TransactionID,
			&i.BillingPayment.GatewayReference,
			&i.BillingPayment.Status,
			&i.BillingPayment.PaymentDate,
			&i.BillingPayment.ProcessedAt,
			&i.BillingPayment.Currency,
			&i.BillingPayment.ExchangeRate,
			&i.BillingPayment.Fees,
			&i.BillingPayment.NetAmount,
			&i.BillingPayment.Notes,
			&i.BillingPayment.ProcessedByUserID,
			&i.BillingPayment.CreatedAt,
			&i.BillingPayment.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemovePayment = `-- name: BillingRemovePayment :exec
delete from "billing"."payments"
where id = $1::uuid
`

func (q *Queries) BillingRemovePayment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemovePayment, id)
	return err
}

const billingUpdatePayment = `-- name: BillingUpdatePayment :one
update
  "billing"."payments"
set
  updated_at = now(),
  invoice_id = case when $1 is not null then
    $1::uuid
  else
    invoice_id
  end,
  amount = case when $2 is not null then
    $2::numeric
  else
    amount
  end,
  payment_method = case when $3 is not null then
    $3::billing.payment_method_enum
  else
    payment_method
  end,
  transaction_id = case when $4 is not null then
    $4::varchar
  else
    transaction_id
  end,
  gateway_reference = case when $5 is not null then
    $5::varchar
  else
    gateway_reference
  end,
  status = case when $6 is not null then
    $6::billing.payment_status_enum
  else
    status
  end,
  payment_date = case when $7 is not null then
    $7::timestamp
  else
    payment_date
  end,
  processed_at = case when $8 is not null then
    $8::timestamp
  else
    processed_at
  end,
  currency = case when $9 is not null then
    $9::varchar
  else
    currency
  end,
  exchange_rate = case when $10 is not null then
    $10::numeric
  else
    exchange_rate
  end,
  fees = case when $11 is not null then
    $11::numeric
  else
    fees
  end,
  notes = case when $12 is not null then
    $12::text
  else
    notes
  end,
  processed_by_user_id = case when $13 is not null then
    $13::text
  else
    processed_by_user_id
  end
where
  id = $14::uuid
returning
  id, invoice_id, amount, payment_method, transaction_id, gateway_reference, status, payment_date, processed_at, currency, exchange_rate, fees, net_amount, notes, processed_by_user_id, created_at, updated_at
`

type BillingUpdatePaymentParams struct {
	InvoiceID         pgtype.UUID                  `db:"invoice_id" json:"invoice_id"`
	Amount            pgtype.Numeric               `db:"amount" json:"amount"`
	PaymentMethod     BillingPaymentMethodEnum     `db:"payment_method" json:"payment_method"`
	TransactionID     pgtype.Text                  `db:"transaction_id" json:"transaction_id"`
	GatewayReference  pgtype.Text                  `db:"gateway_reference" json:"gateway_reference"`
	Status            NullBillingPaymentStatusEnum `db:"status" json:"status"`
	PaymentDate       pgtype.Timestamp             `db:"payment_date" json:"payment_date"`
	ProcessedAt       pgtype.Timestamp             `db:"processed_at" json:"processed_at"`
	Currency          pgtype.Text                  `db:"currency" json:"currency"`
	ExchangeRate      pgtype.Numeric               `db:"exchange_rate" json:"exchange_rate"`
	Fees              pgtype.Numeric               `db:"fees" json:"fees"`
	Notes             pgtype.Text                  `db:"notes" json:"notes"`
	ProcessedByUserID pgtype.Text                  `db:"processed_by_user_id" json:"processed_by_user_id"`
	ID                pgtype.UUID                  `db:"id" json:"id"`
}

func (q *Queries) BillingUpdatePayment(ctx context.Context, arg BillingUpdatePaymentParams) (BillingPayment, error) {
	row := q.db.QueryRow(ctx, billingUpdatePayment,
		arg.InvoiceID,
		arg.Amount,
		arg.PaymentMethod,
		arg.TransactionID,
		arg.GatewayReference,
		arg.Status,
		arg.PaymentDate,
		arg.ProcessedAt,
		arg.Currency,
		arg.ExchangeRate,
		arg.Fees,
		arg.Notes,
		arg.ProcessedByUserID,
		arg.ID,
	)
	var i BillingPayment
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Amount,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.GatewayReference,
		&i.Status,
		&i.PaymentDate,
		&i.ProcessedAt,
		&i.Currency,
		&i.ExchangeRate,
		&i.Fees,
		&i.NetAmount,
		&i.Notes,
		&i.ProcessedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
