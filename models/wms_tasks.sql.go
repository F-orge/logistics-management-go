// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_tasks.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyTask = `-- name: WmsAnyTask :many
select
  tasks.id, tasks.task_number, tasks.warehouse_id, tasks.user_id, tasks.type, tasks.status, tasks.priority, tasks.source_entity_id, tasks.source_entity_type, tasks.pick_batch_id, tasks.estimated_duration, tasks.actual_duration, tasks.instructions, tasks.notes, tasks.start_time, tasks.end_time, tasks.duration_seconds, tasks.created_at, tasks.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at
from
  "wms"."tasks" as tasks
  inner join "wms"."warehouses" as warehouse on tasks.warehouse_id = warehouse.id
  left join "public"."user" as users on tasks.user_id = users.id
  left join "wms"."pick_batches" as pick_batch on tasks.pick_batch_id = pick_batch.id
where
  tasks.id = any ($1::uuid[])
`

type WmsAnyTaskRow struct {
	WmsTask      WmsTask
	WmsWarehouse WmsWarehouse
	User         User
	WmsPickBatch WmsPickBatch
}

func (q *Queries) WmsAnyTask(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyTaskRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyTask, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyTaskRow
	for rows.Next() {
		var i WmsAnyTaskRow
		if err := rows.Scan(
			&i.WmsTask.ID,
			&i.WmsTask.TaskNumber,
			&i.WmsTask.WarehouseID,
			&i.WmsTask.UserID,
			&i.WmsTask.Type,
			&i.WmsTask.Status,
			&i.WmsTask.Priority,
			&i.WmsTask.SourceEntityID,
			&i.WmsTask.SourceEntityType,
			&i.WmsTask.PickBatchID,
			&i.WmsTask.EstimatedDuration,
			&i.WmsTask.ActualDuration,
			&i.WmsTask.Instructions,
			&i.WmsTask.Notes,
			&i.WmsTask.StartTime,
			&i.WmsTask.EndTime,
			&i.WmsTask.DurationSeconds,
			&i.WmsTask.CreatedAt,
			&i.WmsTask.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindTask = `-- name: WmsFindTask :one
select
  tasks.id, tasks.task_number, tasks.warehouse_id, tasks.user_id, tasks.type, tasks.status, tasks.priority, tasks.source_entity_id, tasks.source_entity_type, tasks.pick_batch_id, tasks.estimated_duration, tasks.actual_duration, tasks.instructions, tasks.notes, tasks.start_time, tasks.end_time, tasks.duration_seconds, tasks.created_at, tasks.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at
from
  "wms"."tasks" as tasks
  inner join "wms"."warehouses" as warehouse on tasks.warehouse_id = warehouse.id
  left join "public"."user" as users on tasks.user_id = users.id
  left join "wms"."pick_batches" as pick_batch on tasks.pick_batch_id = pick_batch.id
where
  tasks.id = $1::uuid
`

type WmsFindTaskRow struct {
	WmsTask      WmsTask
	WmsWarehouse WmsWarehouse
	User         User
	WmsPickBatch WmsPickBatch
}

func (q *Queries) WmsFindTask(ctx context.Context, id pgtype.UUID) (WmsFindTaskRow, error) {
	row := q.db.QueryRow(ctx, wmsFindTask, id)
	var i WmsFindTaskRow
	err := row.Scan(
		&i.WmsTask.ID,
		&i.WmsTask.TaskNumber,
		&i.WmsTask.WarehouseID,
		&i.WmsTask.UserID,
		&i.WmsTask.Type,
		&i.WmsTask.Status,
		&i.WmsTask.Priority,
		&i.WmsTask.SourceEntityID,
		&i.WmsTask.SourceEntityType,
		&i.WmsTask.PickBatchID,
		&i.WmsTask.EstimatedDuration,
		&i.WmsTask.ActualDuration,
		&i.WmsTask.Instructions,
		&i.WmsTask.Notes,
		&i.WmsTask.StartTime,
		&i.WmsTask.EndTime,
		&i.WmsTask.DurationSeconds,
		&i.WmsTask.CreatedAt,
		&i.WmsTask.UpdatedAt,
		&i.WmsWarehouse.ID,
		&i.WmsWarehouse.Name,
		&i.WmsWarehouse.Address,
		&i.WmsWarehouse.City,
		&i.WmsWarehouse.State,
		&i.WmsWarehouse.PostalCode,
		&i.WmsWarehouse.Country,
		&i.WmsWarehouse.Timezone,
		&i.WmsWarehouse.ContactPerson,
		&i.WmsWarehouse.ContactEmail,
		&i.WmsWarehouse.ContactPhone,
		&i.WmsWarehouse.IsActive,
		&i.WmsWarehouse.CreatedAt,
		&i.WmsWarehouse.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
		&i.WmsPickBatch.ID,
		&i.WmsPickBatch.BatchNumber,
		&i.WmsPickBatch.WarehouseID,
		&i.WmsPickBatch.Status,
		&i.WmsPickBatch.Strategy,
		&i.WmsPickBatch.Priority,
		&i.WmsPickBatch.AssignedUserID,
		&i.WmsPickBatch.WaveID,
		&i.WmsPickBatch.ZoneRestrictions,
		&i.WmsPickBatch.EstimatedDuration,
		&i.WmsPickBatch.ActualDuration,
		&i.WmsPickBatch.TotalItems,
		&i.WmsPickBatch.CompletedItems,
		&i.WmsPickBatch.StartedAt,
		&i.WmsPickBatch.CompletedAt,
		&i.WmsPickBatch.CreatedAt,
		&i.WmsPickBatch.UpdatedAt,
	)
	return i, err
}

const wmsInsertTask = `-- name: WmsInsertTask :one
insert into "wms"."tasks"(task_number, warehouse_id, user_id, type, status, priority, source_entity_id, source_entity_type, pick_batch_id, estimated_duration, actual_duration, instructions, notes, start_time, end_time)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
returning
  id, task_number, warehouse_id, user_id, type, status, priority, source_entity_id, source_entity_type, pick_batch_id, estimated_duration, actual_duration, instructions, notes, start_time, end_time, duration_seconds, created_at, updated_at
`

type WmsInsertTaskParams struct {
	TaskNumber        string
	WarehouseID       pgtype.UUID
	UserID            pgtype.Text
	Type              WmsTaskTypeEnum
	Status            NullWmsTaskStatusEnum
	Priority          pgtype.Int4
	SourceEntityID    pgtype.UUID
	SourceEntityType  pgtype.Text
	PickBatchID       pgtype.UUID
	EstimatedDuration pgtype.Int4
	ActualDuration    pgtype.Int4
	Instructions      pgtype.Text
	Notes             pgtype.Text
	StartTime         pgtype.Timestamp
	EndTime           pgtype.Timestamp
}

func (q *Queries) WmsInsertTask(ctx context.Context, arg WmsInsertTaskParams) (WmsTask, error) {
	row := q.db.QueryRow(ctx, wmsInsertTask,
		arg.TaskNumber,
		arg.WarehouseID,
		arg.UserID,
		arg.Type,
		arg.Status,
		arg.Priority,
		arg.SourceEntityID,
		arg.SourceEntityType,
		arg.PickBatchID,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.Instructions,
		arg.Notes,
		arg.StartTime,
		arg.EndTime,
	)
	var i WmsTask
	err := row.Scan(
		&i.ID,
		&i.TaskNumber,
		&i.WarehouseID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.Priority,
		&i.SourceEntityID,
		&i.SourceEntityType,
		&i.PickBatchID,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Instructions,
		&i.Notes,
		&i.StartTime,
		&i.EndTime,
		&i.DurationSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateTask = `-- name: WmsPaginateTask :many
select
  tasks.id, tasks.task_number, tasks.warehouse_id, tasks.user_id, tasks.type, tasks.status, tasks.priority, tasks.source_entity_id, tasks.source_entity_type, tasks.pick_batch_id, tasks.estimated_duration, tasks.actual_duration, tasks.instructions, tasks.notes, tasks.start_time, tasks.end_time, tasks.duration_seconds, tasks.created_at, tasks.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at
from
  "wms"."tasks" as tasks
  inner join "wms"."warehouses" as warehouse on tasks.warehouse_id = warehouse.id
  left join "public"."user" as users on tasks.user_id = users.id
  left join "wms"."pick_batches" as pick_batch on tasks.pick_batch_id = pick_batch.id
limit $2::int offset ($1::int - 1) * $2::int
`

type WmsPaginateTaskParams struct {
	Page    int32
	Perpage int32
}

type WmsPaginateTaskRow struct {
	WmsTask      WmsTask
	WmsWarehouse WmsWarehouse
	User         User
	WmsPickBatch WmsPickBatch
}

func (q *Queries) WmsPaginateTask(ctx context.Context, arg WmsPaginateTaskParams) ([]WmsPaginateTaskRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateTask, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateTaskRow
	for rows.Next() {
		var i WmsPaginateTaskRow
		if err := rows.Scan(
			&i.WmsTask.ID,
			&i.WmsTask.TaskNumber,
			&i.WmsTask.WarehouseID,
			&i.WmsTask.UserID,
			&i.WmsTask.Type,
			&i.WmsTask.Status,
			&i.WmsTask.Priority,
			&i.WmsTask.SourceEntityID,
			&i.WmsTask.SourceEntityType,
			&i.WmsTask.PickBatchID,
			&i.WmsTask.EstimatedDuration,
			&i.WmsTask.ActualDuration,
			&i.WmsTask.Instructions,
			&i.WmsTask.Notes,
			&i.WmsTask.StartTime,
			&i.WmsTask.EndTime,
			&i.WmsTask.DurationSeconds,
			&i.WmsTask.CreatedAt,
			&i.WmsTask.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeTask = `-- name: WmsRangeTask :many
select
  tasks.id, tasks.task_number, tasks.warehouse_id, tasks.user_id, tasks.type, tasks.status, tasks.priority, tasks.source_entity_id, tasks.source_entity_type, tasks.pick_batch_id, tasks.estimated_duration, tasks.actual_duration, tasks.instructions, tasks.notes, tasks.start_time, tasks.end_time, tasks.duration_seconds, tasks.created_at, tasks.updated_at,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at
from
  "wms"."tasks" as tasks
  inner join "wms"."warehouses" as warehouse on tasks.warehouse_id = warehouse.id
  left join "public"."user" as users on tasks.user_id = users.id
  left join "wms"."pick_batches" as pick_batch on tasks.pick_batch_id = pick_batch.id
where
  tasks.created_at >= $1::date
  and tasks.created_at <= $2::date
`

type WmsRangeTaskParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type WmsRangeTaskRow struct {
	WmsTask      WmsTask
	WmsWarehouse WmsWarehouse
	User         User
	WmsPickBatch WmsPickBatch
}

func (q *Queries) WmsRangeTask(ctx context.Context, arg WmsRangeTaskParams) ([]WmsRangeTaskRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeTask, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeTaskRow
	for rows.Next() {
		var i WmsRangeTaskRow
		if err := rows.Scan(
			&i.WmsTask.ID,
			&i.WmsTask.TaskNumber,
			&i.WmsTask.WarehouseID,
			&i.WmsTask.UserID,
			&i.WmsTask.Type,
			&i.WmsTask.Status,
			&i.WmsTask.Priority,
			&i.WmsTask.SourceEntityID,
			&i.WmsTask.SourceEntityType,
			&i.WmsTask.PickBatchID,
			&i.WmsTask.EstimatedDuration,
			&i.WmsTask.ActualDuration,
			&i.WmsTask.Instructions,
			&i.WmsTask.Notes,
			&i.WmsTask.StartTime,
			&i.WmsTask.EndTime,
			&i.WmsTask.DurationSeconds,
			&i.WmsTask.CreatedAt,
			&i.WmsTask.UpdatedAt,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveTask = `-- name: WmsRemoveTask :exec
delete from "wms"."tasks"
where id = $1::uuid
`

func (q *Queries) WmsRemoveTask(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveTask, id)
	return err
}

const wmsUpdateTask = `-- name: WmsUpdateTask :one
update
  "wms"."tasks"
set
  task_number = case when $1::boolean then
    $2::varchar
  else
    task_number
  end,
  warehouse_id = case when $3::boolean then
    $4::uuid
  else
    warehouse_id
  end,
  user_id = case when $5::boolean then
    $6::text
  else
    user_id
  end,
  type = case when $7::boolean then
    $8::wms.task_type_enum
  else
    type
  end,
  status = case when $9::boolean then
    $10::wms.task_status_enum
  else
    status
  end,
  priority = case when $11::boolean then
    $12::integer
  else
    priority
  end,
  source_entity_id = case when $13::boolean then
    $14::uuid
  else
    source_entity_id
  end,
  source_entity_type = case when $15::boolean then
    $16::varchar
  else
    source_entity_type
  end,
  pick_batch_id = case when $17::boolean then
    $18::uuid
  else
    pick_batch_id
  end,
  estimated_duration = case when $19::boolean then
    $20::integer
  else
    estimated_duration
  end,
  actual_duration = case when $21::boolean then
    $22::integer
  else
    actual_duration
  end,
  instructions = case when $23::boolean then
    $24::text
  else
    instructions
  end,
  notes = case when $25::boolean then
    $26::text
  else
    notes
  end,
  start_time = case when $27::boolean then
    $28::timestamp
  else
    start_time
  end,
  end_time = case when $29::boolean then
    $30::timestamp
  else
    end_time
  end
where
  id = $31::uuid
returning
  id, task_number, warehouse_id, user_id, type, status, priority, source_entity_id, source_entity_type, pick_batch_id, estimated_duration, actual_duration, instructions, notes, start_time, end_time, duration_seconds, created_at, updated_at
`

type WmsUpdateTaskParams struct {
	SetTaskNumber        bool
	TaskNumber           string
	SetWarehouseID       bool
	WarehouseID          pgtype.UUID
	SetUserID            bool
	UserID               string
	SetType              bool
	Type                 WmsTaskTypeEnum
	SetStatus            bool
	Status               WmsTaskStatusEnum
	SetPriority          bool
	Priority             int32
	SetSourceEntityID    bool
	SourceEntityID       pgtype.UUID
	SetSourceEntityType  bool
	SourceEntityType     string
	SetPickBatchID       bool
	PickBatchID          pgtype.UUID
	SetEstimatedDuration bool
	EstimatedDuration    int32
	SetActualDuration    bool
	ActualDuration       int32
	SetInstructions      bool
	Instructions         string
	SetNotes             bool
	Notes                string
	SetStartTime         bool
	StartTime            pgtype.Timestamp
	SetEndTime           bool
	EndTime              pgtype.Timestamp
	ID                   pgtype.UUID
}

func (q *Queries) WmsUpdateTask(ctx context.Context, arg WmsUpdateTaskParams) (WmsTask, error) {
	row := q.db.QueryRow(ctx, wmsUpdateTask,
		arg.SetTaskNumber,
		arg.TaskNumber,
		arg.SetWarehouseID,
		arg.WarehouseID,
		arg.SetUserID,
		arg.UserID,
		arg.SetType,
		arg.Type,
		arg.SetStatus,
		arg.Status,
		arg.SetPriority,
		arg.Priority,
		arg.SetSourceEntityID,
		arg.SourceEntityID,
		arg.SetSourceEntityType,
		arg.SourceEntityType,
		arg.SetPickBatchID,
		arg.PickBatchID,
		arg.SetEstimatedDuration,
		arg.EstimatedDuration,
		arg.SetActualDuration,
		arg.ActualDuration,
		arg.SetInstructions,
		arg.Instructions,
		arg.SetNotes,
		arg.Notes,
		arg.SetStartTime,
		arg.StartTime,
		arg.SetEndTime,
		arg.EndTime,
		arg.ID,
	)
	var i WmsTask
	err := row.Scan(
		&i.ID,
		&i.TaskNumber,
		&i.WarehouseID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.Priority,
		&i.SourceEntityID,
		&i.SourceEntityType,
		&i.PickBatchID,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Instructions,
		&i.Notes,
		&i.StartTime,
		&i.EndTime,
		&i.DurationSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
