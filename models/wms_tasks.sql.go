// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_tasks.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyTask = `-- name: WmsAnyTask :many
select
  tasks.id, tasks.task_number, tasks.warehouse_id, tasks.user_id, tasks.type, tasks.status, tasks.priority, tasks.source_entity_id, tasks.source_entity_type, tasks.pick_batch_id, tasks.estimated_duration, tasks.actual_duration, tasks.instructions, tasks.notes, tasks.start_time, tasks.end_time, tasks.duration_seconds, tasks.created_at, tasks.updated_at, tasks.task_items,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at
from
  "wms"."tasks_view" as tasks
  inner join "wms"."warehouses" as warehouse on tasks.warehouse_id = warehouse.id
  left join "public"."user" as users on tasks.user_id = users.id
  left join "wms"."pick_batches" as pick_batch on tasks.pick_batch_id = pick_batch.id
where
  tasks.id = any ($1::uuid[])
`

type WmsAnyTaskRow struct {
	ID                pgtype.UUID           `db:"id" json:"id"`
	TaskNumber        string                `db:"task_number" json:"task_number"`
	WarehouseID       pgtype.UUID           `db:"warehouse_id" json:"warehouse_id"`
	UserID            pgtype.Text           `db:"user_id" json:"user_id"`
	Type              WmsTaskTypeEnum       `db:"type" json:"type"`
	Status            NullWmsTaskStatusEnum `db:"status" json:"status"`
	Priority          pgtype.Int4           `db:"priority" json:"priority"`
	SourceEntityID    pgtype.UUID           `db:"source_entity_id" json:"source_entity_id"`
	SourceEntityType  pgtype.Text           `db:"source_entity_type" json:"source_entity_type"`
	PickBatchID       pgtype.UUID           `db:"pick_batch_id" json:"pick_batch_id"`
	EstimatedDuration pgtype.Int4           `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4           `db:"actual_duration" json:"actual_duration"`
	Instructions      pgtype.Text           `db:"instructions" json:"instructions"`
	Notes             pgtype.Text           `db:"notes" json:"notes"`
	StartTime         pgtype.Timestamp      `db:"start_time" json:"start_time"`
	EndTime           pgtype.Timestamp      `db:"end_time" json:"end_time"`
	DurationSeconds   pgtype.Int4           `db:"duration_seconds" json:"duration_seconds"`
	CreatedAt         pgtype.Timestamp      `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp      `db:"updated_at" json:"updated_at"`
	TaskItems         []WmsTaskItem         `db:"task_items" json:"task_items"`
	WmsWarehouse      WmsWarehouse          `db:"wms_warehouse" json:"wms_warehouse"`
	User              User                  `db:"user" json:"user"`
	WmsPickBatch      WmsPickBatch          `db:"wms_pick_batch" json:"wms_pick_batch"`
}

func (q *Queries) WmsAnyTask(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyTaskRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyTask, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyTaskRow
	for rows.Next() {
		var i WmsAnyTaskRow
		if err := rows.Scan(
			&i.ID,
			&i.TaskNumber,
			&i.WarehouseID,
			&i.UserID,
			&i.Type,
			&i.Status,
			&i.Priority,
			&i.SourceEntityID,
			&i.SourceEntityType,
			&i.PickBatchID,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.Instructions,
			&i.Notes,
			&i.StartTime,
			&i.EndTime,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TaskItems,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindTask = `-- name: WmsFindTask :one
select
  tasks.id, tasks.task_number, tasks.warehouse_id, tasks.user_id, tasks.type, tasks.status, tasks.priority, tasks.source_entity_id, tasks.source_entity_type, tasks.pick_batch_id, tasks.estimated_duration, tasks.actual_duration, tasks.instructions, tasks.notes, tasks.start_time, tasks.end_time, tasks.duration_seconds, tasks.created_at, tasks.updated_at, tasks.task_items,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at
from
  "wms"."tasks_view" as tasks
  inner join "wms"."warehouses" as warehouse on tasks.warehouse_id = warehouse.id
  left join "public"."user" as users on tasks.user_id = users.id
  left join "wms"."pick_batches" as pick_batch on tasks.pick_batch_id = pick_batch.id
where
  tasks.id = $1::uuid
`

type WmsFindTaskRow struct {
	ID                pgtype.UUID           `db:"id" json:"id"`
	TaskNumber        string                `db:"task_number" json:"task_number"`
	WarehouseID       pgtype.UUID           `db:"warehouse_id" json:"warehouse_id"`
	UserID            pgtype.Text           `db:"user_id" json:"user_id"`
	Type              WmsTaskTypeEnum       `db:"type" json:"type"`
	Status            NullWmsTaskStatusEnum `db:"status" json:"status"`
	Priority          pgtype.Int4           `db:"priority" json:"priority"`
	SourceEntityID    pgtype.UUID           `db:"source_entity_id" json:"source_entity_id"`
	SourceEntityType  pgtype.Text           `db:"source_entity_type" json:"source_entity_type"`
	PickBatchID       pgtype.UUID           `db:"pick_batch_id" json:"pick_batch_id"`
	EstimatedDuration pgtype.Int4           `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4           `db:"actual_duration" json:"actual_duration"`
	Instructions      pgtype.Text           `db:"instructions" json:"instructions"`
	Notes             pgtype.Text           `db:"notes" json:"notes"`
	StartTime         pgtype.Timestamp      `db:"start_time" json:"start_time"`
	EndTime           pgtype.Timestamp      `db:"end_time" json:"end_time"`
	DurationSeconds   pgtype.Int4           `db:"duration_seconds" json:"duration_seconds"`
	CreatedAt         pgtype.Timestamp      `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp      `db:"updated_at" json:"updated_at"`
	TaskItems         []WmsTaskItem         `db:"task_items" json:"task_items"`
	WmsWarehouse      WmsWarehouse          `db:"wms_warehouse" json:"wms_warehouse"`
	User              User                  `db:"user" json:"user"`
	WmsPickBatch      WmsPickBatch          `db:"wms_pick_batch" json:"wms_pick_batch"`
}

func (q *Queries) WmsFindTask(ctx context.Context, id pgtype.UUID) (WmsFindTaskRow, error) {
	row := q.db.QueryRow(ctx, wmsFindTask, id)
	var i WmsFindTaskRow
	err := row.Scan(
		&i.ID,
		&i.TaskNumber,
		&i.WarehouseID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.Priority,
		&i.SourceEntityID,
		&i.SourceEntityType,
		&i.PickBatchID,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Instructions,
		&i.Notes,
		&i.StartTime,
		&i.EndTime,
		&i.DurationSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TaskItems,
		&i.WmsWarehouse.ID,
		&i.WmsWarehouse.Name,
		&i.WmsWarehouse.Address,
		&i.WmsWarehouse.City,
		&i.WmsWarehouse.State,
		&i.WmsWarehouse.PostalCode,
		&i.WmsWarehouse.Country,
		&i.WmsWarehouse.Timezone,
		&i.WmsWarehouse.ContactPerson,
		&i.WmsWarehouse.ContactEmail,
		&i.WmsWarehouse.ContactPhone,
		&i.WmsWarehouse.IsActive,
		&i.WmsWarehouse.CreatedAt,
		&i.WmsWarehouse.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
		&i.WmsPickBatch.ID,
		&i.WmsPickBatch.BatchNumber,
		&i.WmsPickBatch.WarehouseID,
		&i.WmsPickBatch.Status,
		&i.WmsPickBatch.Strategy,
		&i.WmsPickBatch.Priority,
		&i.WmsPickBatch.AssignedUserID,
		&i.WmsPickBatch.WaveID,
		&i.WmsPickBatch.ZoneRestrictions,
		&i.WmsPickBatch.EstimatedDuration,
		&i.WmsPickBatch.ActualDuration,
		&i.WmsPickBatch.TotalItems,
		&i.WmsPickBatch.CompletedItems,
		&i.WmsPickBatch.StartedAt,
		&i.WmsPickBatch.CompletedAt,
		&i.WmsPickBatch.CreatedAt,
		&i.WmsPickBatch.UpdatedAt,
	)
	return i, err
}

const wmsInsertTask = `-- name: WmsInsertTask :one
insert into "wms"."tasks"(task_number, warehouse_id, user_id, type, status, priority, source_entity_id, source_entity_type, pick_batch_id, estimated_duration, actual_duration, instructions, notes, start_time, end_time)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
returning
  id, task_number, warehouse_id, user_id, type, status, priority, source_entity_id, source_entity_type, pick_batch_id, estimated_duration, actual_duration, instructions, notes, start_time, end_time, duration_seconds, created_at, updated_at
`

type WmsInsertTaskParams struct {
	TaskNumber        string                `db:"task_number" fake:"{uuid}" json:"task_number"`
	WarehouseID       pgtype.UUID           `db:"warehouse_id" json:"warehouse_id"`
	UserID            pgtype.Text           `db:"user_id" json:"user_id"`
	Type              WmsTaskTypeEnum       `db:"type" json:"type"`
	Status            NullWmsTaskStatusEnum `db:"status" json:"status"`
	Priority          pgtype.Int4           `db:"priority" fake:"{number:1,100}" json:"priority"`
	SourceEntityID    pgtype.UUID           `db:"source_entity_id" json:"source_entity_id"`
	SourceEntityType  pgtype.Text           `db:"source_entity_type" fake:"{randomstring:[inbound_shipment,pick_batch,return]}" json:"source_entity_type"`
	PickBatchID       pgtype.UUID           `db:"pick_batch_id" json:"pick_batch_id"`
	EstimatedDuration pgtype.Int4           `db:"estimated_duration" fake:"{number:10,60}" json:"estimated_duration"`
	ActualDuration    pgtype.Int4           `db:"actual_duration" fake:"{number:10,60}" json:"actual_duration"`
	Instructions      pgtype.Text           `db:"instructions" fake:"{sentence}" json:"instructions"`
	Notes             pgtype.Text           `db:"notes" fake:"{paragraph}" json:"notes"`
	StartTime         pgtype.Timestamp      `db:"start_time" fake:"{date}" json:"start_time"`
	EndTime           pgtype.Timestamp      `db:"end_time" fake:"{date}" json:"end_time"`
}

func (q *Queries) WmsInsertTask(ctx context.Context, arg WmsInsertTaskParams) (WmsTask, error) {
	row := q.db.QueryRow(ctx, wmsInsertTask,
		arg.TaskNumber,
		arg.WarehouseID,
		arg.UserID,
		arg.Type,
		arg.Status,
		arg.Priority,
		arg.SourceEntityID,
		arg.SourceEntityType,
		arg.PickBatchID,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.Instructions,
		arg.Notes,
		arg.StartTime,
		arg.EndTime,
	)
	var i WmsTask
	err := row.Scan(
		&i.ID,
		&i.TaskNumber,
		&i.WarehouseID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.Priority,
		&i.SourceEntityID,
		&i.SourceEntityType,
		&i.PickBatchID,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Instructions,
		&i.Notes,
		&i.StartTime,
		&i.EndTime,
		&i.DurationSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateTask = `-- name: WmsPaginateTask :many
select
  tasks.id, tasks.task_number, tasks.warehouse_id, tasks.user_id, tasks.type, tasks.status, tasks.priority, tasks.source_entity_id, tasks.source_entity_type, tasks.pick_batch_id, tasks.estimated_duration, tasks.actual_duration, tasks.instructions, tasks.notes, tasks.start_time, tasks.end_time, tasks.duration_seconds, tasks.created_at, tasks.updated_at, tasks.task_items,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at
from
  "wms"."tasks_view" as tasks
  inner join "wms"."warehouses" as warehouse on tasks.warehouse_id = warehouse.id
  left join "public"."user" as users on tasks.user_id = users.id
  left join "wms"."pick_batches" as pick_batch on tasks.pick_batch_id = pick_batch.id
where (tasks.task_number ilike $1::text
  or warehouse.name ilike $1::text
  or users.name ilike $1::text
  or tasks.type::text ilike $1::text
  or tasks.status::text ilike $1::text
  or pick_batch.batch_number ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateTaskParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type WmsPaginateTaskRow struct {
	ID                pgtype.UUID           `db:"id" json:"id"`
	TaskNumber        string                `db:"task_number" json:"task_number"`
	WarehouseID       pgtype.UUID           `db:"warehouse_id" json:"warehouse_id"`
	UserID            pgtype.Text           `db:"user_id" json:"user_id"`
	Type              WmsTaskTypeEnum       `db:"type" json:"type"`
	Status            NullWmsTaskStatusEnum `db:"status" json:"status"`
	Priority          pgtype.Int4           `db:"priority" json:"priority"`
	SourceEntityID    pgtype.UUID           `db:"source_entity_id" json:"source_entity_id"`
	SourceEntityType  pgtype.Text           `db:"source_entity_type" json:"source_entity_type"`
	PickBatchID       pgtype.UUID           `db:"pick_batch_id" json:"pick_batch_id"`
	EstimatedDuration pgtype.Int4           `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4           `db:"actual_duration" json:"actual_duration"`
	Instructions      pgtype.Text           `db:"instructions" json:"instructions"`
	Notes             pgtype.Text           `db:"notes" json:"notes"`
	StartTime         pgtype.Timestamp      `db:"start_time" json:"start_time"`
	EndTime           pgtype.Timestamp      `db:"end_time" json:"end_time"`
	DurationSeconds   pgtype.Int4           `db:"duration_seconds" json:"duration_seconds"`
	CreatedAt         pgtype.Timestamp      `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp      `db:"updated_at" json:"updated_at"`
	TaskItems         []WmsTaskItem         `db:"task_items" json:"task_items"`
	WmsWarehouse      WmsWarehouse          `db:"wms_warehouse" json:"wms_warehouse"`
	User              User                  `db:"user" json:"user"`
	WmsPickBatch      WmsPickBatch          `db:"wms_pick_batch" json:"wms_pick_batch"`
}

func (q *Queries) WmsPaginateTask(ctx context.Context, arg WmsPaginateTaskParams) ([]WmsPaginateTaskRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateTask, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateTaskRow
	for rows.Next() {
		var i WmsPaginateTaskRow
		if err := rows.Scan(
			&i.ID,
			&i.TaskNumber,
			&i.WarehouseID,
			&i.UserID,
			&i.Type,
			&i.Status,
			&i.Priority,
			&i.SourceEntityID,
			&i.SourceEntityType,
			&i.PickBatchID,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.Instructions,
			&i.Notes,
			&i.StartTime,
			&i.EndTime,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TaskItems,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsPaginateTaskMetadata = `-- name: WmsPaginateTaskMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "wms"."tasks_view" as tasks
`

type WmsPaginateTaskMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type WmsPaginateTaskMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) WmsPaginateTaskMetadata(ctx context.Context, arg WmsPaginateTaskMetadataParams) (WmsPaginateTaskMetadataRow, error) {
	row := q.db.QueryRow(ctx, wmsPaginateTaskMetadata, arg.PerPage, arg.Page)
	var i WmsPaginateTaskMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const wmsRangeTask = `-- name: WmsRangeTask :many
select
  tasks.id, tasks.task_number, tasks.warehouse_id, tasks.user_id, tasks.type, tasks.status, tasks.priority, tasks.source_entity_id, tasks.source_entity_type, tasks.pick_batch_id, tasks.estimated_duration, tasks.actual_duration, tasks.instructions, tasks.notes, tasks.start_time, tasks.end_time, tasks.duration_seconds, tasks.created_at, tasks.updated_at, tasks.task_items,
  warehouse.id, warehouse.name, warehouse.address, warehouse.city, warehouse.state, warehouse.postal_code, warehouse.country, warehouse.timezone, warehouse.contact_person, warehouse.contact_email, warehouse.contact_phone, warehouse.is_active, warehouse.created_at, warehouse.updated_at,
  users.id, users.name, users.email, users.email_verified, users.image, users.created_at, users.updated_at, users.role, users.banned, users.ban_reason, users.ban_expires,
  pick_batch.id, pick_batch.batch_number, pick_batch.warehouse_id, pick_batch.status, pick_batch.strategy, pick_batch.priority, pick_batch.assigned_user_id, pick_batch.wave_id, pick_batch.zone_restrictions, pick_batch.estimated_duration, pick_batch.actual_duration, pick_batch.total_items, pick_batch.completed_items, pick_batch.started_at, pick_batch.completed_at, pick_batch.created_at, pick_batch.updated_at
from
  "wms"."tasks_view" as tasks
  inner join "wms"."warehouses" as warehouse on tasks.warehouse_id = warehouse.id
  left join "public"."user" as users on tasks.user_id = users.id
  left join "wms"."pick_batches" as pick_batch on tasks.pick_batch_id = pick_batch.id
where
  tasks.created_at >= $1::date
  and tasks.created_at <= $2::date
  and (tasks.task_number ilike $3::text
    or warehouse.name ilike $3::text
    or users.name ilike $3::text
    or tasks.type::text ilike $3::text
    or tasks.status::text ilike $3::text
    or pick_batch.batch_number ilike $3::text
    or $3::text is null)
`

type WmsRangeTaskParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangeTaskRow struct {
	ID                pgtype.UUID           `db:"id" json:"id"`
	TaskNumber        string                `db:"task_number" json:"task_number"`
	WarehouseID       pgtype.UUID           `db:"warehouse_id" json:"warehouse_id"`
	UserID            pgtype.Text           `db:"user_id" json:"user_id"`
	Type              WmsTaskTypeEnum       `db:"type" json:"type"`
	Status            NullWmsTaskStatusEnum `db:"status" json:"status"`
	Priority          pgtype.Int4           `db:"priority" json:"priority"`
	SourceEntityID    pgtype.UUID           `db:"source_entity_id" json:"source_entity_id"`
	SourceEntityType  pgtype.Text           `db:"source_entity_type" json:"source_entity_type"`
	PickBatchID       pgtype.UUID           `db:"pick_batch_id" json:"pick_batch_id"`
	EstimatedDuration pgtype.Int4           `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4           `db:"actual_duration" json:"actual_duration"`
	Instructions      pgtype.Text           `db:"instructions" json:"instructions"`
	Notes             pgtype.Text           `db:"notes" json:"notes"`
	StartTime         pgtype.Timestamp      `db:"start_time" json:"start_time"`
	EndTime           pgtype.Timestamp      `db:"end_time" json:"end_time"`
	DurationSeconds   pgtype.Int4           `db:"duration_seconds" json:"duration_seconds"`
	CreatedAt         pgtype.Timestamp      `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp      `db:"updated_at" json:"updated_at"`
	TaskItems         []WmsTaskItem         `db:"task_items" json:"task_items"`
	WmsWarehouse      WmsWarehouse          `db:"wms_warehouse" json:"wms_warehouse"`
	User              User                  `db:"user" json:"user"`
	WmsPickBatch      WmsPickBatch          `db:"wms_pick_batch" json:"wms_pick_batch"`
}

func (q *Queries) WmsRangeTask(ctx context.Context, arg WmsRangeTaskParams) ([]WmsRangeTaskRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeTask, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeTaskRow
	for rows.Next() {
		var i WmsRangeTaskRow
		if err := rows.Scan(
			&i.ID,
			&i.TaskNumber,
			&i.WarehouseID,
			&i.UserID,
			&i.Type,
			&i.Status,
			&i.Priority,
			&i.SourceEntityID,
			&i.SourceEntityType,
			&i.PickBatchID,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.Instructions,
			&i.Notes,
			&i.StartTime,
			&i.EndTime,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TaskItems,
			&i.WmsWarehouse.ID,
			&i.WmsWarehouse.Name,
			&i.WmsWarehouse.Address,
			&i.WmsWarehouse.City,
			&i.WmsWarehouse.State,
			&i.WmsWarehouse.PostalCode,
			&i.WmsWarehouse.Country,
			&i.WmsWarehouse.Timezone,
			&i.WmsWarehouse.ContactPerson,
			&i.WmsWarehouse.ContactEmail,
			&i.WmsWarehouse.ContactPhone,
			&i.WmsWarehouse.IsActive,
			&i.WmsWarehouse.CreatedAt,
			&i.WmsWarehouse.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.WmsPickBatch.ID,
			&i.WmsPickBatch.BatchNumber,
			&i.WmsPickBatch.WarehouseID,
			&i.WmsPickBatch.Status,
			&i.WmsPickBatch.Strategy,
			&i.WmsPickBatch.Priority,
			&i.WmsPickBatch.AssignedUserID,
			&i.WmsPickBatch.WaveID,
			&i.WmsPickBatch.ZoneRestrictions,
			&i.WmsPickBatch.EstimatedDuration,
			&i.WmsPickBatch.ActualDuration,
			&i.WmsPickBatch.TotalItems,
			&i.WmsPickBatch.CompletedItems,
			&i.WmsPickBatch.StartedAt,
			&i.WmsPickBatch.CompletedAt,
			&i.WmsPickBatch.CreatedAt,
			&i.WmsPickBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveTask = `-- name: WmsRemoveTask :exec
delete from "wms"."tasks"
where id = $1::uuid
`

func (q *Queries) WmsRemoveTask(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveTask, id)
	return err
}

const wmsUpdateTask = `-- name: WmsUpdateTask :one
update
  "wms"."tasks"
set
  updated_at = now(),
  task_number = case when $1 is not null then
    $1::varchar
  else
    task_number
  end,
  warehouse_id = case when $2 is not null then
    $2::uuid
  else
    warehouse_id
  end,
  user_id = case when $3 is not null then
    $3::text
  else
    user_id
  end,
  type = case when $4 is not null then
    $4::wms.task_type_enum
  else
    type
  end,
  status = case when $5 is not null then
    $5::wms.task_status_enum
  else
    status
  end,
  priority = case when $6 is not null then
    $6::integer
  else
    priority
  end,
  source_entity_id = case when $7 is not null then
    $7::uuid
  else
    source_entity_id
  end,
  source_entity_type = case when $8 is not null then
    $8::varchar
  else
    source_entity_type
  end,
  pick_batch_id = case when $9 is not null then
    $9::uuid
  else
    pick_batch_id
  end,
  estimated_duration = case when $10 is not null then
    $10::integer
  else
    estimated_duration
  end,
  actual_duration = case when $11 is not null then
    $11::integer
  else
    actual_duration
  end,
  instructions = case when $12 is not null then
    $12::text
  else
    instructions
  end,
  notes = case when $13 is not null then
    $13::text
  else
    notes
  end,
  start_time = case when $14 is not null then
    $14::timestamp
  else
    start_time
  end,
  end_time = case when $15 is not null then
    $15::timestamp
  else
    end_time
  end
where
  id = $16::uuid
returning
  id, task_number, warehouse_id, user_id, type, status, priority, source_entity_id, source_entity_type, pick_batch_id, estimated_duration, actual_duration, instructions, notes, start_time, end_time, duration_seconds, created_at, updated_at
`

type WmsUpdateTaskParams struct {
	TaskNumber        string                `db:"task_number" fake:"{uuid}" json:"task_number"`
	WarehouseID       pgtype.UUID           `db:"warehouse_id" json:"warehouse_id"`
	UserID            pgtype.Text           `db:"user_id" json:"user_id"`
	Type              WmsTaskTypeEnum       `db:"type" json:"type"`
	Status            NullWmsTaskStatusEnum `db:"status" json:"status"`
	Priority          pgtype.Int4           `db:"priority" fake:"{number:1,100}" json:"priority"`
	SourceEntityID    pgtype.UUID           `db:"source_entity_id" json:"source_entity_id"`
	SourceEntityType  pgtype.Text           `db:"source_entity_type" fake:"{randomstring:[inbound_shipment,pick_batch,return]}" json:"source_entity_type"`
	PickBatchID       pgtype.UUID           `db:"pick_batch_id" json:"pick_batch_id"`
	EstimatedDuration pgtype.Int4           `db:"estimated_duration" fake:"{number:10,60}" json:"estimated_duration"`
	ActualDuration    pgtype.Int4           `db:"actual_duration" fake:"{number:10,60}" json:"actual_duration"`
	Instructions      pgtype.Text           `db:"instructions" fake:"{sentence}" json:"instructions"`
	Notes             pgtype.Text           `db:"notes" fake:"{paragraph}" json:"notes"`
	StartTime         pgtype.Timestamp      `db:"start_time" fake:"{date}" json:"start_time"`
	EndTime           pgtype.Timestamp      `db:"end_time" fake:"{date}" json:"end_time"`
	ID                pgtype.UUID           `db:"id" json:"id"`
}

func (q *Queries) WmsUpdateTask(ctx context.Context, arg WmsUpdateTaskParams) (WmsTask, error) {
	row := q.db.QueryRow(ctx, wmsUpdateTask,
		arg.TaskNumber,
		arg.WarehouseID,
		arg.UserID,
		arg.Type,
		arg.Status,
		arg.Priority,
		arg.SourceEntityID,
		arg.SourceEntityType,
		arg.PickBatchID,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.Instructions,
		arg.Notes,
		arg.StartTime,
		arg.EndTime,
		arg.ID,
	)
	var i WmsTask
	err := row.Scan(
		&i.ID,
		&i.TaskNumber,
		&i.WarehouseID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.Priority,
		&i.SourceEntityID,
		&i.SourceEntityType,
		&i.PickBatchID,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Instructions,
		&i.Notes,
		&i.StartTime,
		&i.EndTime,
		&i.DurationSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
