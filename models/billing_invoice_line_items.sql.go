// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_invoice_line_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyInvoiceLineItem = `-- name: BillingAnyInvoiceLineItem :many
select
  invoice_line_items.id, invoice_line_items.invoice_id, invoice_line_items.source_record_id, invoice_line_items.source_record_type, invoice_line_items.description, invoice_line_items.quantity, invoice_line_items.unit_price, invoice_line_items.total_price, invoice_line_items.tax_rate, invoice_line_items.tax_amount, invoice_line_items.discount_rate, invoice_line_items.discount_amount, invoice_line_items.line_total, invoice_line_items.created_at, invoice_line_items.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at
from
  "billing"."invoice_line_items" as invoice_line_items
  inner join "billing"."invoices" as invoice on invoice_line_items.invoice_id = invoice.id
where
  invoice_line_items.id = any ($1::uuid[])
`

type BillingAnyInvoiceLineItemRow struct {
	BillingInvoiceLineItem BillingInvoiceLineItem `db:"billing_invoice_line_item" json:"billing_invoice_line_item"`
	BillingInvoice         BillingInvoice         `db:"billing_invoice" json:"billing_invoice"`
}

func (q *Queries) BillingAnyInvoiceLineItem(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyInvoiceLineItemRow, error) {
	rows, err := q.db.Query(ctx, billingAnyInvoiceLineItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyInvoiceLineItemRow
	for rows.Next() {
		var i BillingAnyInvoiceLineItemRow
		if err := rows.Scan(
			&i.BillingInvoiceLineItem.ID,
			&i.BillingInvoiceLineItem.InvoiceID,
			&i.BillingInvoiceLineItem.SourceRecordID,
			&i.BillingInvoiceLineItem.SourceRecordType,
			&i.BillingInvoiceLineItem.Description,
			&i.BillingInvoiceLineItem.Quantity,
			&i.BillingInvoiceLineItem.UnitPrice,
			&i.BillingInvoiceLineItem.TotalPrice,
			&i.BillingInvoiceLineItem.TaxRate,
			&i.BillingInvoiceLineItem.TaxAmount,
			&i.BillingInvoiceLineItem.DiscountRate,
			&i.BillingInvoiceLineItem.DiscountAmount,
			&i.BillingInvoiceLineItem.LineTotal,
			&i.BillingInvoiceLineItem.CreatedAt,
			&i.BillingInvoiceLineItem.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindInvoiceLineItem = `-- name: BillingFindInvoiceLineItem :one
select
  invoice_line_items.id, invoice_line_items.invoice_id, invoice_line_items.source_record_id, invoice_line_items.source_record_type, invoice_line_items.description, invoice_line_items.quantity, invoice_line_items.unit_price, invoice_line_items.total_price, invoice_line_items.tax_rate, invoice_line_items.tax_amount, invoice_line_items.discount_rate, invoice_line_items.discount_amount, invoice_line_items.line_total, invoice_line_items.created_at, invoice_line_items.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at
from
  "billing"."invoice_line_items" as invoice_line_items
  inner join "billing"."invoices" as invoice on invoice_line_items.invoice_id = invoice.id
where
  invoice_line_items.id = $1::uuid
`

type BillingFindInvoiceLineItemRow struct {
	BillingInvoiceLineItem BillingInvoiceLineItem `db:"billing_invoice_line_item" json:"billing_invoice_line_item"`
	BillingInvoice         BillingInvoice         `db:"billing_invoice" json:"billing_invoice"`
}

func (q *Queries) BillingFindInvoiceLineItem(ctx context.Context, id pgtype.UUID) (BillingFindInvoiceLineItemRow, error) {
	row := q.db.QueryRow(ctx, billingFindInvoiceLineItem, id)
	var i BillingFindInvoiceLineItemRow
	err := row.Scan(
		&i.BillingInvoiceLineItem.ID,
		&i.BillingInvoiceLineItem.InvoiceID,
		&i.BillingInvoiceLineItem.SourceRecordID,
		&i.BillingInvoiceLineItem.SourceRecordType,
		&i.BillingInvoiceLineItem.Description,
		&i.BillingInvoiceLineItem.Quantity,
		&i.BillingInvoiceLineItem.UnitPrice,
		&i.BillingInvoiceLineItem.TotalPrice,
		&i.BillingInvoiceLineItem.TaxRate,
		&i.BillingInvoiceLineItem.TaxAmount,
		&i.BillingInvoiceLineItem.DiscountRate,
		&i.BillingInvoiceLineItem.DiscountAmount,
		&i.BillingInvoiceLineItem.LineTotal,
		&i.BillingInvoiceLineItem.CreatedAt,
		&i.BillingInvoiceLineItem.UpdatedAt,
		&i.BillingInvoice.ID,
		&i.BillingInvoice.ClientID,
		&i.BillingInvoice.QuoteID,
		&i.BillingInvoice.InvoiceNumber,
		&i.BillingInvoice.Status,
		&i.BillingInvoice.IssueDate,
		&i.BillingInvoice.DueDate,
		&i.BillingInvoice.TotalAmount,
		&i.BillingInvoice.AmountPaid,
		&i.BillingInvoice.AmountOutstanding,
		&i.BillingInvoice.Currency,
		&i.BillingInvoice.TaxAmount,
		&i.BillingInvoice.DiscountAmount,
		&i.BillingInvoice.Subtotal,
		&i.BillingInvoice.PaymentTerms,
		&i.BillingInvoice.Notes,
		&i.BillingInvoice.SentAt,
		&i.BillingInvoice.PaidAt,
		&i.BillingInvoice.CreatedByUserID,
		&i.BillingInvoice.CreatedAt,
		&i.BillingInvoice.UpdatedAt,
	)
	return i, err
}

const billingInsertInvoiceLineItem = `-- name: BillingInsertInvoiceLineItem :one
insert into "billing"."invoice_line_items"(invoice_id, source_record_id, source_record_type, description, quantity, unit_price, tax_rate, discount_rate)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, invoice_id, source_record_id, source_record_type, description, quantity, unit_price, total_price, tax_rate, tax_amount, discount_rate, discount_amount, line_total, created_at, updated_at
`

type BillingInsertInvoiceLineItemParams struct {
	InvoiceID        pgtype.UUID    `db:"invoice_id" json:"invoice_id"`
	SourceRecordID   pgtype.UUID    `db:"source_record_id" json:"source_record_id"`
	SourceRecordType pgtype.Text    `db:"source_record_type" json:"source_record_type"`
	Description      string         `db:"description" json:"description"`
	Quantity         pgtype.Numeric `db:"quantity" json:"quantity"`
	UnitPrice        pgtype.Numeric `db:"unit_price" json:"unit_price"`
	TaxRate          pgtype.Numeric `db:"tax_rate" json:"tax_rate"`
	DiscountRate     pgtype.Numeric `db:"discount_rate" json:"discount_rate"`
}

func (q *Queries) BillingInsertInvoiceLineItem(ctx context.Context, arg BillingInsertInvoiceLineItemParams) (BillingInvoiceLineItem, error) {
	row := q.db.QueryRow(ctx, billingInsertInvoiceLineItem,
		arg.InvoiceID,
		arg.SourceRecordID,
		arg.SourceRecordType,
		arg.Description,
		arg.Quantity,
		arg.UnitPrice,
		arg.TaxRate,
		arg.DiscountRate,
	)
	var i BillingInvoiceLineItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.SourceRecordID,
		&i.SourceRecordType,
		&i.Description,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.TaxRate,
		&i.TaxAmount,
		&i.DiscountRate,
		&i.DiscountAmount,
		&i.LineTotal,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateInvoiceLineItem = `-- name: BillingPaginateInvoiceLineItem :many
select
  invoice_line_items.id, invoice_line_items.invoice_id, invoice_line_items.source_record_id, invoice_line_items.source_record_type, invoice_line_items.description, invoice_line_items.quantity, invoice_line_items.unit_price, invoice_line_items.total_price, invoice_line_items.tax_rate, invoice_line_items.tax_amount, invoice_line_items.discount_rate, invoice_line_items.discount_amount, invoice_line_items.line_total, invoice_line_items.created_at, invoice_line_items.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at
from
  "billing"."invoice_line_items" as invoice_line_items
  inner join "billing"."invoices" as invoice on invoice_line_items.invoice_id = invoice.id
where (invoice.invoice_number ilike $1::text
  or invoice_line_items.description ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateInvoiceLineItemParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type BillingPaginateInvoiceLineItemRow struct {
	BillingInvoiceLineItem BillingInvoiceLineItem `db:"billing_invoice_line_item" json:"billing_invoice_line_item"`
	BillingInvoice         BillingInvoice         `db:"billing_invoice" json:"billing_invoice"`
}

func (q *Queries) BillingPaginateInvoiceLineItem(ctx context.Context, arg BillingPaginateInvoiceLineItemParams) ([]BillingPaginateInvoiceLineItemRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateInvoiceLineItem, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateInvoiceLineItemRow
	for rows.Next() {
		var i BillingPaginateInvoiceLineItemRow
		if err := rows.Scan(
			&i.BillingInvoiceLineItem.ID,
			&i.BillingInvoiceLineItem.InvoiceID,
			&i.BillingInvoiceLineItem.SourceRecordID,
			&i.BillingInvoiceLineItem.SourceRecordType,
			&i.BillingInvoiceLineItem.Description,
			&i.BillingInvoiceLineItem.Quantity,
			&i.BillingInvoiceLineItem.UnitPrice,
			&i.BillingInvoiceLineItem.TotalPrice,
			&i.BillingInvoiceLineItem.TaxRate,
			&i.BillingInvoiceLineItem.TaxAmount,
			&i.BillingInvoiceLineItem.DiscountRate,
			&i.BillingInvoiceLineItem.DiscountAmount,
			&i.BillingInvoiceLineItem.LineTotal,
			&i.BillingInvoiceLineItem.CreatedAt,
			&i.BillingInvoiceLineItem.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeInvoiceLineItem = `-- name: BillingRangeInvoiceLineItem :many
select
  invoice_line_items.id, invoice_line_items.invoice_id, invoice_line_items.source_record_id, invoice_line_items.source_record_type, invoice_line_items.description, invoice_line_items.quantity, invoice_line_items.unit_price, invoice_line_items.total_price, invoice_line_items.tax_rate, invoice_line_items.tax_amount, invoice_line_items.discount_rate, invoice_line_items.discount_amount, invoice_line_items.line_total, invoice_line_items.created_at, invoice_line_items.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at
from
  "billing"."invoice_line_items" as invoice_line_items
  inner join "billing"."invoices" as invoice on invoice_line_items.invoice_id = invoice.id
where
  invoice_line_items.created_at >= $1::date
  and invoice_line_items.created_at <= $2::date
  and (invoice.invoice_number ilike $3::text
    or invoice_line_items.description ilike $3::text
    or $3::text is null)
`

type BillingRangeInvoiceLineItemParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type BillingRangeInvoiceLineItemRow struct {
	BillingInvoiceLineItem BillingInvoiceLineItem `db:"billing_invoice_line_item" json:"billing_invoice_line_item"`
	BillingInvoice         BillingInvoice         `db:"billing_invoice" json:"billing_invoice"`
}

func (q *Queries) BillingRangeInvoiceLineItem(ctx context.Context, arg BillingRangeInvoiceLineItemParams) ([]BillingRangeInvoiceLineItemRow, error) {
	rows, err := q.db.Query(ctx, billingRangeInvoiceLineItem, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeInvoiceLineItemRow
	for rows.Next() {
		var i BillingRangeInvoiceLineItemRow
		if err := rows.Scan(
			&i.BillingInvoiceLineItem.ID,
			&i.BillingInvoiceLineItem.InvoiceID,
			&i.BillingInvoiceLineItem.SourceRecordID,
			&i.BillingInvoiceLineItem.SourceRecordType,
			&i.BillingInvoiceLineItem.Description,
			&i.BillingInvoiceLineItem.Quantity,
			&i.BillingInvoiceLineItem.UnitPrice,
			&i.BillingInvoiceLineItem.TotalPrice,
			&i.BillingInvoiceLineItem.TaxRate,
			&i.BillingInvoiceLineItem.TaxAmount,
			&i.BillingInvoiceLineItem.DiscountRate,
			&i.BillingInvoiceLineItem.DiscountAmount,
			&i.BillingInvoiceLineItem.LineTotal,
			&i.BillingInvoiceLineItem.CreatedAt,
			&i.BillingInvoiceLineItem.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveInvoiceLineItem = `-- name: BillingRemoveInvoiceLineItem :exec
delete from "billing"."invoice_line_items"
where id = $1::uuid
`

func (q *Queries) BillingRemoveInvoiceLineItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveInvoiceLineItem, id)
	return err
}

const billingUpdateInvoiceLineItem = `-- name: BillingUpdateInvoiceLineItem :one
update
  "billing"."invoice_line_items"
set
  updated_at = now(),
  invoice_id = case when $1 is not null then
    $1::uuid
  else
    invoice_id
  end,
  source_record_id = case when $2 is not null then
    $2::uuid
  else
    source_record_id
  end,
  source_record_type = case when $3 is not null then
    $3::varchar
  else
    source_record_type
  end,
  description = case when $4 is not null then
    $4::text
  else
    description
  end,
  quantity = case when $5 is not null then
    $5::numeric
  else
    quantity
  end,
  unit_price = case when $6 is not null then
    $6::numeric
  else
    unit_price
  end,
  tax_rate = case when $7 is not null then
    $7::numeric
  else
    tax_rate
  end,
  discount_rate = case when $8 is not null then
    $8::numeric
  else
    discount_rate
  end
where
  id = $9::uuid
returning
  id, invoice_id, source_record_id, source_record_type, description, quantity, unit_price, total_price, tax_rate, tax_amount, discount_rate, discount_amount, line_total, created_at, updated_at
`

type BillingUpdateInvoiceLineItemParams struct {
	InvoiceID        pgtype.UUID    `db:"invoice_id" json:"invoice_id"`
	SourceRecordID   pgtype.UUID    `db:"source_record_id" json:"source_record_id"`
	SourceRecordType pgtype.Text    `db:"source_record_type" json:"source_record_type"`
	Description      string         `db:"description" json:"description"`
	Quantity         pgtype.Numeric `db:"quantity" json:"quantity"`
	UnitPrice        pgtype.Numeric `db:"unit_price" json:"unit_price"`
	TaxRate          pgtype.Numeric `db:"tax_rate" json:"tax_rate"`
	DiscountRate     pgtype.Numeric `db:"discount_rate" json:"discount_rate"`
	ID               pgtype.UUID    `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateInvoiceLineItem(ctx context.Context, arg BillingUpdateInvoiceLineItemParams) (BillingInvoiceLineItem, error) {
	row := q.db.QueryRow(ctx, billingUpdateInvoiceLineItem,
		arg.InvoiceID,
		arg.SourceRecordID,
		arg.SourceRecordType,
		arg.Description,
		arg.Quantity,
		arg.UnitPrice,
		arg.TaxRate,
		arg.DiscountRate,
		arg.ID,
	)
	var i BillingInvoiceLineItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.SourceRecordID,
		&i.SourceRecordType,
		&i.Description,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.TaxRate,
		&i.TaxAmount,
		&i.DiscountRate,
		&i.DiscountAmount,
		&i.LineTotal,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
