// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_expenses.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyExpense = `-- name: TmsAnyExpense :many
select
  expenses.id, expenses.trip_id, expenses.driver_id, expenses.type, expenses.amount, expenses.currency, expenses.receipt_url, expenses.fuel_quantity, expenses.odometer_reading, expenses.status, expenses.created_at, expenses.updated_at, expenses.description, expenses.expense_date,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."expenses" as expenses
  left join "tms"."trips" as trip on expenses.trip_id = trip.id
  left join "tms"."drivers" as driver on expenses.driver_id = driver.id
where
  expenses.id = any ($1::uuid[])
`

type TmsAnyExpenseRow struct {
	ID              pgtype.UUID              `db:"id" json:"id"`
	TripID          pgtype.UUID              `db:"trip_id" json:"trip_id"`
	DriverID        pgtype.UUID              `db:"driver_id" json:"driver_id"`
	Type            NullTmsExpenseTypeEnum   `db:"type" json:"type"`
	Amount          pgtype.Numeric           `db:"amount" fake:"{price:10,500}" json:"amount"`
	Currency        NullTmsCurrencyEnum      `db:"currency" json:"currency"`
	ReceiptUrl      pgtype.Text              `db:"receipt_url" fake:"{url}" json:"receipt_url"`
	FuelQuantity    pgtype.Float4            `db:"fuel_quantity" fake:"{float64range:10,100}" json:"fuel_quantity"`
	OdometerReading pgtype.Int4              `db:"odometer_reading" fake:"{number:10000,200000}" json:"odometer_reading"`
	Status          NullTmsExpenseStatusEnum `db:"status" json:"status"`
	CreatedAt       pgtype.Timestamp         `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp         `db:"updated_at" json:"updated_at"`
	Description     pgtype.Text              `db:"description" json:"description"`
	ExpenseDate     pgtype.Date              `db:"expense_date" json:"expense_date"`
	TmsTrip         TmsTrip                  `db:"tms_trip" json:"tms_trip"`
	TmsDriver       TmsDriver                `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) TmsAnyExpense(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyExpenseRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyExpense, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyExpenseRow
	for rows.Next() {
		var i TmsAnyExpenseRow
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.DriverID,
			&i.Type,
			&i.Amount,
			&i.Currency,
			&i.ReceiptUrl,
			&i.FuelQuantity,
			&i.OdometerReading,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ExpenseDate,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindExpense = `-- name: TmsFindExpense :one
select
  expenses.id, expenses.trip_id, expenses.driver_id, expenses.type, expenses.amount, expenses.currency, expenses.receipt_url, expenses.fuel_quantity, expenses.odometer_reading, expenses.status, expenses.created_at, expenses.updated_at, expenses.description, expenses.expense_date,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."expenses" as expenses
  left join "tms"."trips" as trip on expenses.trip_id = trip.id
  left join "tms"."drivers" as driver on expenses.driver_id = driver.id
where
  expenses.id = $1::uuid
`

type TmsFindExpenseRow struct {
	ID              pgtype.UUID              `db:"id" json:"id"`
	TripID          pgtype.UUID              `db:"trip_id" json:"trip_id"`
	DriverID        pgtype.UUID              `db:"driver_id" json:"driver_id"`
	Type            NullTmsExpenseTypeEnum   `db:"type" json:"type"`
	Amount          pgtype.Numeric           `db:"amount" fake:"{price:10,500}" json:"amount"`
	Currency        NullTmsCurrencyEnum      `db:"currency" json:"currency"`
	ReceiptUrl      pgtype.Text              `db:"receipt_url" fake:"{url}" json:"receipt_url"`
	FuelQuantity    pgtype.Float4            `db:"fuel_quantity" fake:"{float64range:10,100}" json:"fuel_quantity"`
	OdometerReading pgtype.Int4              `db:"odometer_reading" fake:"{number:10000,200000}" json:"odometer_reading"`
	Status          NullTmsExpenseStatusEnum `db:"status" json:"status"`
	CreatedAt       pgtype.Timestamp         `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp         `db:"updated_at" json:"updated_at"`
	Description     pgtype.Text              `db:"description" json:"description"`
	ExpenseDate     pgtype.Date              `db:"expense_date" json:"expense_date"`
	TmsTrip         TmsTrip                  `db:"tms_trip" json:"tms_trip"`
	TmsDriver       TmsDriver                `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) TmsFindExpense(ctx context.Context, id pgtype.UUID) (TmsFindExpenseRow, error) {
	row := q.db.QueryRow(ctx, tmsFindExpense, id)
	var i TmsFindExpenseRow
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.DriverID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.ReceiptUrl,
		&i.FuelQuantity,
		&i.OdometerReading,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ExpenseDate,
		&i.TmsTrip.ID,
		&i.TmsTrip.DriverID,
		&i.TmsTrip.VehicleID,
		&i.TmsTrip.Status,
		&i.TmsTrip.CreatedAt,
		&i.TmsTrip.UpdatedAt,
		&i.TmsTrip.EndLocation,
		&i.TmsTrip.EndTime,
		&i.TmsTrip.StartLocation,
		&i.TmsTrip.StartTime,
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
	)
	return i, err
}

const tmsInsertExpense = `-- name: TmsInsertExpense :one
insert into "tms"."expenses"(trip_id, driver_id, type, amount, currency, receipt_url, fuel_quantity, odometer_reading, status)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning
  id, trip_id, driver_id, type, amount, currency, receipt_url, fuel_quantity, odometer_reading, status, created_at, updated_at, description, expense_date
`

type TmsInsertExpenseParams struct {
	TripID          pgtype.UUID              `db:"trip_id" json:"trip_id"`
	DriverID        pgtype.UUID              `db:"driver_id" json:"driver_id"`
	Type            NullTmsExpenseTypeEnum   `db:"type" json:"type"`
	Amount          pgtype.Numeric           `db:"amount" fake:"{price:10,500}" json:"amount"`
	Currency        NullTmsCurrencyEnum      `db:"currency" json:"currency"`
	ReceiptUrl      pgtype.Text              `db:"receipt_url" fake:"{url}" json:"receipt_url"`
	FuelQuantity    pgtype.Float4            `db:"fuel_quantity" fake:"{float64range:10,100}" json:"fuel_quantity"`
	OdometerReading pgtype.Int4              `db:"odometer_reading" fake:"{number:10000,200000}" json:"odometer_reading"`
	Status          NullTmsExpenseStatusEnum `db:"status" json:"status"`
}

func (q *Queries) TmsInsertExpense(ctx context.Context, arg TmsInsertExpenseParams) (TmsExpense, error) {
	row := q.db.QueryRow(ctx, tmsInsertExpense,
		arg.TripID,
		arg.DriverID,
		arg.Type,
		arg.Amount,
		arg.Currency,
		arg.ReceiptUrl,
		arg.FuelQuantity,
		arg.OdometerReading,
		arg.Status,
	)
	var i TmsExpense
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.DriverID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.ReceiptUrl,
		&i.FuelQuantity,
		&i.OdometerReading,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ExpenseDate,
	)
	return i, err
}

const tmsPaginateExpense = `-- name: TmsPaginateExpense :many
select
  expenses.id, expenses.trip_id, expenses.driver_id, expenses.type, expenses.amount, expenses.currency, expenses.receipt_url, expenses.fuel_quantity, expenses.odometer_reading, expenses.status, expenses.created_at, expenses.updated_at, expenses.description, expenses.expense_date,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."expenses" as expenses
  left join "tms"."trips" as trip on expenses.trip_id = trip.id
  left join "tms"."drivers" as driver on expenses.driver_id = driver.id
where (trip.status::text ilike $1::text
  or driver.name ilike $1::text
  or expenses.type::text ilike $1::text
  or expenses.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateExpenseParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type TmsPaginateExpenseRow struct {
	ID              pgtype.UUID              `db:"id" json:"id"`
	TripID          pgtype.UUID              `db:"trip_id" json:"trip_id"`
	DriverID        pgtype.UUID              `db:"driver_id" json:"driver_id"`
	Type            NullTmsExpenseTypeEnum   `db:"type" json:"type"`
	Amount          pgtype.Numeric           `db:"amount" fake:"{price:10,500}" json:"amount"`
	Currency        NullTmsCurrencyEnum      `db:"currency" json:"currency"`
	ReceiptUrl      pgtype.Text              `db:"receipt_url" fake:"{url}" json:"receipt_url"`
	FuelQuantity    pgtype.Float4            `db:"fuel_quantity" fake:"{float64range:10,100}" json:"fuel_quantity"`
	OdometerReading pgtype.Int4              `db:"odometer_reading" fake:"{number:10000,200000}" json:"odometer_reading"`
	Status          NullTmsExpenseStatusEnum `db:"status" json:"status"`
	CreatedAt       pgtype.Timestamp         `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp         `db:"updated_at" json:"updated_at"`
	Description     pgtype.Text              `db:"description" json:"description"`
	ExpenseDate     pgtype.Date              `db:"expense_date" json:"expense_date"`
	TmsTrip         TmsTrip                  `db:"tms_trip" json:"tms_trip"`
	TmsDriver       TmsDriver                `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) TmsPaginateExpense(ctx context.Context, arg TmsPaginateExpenseParams) ([]TmsPaginateExpenseRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateExpense, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateExpenseRow
	for rows.Next() {
		var i TmsPaginateExpenseRow
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.DriverID,
			&i.Type,
			&i.Amount,
			&i.Currency,
			&i.ReceiptUrl,
			&i.FuelQuantity,
			&i.OdometerReading,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ExpenseDate,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsPaginateExpenseMetadata = `-- name: TmsPaginateExpenseMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "tms"."expenses" as expenses
`

type TmsPaginateExpenseMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type TmsPaginateExpenseMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) TmsPaginateExpenseMetadata(ctx context.Context, arg TmsPaginateExpenseMetadataParams) (TmsPaginateExpenseMetadataRow, error) {
	row := q.db.QueryRow(ctx, tmsPaginateExpenseMetadata, arg.PerPage, arg.Page)
	var i TmsPaginateExpenseMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const tmsRangeExpense = `-- name: TmsRangeExpense :many
select
  expenses.id, expenses.trip_id, expenses.driver_id, expenses.type, expenses.amount, expenses.currency, expenses.receipt_url, expenses.fuel_quantity, expenses.odometer_reading, expenses.status, expenses.created_at, expenses.updated_at, expenses.description, expenses.expense_date,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."expenses" as expenses
  left join "tms"."trips" as trip on expenses.trip_id = trip.id
  left join "tms"."drivers" as driver on expenses.driver_id = driver.id
where
  expenses.created_at >= $1::date
  and expenses.created_at <= $2::date
  and (trip.status::text ilike $3::text
    or driver.name ilike $3::text
    or expenses.type::text ilike $3::text
    or expenses.status::text ilike $3::text
    or $3::text is null)
`

type TmsRangeExpenseParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeExpenseRow struct {
	ID              pgtype.UUID              `db:"id" json:"id"`
	TripID          pgtype.UUID              `db:"trip_id" json:"trip_id"`
	DriverID        pgtype.UUID              `db:"driver_id" json:"driver_id"`
	Type            NullTmsExpenseTypeEnum   `db:"type" json:"type"`
	Amount          pgtype.Numeric           `db:"amount" fake:"{price:10,500}" json:"amount"`
	Currency        NullTmsCurrencyEnum      `db:"currency" json:"currency"`
	ReceiptUrl      pgtype.Text              `db:"receipt_url" fake:"{url}" json:"receipt_url"`
	FuelQuantity    pgtype.Float4            `db:"fuel_quantity" fake:"{float64range:10,100}" json:"fuel_quantity"`
	OdometerReading pgtype.Int4              `db:"odometer_reading" fake:"{number:10000,200000}" json:"odometer_reading"`
	Status          NullTmsExpenseStatusEnum `db:"status" json:"status"`
	CreatedAt       pgtype.Timestamp         `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp         `db:"updated_at" json:"updated_at"`
	Description     pgtype.Text              `db:"description" json:"description"`
	ExpenseDate     pgtype.Date              `db:"expense_date" json:"expense_date"`
	TmsTrip         TmsTrip                  `db:"tms_trip" json:"tms_trip"`
	TmsDriver       TmsDriver                `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) TmsRangeExpense(ctx context.Context, arg TmsRangeExpenseParams) ([]TmsRangeExpenseRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeExpense, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeExpenseRow
	for rows.Next() {
		var i TmsRangeExpenseRow
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.DriverID,
			&i.Type,
			&i.Amount,
			&i.Currency,
			&i.ReceiptUrl,
			&i.FuelQuantity,
			&i.OdometerReading,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.ExpenseDate,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveExpense = `-- name: TmsRemoveExpense :exec
delete from "tms"."expenses"
where id = $1::uuid
`

func (q *Queries) TmsRemoveExpense(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveExpense, id)
	return err
}

const tmsUpdateExpense = `-- name: TmsUpdateExpense :one
update
  "tms"."expenses"
set
  updated_at = now(),
  trip_id = case when $1 is not null then
    $1::uuid
  else
    trip_id
  end,
  driver_id = case when $2 is not null then
    $2::uuid
  else
    driver_id
  end,
  type = case when $3 is not null then
    $3::tms.expense_type_enum
  else
    type
  end,
  amount = case when $4 is not null then
    $4::numeric
  else
    amount
  end,
  currency = case when $5 is not null then
    $5::tms.currency_enum
  else
    currency
  end,
  receipt_url = case when $6 is not null then
    $6::varchar
  else
    receipt_url
  end,
  fuel_quantity = case when $7 is not null then
    $7::real
  else
    fuel_quantity
  end,
  odometer_reading = case when $8 is not null then
    $8::integer
  else
    odometer_reading
  end,
  status = case when $9 is not null then
    $9::tms.expense_status_enum
  else
    status
  end
where
  id = $10::uuid
returning
  id, trip_id, driver_id, type, amount, currency, receipt_url, fuel_quantity, odometer_reading, status, created_at, updated_at, description, expense_date
`

type TmsUpdateExpenseParams struct {
	TripID          pgtype.UUID              `db:"trip_id" json:"trip_id"`
	DriverID        pgtype.UUID              `db:"driver_id" json:"driver_id"`
	Type            NullTmsExpenseTypeEnum   `db:"type" json:"type"`
	Amount          pgtype.Numeric           `db:"amount" fake:"{price:10,500}" json:"amount"`
	Currency        NullTmsCurrencyEnum      `db:"currency" json:"currency"`
	ReceiptUrl      pgtype.Text              `db:"receipt_url" fake:"{url}" json:"receipt_url"`
	FuelQuantity    pgtype.Float4            `db:"fuel_quantity" fake:"{float64range:10,100}" json:"fuel_quantity"`
	OdometerReading pgtype.Int4              `db:"odometer_reading" fake:"{number:10000,200000}" json:"odometer_reading"`
	Status          NullTmsExpenseStatusEnum `db:"status" json:"status"`
	ID              pgtype.UUID              `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateExpense(ctx context.Context, arg TmsUpdateExpenseParams) (TmsExpense, error) {
	row := q.db.QueryRow(ctx, tmsUpdateExpense,
		arg.TripID,
		arg.DriverID,
		arg.Type,
		arg.Amount,
		arg.Currency,
		arg.ReceiptUrl,
		arg.FuelQuantity,
		arg.OdometerReading,
		arg.Status,
		arg.ID,
	)
	var i TmsExpense
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.DriverID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.ReceiptUrl,
		&i.FuelQuantity,
		&i.OdometerReading,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ExpenseDate,
	)
	return i, err
}
