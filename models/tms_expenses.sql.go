// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_expenses.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyExpense = `-- name: TmsAnyExpense :many
select
  expenses.id, expenses.trip_id, expenses.driver_id, expenses.type, expenses.amount, expenses.currency, expenses.receipt_url, expenses.fuel_quantity, expenses.odometer_reading, expenses.status, expenses.created_at, expenses.updated_at, expenses.description, expenses.expense_date,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."expenses" as expenses
  left join "tms"."trips" as trip on expenses.trip_id = trip.id
  left join "tms"."drivers" as driver on expenses.driver_id = driver.id
where
  expenses.id = any ($1::uuid[])
`

type TmsAnyExpenseRow struct {
	TmsExpense TmsExpense
	TmsTrip    TmsTrip
	TmsDriver  TmsDriver
}

func (q *Queries) TmsAnyExpense(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyExpenseRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyExpense, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyExpenseRow
	for rows.Next() {
		var i TmsAnyExpenseRow
		if err := rows.Scan(
			&i.TmsExpense.ID,
			&i.TmsExpense.TripID,
			&i.TmsExpense.DriverID,
			&i.TmsExpense.Type,
			&i.TmsExpense.Amount,
			&i.TmsExpense.Currency,
			&i.TmsExpense.ReceiptUrl,
			&i.TmsExpense.FuelQuantity,
			&i.TmsExpense.OdometerReading,
			&i.TmsExpense.Status,
			&i.TmsExpense.CreatedAt,
			&i.TmsExpense.UpdatedAt,
			&i.TmsExpense.Description,
			&i.TmsExpense.ExpenseDate,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindExpense = `-- name: TmsFindExpense :one
select
  expenses.id, expenses.trip_id, expenses.driver_id, expenses.type, expenses.amount, expenses.currency, expenses.receipt_url, expenses.fuel_quantity, expenses.odometer_reading, expenses.status, expenses.created_at, expenses.updated_at, expenses.description, expenses.expense_date,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."expenses" as expenses
  left join "tms"."trips" as trip on expenses.trip_id = trip.id
  left join "tms"."drivers" as driver on expenses.driver_id = driver.id
where
  expenses.id = $1::uuid
`

type TmsFindExpenseRow struct {
	TmsExpense TmsExpense
	TmsTrip    TmsTrip
	TmsDriver  TmsDriver
}

func (q *Queries) TmsFindExpense(ctx context.Context, id pgtype.UUID) (TmsFindExpenseRow, error) {
	row := q.db.QueryRow(ctx, tmsFindExpense, id)
	var i TmsFindExpenseRow
	err := row.Scan(
		&i.TmsExpense.ID,
		&i.TmsExpense.TripID,
		&i.TmsExpense.DriverID,
		&i.TmsExpense.Type,
		&i.TmsExpense.Amount,
		&i.TmsExpense.Currency,
		&i.TmsExpense.ReceiptUrl,
		&i.TmsExpense.FuelQuantity,
		&i.TmsExpense.OdometerReading,
		&i.TmsExpense.Status,
		&i.TmsExpense.CreatedAt,
		&i.TmsExpense.UpdatedAt,
		&i.TmsExpense.Description,
		&i.TmsExpense.ExpenseDate,
		&i.TmsTrip.ID,
		&i.TmsTrip.DriverID,
		&i.TmsTrip.VehicleID,
		&i.TmsTrip.Status,
		&i.TmsTrip.CreatedAt,
		&i.TmsTrip.UpdatedAt,
		&i.TmsTrip.EndLocation,
		&i.TmsTrip.EndTime,
		&i.TmsTrip.StartLocation,
		&i.TmsTrip.StartTime,
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
	)
	return i, err
}

const tmsInsertExpense = `-- name: TmsInsertExpense :one
insert into "tms"."expenses"(trip_id, driver_id, type, amount, currency, receipt_url, fuel_quantity, odometer_reading, status)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning
  id, trip_id, driver_id, type, amount, currency, receipt_url, fuel_quantity, odometer_reading, status, created_at, updated_at, description, expense_date
`

type TmsInsertExpenseParams struct {
	TripID          pgtype.UUID
	DriverID        pgtype.UUID
	Type            NullTmsExpenseTypeEnum
	Amount          pgtype.Numeric
	Currency        NullTmsCurrencyEnum
	ReceiptUrl      pgtype.Text
	FuelQuantity    pgtype.Float4
	OdometerReading pgtype.Int4
	Status          NullTmsExpenseStatusEnum
}

func (q *Queries) TmsInsertExpense(ctx context.Context, arg TmsInsertExpenseParams) (TmsExpense, error) {
	row := q.db.QueryRow(ctx, tmsInsertExpense,
		arg.TripID,
		arg.DriverID,
		arg.Type,
		arg.Amount,
		arg.Currency,
		arg.ReceiptUrl,
		arg.FuelQuantity,
		arg.OdometerReading,
		arg.Status,
	)
	var i TmsExpense
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.DriverID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.ReceiptUrl,
		&i.FuelQuantity,
		&i.OdometerReading,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ExpenseDate,
	)
	return i, err
}

const tmsPaginateExpense = `-- name: TmsPaginateExpense :many
select
  expenses.id, expenses.trip_id, expenses.driver_id, expenses.type, expenses.amount, expenses.currency, expenses.receipt_url, expenses.fuel_quantity, expenses.odometer_reading, expenses.status, expenses.created_at, expenses.updated_at, expenses.description, expenses.expense_date,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."expenses" as expenses
  left join "tms"."trips" as trip on expenses.trip_id = trip.id
  left join "tms"."drivers" as driver on expenses.driver_id = driver.id
where
  (trip.status::text ilike $1::text
  or driver.name ilike $1::text
  or expenses.type::text ilike $1::text
  or expenses.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateExpenseParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type TmsPaginateExpenseRow struct {
	TmsExpense TmsExpense
	TmsTrip    TmsTrip
	TmsDriver  TmsDriver
}

func (q *Queries) TmsPaginateExpense(ctx context.Context, arg TmsPaginateExpenseParams) ([]TmsPaginateExpenseRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateExpense, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateExpenseRow
	for rows.Next() {
		var i TmsPaginateExpenseRow
		if err := rows.Scan(
			&i.TmsExpense.ID,
			&i.TmsExpense.TripID,
			&i.TmsExpense.DriverID,
			&i.TmsExpense.Type,
			&i.TmsExpense.Amount,
			&i.TmsExpense.Currency,
			&i.TmsExpense.ReceiptUrl,
			&i.TmsExpense.FuelQuantity,
			&i.TmsExpense.OdometerReading,
			&i.TmsExpense.Status,
			&i.TmsExpense.CreatedAt,
			&i.TmsExpense.UpdatedAt,
			&i.TmsExpense.Description,
			&i.TmsExpense.ExpenseDate,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeExpense = `-- name: TmsRangeExpense :many
select
  expenses.id, expenses.trip_id, expenses.driver_id, expenses.type, expenses.amount, expenses.currency, expenses.receipt_url, expenses.fuel_quantity, expenses.odometer_reading, expenses.status, expenses.created_at, expenses.updated_at, expenses.description, expenses.expense_date,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."expenses" as expenses
  left join "tms"."trips" as trip on expenses.trip_id = trip.id
  left join "tms"."drivers" as driver on expenses.driver_id = driver.id
where
  expenses.created_at >= $1::date
  and expenses.created_at <= $2::date
  and (trip.status::text ilike $3::text
  or driver.name ilike $3::text
  or expenses.type::text ilike $3::text
  or expenses.status::text ilike $3::text
  or $3::text is null)
`

type TmsRangeExpenseParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type TmsRangeExpenseRow struct {
	TmsExpense TmsExpense
	TmsTrip    TmsTrip
	TmsDriver  TmsDriver
}

func (q *Queries) TmsRangeExpense(ctx context.Context, arg TmsRangeExpenseParams) ([]TmsRangeExpenseRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeExpense, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeExpenseRow
	for rows.Next() {
		var i TmsRangeExpenseRow
		if err := rows.Scan(
			&i.TmsExpense.ID,
			&i.TmsExpense.TripID,
			&i.TmsExpense.DriverID,
			&i.TmsExpense.Type,
			&i.TmsExpense.Amount,
			&i.TmsExpense.Currency,
			&i.TmsExpense.ReceiptUrl,
			&i.TmsExpense.FuelQuantity,
			&i.TmsExpense.OdometerReading,
			&i.TmsExpense.Status,
			&i.TmsExpense.CreatedAt,
			&i.TmsExpense.UpdatedAt,
			&i.TmsExpense.Description,
			&i.TmsExpense.ExpenseDate,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveExpense = `-- name: TmsRemoveExpense :exec
delete from "tms"."expenses"
where id = $1::uuid
`

func (q *Queries) TmsRemoveExpense(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveExpense, id)
	return err
}

const tmsUpdateExpense = `-- name: TmsUpdateExpense :one
update
  "tms"."expenses"
set
  trip_id = case when $1::boolean then
    $2::uuid
  else
    trip_id
  end,
  driver_id = case when $3::boolean then
    $4::uuid
  else
    driver_id
  end,
  type = case when $5::boolean then
    $6::tms.expense_type_enum
  else
    type
  end,
  amount = case when $7::boolean then
    $8::numeric
  else
    amount
  end,
  currency = case when $9::boolean then
    $10::tms.currency_enum
  else
    currency
  end,
  receipt_url = case when $11::boolean then
    $12::varchar
  else
    receipt_url
  end,
  fuel_quantity = case when $13::boolean then
    $14::real
  else
    fuel_quantity
  end,
  odometer_reading = case when $15::boolean then
    $16::integer
  else
    odometer_reading
  end,
  status = case when $17::boolean then
    $18::tms.expense_status_enum
  else
    status
  end
where
  id = $19::uuid
returning
  id, trip_id, driver_id, type, amount, currency, receipt_url, fuel_quantity, odometer_reading, status, created_at, updated_at, description, expense_date
`

type TmsUpdateExpenseParams struct {
	SetTripID          bool
	TripID             pgtype.UUID
	SetDriverID        bool
	DriverID           pgtype.UUID
	SetType            bool
	Type               TmsExpenseTypeEnum
	SetAmount          bool
	Amount             pgtype.Numeric
	SetCurrency        bool
	Currency           TmsCurrencyEnum
	SetReceiptUrl      bool
	ReceiptUrl         string
	SetFuelQuantity    bool
	FuelQuantity       float32
	SetOdometerReading bool
	OdometerReading    int32
	SetStatus          bool
	Status             TmsExpenseStatusEnum
	ID                 pgtype.UUID
}

func (q *Queries) TmsUpdateExpense(ctx context.Context, arg TmsUpdateExpenseParams) (TmsExpense, error) {
	row := q.db.QueryRow(ctx, tmsUpdateExpense,
		arg.SetTripID,
		arg.TripID,
		arg.SetDriverID,
		arg.DriverID,
		arg.SetType,
		arg.Type,
		arg.SetAmount,
		arg.Amount,
		arg.SetCurrency,
		arg.Currency,
		arg.SetReceiptUrl,
		arg.ReceiptUrl,
		arg.SetFuelQuantity,
		arg.FuelQuantity,
		arg.SetOdometerReading,
		arg.OdometerReading,
		arg.SetStatus,
		arg.Status,
		arg.ID,
	)
	var i TmsExpense
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.DriverID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.ReceiptUrl,
		&i.FuelQuantity,
		&i.OdometerReading,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.ExpenseDate,
	)
	return i, err
}
