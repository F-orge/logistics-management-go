// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vehicles.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVehicle = `-- name: CreateVehicle :one
insert into vehicles (license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

type CreateVehicleParams struct {
	LicensePlate   string
	Make           string
	Model          string
	Type           string
	CapacityVolume pgtype.Numeric
	CapacityWeight pgtype.Numeric
	Status         string
	CurrentDriver  pgtype.UUID
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle,
		arg.LicensePlate,
		arg.Make,
		arg.Model,
		arg.Type,
		arg.CapacityVolume,
		arg.CapacityWeight,
		arg.Status,
		arg.CurrentDriver,
		arg.Created,
		arg.Updated,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteVehicle = `-- name: DeleteVehicle :one
delete from vehicles where id = $1 returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

func (q *Queries) DeleteVehicle(ctx context.Context, id pgtype.UUID) (Vehicle, error) {
	row := q.db.QueryRow(ctx, deleteVehicle, id)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getVehicleByID = `-- name: GetVehicleByID :one
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles where id = $1
`

func (q *Queries) GetVehicleByID(ctx context.Context, id pgtype.UUID) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByID, id)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getVehicles = `-- name: GetVehicles :many
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles order by created desc offset $1 limit $2
`

type GetVehiclesParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetVehicles(ctx context.Context, arg GetVehiclesParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, getVehicles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.LicensePlate,
			&i.Make,
			&i.Model,
			&i.Type,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CurrentDriver,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByDriver = `-- name: GetVehiclesByDriver :many
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles where current_driver = $1 order by created desc offset $2 limit $3
`

type GetVehiclesByDriverParams struct {
	CurrentDriver pgtype.UUID
	Offset        int32
	Limit         int32
}

func (q *Queries) GetVehiclesByDriver(ctx context.Context, arg GetVehiclesByDriverParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, getVehiclesByDriver, arg.CurrentDriver, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.LicensePlate,
			&i.Make,
			&i.Model,
			&i.Type,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CurrentDriver,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByStatus = `-- name: GetVehiclesByStatus :many
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles where status = $1 order by created desc offset $2 limit $3
`

type GetVehiclesByStatusParams struct {
	Status string
	Offset int32
	Limit  int32
}

func (q *Queries) GetVehiclesByStatus(ctx context.Context, arg GetVehiclesByStatusParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, getVehiclesByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.LicensePlate,
			&i.Make,
			&i.Model,
			&i.Type,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CurrentDriver,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVehicles = `-- name: SearchVehicles :many
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles where license_plate ilike '%' || $1::text || '%' or
make ilike '%' || $1::text || '%' or
model ilike '%' || $1::text || '%' or
type ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchVehiclesParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchVehicles(ctx context.Context, arg SearchVehiclesParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, searchVehicles, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.LicensePlate,
			&i.Make,
			&i.Model,
			&i.Type,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CurrentDriver,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVehicleCapacity = `-- name: UpdateVehicleCapacity :one
update vehicles set capacity_volume = $1, capacity_weight = $2 where id = $3
returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

type UpdateVehicleCapacityParams struct {
	CapacityVolume pgtype.Numeric
	CapacityWeight pgtype.Numeric
	ID             pgtype.UUID
}

func (q *Queries) UpdateVehicleCapacity(ctx context.Context, arg UpdateVehicleCapacityParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicleCapacity, arg.CapacityVolume, arg.CapacityWeight, arg.ID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateVehicleCurrentDriver = `-- name: UpdateVehicleCurrentDriver :one
update vehicles set current_driver = $1 where id = $2 returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

type UpdateVehicleCurrentDriverParams struct {
	CurrentDriver pgtype.UUID
	ID            pgtype.UUID
}

func (q *Queries) UpdateVehicleCurrentDriver(ctx context.Context, arg UpdateVehicleCurrentDriverParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicleCurrentDriver, arg.CurrentDriver, arg.ID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateVehicleStatus = `-- name: UpdateVehicleStatus :one
update vehicles set status = $1 where id = $2 returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

type UpdateVehicleStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateVehicleStatus(ctx context.Context, arg UpdateVehicleStatusParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicleStatus, arg.Status, arg.ID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
