// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_geofence_events.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyGeofenceEvent = `-- name: TmsAnyGeofenceEvent :many
select
  geofence_events.id, geofence_events.vehicle_id, geofence_events.geofence_id, geofence_events.event_type, geofence_events.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date,
  geofence.id, geofence.name, geofence.created_at, geofence.updated_at, geofence.longitude, geofence.latitude
from
  "tms"."geofence_events" as geofence_events
  inner join "tms"."vehicles" as vehicle on geofence_events.vehicle_id = vehicle.id
  inner join "tms"."geofences" as geofence on geofence_events.geofence_id = geofence.id
where
  geofence_events.id = any ($1::uuid[])
`

type TmsAnyGeofenceEventRow struct {
	TmsGeofenceEvent TmsGeofenceEvent
	TmsVehicle       TmsVehicle
	TmsGeofence      TmsGeofence
}

func (q *Queries) TmsAnyGeofenceEvent(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyGeofenceEventRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyGeofenceEvent, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyGeofenceEventRow
	for rows.Next() {
		var i TmsAnyGeofenceEventRow
		if err := rows.Scan(
			&i.TmsGeofenceEvent.ID,
			&i.TmsGeofenceEvent.VehicleID,
			&i.TmsGeofenceEvent.GeofenceID,
			&i.TmsGeofenceEvent.EventType,
			&i.TmsGeofenceEvent.Timestamp,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
			&i.TmsGeofence.ID,
			&i.TmsGeofence.Name,
			&i.TmsGeofence.CreatedAt,
			&i.TmsGeofence.UpdatedAt,
			&i.TmsGeofence.Longitude,
			&i.TmsGeofence.Latitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindGeofenceEvent = `-- name: TmsFindGeofenceEvent :one
select
  geofence_events.id, geofence_events.vehicle_id, geofence_events.geofence_id, geofence_events.event_type, geofence_events.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date,
  geofence.id, geofence.name, geofence.created_at, geofence.updated_at, geofence.longitude, geofence.latitude
from
  "tms"."geofence_events" as geofence_events
  inner join "tms"."vehicles" as vehicle on geofence_events.vehicle_id = vehicle.id
  inner join "tms"."geofences" as geofence on geofence_events.geofence_id = geofence.id
where
  geofence_events.id = $1::uuid
`

type TmsFindGeofenceEventRow struct {
	TmsGeofenceEvent TmsGeofenceEvent
	TmsVehicle       TmsVehicle
	TmsGeofence      TmsGeofence
}

func (q *Queries) TmsFindGeofenceEvent(ctx context.Context, id pgtype.UUID) (TmsFindGeofenceEventRow, error) {
	row := q.db.QueryRow(ctx, tmsFindGeofenceEvent, id)
	var i TmsFindGeofenceEventRow
	err := row.Scan(
		&i.TmsGeofenceEvent.ID,
		&i.TmsGeofenceEvent.VehicleID,
		&i.TmsGeofenceEvent.GeofenceID,
		&i.TmsGeofenceEvent.EventType,
		&i.TmsGeofenceEvent.Timestamp,
		&i.TmsVehicle.ID,
		&i.TmsVehicle.RegistrationNumber,
		&i.TmsVehicle.Model,
		&i.TmsVehicle.CapacityVolume,
		&i.TmsVehicle.CapacityWeight,
		&i.TmsVehicle.Status,
		&i.TmsVehicle.CreatedAt,
		&i.TmsVehicle.UpdatedAt,
		&i.TmsVehicle.Make,
		&i.TmsVehicle.Year,
		&i.TmsVehicle.Vin,
		&i.TmsVehicle.CurrentMileage,
		&i.TmsVehicle.LastMaintenanceDate,
		&i.TmsGeofence.ID,
		&i.TmsGeofence.Name,
		&i.TmsGeofence.CreatedAt,
		&i.TmsGeofence.UpdatedAt,
		&i.TmsGeofence.Longitude,
		&i.TmsGeofence.Latitude,
	)
	return i, err
}

const tmsInsertGeofenceEvent = `-- name: TmsInsertGeofenceEvent :one
insert into "tms"."geofence_events"(vehicle_id, geofence_id, event_type, timestamp)
  values ($1, $2, $3, $4)
returning
  id, vehicle_id, geofence_id, event_type, timestamp
`

type TmsInsertGeofenceEventParams struct {
	VehicleID  pgtype.UUID
	GeofenceID pgtype.UUID
	EventType  TmsGeofenceEventTypeEnum
	Timestamp  pgtype.Timestamp
}

func (q *Queries) TmsInsertGeofenceEvent(ctx context.Context, arg TmsInsertGeofenceEventParams) (TmsGeofenceEvent, error) {
	row := q.db.QueryRow(ctx, tmsInsertGeofenceEvent,
		arg.VehicleID,
		arg.GeofenceID,
		arg.EventType,
		arg.Timestamp,
	)
	var i TmsGeofenceEvent
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.GeofenceID,
		&i.EventType,
		&i.Timestamp,
	)
	return i, err
}

const tmsPaginateGeofenceEvent = `-- name: TmsPaginateGeofenceEvent :many
select
  geofence_events.id, geofence_events.vehicle_id, geofence_events.geofence_id, geofence_events.event_type, geofence_events.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date,
  geofence.id, geofence.name, geofence.created_at, geofence.updated_at, geofence.longitude, geofence.latitude
from
  "tms"."geofence_events" as geofence_events
  inner join "tms"."vehicles" as vehicle on geofence_events.vehicle_id = vehicle.id
  inner join "tms"."geofences" as geofence on geofence_events.geofence_id = geofence.id
limit $2::int offset ($1::int - 1) * $2::int
`

type TmsPaginateGeofenceEventParams struct {
	Page    int32
	Perpage int32
}

type TmsPaginateGeofenceEventRow struct {
	TmsGeofenceEvent TmsGeofenceEvent
	TmsVehicle       TmsVehicle
	TmsGeofence      TmsGeofence
}

func (q *Queries) TmsPaginateGeofenceEvent(ctx context.Context, arg TmsPaginateGeofenceEventParams) ([]TmsPaginateGeofenceEventRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateGeofenceEvent, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateGeofenceEventRow
	for rows.Next() {
		var i TmsPaginateGeofenceEventRow
		if err := rows.Scan(
			&i.TmsGeofenceEvent.ID,
			&i.TmsGeofenceEvent.VehicleID,
			&i.TmsGeofenceEvent.GeofenceID,
			&i.TmsGeofenceEvent.EventType,
			&i.TmsGeofenceEvent.Timestamp,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
			&i.TmsGeofence.ID,
			&i.TmsGeofence.Name,
			&i.TmsGeofence.CreatedAt,
			&i.TmsGeofence.UpdatedAt,
			&i.TmsGeofence.Longitude,
			&i.TmsGeofence.Latitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeGeofenceEvent = `-- name: TmsRangeGeofenceEvent :many
select
  geofence_events.id, geofence_events.vehicle_id, geofence_events.geofence_id, geofence_events.event_type, geofence_events.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date,
  geofence.id, geofence.name, geofence.created_at, geofence.updated_at, geofence.longitude, geofence.latitude
from
  "tms"."geofence_events" as geofence_events
  inner join "tms"."vehicles" as vehicle on geofence_events.vehicle_id = vehicle.id
  inner join "tms"."geofences" as geofence on geofence_events.geofence_id = geofence.id
where
  geofence_events.timestamp >= $1::date
  and geofence_events.timestamp <= $2::date
`

type TmsRangeGeofenceEventParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type TmsRangeGeofenceEventRow struct {
	TmsGeofenceEvent TmsGeofenceEvent
	TmsVehicle       TmsVehicle
	TmsGeofence      TmsGeofence
}

func (q *Queries) TmsRangeGeofenceEvent(ctx context.Context, arg TmsRangeGeofenceEventParams) ([]TmsRangeGeofenceEventRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeGeofenceEvent, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeGeofenceEventRow
	for rows.Next() {
		var i TmsRangeGeofenceEventRow
		if err := rows.Scan(
			&i.TmsGeofenceEvent.ID,
			&i.TmsGeofenceEvent.VehicleID,
			&i.TmsGeofenceEvent.GeofenceID,
			&i.TmsGeofenceEvent.EventType,
			&i.TmsGeofenceEvent.Timestamp,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
			&i.TmsGeofence.ID,
			&i.TmsGeofence.Name,
			&i.TmsGeofence.CreatedAt,
			&i.TmsGeofence.UpdatedAt,
			&i.TmsGeofence.Longitude,
			&i.TmsGeofence.Latitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveGeofenceEvent = `-- name: TmsRemoveGeofenceEvent :exec
delete from "tms"."geofence_events"
where id = $1::uuid
`

func (q *Queries) TmsRemoveGeofenceEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveGeofenceEvent, id)
	return err
}

const tmsUpdateGeofenceEvent = `-- name: TmsUpdateGeofenceEvent :one
update
  "tms"."geofence_events"
set
  vehicle_id = case when $1::boolean then
    $2::uuid
  else
    vehicle_id
  end,
  geofence_id = case when $3::boolean then
    $4::uuid
  else
    geofence_id
  end,
  event_type = case when $5::boolean then
    $6::tms.geofence_event_type_enum
  else
    event_type
  end,
  timestamp = case when $7::boolean then
    $8::timestamp
  else
    timestamp
  end
where
  id = $9::uuid
returning
  id, vehicle_id, geofence_id, event_type, timestamp
`

type TmsUpdateGeofenceEventParams struct {
	SetVehicleID  bool
	VehicleID     pgtype.UUID
	SetGeofenceID bool
	GeofenceID    pgtype.UUID
	SetEventType  bool
	EventType     TmsGeofenceEventTypeEnum
	SetTimestamp  bool
	Timestamp     pgtype.Timestamp
	ID            pgtype.UUID
}

func (q *Queries) TmsUpdateGeofenceEvent(ctx context.Context, arg TmsUpdateGeofenceEventParams) (TmsGeofenceEvent, error) {
	row := q.db.QueryRow(ctx, tmsUpdateGeofenceEvent,
		arg.SetVehicleID,
		arg.VehicleID,
		arg.SetGeofenceID,
		arg.GeofenceID,
		arg.SetEventType,
		arg.EventType,
		arg.SetTimestamp,
		arg.Timestamp,
		arg.ID,
	)
	var i TmsGeofenceEvent
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.GeofenceID,
		&i.EventType,
		&i.Timestamp,
	)
	return i, err
}
