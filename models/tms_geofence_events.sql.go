// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_geofence_events.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyGeofenceEvent = `-- name: TmsAnyGeofenceEvent :many
select
  geofence_events.id, geofence_events.vehicle_id, geofence_events.geofence_id, geofence_events.event_type, geofence_events.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date,
  geofence.id, geofence.name, geofence.created_at, geofence.updated_at, geofence.longitude, geofence.latitude
from
  "tms"."geofence_events" as geofence_events
  inner join "tms"."vehicles" as vehicle on geofence_events.vehicle_id = vehicle.id
  inner join "tms"."geofences" as geofence on geofence_events.geofence_id = geofence.id
where
  geofence_events.id = any ($1::uuid[])
`

type TmsAnyGeofenceEventRow struct {
	TmsGeofenceEvent TmsGeofenceEvent `db:"tms_geofence_event" json:"tms_geofence_event"`
	TmsVehicle       TmsVehicle       `db:"tms_vehicle" json:"tms_vehicle"`
	TmsGeofence      TmsGeofence      `db:"tms_geofence" json:"tms_geofence"`
}

func (q *Queries) TmsAnyGeofenceEvent(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyGeofenceEventRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyGeofenceEvent, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyGeofenceEventRow
	for rows.Next() {
		var i TmsAnyGeofenceEventRow
		if err := rows.Scan(
			&i.TmsGeofenceEvent.ID,
			&i.TmsGeofenceEvent.VehicleID,
			&i.TmsGeofenceEvent.GeofenceID,
			&i.TmsGeofenceEvent.EventType,
			&i.TmsGeofenceEvent.Timestamp,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
			&i.TmsGeofence.ID,
			&i.TmsGeofence.Name,
			&i.TmsGeofence.CreatedAt,
			&i.TmsGeofence.UpdatedAt,
			&i.TmsGeofence.Longitude,
			&i.TmsGeofence.Latitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindGeofenceEvent = `-- name: TmsFindGeofenceEvent :one
select
  geofence_events.id, geofence_events.vehicle_id, geofence_events.geofence_id, geofence_events.event_type, geofence_events.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date,
  geofence.id, geofence.name, geofence.created_at, geofence.updated_at, geofence.longitude, geofence.latitude
from
  "tms"."geofence_events" as geofence_events
  inner join "tms"."vehicles" as vehicle on geofence_events.vehicle_id = vehicle.id
  inner join "tms"."geofences" as geofence on geofence_events.geofence_id = geofence.id
where
  geofence_events.id = $1::uuid
`

type TmsFindGeofenceEventRow struct {
	TmsGeofenceEvent TmsGeofenceEvent `db:"tms_geofence_event" json:"tms_geofence_event"`
	TmsVehicle       TmsVehicle       `db:"tms_vehicle" json:"tms_vehicle"`
	TmsGeofence      TmsGeofence      `db:"tms_geofence" json:"tms_geofence"`
}

func (q *Queries) TmsFindGeofenceEvent(ctx context.Context, id pgtype.UUID) (TmsFindGeofenceEventRow, error) {
	row := q.db.QueryRow(ctx, tmsFindGeofenceEvent, id)
	var i TmsFindGeofenceEventRow
	err := row.Scan(
		&i.TmsGeofenceEvent.ID,
		&i.TmsGeofenceEvent.VehicleID,
		&i.TmsGeofenceEvent.GeofenceID,
		&i.TmsGeofenceEvent.EventType,
		&i.TmsGeofenceEvent.Timestamp,
		&i.TmsVehicle.ID,
		&i.TmsVehicle.RegistrationNumber,
		&i.TmsVehicle.Model,
		&i.TmsVehicle.CapacityVolume,
		&i.TmsVehicle.CapacityWeight,
		&i.TmsVehicle.Status,
		&i.TmsVehicle.CreatedAt,
		&i.TmsVehicle.UpdatedAt,
		&i.TmsVehicle.Make,
		&i.TmsVehicle.Year,
		&i.TmsVehicle.Vin,
		&i.TmsVehicle.CurrentMileage,
		&i.TmsVehicle.LastMaintenanceDate,
		&i.TmsGeofence.ID,
		&i.TmsGeofence.Name,
		&i.TmsGeofence.CreatedAt,
		&i.TmsGeofence.UpdatedAt,
		&i.TmsGeofence.Longitude,
		&i.TmsGeofence.Latitude,
	)
	return i, err
}

const tmsInsertGeofenceEvent = `-- name: TmsInsertGeofenceEvent :one
insert into "tms"."geofence_events"(vehicle_id, geofence_id, event_type, timestamp)
  values ($1, $2, $3, $4)
returning
  id, vehicle_id, geofence_id, event_type, timestamp
`

type TmsInsertGeofenceEventParams struct {
	VehicleID  pgtype.UUID              `db:"vehicle_id" json:"vehicle_id"`
	GeofenceID pgtype.UUID              `db:"geofence_id" json:"geofence_id"`
	EventType  TmsGeofenceEventTypeEnum `db:"event_type" json:"event_type"`
	Timestamp  pgtype.Timestamp         `db:"timestamp" json:"timestamp"`
}

func (q *Queries) TmsInsertGeofenceEvent(ctx context.Context, arg TmsInsertGeofenceEventParams) (TmsGeofenceEvent, error) {
	row := q.db.QueryRow(ctx, tmsInsertGeofenceEvent,
		arg.VehicleID,
		arg.GeofenceID,
		arg.EventType,
		arg.Timestamp,
	)
	var i TmsGeofenceEvent
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.GeofenceID,
		&i.EventType,
		&i.Timestamp,
	)
	return i, err
}

const tmsPaginateGeofenceEvent = `-- name: TmsPaginateGeofenceEvent :many
select
  geofence_events.id, geofence_events.vehicle_id, geofence_events.geofence_id, geofence_events.event_type, geofence_events.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date,
  geofence.id, geofence.name, geofence.created_at, geofence.updated_at, geofence.longitude, geofence.latitude
from
  "tms"."geofence_events" as geofence_events
  inner join "tms"."vehicles" as vehicle on geofence_events.vehicle_id = vehicle.id
  inner join "tms"."geofences" as geofence on geofence_events.geofence_id = geofence.id
where (vehicle.registration_number ilike $1::text
  or geofence.name ilike $1::text
  or geofence_events.event_type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateGeofenceEventParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	Perpage int32       `db:"perpage" json:"perpage"`
}

type TmsPaginateGeofenceEventRow struct {
	TmsGeofenceEvent TmsGeofenceEvent `db:"tms_geofence_event" json:"tms_geofence_event"`
	TmsVehicle       TmsVehicle       `db:"tms_vehicle" json:"tms_vehicle"`
	TmsGeofence      TmsGeofence      `db:"tms_geofence" json:"tms_geofence"`
}

func (q *Queries) TmsPaginateGeofenceEvent(ctx context.Context, arg TmsPaginateGeofenceEventParams) ([]TmsPaginateGeofenceEventRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateGeofenceEvent, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateGeofenceEventRow
	for rows.Next() {
		var i TmsPaginateGeofenceEventRow
		if err := rows.Scan(
			&i.TmsGeofenceEvent.ID,
			&i.TmsGeofenceEvent.VehicleID,
			&i.TmsGeofenceEvent.GeofenceID,
			&i.TmsGeofenceEvent.EventType,
			&i.TmsGeofenceEvent.Timestamp,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
			&i.TmsGeofence.ID,
			&i.TmsGeofence.Name,
			&i.TmsGeofence.CreatedAt,
			&i.TmsGeofence.UpdatedAt,
			&i.TmsGeofence.Longitude,
			&i.TmsGeofence.Latitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeGeofenceEvent = `-- name: TmsRangeGeofenceEvent :many
select
  geofence_events.id, geofence_events.vehicle_id, geofence_events.geofence_id, geofence_events.event_type, geofence_events.timestamp,
  vehicle.id, vehicle.registration_number, vehicle.model, vehicle.capacity_volume, vehicle.capacity_weight, vehicle.status, vehicle.created_at, vehicle.updated_at, vehicle.make, vehicle.year, vehicle.vin, vehicle.current_mileage, vehicle.last_maintenance_date,
  geofence.id, geofence.name, geofence.created_at, geofence.updated_at, geofence.longitude, geofence.latitude
from
  "tms"."geofence_events" as geofence_events
  inner join "tms"."vehicles" as vehicle on geofence_events.vehicle_id = vehicle.id
  inner join "tms"."geofences" as geofence on geofence_events.geofence_id = geofence.id
where
  geofence_events.timestamp >= $1::date
  and geofence_events.timestamp <= $2::date
  and (vehicle.registration_number ilike $3::text
    or geofence.name ilike $3::text
    or geofence_events.event_type::text ilike $3::text
    or $3::text is null)
`

type TmsRangeGeofenceEventParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeGeofenceEventRow struct {
	TmsGeofenceEvent TmsGeofenceEvent `db:"tms_geofence_event" json:"tms_geofence_event"`
	TmsVehicle       TmsVehicle       `db:"tms_vehicle" json:"tms_vehicle"`
	TmsGeofence      TmsGeofence      `db:"tms_geofence" json:"tms_geofence"`
}

func (q *Queries) TmsRangeGeofenceEvent(ctx context.Context, arg TmsRangeGeofenceEventParams) ([]TmsRangeGeofenceEventRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeGeofenceEvent, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeGeofenceEventRow
	for rows.Next() {
		var i TmsRangeGeofenceEventRow
		if err := rows.Scan(
			&i.TmsGeofenceEvent.ID,
			&i.TmsGeofenceEvent.VehicleID,
			&i.TmsGeofenceEvent.GeofenceID,
			&i.TmsGeofenceEvent.EventType,
			&i.TmsGeofenceEvent.Timestamp,
			&i.TmsVehicle.ID,
			&i.TmsVehicle.RegistrationNumber,
			&i.TmsVehicle.Model,
			&i.TmsVehicle.CapacityVolume,
			&i.TmsVehicle.CapacityWeight,
			&i.TmsVehicle.Status,
			&i.TmsVehicle.CreatedAt,
			&i.TmsVehicle.UpdatedAt,
			&i.TmsVehicle.Make,
			&i.TmsVehicle.Year,
			&i.TmsVehicle.Vin,
			&i.TmsVehicle.CurrentMileage,
			&i.TmsVehicle.LastMaintenanceDate,
			&i.TmsGeofence.ID,
			&i.TmsGeofence.Name,
			&i.TmsGeofence.CreatedAt,
			&i.TmsGeofence.UpdatedAt,
			&i.TmsGeofence.Longitude,
			&i.TmsGeofence.Latitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveGeofenceEvent = `-- name: TmsRemoveGeofenceEvent :exec
delete from "tms"."geofence_events"
where id = $1::uuid
`

func (q *Queries) TmsRemoveGeofenceEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveGeofenceEvent, id)
	return err
}

const tmsUpdateGeofenceEvent = `-- name: TmsUpdateGeofenceEvent :one
update
  "tms"."geofence_events"
set
  updated_at = now(),
  vehicle_id = case when $1 is not null then
    $1::uuid
  else
    vehicle_id
  end,
  geofence_id = case when $2 is not null then
    $2::uuid
  else
    geofence_id
  end,
  event_type = case when $3 is not null then
    $3::tms.geofence_event_type_enum
  else
    event_type
  end,
  timestamp = case when $4 is not null then
    $4::timestamp
  else
    timestamp
  end
where
  id = $5::uuid
returning
  id, vehicle_id, geofence_id, event_type, timestamp
`

type TmsUpdateGeofenceEventParams struct {
	VehicleID  pgtype.UUID              `db:"vehicle_id" json:"vehicle_id"`
	GeofenceID pgtype.UUID              `db:"geofence_id" json:"geofence_id"`
	EventType  TmsGeofenceEventTypeEnum `db:"event_type" json:"event_type"`
	Timestamp  pgtype.Timestamp         `db:"timestamp" json:"timestamp"`
	ID         pgtype.UUID              `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateGeofenceEvent(ctx context.Context, arg TmsUpdateGeofenceEventParams) (TmsGeofenceEvent, error) {
	row := q.db.QueryRow(ctx, tmsUpdateGeofenceEvent,
		arg.VehicleID,
		arg.GeofenceID,
		arg.EventType,
		arg.Timestamp,
		arg.ID,
	)
	var i TmsGeofenceEvent
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.GeofenceID,
		&i.EventType,
		&i.Timestamp,
	)
	return i, err
}
