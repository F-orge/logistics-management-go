// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_package_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyPackageItem = `-- name: WmsAnyPackageItem :many
select
  package_items.id, package_items.package_id, package_items.product_id, package_items.batch_id, package_items.quantity, package_items.lot_number, package_items.serial_numbers, package_items.expiry_date, package_items.unit_weight, package_items.total_weight, package_items.created_at, package_items.updated_at,
  package.id, package.sales_order_id, package.package_number, package.warehouse_id, package.package_type, package.weight, package.length, package.width, package.height, package.volume, package.tracking_number, package.carrier, package.service_level, package.packed_by_user_id, package.packed_at, package.shipped_at, package.is_fragile, package.is_hazmat, package.requires_signature, package.insurance_value, package.created_at, package.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."package_items" as package_items
  inner join "wms"."packages" as package on package_items.package_id = package.id
  inner join "wms"."products" as product on package_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on package_items.batch_id = batch.id
where
  package_items.id = any ($1::uuid[])
`

type WmsAnyPackageItemRow struct {
	WmsPackageItem    WmsPackageItem
	WmsPackage        WmsPackage
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
}

func (q *Queries) WmsAnyPackageItem(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyPackageItemRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyPackageItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyPackageItemRow
	for rows.Next() {
		var i WmsAnyPackageItemRow
		if err := rows.Scan(
			&i.WmsPackageItem.ID,
			&i.WmsPackageItem.PackageID,
			&i.WmsPackageItem.ProductID,
			&i.WmsPackageItem.BatchID,
			&i.WmsPackageItem.Quantity,
			&i.WmsPackageItem.LotNumber,
			&i.WmsPackageItem.SerialNumbers,
			&i.WmsPackageItem.ExpiryDate,
			&i.WmsPackageItem.UnitWeight,
			&i.WmsPackageItem.TotalWeight,
			&i.WmsPackageItem.CreatedAt,
			&i.WmsPackageItem.UpdatedAt,
			&i.WmsPackage.ID,
			&i.WmsPackage.SalesOrderID,
			&i.WmsPackage.PackageNumber,
			&i.WmsPackage.WarehouseID,
			&i.WmsPackage.PackageType,
			&i.WmsPackage.Weight,
			&i.WmsPackage.Length,
			&i.WmsPackage.Width,
			&i.WmsPackage.Height,
			&i.WmsPackage.Volume,
			&i.WmsPackage.TrackingNumber,
			&i.WmsPackage.Carrier,
			&i.WmsPackage.ServiceLevel,
			&i.WmsPackage.PackedByUserID,
			&i.WmsPackage.PackedAt,
			&i.WmsPackage.ShippedAt,
			&i.WmsPackage.IsFragile,
			&i.WmsPackage.IsHazmat,
			&i.WmsPackage.RequiresSignature,
			&i.WmsPackage.InsuranceValue,
			&i.WmsPackage.CreatedAt,
			&i.WmsPackage.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindPackageItem = `-- name: WmsFindPackageItem :one
select
  package_items.id, package_items.package_id, package_items.product_id, package_items.batch_id, package_items.quantity, package_items.lot_number, package_items.serial_numbers, package_items.expiry_date, package_items.unit_weight, package_items.total_weight, package_items.created_at, package_items.updated_at,
  package.id, package.sales_order_id, package.package_number, package.warehouse_id, package.package_type, package.weight, package.length, package.width, package.height, package.volume, package.tracking_number, package.carrier, package.service_level, package.packed_by_user_id, package.packed_at, package.shipped_at, package.is_fragile, package.is_hazmat, package.requires_signature, package.insurance_value, package.created_at, package.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."package_items" as package_items
  inner join "wms"."packages" as package on package_items.package_id = package.id
  inner join "wms"."products" as product on package_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on package_items.batch_id = batch.id
where
  package_items.id = $1::uuid
`

type WmsFindPackageItemRow struct {
	WmsPackageItem    WmsPackageItem
	WmsPackage        WmsPackage
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
}

func (q *Queries) WmsFindPackageItem(ctx context.Context, id pgtype.UUID) (WmsFindPackageItemRow, error) {
	row := q.db.QueryRow(ctx, wmsFindPackageItem, id)
	var i WmsFindPackageItemRow
	err := row.Scan(
		&i.WmsPackageItem.ID,
		&i.WmsPackageItem.PackageID,
		&i.WmsPackageItem.ProductID,
		&i.WmsPackageItem.BatchID,
		&i.WmsPackageItem.Quantity,
		&i.WmsPackageItem.LotNumber,
		&i.WmsPackageItem.SerialNumbers,
		&i.WmsPackageItem.ExpiryDate,
		&i.WmsPackageItem.UnitWeight,
		&i.WmsPackageItem.TotalWeight,
		&i.WmsPackageItem.CreatedAt,
		&i.WmsPackageItem.UpdatedAt,
		&i.WmsPackage.ID,
		&i.WmsPackage.SalesOrderID,
		&i.WmsPackage.PackageNumber,
		&i.WmsPackage.WarehouseID,
		&i.WmsPackage.PackageType,
		&i.WmsPackage.Weight,
		&i.WmsPackage.Length,
		&i.WmsPackage.Width,
		&i.WmsPackage.Height,
		&i.WmsPackage.Volume,
		&i.WmsPackage.TrackingNumber,
		&i.WmsPackage.Carrier,
		&i.WmsPackage.ServiceLevel,
		&i.WmsPackage.PackedByUserID,
		&i.WmsPackage.PackedAt,
		&i.WmsPackage.ShippedAt,
		&i.WmsPackage.IsFragile,
		&i.WmsPackage.IsHazmat,
		&i.WmsPackage.RequiresSignature,
		&i.WmsPackage.InsuranceValue,
		&i.WmsPackage.CreatedAt,
		&i.WmsPackage.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
		&i.WmsInventoryBatch.ID,
		&i.WmsInventoryBatch.ProductID,
		&i.WmsInventoryBatch.BatchNumber,
		&i.WmsInventoryBatch.ExpirationDate,
		&i.WmsInventoryBatch.CreatedAt,
		&i.WmsInventoryBatch.UpdatedAt,
	)
	return i, err
}

const wmsInsertPackageItem = `-- name: WmsInsertPackageItem :one
insert into "wms"."package_items"(package_id, product_id, batch_id, quantity, lot_number, serial_numbers, expiry_date, unit_weight)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, package_id, product_id, batch_id, quantity, lot_number, serial_numbers, expiry_date, unit_weight, total_weight, created_at, updated_at
`

type WmsInsertPackageItemParams struct {
	PackageID     pgtype.UUID
	ProductID     pgtype.UUID
	BatchID       pgtype.UUID
	Quantity      int32
	LotNumber     pgtype.Text
	SerialNumbers []string
	ExpiryDate    pgtype.Date
	UnitWeight    pgtype.Float4
}

func (q *Queries) WmsInsertPackageItem(ctx context.Context, arg WmsInsertPackageItemParams) (WmsPackageItem, error) {
	row := q.db.QueryRow(ctx, wmsInsertPackageItem,
		arg.PackageID,
		arg.ProductID,
		arg.BatchID,
		arg.Quantity,
		arg.LotNumber,
		arg.SerialNumbers,
		arg.ExpiryDate,
		arg.UnitWeight,
	)
	var i WmsPackageItem
	err := row.Scan(
		&i.ID,
		&i.PackageID,
		&i.ProductID,
		&i.BatchID,
		&i.Quantity,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.UnitWeight,
		&i.TotalWeight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginatePackageItem = `-- name: WmsPaginatePackageItem :many
select
  package_items.id, package_items.package_id, package_items.product_id, package_items.batch_id, package_items.quantity, package_items.lot_number, package_items.serial_numbers, package_items.expiry_date, package_items.unit_weight, package_items.total_weight, package_items.created_at, package_items.updated_at,
  package.id, package.sales_order_id, package.package_number, package.warehouse_id, package.package_type, package.weight, package.length, package.width, package.height, package.volume, package.tracking_number, package.carrier, package.service_level, package.packed_by_user_id, package.packed_at, package.shipped_at, package.is_fragile, package.is_hazmat, package.requires_signature, package.insurance_value, package.created_at, package.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."package_items" as package_items
  inner join "wms"."packages" as package on package_items.package_id = package.id
  inner join "wms"."products" as product on package_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on package_items.batch_id = batch.id
where
  (package.package_number ilike $1::text
  or product.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginatePackageItemParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginatePackageItemRow struct {
	WmsPackageItem    WmsPackageItem
	WmsPackage        WmsPackage
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
}

func (q *Queries) WmsPaginatePackageItem(ctx context.Context, arg WmsPaginatePackageItemParams) ([]WmsPaginatePackageItemRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginatePackageItem, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginatePackageItemRow
	for rows.Next() {
		var i WmsPaginatePackageItemRow
		if err := rows.Scan(
			&i.WmsPackageItem.ID,
			&i.WmsPackageItem.PackageID,
			&i.WmsPackageItem.ProductID,
			&i.WmsPackageItem.BatchID,
			&i.WmsPackageItem.Quantity,
			&i.WmsPackageItem.LotNumber,
			&i.WmsPackageItem.SerialNumbers,
			&i.WmsPackageItem.ExpiryDate,
			&i.WmsPackageItem.UnitWeight,
			&i.WmsPackageItem.TotalWeight,
			&i.WmsPackageItem.CreatedAt,
			&i.WmsPackageItem.UpdatedAt,
			&i.WmsPackage.ID,
			&i.WmsPackage.SalesOrderID,
			&i.WmsPackage.PackageNumber,
			&i.WmsPackage.WarehouseID,
			&i.WmsPackage.PackageType,
			&i.WmsPackage.Weight,
			&i.WmsPackage.Length,
			&i.WmsPackage.Width,
			&i.WmsPackage.Height,
			&i.WmsPackage.Volume,
			&i.WmsPackage.TrackingNumber,
			&i.WmsPackage.Carrier,
			&i.WmsPackage.ServiceLevel,
			&i.WmsPackage.PackedByUserID,
			&i.WmsPackage.PackedAt,
			&i.WmsPackage.ShippedAt,
			&i.WmsPackage.IsFragile,
			&i.WmsPackage.IsHazmat,
			&i.WmsPackage.RequiresSignature,
			&i.WmsPackage.InsuranceValue,
			&i.WmsPackage.CreatedAt,
			&i.WmsPackage.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangePackageItem = `-- name: WmsRangePackageItem :many
select
  package_items.id, package_items.package_id, package_items.product_id, package_items.batch_id, package_items.quantity, package_items.lot_number, package_items.serial_numbers, package_items.expiry_date, package_items.unit_weight, package_items.total_weight, package_items.created_at, package_items.updated_at,
  package.id, package.sales_order_id, package.package_number, package.warehouse_id, package.package_type, package.weight, package.length, package.width, package.height, package.volume, package.tracking_number, package.carrier, package.service_level, package.packed_by_user_id, package.packed_at, package.shipped_at, package.is_fragile, package.is_hazmat, package.requires_signature, package.insurance_value, package.created_at, package.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."package_items" as package_items
  inner join "wms"."packages" as package on package_items.package_id = package.id
  inner join "wms"."products" as product on package_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on package_items.batch_id = batch.id
where
  package_items.created_at >= $1::date
  and package_items.created_at <= $2::date
  and (package.package_number ilike $3::text
  or product.name ilike $3::text
  or $3::text is null)
`

type WmsRangePackageItemParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangePackageItemRow struct {
	WmsPackageItem    WmsPackageItem
	WmsPackage        WmsPackage
	WmsProduct        WmsProduct
	WmsInventoryBatch WmsInventoryBatch
}

func (q *Queries) WmsRangePackageItem(ctx context.Context, arg WmsRangePackageItemParams) ([]WmsRangePackageItemRow, error) {
	rows, err := q.db.Query(ctx, wmsRangePackageItem, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangePackageItemRow
	for rows.Next() {
		var i WmsRangePackageItemRow
		if err := rows.Scan(
			&i.WmsPackageItem.ID,
			&i.WmsPackageItem.PackageID,
			&i.WmsPackageItem.ProductID,
			&i.WmsPackageItem.BatchID,
			&i.WmsPackageItem.Quantity,
			&i.WmsPackageItem.LotNumber,
			&i.WmsPackageItem.SerialNumbers,
			&i.WmsPackageItem.ExpiryDate,
			&i.WmsPackageItem.UnitWeight,
			&i.WmsPackageItem.TotalWeight,
			&i.WmsPackageItem.CreatedAt,
			&i.WmsPackageItem.UpdatedAt,
			&i.WmsPackage.ID,
			&i.WmsPackage.SalesOrderID,
			&i.WmsPackage.PackageNumber,
			&i.WmsPackage.WarehouseID,
			&i.WmsPackage.PackageType,
			&i.WmsPackage.Weight,
			&i.WmsPackage.Length,
			&i.WmsPackage.Width,
			&i.WmsPackage.Height,
			&i.WmsPackage.Volume,
			&i.WmsPackage.TrackingNumber,
			&i.WmsPackage.Carrier,
			&i.WmsPackage.ServiceLevel,
			&i.WmsPackage.PackedByUserID,
			&i.WmsPackage.PackedAt,
			&i.WmsPackage.ShippedAt,
			&i.WmsPackage.IsFragile,
			&i.WmsPackage.IsHazmat,
			&i.WmsPackage.RequiresSignature,
			&i.WmsPackage.InsuranceValue,
			&i.WmsPackage.CreatedAt,
			&i.WmsPackage.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemovePackageItem = `-- name: WmsRemovePackageItem :exec
delete from "wms"."package_items"
where id = $1::uuid
`

func (q *Queries) WmsRemovePackageItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemovePackageItem, id)
	return err
}

const wmsUpdatePackageItem = `-- name: WmsUpdatePackageItem :one
update
  "wms"."package_items"
set
  package_id = case when $1::boolean then
    $2::uuid
  else
    package_id
  end,
  product_id = case when $3::boolean then
    $4::uuid
  else
    product_id
  end,
  batch_id = case when $5::boolean then
    $6::uuid
  else
    batch_id
  end,
  quantity = case when $7::boolean then
    $8::integer
  else
    quantity
  end,
  lot_number = case when $9::boolean then
    $10::varchar
  else
    lot_number
  end,
  serial_numbers = case when $11::boolean then
    $12::text[]
  else
    serial_numbers
  end,
  expiry_date = case when $13::boolean then
    $14::date
  else
    expiry_date
  end,
  unit_weight = case when $15::boolean then
    $16::real
  else
    unit_weight
  end
where
  id = $17::uuid
returning
  id, package_id, product_id, batch_id, quantity, lot_number, serial_numbers, expiry_date, unit_weight, total_weight, created_at, updated_at
`

type WmsUpdatePackageItemParams struct {
	SetPackageID     bool
	PackageID        pgtype.UUID
	SetProductID     bool
	ProductID        pgtype.UUID
	SetBatchID       bool
	BatchID          pgtype.UUID
	SetQuantity      bool
	Quantity         int32
	SetLotNumber     bool
	LotNumber        string
	SetSerialNumbers bool
	SerialNumbers    []string
	SetExpiryDate    bool
	ExpiryDate       pgtype.Date
	SetUnitWeight    bool
	UnitWeight       float32
	ID               pgtype.UUID
}

func (q *Queries) WmsUpdatePackageItem(ctx context.Context, arg WmsUpdatePackageItemParams) (WmsPackageItem, error) {
	row := q.db.QueryRow(ctx, wmsUpdatePackageItem,
		arg.SetPackageID,
		arg.PackageID,
		arg.SetProductID,
		arg.ProductID,
		arg.SetBatchID,
		arg.BatchID,
		arg.SetQuantity,
		arg.Quantity,
		arg.SetLotNumber,
		arg.LotNumber,
		arg.SetSerialNumbers,
		arg.SerialNumbers,
		arg.SetExpiryDate,
		arg.ExpiryDate,
		arg.SetUnitWeight,
		arg.UnitWeight,
		arg.ID,
	)
	var i WmsPackageItem
	err := row.Scan(
		&i.ID,
		&i.PackageID,
		&i.ProductID,
		&i.BatchID,
		&i.Quantity,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.UnitWeight,
		&i.TotalWeight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
