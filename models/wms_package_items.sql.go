// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_package_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyPackageItem = `-- name: WmsAnyPackageItem :many
select
  package_items.id, package_items.package_id, package_items.product_id, package_items.batch_id, package_items.quantity, package_items.lot_number, package_items.serial_numbers, package_items.expiry_date, package_items.unit_weight, package_items.total_weight, package_items.created_at, package_items.updated_at,
  package.id, package.sales_order_id, package.package_number, package.warehouse_id, package.package_type, package.weight, package.length, package.width, package.height, package.volume, package.tracking_number, package.carrier, package.service_level, package.packed_by_user_id, package.packed_at, package.shipped_at, package.is_fragile, package.is_hazmat, package.requires_signature, package.insurance_value, package.created_at, package.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."package_items" as package_items
  inner join "wms"."packages" as package on package_items.package_id = package.id
  inner join "wms"."products" as product on package_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on package_items.batch_id = batch.id
where
  package_items.id = any ($1::uuid[])
`

type WmsAnyPackageItemRow struct {
	ID                pgtype.UUID       `db:"id" json:"id"`
	PackageID         pgtype.UUID       `db:"package_id" json:"package_id"`
	ProductID         pgtype.UUID       `db:"product_id" json:"product_id"`
	BatchID           pgtype.UUID       `db:"batch_id" json:"batch_id"`
	Quantity          int32             `db:"quantity" json:"quantity"`
	LotNumber         pgtype.Text       `db:"lot_number" json:"lot_number"`
	SerialNumbers     []string          `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate        pgtype.Date       `db:"expiry_date" json:"expiry_date"`
	UnitWeight        pgtype.Float4     `db:"unit_weight" json:"unit_weight"`
	TotalWeight       pgtype.Float4     `db:"total_weight" json:"total_weight"`
	CreatedAt         pgtype.Timestamp  `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp  `db:"updated_at" json:"updated_at"`
	WmsPackage        WmsPackage        `db:"wms_package" json:"wms_package"`
	WmsProduct        WmsProduct        `db:"wms_product" json:"wms_product"`
	WmsInventoryBatch WmsInventoryBatch `db:"wms_inventory_batch" json:"wms_inventory_batch"`
}

func (q *Queries) WmsAnyPackageItem(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyPackageItemRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyPackageItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyPackageItemRow
	for rows.Next() {
		var i WmsAnyPackageItemRow
		if err := rows.Scan(
			&i.ID,
			&i.PackageID,
			&i.ProductID,
			&i.BatchID,
			&i.Quantity,
			&i.LotNumber,
			&i.SerialNumbers,
			&i.ExpiryDate,
			&i.UnitWeight,
			&i.TotalWeight,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsPackage.ID,
			&i.WmsPackage.SalesOrderID,
			&i.WmsPackage.PackageNumber,
			&i.WmsPackage.WarehouseID,
			&i.WmsPackage.PackageType,
			&i.WmsPackage.Weight,
			&i.WmsPackage.Length,
			&i.WmsPackage.Width,
			&i.WmsPackage.Height,
			&i.WmsPackage.Volume,
			&i.WmsPackage.TrackingNumber,
			&i.WmsPackage.Carrier,
			&i.WmsPackage.ServiceLevel,
			&i.WmsPackage.PackedByUserID,
			&i.WmsPackage.PackedAt,
			&i.WmsPackage.ShippedAt,
			&i.WmsPackage.IsFragile,
			&i.WmsPackage.IsHazmat,
			&i.WmsPackage.RequiresSignature,
			&i.WmsPackage.InsuranceValue,
			&i.WmsPackage.CreatedAt,
			&i.WmsPackage.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindPackageItem = `-- name: WmsFindPackageItem :one
select
  package_items.id, package_items.package_id, package_items.product_id, package_items.batch_id, package_items.quantity, package_items.lot_number, package_items.serial_numbers, package_items.expiry_date, package_items.unit_weight, package_items.total_weight, package_items.created_at, package_items.updated_at,
  package.id, package.sales_order_id, package.package_number, package.warehouse_id, package.package_type, package.weight, package.length, package.width, package.height, package.volume, package.tracking_number, package.carrier, package.service_level, package.packed_by_user_id, package.packed_at, package.shipped_at, package.is_fragile, package.is_hazmat, package.requires_signature, package.insurance_value, package.created_at, package.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."package_items" as package_items
  inner join "wms"."packages" as package on package_items.package_id = package.id
  inner join "wms"."products" as product on package_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on package_items.batch_id = batch.id
where
  package_items.id = $1::uuid
`

type WmsFindPackageItemRow struct {
	ID                pgtype.UUID       `db:"id" json:"id"`
	PackageID         pgtype.UUID       `db:"package_id" json:"package_id"`
	ProductID         pgtype.UUID       `db:"product_id" json:"product_id"`
	BatchID           pgtype.UUID       `db:"batch_id" json:"batch_id"`
	Quantity          int32             `db:"quantity" json:"quantity"`
	LotNumber         pgtype.Text       `db:"lot_number" json:"lot_number"`
	SerialNumbers     []string          `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate        pgtype.Date       `db:"expiry_date" json:"expiry_date"`
	UnitWeight        pgtype.Float4     `db:"unit_weight" json:"unit_weight"`
	TotalWeight       pgtype.Float4     `db:"total_weight" json:"total_weight"`
	CreatedAt         pgtype.Timestamp  `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp  `db:"updated_at" json:"updated_at"`
	WmsPackage        WmsPackage        `db:"wms_package" json:"wms_package"`
	WmsProduct        WmsProduct        `db:"wms_product" json:"wms_product"`
	WmsInventoryBatch WmsInventoryBatch `db:"wms_inventory_batch" json:"wms_inventory_batch"`
}

func (q *Queries) WmsFindPackageItem(ctx context.Context, id pgtype.UUID) (WmsFindPackageItemRow, error) {
	row := q.db.QueryRow(ctx, wmsFindPackageItem, id)
	var i WmsFindPackageItemRow
	err := row.Scan(
		&i.ID,
		&i.PackageID,
		&i.ProductID,
		&i.BatchID,
		&i.Quantity,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.UnitWeight,
		&i.TotalWeight,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WmsPackage.ID,
		&i.WmsPackage.SalesOrderID,
		&i.WmsPackage.PackageNumber,
		&i.WmsPackage.WarehouseID,
		&i.WmsPackage.PackageType,
		&i.WmsPackage.Weight,
		&i.WmsPackage.Length,
		&i.WmsPackage.Width,
		&i.WmsPackage.Height,
		&i.WmsPackage.Volume,
		&i.WmsPackage.TrackingNumber,
		&i.WmsPackage.Carrier,
		&i.WmsPackage.ServiceLevel,
		&i.WmsPackage.PackedByUserID,
		&i.WmsPackage.PackedAt,
		&i.WmsPackage.ShippedAt,
		&i.WmsPackage.IsFragile,
		&i.WmsPackage.IsHazmat,
		&i.WmsPackage.RequiresSignature,
		&i.WmsPackage.InsuranceValue,
		&i.WmsPackage.CreatedAt,
		&i.WmsPackage.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
		&i.WmsInventoryBatch.ID,
		&i.WmsInventoryBatch.ProductID,
		&i.WmsInventoryBatch.BatchNumber,
		&i.WmsInventoryBatch.ExpirationDate,
		&i.WmsInventoryBatch.CreatedAt,
		&i.WmsInventoryBatch.UpdatedAt,
	)
	return i, err
}

const wmsInsertPackageItem = `-- name: WmsInsertPackageItem :one
insert into "wms"."package_items"(package_id, product_id, batch_id, quantity, lot_number, serial_numbers, expiry_date, unit_weight)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, package_id, product_id, batch_id, quantity, lot_number, serial_numbers, expiry_date, unit_weight, total_weight, created_at, updated_at
`

type WmsInsertPackageItemParams struct {
	PackageID     pgtype.UUID   `db:"package_id" json:"package_id"`
	ProductID     pgtype.UUID   `db:"product_id" json:"product_id"`
	BatchID       pgtype.UUID   `db:"batch_id" json:"batch_id"`
	Quantity      int32         `db:"quantity" json:"quantity"`
	LotNumber     pgtype.Text   `db:"lot_number" json:"lot_number"`
	SerialNumbers []string      `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate    pgtype.Date   `db:"expiry_date" json:"expiry_date"`
	UnitWeight    pgtype.Float4 `db:"unit_weight" json:"unit_weight"`
}

func (q *Queries) WmsInsertPackageItem(ctx context.Context, arg WmsInsertPackageItemParams) (WmsPackageItem, error) {
	row := q.db.QueryRow(ctx, wmsInsertPackageItem,
		arg.PackageID,
		arg.ProductID,
		arg.BatchID,
		arg.Quantity,
		arg.LotNumber,
		arg.SerialNumbers,
		arg.ExpiryDate,
		arg.UnitWeight,
	)
	var i WmsPackageItem
	err := row.Scan(
		&i.ID,
		&i.PackageID,
		&i.ProductID,
		&i.BatchID,
		&i.Quantity,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.UnitWeight,
		&i.TotalWeight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginatePackageItem = `-- name: WmsPaginatePackageItem :many
select
  package_items.id, package_items.package_id, package_items.product_id, package_items.batch_id, package_items.quantity, package_items.lot_number, package_items.serial_numbers, package_items.expiry_date, package_items.unit_weight, package_items.total_weight, package_items.created_at, package_items.updated_at,
  package.id, package.sales_order_id, package.package_number, package.warehouse_id, package.package_type, package.weight, package.length, package.width, package.height, package.volume, package.tracking_number, package.carrier, package.service_level, package.packed_by_user_id, package.packed_at, package.shipped_at, package.is_fragile, package.is_hazmat, package.requires_signature, package.insurance_value, package.created_at, package.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."package_items" as package_items
  inner join "wms"."packages" as package on package_items.package_id = package.id
  inner join "wms"."products" as product on package_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on package_items.batch_id = batch.id
where (package.package_number ilike $1::text
  or product.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginatePackageItemParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type WmsPaginatePackageItemRow struct {
	ID                pgtype.UUID       `db:"id" json:"id"`
	PackageID         pgtype.UUID       `db:"package_id" json:"package_id"`
	ProductID         pgtype.UUID       `db:"product_id" json:"product_id"`
	BatchID           pgtype.UUID       `db:"batch_id" json:"batch_id"`
	Quantity          int32             `db:"quantity" json:"quantity"`
	LotNumber         pgtype.Text       `db:"lot_number" json:"lot_number"`
	SerialNumbers     []string          `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate        pgtype.Date       `db:"expiry_date" json:"expiry_date"`
	UnitWeight        pgtype.Float4     `db:"unit_weight" json:"unit_weight"`
	TotalWeight       pgtype.Float4     `db:"total_weight" json:"total_weight"`
	CreatedAt         pgtype.Timestamp  `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp  `db:"updated_at" json:"updated_at"`
	WmsPackage        WmsPackage        `db:"wms_package" json:"wms_package"`
	WmsProduct        WmsProduct        `db:"wms_product" json:"wms_product"`
	WmsInventoryBatch WmsInventoryBatch `db:"wms_inventory_batch" json:"wms_inventory_batch"`
}

func (q *Queries) WmsPaginatePackageItem(ctx context.Context, arg WmsPaginatePackageItemParams) ([]WmsPaginatePackageItemRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginatePackageItem, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginatePackageItemRow
	for rows.Next() {
		var i WmsPaginatePackageItemRow
		if err := rows.Scan(
			&i.ID,
			&i.PackageID,
			&i.ProductID,
			&i.BatchID,
			&i.Quantity,
			&i.LotNumber,
			&i.SerialNumbers,
			&i.ExpiryDate,
			&i.UnitWeight,
			&i.TotalWeight,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsPackage.ID,
			&i.WmsPackage.SalesOrderID,
			&i.WmsPackage.PackageNumber,
			&i.WmsPackage.WarehouseID,
			&i.WmsPackage.PackageType,
			&i.WmsPackage.Weight,
			&i.WmsPackage.Length,
			&i.WmsPackage.Width,
			&i.WmsPackage.Height,
			&i.WmsPackage.Volume,
			&i.WmsPackage.TrackingNumber,
			&i.WmsPackage.Carrier,
			&i.WmsPackage.ServiceLevel,
			&i.WmsPackage.PackedByUserID,
			&i.WmsPackage.PackedAt,
			&i.WmsPackage.ShippedAt,
			&i.WmsPackage.IsFragile,
			&i.WmsPackage.IsHazmat,
			&i.WmsPackage.RequiresSignature,
			&i.WmsPackage.InsuranceValue,
			&i.WmsPackage.CreatedAt,
			&i.WmsPackage.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsPaginatePackageItemMetadata = `-- name: WmsPaginatePackageItemMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "wms"."package_items" as package_items
`

type WmsPaginatePackageItemMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type WmsPaginatePackageItemMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) WmsPaginatePackageItemMetadata(ctx context.Context, arg WmsPaginatePackageItemMetadataParams) (WmsPaginatePackageItemMetadataRow, error) {
	row := q.db.QueryRow(ctx, wmsPaginatePackageItemMetadata, arg.PerPage, arg.Page)
	var i WmsPaginatePackageItemMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const wmsRangePackageItem = `-- name: WmsRangePackageItem :many
select
  package_items.id, package_items.package_id, package_items.product_id, package_items.batch_id, package_items.quantity, package_items.lot_number, package_items.serial_numbers, package_items.expiry_date, package_items.unit_weight, package_items.total_weight, package_items.created_at, package_items.updated_at,
  package.id, package.sales_order_id, package.package_number, package.warehouse_id, package.package_type, package.weight, package.length, package.width, package.height, package.volume, package.tracking_number, package.carrier, package.service_level, package.packed_by_user_id, package.packed_at, package.shipped_at, package.is_fragile, package.is_hazmat, package.requires_signature, package.insurance_value, package.created_at, package.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at,
  batch.id, batch.product_id, batch.batch_number, batch.expiration_date, batch.created_at, batch.updated_at
from
  "wms"."package_items" as package_items
  inner join "wms"."packages" as package on package_items.package_id = package.id
  inner join "wms"."products" as product on package_items.product_id = product.id
  left join "wms"."inventory_batches" as batch on package_items.batch_id = batch.id
where
  package_items.created_at >= $1::date
  and package_items.created_at <= $2::date
  and (package.package_number ilike $3::text
    or product.name ilike $3::text
    or $3::text is null)
`

type WmsRangePackageItemParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangePackageItemRow struct {
	ID                pgtype.UUID       `db:"id" json:"id"`
	PackageID         pgtype.UUID       `db:"package_id" json:"package_id"`
	ProductID         pgtype.UUID       `db:"product_id" json:"product_id"`
	BatchID           pgtype.UUID       `db:"batch_id" json:"batch_id"`
	Quantity          int32             `db:"quantity" json:"quantity"`
	LotNumber         pgtype.Text       `db:"lot_number" json:"lot_number"`
	SerialNumbers     []string          `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate        pgtype.Date       `db:"expiry_date" json:"expiry_date"`
	UnitWeight        pgtype.Float4     `db:"unit_weight" json:"unit_weight"`
	TotalWeight       pgtype.Float4     `db:"total_weight" json:"total_weight"`
	CreatedAt         pgtype.Timestamp  `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp  `db:"updated_at" json:"updated_at"`
	WmsPackage        WmsPackage        `db:"wms_package" json:"wms_package"`
	WmsProduct        WmsProduct        `db:"wms_product" json:"wms_product"`
	WmsInventoryBatch WmsInventoryBatch `db:"wms_inventory_batch" json:"wms_inventory_batch"`
}

func (q *Queries) WmsRangePackageItem(ctx context.Context, arg WmsRangePackageItemParams) ([]WmsRangePackageItemRow, error) {
	rows, err := q.db.Query(ctx, wmsRangePackageItem, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangePackageItemRow
	for rows.Next() {
		var i WmsRangePackageItemRow
		if err := rows.Scan(
			&i.ID,
			&i.PackageID,
			&i.ProductID,
			&i.BatchID,
			&i.Quantity,
			&i.LotNumber,
			&i.SerialNumbers,
			&i.ExpiryDate,
			&i.UnitWeight,
			&i.TotalWeight,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsPackage.ID,
			&i.WmsPackage.SalesOrderID,
			&i.WmsPackage.PackageNumber,
			&i.WmsPackage.WarehouseID,
			&i.WmsPackage.PackageType,
			&i.WmsPackage.Weight,
			&i.WmsPackage.Length,
			&i.WmsPackage.Width,
			&i.WmsPackage.Height,
			&i.WmsPackage.Volume,
			&i.WmsPackage.TrackingNumber,
			&i.WmsPackage.Carrier,
			&i.WmsPackage.ServiceLevel,
			&i.WmsPackage.PackedByUserID,
			&i.WmsPackage.PackedAt,
			&i.WmsPackage.ShippedAt,
			&i.WmsPackage.IsFragile,
			&i.WmsPackage.IsHazmat,
			&i.WmsPackage.RequiresSignature,
			&i.WmsPackage.InsuranceValue,
			&i.WmsPackage.CreatedAt,
			&i.WmsPackage.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemovePackageItem = `-- name: WmsRemovePackageItem :exec
delete from "wms"."package_items"
where id = $1::uuid
`

func (q *Queries) WmsRemovePackageItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemovePackageItem, id)
	return err
}

const wmsUpdatePackageItem = `-- name: WmsUpdatePackageItem :one
update
  "wms"."package_items"
set
  updated_at = now(),
  package_id = case when $1 is not null then
    $1::uuid
  else
    package_id
  end,
  product_id = case when $2 is not null then
    $2::uuid
  else
    product_id
  end,
  batch_id = case when $3 is not null then
    $3::uuid
  else
    batch_id
  end,
  quantity = case when $4 is not null then
    $4::integer
  else
    quantity
  end,
  lot_number = case when $5 is not null then
    $5::varchar
  else
    lot_number
  end,
  serial_numbers = case when $6 is not null then
    $6::text[]
  else
    serial_numbers
  end,
  expiry_date = case when $7 is not null then
    $7::date
  else
    expiry_date
  end,
  unit_weight = case when $8 is not null then
    $8::real
  else
    unit_weight
  end
where
  id = $9::uuid
returning
  id, package_id, product_id, batch_id, quantity, lot_number, serial_numbers, expiry_date, unit_weight, total_weight, created_at, updated_at
`

type WmsUpdatePackageItemParams struct {
	PackageID     pgtype.UUID   `db:"package_id" json:"package_id"`
	ProductID     pgtype.UUID   `db:"product_id" json:"product_id"`
	BatchID       pgtype.UUID   `db:"batch_id" json:"batch_id"`
	Quantity      int32         `db:"quantity" json:"quantity"`
	LotNumber     pgtype.Text   `db:"lot_number" json:"lot_number"`
	SerialNumbers []string      `db:"serial_numbers" json:"serial_numbers"`
	ExpiryDate    pgtype.Date   `db:"expiry_date" json:"expiry_date"`
	UnitWeight    pgtype.Float4 `db:"unit_weight" json:"unit_weight"`
	ID            pgtype.UUID   `db:"id" json:"id"`
}

func (q *Queries) WmsUpdatePackageItem(ctx context.Context, arg WmsUpdatePackageItemParams) (WmsPackageItem, error) {
	row := q.db.QueryRow(ctx, wmsUpdatePackageItem,
		arg.PackageID,
		arg.ProductID,
		arg.BatchID,
		arg.Quantity,
		arg.LotNumber,
		arg.SerialNumbers,
		arg.ExpiryDate,
		arg.UnitWeight,
		arg.ID,
	)
	var i WmsPackageItem
	err := row.Scan(
		&i.ID,
		&i.PackageID,
		&i.ProductID,
		&i.BatchID,
		&i.Quantity,
		&i.LotNumber,
		&i.SerialNumbers,
		&i.ExpiryDate,
		&i.UnitWeight,
		&i.TotalWeight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
