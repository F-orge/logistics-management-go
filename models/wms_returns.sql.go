// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_returns.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyReturn = `-- name: WmsAnyReturn :many
select
  wms_returns.id, wms_returns.return_number, wms_returns.sales_order_id, wms_returns.client_id, wms_returns.status, wms_returns.reason, wms_returns.created_at, wms_returns.updated_at, wms_returns.return_items,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."returns_view" as wms_returns
  left join "wms"."sales_orders" as sales_order on wms_returns.sales_order_id = sales_order.id
  inner join "crm"."companies" as client on wms_returns.client_id = client.id
where
  wms_returns.id = any ($1::uuid[])
`

type WmsAnyReturnRow struct {
	WmsReturnsView WmsReturnsView `db:"wms_returns_view" json:"wms_returns_view"`
	WmsSalesOrder  WmsSalesOrder  `db:"wms_sales_order" json:"wms_sales_order"`
	CrmCompany     CrmCompany     `db:"crm_company" json:"crm_company"`
}

func (q *Queries) WmsAnyReturn(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyReturnRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyReturn, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyReturnRow
	for rows.Next() {
		var i WmsAnyReturnRow
		if err := rows.Scan(
			&i.WmsReturnsView.ID,
			&i.WmsReturnsView.ReturnNumber,
			&i.WmsReturnsView.SalesOrderID,
			&i.WmsReturnsView.ClientID,
			&i.WmsReturnsView.Status,
			&i.WmsReturnsView.Reason,
			&i.WmsReturnsView.CreatedAt,
			&i.WmsReturnsView.UpdatedAt,
			&i.WmsReturnsView.ReturnItems,
			&i.WmsSalesOrder.ID,
			&i.WmsSalesOrder.OrderNumber,
			&i.WmsSalesOrder.ClientID,
			&i.WmsSalesOrder.CrmOpportunityID,
			&i.WmsSalesOrder.Status,
			&i.WmsSalesOrder.ShippingAddress,
			&i.WmsSalesOrder.CreatedAt,
			&i.WmsSalesOrder.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindReturn = `-- name: WmsFindReturn :one
select
  wms_returns.id, wms_returns.return_number, wms_returns.sales_order_id, wms_returns.client_id, wms_returns.status, wms_returns.reason, wms_returns.created_at, wms_returns.updated_at, wms_returns.return_items,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."returns_view" as wms_returns
  left join "wms"."sales_orders" as sales_order on wms_returns.sales_order_id = sales_order.id
  inner join "crm"."companies" as client on wms_returns.client_id = client.id
where
  wms_returns.id = $1::uuid
`

type WmsFindReturnRow struct {
	WmsReturnsView WmsReturnsView `db:"wms_returns_view" json:"wms_returns_view"`
	WmsSalesOrder  WmsSalesOrder  `db:"wms_sales_order" json:"wms_sales_order"`
	CrmCompany     CrmCompany     `db:"crm_company" json:"crm_company"`
}

func (q *Queries) WmsFindReturn(ctx context.Context, id pgtype.UUID) (WmsFindReturnRow, error) {
	row := q.db.QueryRow(ctx, wmsFindReturn, id)
	var i WmsFindReturnRow
	err := row.Scan(
		&i.WmsReturnsView.ID,
		&i.WmsReturnsView.ReturnNumber,
		&i.WmsReturnsView.SalesOrderID,
		&i.WmsReturnsView.ClientID,
		&i.WmsReturnsView.Status,
		&i.WmsReturnsView.Reason,
		&i.WmsReturnsView.CreatedAt,
		&i.WmsReturnsView.UpdatedAt,
		&i.WmsReturnsView.ReturnItems,
		&i.WmsSalesOrder.ID,
		&i.WmsSalesOrder.OrderNumber,
		&i.WmsSalesOrder.ClientID,
		&i.WmsSalesOrder.CrmOpportunityID,
		&i.WmsSalesOrder.Status,
		&i.WmsSalesOrder.ShippingAddress,
		&i.WmsSalesOrder.CreatedAt,
		&i.WmsSalesOrder.UpdatedAt,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
	)
	return i, err
}

const wmsInsertReturn = `-- name: WmsInsertReturn :one
insert into "wms"."returns"(return_number, sales_order_id, client_id, status, reason)
  values ($1, $2, $3, $4, $5)
returning
  id, return_number, sales_order_id, client_id, status, reason, created_at, updated_at
`

type WmsInsertReturnParams struct {
	ReturnNumber string                  `db:"return_number" json:"return_number"`
	SalesOrderID pgtype.UUID             `db:"sales_order_id" json:"sales_order_id"`
	ClientID     pgtype.UUID             `db:"client_id" json:"client_id"`
	Status       NullWmsReturnStatusEnum `db:"status" json:"status"`
	Reason       pgtype.Text             `db:"reason" json:"reason"`
}

func (q *Queries) WmsInsertReturn(ctx context.Context, arg WmsInsertReturnParams) (WmsReturn, error) {
	row := q.db.QueryRow(ctx, wmsInsertReturn,
		arg.ReturnNumber,
		arg.SalesOrderID,
		arg.ClientID,
		arg.Status,
		arg.Reason,
	)
	var i WmsReturn
	err := row.Scan(
		&i.ID,
		&i.ReturnNumber,
		&i.SalesOrderID,
		&i.ClientID,
		&i.Status,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateReturn = `-- name: WmsPaginateReturn :many
select
  wms_returns.id, wms_returns.return_number, wms_returns.sales_order_id, wms_returns.client_id, wms_returns.status, wms_returns.reason, wms_returns.created_at, wms_returns.updated_at, wms_returns.return_items,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."returns_view" as wms_returns
  left join "wms"."sales_orders" as sales_order on wms_returns.sales_order_id = sales_order.id
  inner join "crm"."companies" as client on wms_returns.client_id = client.id
where (wms_returns.return_number ilike ($1)::text
  or sales_order.order_number ilike ($1)::text
  or client.name ilike ($1)::text
  or wms_returns.status::text ilike ($1)::text
  or ($1)::text is null)
limit $3::int offset (($2::int - 1) * $3::int)
`

type WmsPaginateReturnParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	Perpage int32       `db:"perpage" json:"perpage"`
}

type WmsPaginateReturnRow struct {
	WmsReturnsView WmsReturnsView `db:"wms_returns_view" json:"wms_returns_view"`
	WmsSalesOrder  WmsSalesOrder  `db:"wms_sales_order" json:"wms_sales_order"`
	CrmCompany     CrmCompany     `db:"crm_company" json:"crm_company"`
}

func (q *Queries) WmsPaginateReturn(ctx context.Context, arg WmsPaginateReturnParams) ([]WmsPaginateReturnRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateReturn, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateReturnRow
	for rows.Next() {
		var i WmsPaginateReturnRow
		if err := rows.Scan(
			&i.WmsReturnsView.ID,
			&i.WmsReturnsView.ReturnNumber,
			&i.WmsReturnsView.SalesOrderID,
			&i.WmsReturnsView.ClientID,
			&i.WmsReturnsView.Status,
			&i.WmsReturnsView.Reason,
			&i.WmsReturnsView.CreatedAt,
			&i.WmsReturnsView.UpdatedAt,
			&i.WmsReturnsView.ReturnItems,
			&i.WmsSalesOrder.ID,
			&i.WmsSalesOrder.OrderNumber,
			&i.WmsSalesOrder.ClientID,
			&i.WmsSalesOrder.CrmOpportunityID,
			&i.WmsSalesOrder.Status,
			&i.WmsSalesOrder.ShippingAddress,
			&i.WmsSalesOrder.CreatedAt,
			&i.WmsSalesOrder.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeReturn = `-- name: WmsRangeReturn :many
select
  wms_returns.id, wms_returns.return_number, wms_returns.sales_order_id, wms_returns.client_id, wms_returns.status, wms_returns.reason, wms_returns.created_at, wms_returns.updated_at, wms_returns.return_items,
  sales_order.id, sales_order.order_number, sales_order.client_id, sales_order.crm_opportunity_id, sales_order.status, sales_order.shipping_address, sales_order.created_at, sales_order.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."returns_view" as wms_returns
  left join "wms"."sales_orders" as sales_order on wms_returns.sales_order_id = sales_order.id
  inner join "crm"."companies" as client on wms_returns.client_id = client.id
where
  wms_returns.created_at >= $1::date
  and wms_returns.created_at <= $2::date
  and (wms_returns.return_number ilike $3::text
    or sales_order.order_number ilike $3::text
    or client.name ilike $3::text
    or wms_returns.status::text ilike $3::text
    or $3::text is null)
`

type WmsRangeReturnParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangeReturnRow struct {
	WmsReturnsView WmsReturnsView `db:"wms_returns_view" json:"wms_returns_view"`
	WmsSalesOrder  WmsSalesOrder  `db:"wms_sales_order" json:"wms_sales_order"`
	CrmCompany     CrmCompany     `db:"crm_company" json:"crm_company"`
}

func (q *Queries) WmsRangeReturn(ctx context.Context, arg WmsRangeReturnParams) ([]WmsRangeReturnRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeReturn, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeReturnRow
	for rows.Next() {
		var i WmsRangeReturnRow
		if err := rows.Scan(
			&i.WmsReturnsView.ID,
			&i.WmsReturnsView.ReturnNumber,
			&i.WmsReturnsView.SalesOrderID,
			&i.WmsReturnsView.ClientID,
			&i.WmsReturnsView.Status,
			&i.WmsReturnsView.Reason,
			&i.WmsReturnsView.CreatedAt,
			&i.WmsReturnsView.UpdatedAt,
			&i.WmsReturnsView.ReturnItems,
			&i.WmsSalesOrder.ID,
			&i.WmsSalesOrder.OrderNumber,
			&i.WmsSalesOrder.ClientID,
			&i.WmsSalesOrder.CrmOpportunityID,
			&i.WmsSalesOrder.Status,
			&i.WmsSalesOrder.ShippingAddress,
			&i.WmsSalesOrder.CreatedAt,
			&i.WmsSalesOrder.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveReturn = `-- name: WmsRemoveReturn :exec
delete from "wms"."returns"
where id = $1::uuid
`

func (q *Queries) WmsRemoveReturn(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveReturn, id)
	return err
}

const wmsUpdateReturn = `-- name: WmsUpdateReturn :one
update
  "wms"."returns"
set
  updated_at = now(),
  return_number = case when $1 is not null then
    $1::varchar
  else
    return_number
  end,
  sales_order_id = case when $2 is not null then
    $2::uuid
  else
    sales_order_id
  end,
  client_id = case when $3 is not null then
    $3::uuid
  else
    client_id
  end,
  status = case when $4 is not null then
    $4::wms.return_status_enum
  else
    status
  end,
  reason = case when $5 is not null then
    $5::text
  else
    reason
  end
where
  id = $6::uuid
returning
  id, return_number, sales_order_id, client_id, status, reason, created_at, updated_at
`

type WmsUpdateReturnParams struct {
	ReturnNumber string                  `db:"return_number" json:"return_number"`
	SalesOrderID pgtype.UUID             `db:"sales_order_id" json:"sales_order_id"`
	ClientID     pgtype.UUID             `db:"client_id" json:"client_id"`
	Status       NullWmsReturnStatusEnum `db:"status" json:"status"`
	Reason       pgtype.Text             `db:"reason" json:"reason"`
	ID           pgtype.UUID             `db:"id" json:"id"`
}

func (q *Queries) WmsUpdateReturn(ctx context.Context, arg WmsUpdateReturnParams) (WmsReturn, error) {
	row := q.db.QueryRow(ctx, wmsUpdateReturn,
		arg.ReturnNumber,
		arg.SalesOrderID,
		arg.ClientID,
		arg.Status,
		arg.Reason,
		arg.ID,
	)
	var i WmsReturn
	err := row.Scan(
		&i.ID,
		&i.ReturnNumber,
		&i.SalesOrderID,
		&i.ClientID,
		&i.Status,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
