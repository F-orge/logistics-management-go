// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_warehouses.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyWarehouse = `-- name: WmsAnyWarehouse :many
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
from
  "wms"."warehouses"
where
  id = any ($1::uuid[])
`

func (q *Queries) WmsAnyWarehouse(ctx context.Context, ids []pgtype.UUID) ([]WmsWarehouse, error) {
	rows, err := q.db.Query(ctx, wmsAnyWarehouse, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsWarehouse
	for rows.Next() {
		var i WmsWarehouse
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Timezone,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindWarehouse = `-- name: WmsFindWarehouse :one
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
from
  "wms"."warehouses"
where
  id = $1::uuid
`

func (q *Queries) WmsFindWarehouse(ctx context.Context, id pgtype.UUID) (WmsWarehouse, error) {
	row := q.db.QueryRow(ctx, wmsFindWarehouse, id)
	var i WmsWarehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Timezone,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsInsertWarehouse = `-- name: WmsInsertWarehouse :one
insert into "wms"."warehouses"(name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
`

type WmsInsertWarehouseParams struct {
	Name          string
	Address       pgtype.Text
	City          pgtype.Text
	State         pgtype.Text
	PostalCode    pgtype.Text
	Country       pgtype.Text
	Timezone      pgtype.Text
	ContactPerson pgtype.Text
	ContactEmail  pgtype.Text
	ContactPhone  pgtype.Text
	IsActive      pgtype.Bool
}

func (q *Queries) WmsInsertWarehouse(ctx context.Context, arg WmsInsertWarehouseParams) (WmsWarehouse, error) {
	row := q.db.QueryRow(ctx, wmsInsertWarehouse,
		arg.Name,
		arg.Address,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Timezone,
		arg.ContactPerson,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.IsActive,
	)
	var i WmsWarehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Timezone,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateWarehouse = `-- name: WmsPaginateWarehouse :many
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
from
  "wms"."warehouses"
where
  (name ilike $1::text
  or city ilike $1::text
  or state ilike $1::text
  or country ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateWarehouseParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

func (q *Queries) WmsPaginateWarehouse(ctx context.Context, arg WmsPaginateWarehouseParams) ([]WmsWarehouse, error) {
	rows, err := q.db.Query(ctx, wmsPaginateWarehouse, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsWarehouse
	for rows.Next() {
		var i WmsWarehouse
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Timezone,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeWarehouse = `-- name: WmsRangeWarehouse :many
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
from
  "wms"."warehouses"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (name ilike $3::text
  or city ilike $3::text
  or state ilike $3::text
  or country ilike $3::text
  or $3::text is null)
`

type WmsRangeWarehouseParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

func (q *Queries) WmsRangeWarehouse(ctx context.Context, arg WmsRangeWarehouseParams) ([]WmsWarehouse, error) {
	rows, err := q.db.Query(ctx, wmsRangeWarehouse, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsWarehouse
	for rows.Next() {
		var i WmsWarehouse
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Timezone,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveWarehouse = `-- name: WmsRemoveWarehouse :exec
delete from "wms"."warehouses"
where id = $1::uuid
`

func (q *Queries) WmsRemoveWarehouse(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveWarehouse, id)
	return err
}

const wmsUpdateWarehouse = `-- name: WmsUpdateWarehouse :one
update
  "wms"."warehouses"
set
  updated_at = now(),
  name = case when $1::boolean then
    $2::varchar
  else
    name
  end,
  address = case when $3::boolean then
    $4::text
  else
    address
  end,
  city = case when $5::boolean then
    $6::varchar
  else
    city
  end,
  state = case when $7::boolean then
    $8::varchar
  else
    state
  end,
  postal_code = case when $9::boolean then
    $10::varchar
  else
    postal_code
  end,
  country = case when $11::boolean then
    $12::varchar
  else
    country
  end,
  timezone = case when $13::boolean then
    $14::varchar
  else
    timezone
  end,
  contact_person = case when $15::boolean then
    $16::varchar
  else
    contact_person
  end,
  contact_email = case when $17::boolean then
    $18::varchar
  else
    contact_email
  end,
  contact_phone = case when $19::boolean then
    $20::varchar
  else
    contact_phone
  end,
  is_active = case when $21::boolean then
    $22::boolean
  else
    is_active
  end
where
  id = $23::uuid
returning
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
`

type WmsUpdateWarehouseParams struct {
	SetName          bool
	Name             string
	SetAddress       bool
	Address          string
	SetCity          bool
	City             string
	SetState         bool
	State            string
	SetPostalCode    bool
	PostalCode       string
	SetCountry       bool
	Country          string
	SetTimezone      bool
	Timezone         string
	SetContactPerson bool
	ContactPerson    string
	SetContactEmail  bool
	ContactEmail     string
	SetContactPhone  bool
	ContactPhone     string
	SetIsActive      bool
	IsActive         bool
	ID               pgtype.UUID
}

func (q *Queries) WmsUpdateWarehouse(ctx context.Context, arg WmsUpdateWarehouseParams) (WmsWarehouse, error) {
	row := q.db.QueryRow(ctx, wmsUpdateWarehouse,
		arg.SetName,
		arg.Name,
		arg.SetAddress,
		arg.Address,
		arg.SetCity,
		arg.City,
		arg.SetState,
		arg.State,
		arg.SetPostalCode,
		arg.PostalCode,
		arg.SetCountry,
		arg.Country,
		arg.SetTimezone,
		arg.Timezone,
		arg.SetContactPerson,
		arg.ContactPerson,
		arg.SetContactEmail,
		arg.ContactEmail,
		arg.SetContactPhone,
		arg.ContactPhone,
		arg.SetIsActive,
		arg.IsActive,
		arg.ID,
	)
	var i WmsWarehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Timezone,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
