// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_warehouses.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyWarehouse = `-- name: WmsAnyWarehouse :many
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at, inbound_shipments, outbound_shipments, locations, putaway_rules, pick_batches, tasks
from
  "wms"."warehouses_view"
where
  id = any ($1::uuid[])
`

func (q *Queries) WmsAnyWarehouse(ctx context.Context, ids []pgtype.UUID) ([]WmsWarehousesView, error) {
	rows, err := q.db.Query(ctx, wmsAnyWarehouse, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsWarehousesView
	for rows.Next() {
		var i WmsWarehousesView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Timezone,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InboundShipments,
			&i.OutboundShipments,
			&i.Locations,
			&i.PutawayRules,
			&i.PickBatches,
			&i.Tasks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindWarehouse = `-- name: WmsFindWarehouse :one
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at, inbound_shipments, outbound_shipments, locations, putaway_rules, pick_batches, tasks
from
  "wms"."warehouses_view"
where
  id = $1::uuid
`

func (q *Queries) WmsFindWarehouse(ctx context.Context, id pgtype.UUID) (WmsWarehousesView, error) {
	row := q.db.QueryRow(ctx, wmsFindWarehouse, id)
	var i WmsWarehousesView
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Timezone,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InboundShipments,
		&i.OutboundShipments,
		&i.Locations,
		&i.PutawayRules,
		&i.PickBatches,
		&i.Tasks,
	)
	return i, err
}

const wmsInsertWarehouse = `-- name: WmsInsertWarehouse :one
insert into "wms"."warehouses"(name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
`

type WmsInsertWarehouseParams struct {
	Name          string      `db:"name" fake:"{company} Warehouse" json:"name"`
	Address       pgtype.Text `db:"address" fake:"{streetaddress}" json:"address"`
	City          pgtype.Text `db:"city" fake:"{city}" json:"city"`
	State         pgtype.Text `db:"state" fake:"{state}" json:"state"`
	PostalCode    pgtype.Text `db:"postal_code" fake:"{zip}" json:"postal_code"`
	Country       pgtype.Text `db:"country" fake:"{country}" json:"country"`
	Timezone      pgtype.Text `db:"timezone" fake:"{timezone}" json:"timezone"`
	ContactPerson pgtype.Text `db:"contact_person" fake:"{name}" json:"contact_person"`
	ContactEmail  pgtype.Text `db:"contact_email" fake:"{email}" json:"contact_email"`
	ContactPhone  pgtype.Text `db:"contact_phone" fake:"{phone}" json:"contact_phone"`
	IsActive      pgtype.Bool `db:"is_active" fake:"{bool}" json:"is_active"`
}

func (q *Queries) WmsInsertWarehouse(ctx context.Context, arg WmsInsertWarehouseParams) (WmsWarehouse, error) {
	row := q.db.QueryRow(ctx, wmsInsertWarehouse,
		arg.Name,
		arg.Address,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Timezone,
		arg.ContactPerson,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.IsActive,
	)
	var i WmsWarehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Timezone,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateWarehouse = `-- name: WmsPaginateWarehouse :many
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at, inbound_shipments, outbound_shipments, locations, putaway_rules, pick_batches, tasks
from
  "wms"."warehouses_view" as warehouses
where (name ilike $1::text
  or city ilike $1::text
  or state ilike $1::text
  or country ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateWarehouseParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

func (q *Queries) WmsPaginateWarehouse(ctx context.Context, arg WmsPaginateWarehouseParams) ([]WmsWarehousesView, error) {
	rows, err := q.db.Query(ctx, wmsPaginateWarehouse, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsWarehousesView
	for rows.Next() {
		var i WmsWarehousesView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Timezone,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InboundShipments,
			&i.OutboundShipments,
			&i.Locations,
			&i.PutawayRules,
			&i.PickBatches,
			&i.Tasks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsPaginateWarehouseMetadata = `-- name: WmsPaginateWarehouseMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "wms"."warehouses_view" as warehouses
`

type WmsPaginateWarehouseMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type WmsPaginateWarehouseMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) WmsPaginateWarehouseMetadata(ctx context.Context, arg WmsPaginateWarehouseMetadataParams) (WmsPaginateWarehouseMetadataRow, error) {
	row := q.db.QueryRow(ctx, wmsPaginateWarehouseMetadata, arg.PerPage, arg.Page)
	var i WmsPaginateWarehouseMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const wmsRangeWarehouse = `-- name: WmsRangeWarehouse :many
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at, inbound_shipments, outbound_shipments, locations, putaway_rules, pick_batches, tasks
from
  "wms"."warehouses_view"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (name ilike $3::text
    or city ilike $3::text
    or state ilike $3::text
    or country ilike $3::text
    or $3::text is null)
`

type WmsRangeWarehouseParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) WmsRangeWarehouse(ctx context.Context, arg WmsRangeWarehouseParams) ([]WmsWarehousesView, error) {
	rows, err := q.db.Query(ctx, wmsRangeWarehouse, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsWarehousesView
	for rows.Next() {
		var i WmsWarehousesView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Timezone,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InboundShipments,
			&i.OutboundShipments,
			&i.Locations,
			&i.PutawayRules,
			&i.PickBatches,
			&i.Tasks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveWarehouse = `-- name: WmsRemoveWarehouse :exec
delete from "wms"."warehouses"
where id = $1::uuid
`

func (q *Queries) WmsRemoveWarehouse(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveWarehouse, id)
	return err
}

const wmsUpdateWarehouse = `-- name: WmsUpdateWarehouse :one
update
  "wms"."warehouses"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::varchar
  else
    name
  end,
  address = case when $2 is not null then
    $2::text
  else
    address
  end,
  city = case when $3 is not null then
    $3::varchar
  else
    city
  end,
  state = case when $4 is not null then
    $4::varchar
  else
    state
  end,
  postal_code = case when $5 is not null then
    $5::varchar
  else
    postal_code
  end,
  country = case when $6 is not null then
    $6::varchar
  else
    country
  end,
  timezone = case when $7 is not null then
    $7::varchar
  else
    timezone
  end,
  contact_person = case when $8 is not null then
    $8::varchar
  else
    contact_person
  end,
  contact_email = case when $9 is not null then
    $9::varchar
  else
    contact_email
  end,
  contact_phone = case when $10 is not null then
    $10::varchar
  else
    contact_phone
  end,
  is_active = case when $11 is not null then
    $11::boolean
  else
    is_active
  end
where
  id = $12::uuid
returning
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
`

type WmsUpdateWarehouseParams struct {
	Name          string      `db:"name" fake:"{company} Warehouse" json:"name"`
	Address       pgtype.Text `db:"address" fake:"{streetaddress}" json:"address"`
	City          pgtype.Text `db:"city" fake:"{city}" json:"city"`
	State         pgtype.Text `db:"state" fake:"{state}" json:"state"`
	PostalCode    pgtype.Text `db:"postal_code" fake:"{zip}" json:"postal_code"`
	Country       pgtype.Text `db:"country" fake:"{country}" json:"country"`
	Timezone      pgtype.Text `db:"timezone" fake:"{timezone}" json:"timezone"`
	ContactPerson pgtype.Text `db:"contact_person" fake:"{name}" json:"contact_person"`
	ContactEmail  pgtype.Text `db:"contact_email" fake:"{email}" json:"contact_email"`
	ContactPhone  pgtype.Text `db:"contact_phone" fake:"{phone}" json:"contact_phone"`
	IsActive      pgtype.Bool `db:"is_active" fake:"{bool}" json:"is_active"`
	ID            pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) WmsUpdateWarehouse(ctx context.Context, arg WmsUpdateWarehouseParams) (WmsWarehouse, error) {
	row := q.db.QueryRow(ctx, wmsUpdateWarehouse,
		arg.Name,
		arg.Address,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Timezone,
		arg.ContactPerson,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.IsActive,
		arg.ID,
	)
	var i WmsWarehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Timezone,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
