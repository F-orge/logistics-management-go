// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_warehouses.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyWarehouse = `-- name: WmsAnyWarehouse :many
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at, inbound_shipments, outbound_shipments, locations, putaway_rules, pick_batches, tasks
from
  "wms"."warehouses_view"
where
  id = any ($1::uuid[])
`

func (q *Queries) WmsAnyWarehouse(ctx context.Context, ids []pgtype.UUID) ([]WmsWarehousesView, error) {
	rows, err := q.db.Query(ctx, wmsAnyWarehouse, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsWarehousesView
	for rows.Next() {
		var i WmsWarehousesView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Timezone,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InboundShipments,
			&i.OutboundShipments,
			&i.Locations,
			&i.PutawayRules,
			&i.PickBatches,
			&i.Tasks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindWarehouse = `-- name: WmsFindWarehouse :one
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at, inbound_shipments, outbound_shipments, locations, putaway_rules, pick_batches, tasks
from
  "wms"."warehouses_view"
where
  id = $1::uuid
`

func (q *Queries) WmsFindWarehouse(ctx context.Context, id pgtype.UUID) (WmsWarehousesView, error) {
	row := q.db.QueryRow(ctx, wmsFindWarehouse, id)
	var i WmsWarehousesView
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Timezone,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InboundShipments,
		&i.OutboundShipments,
		&i.Locations,
		&i.PutawayRules,
		&i.PickBatches,
		&i.Tasks,
	)
	return i, err
}

const wmsInsertWarehouse = `-- name: WmsInsertWarehouse :one
insert into "wms"."warehouses"(name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
`

type WmsInsertWarehouseParams struct {
	Name          string
	Address       pgtype.Text
	City          pgtype.Text
	State         pgtype.Text
	PostalCode    pgtype.Text
	Country       pgtype.Text
	Timezone      pgtype.Text
	ContactPerson pgtype.Text
	ContactEmail  pgtype.Text
	ContactPhone  pgtype.Text
	IsActive      pgtype.Bool
}

func (q *Queries) WmsInsertWarehouse(ctx context.Context, arg WmsInsertWarehouseParams) (WmsWarehouse, error) {
	row := q.db.QueryRow(ctx, wmsInsertWarehouse,
		arg.Name,
		arg.Address,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Timezone,
		arg.ContactPerson,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.IsActive,
	)
	var i WmsWarehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Timezone,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateWarehouse = `-- name: WmsPaginateWarehouse :many
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at, inbound_shipments, outbound_shipments, locations, putaway_rules, pick_batches, tasks
from
  "wms"."warehouses_view"
where (name ilike $1::text
  or city ilike $1::text
  or state ilike $1::text
  or country ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateWarehouseParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

func (q *Queries) WmsPaginateWarehouse(ctx context.Context, arg WmsPaginateWarehouseParams) ([]WmsWarehousesView, error) {
	rows, err := q.db.Query(ctx, wmsPaginateWarehouse, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsWarehousesView
	for rows.Next() {
		var i WmsWarehousesView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Timezone,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InboundShipments,
			&i.OutboundShipments,
			&i.Locations,
			&i.PutawayRules,
			&i.PickBatches,
			&i.Tasks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeWarehouse = `-- name: WmsRangeWarehouse :many
select
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at, inbound_shipments, outbound_shipments, locations, putaway_rules, pick_batches, tasks
from
  "wms"."warehouses_view"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (name ilike $3::text
    or city ilike $3::text
    or state ilike $3::text
    or country ilike $3::text
    or $3::text is null)
`

type WmsRangeWarehouseParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

func (q *Queries) WmsRangeWarehouse(ctx context.Context, arg WmsRangeWarehouseParams) ([]WmsWarehousesView, error) {
	rows, err := q.db.Query(ctx, wmsRangeWarehouse, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsWarehousesView
	for rows.Next() {
		var i WmsWarehousesView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Timezone,
			&i.ContactPerson,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InboundShipments,
			&i.OutboundShipments,
			&i.Locations,
			&i.PutawayRules,
			&i.PickBatches,
			&i.Tasks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveWarehouse = `-- name: WmsRemoveWarehouse :exec
delete from "wms"."warehouses"
where id = $1::uuid
`

func (q *Queries) WmsRemoveWarehouse(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveWarehouse, id)
	return err
}

const wmsUpdateWarehouse = `-- name: WmsUpdateWarehouse :one
update
  "wms"."warehouses"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::varchar
  else
    name
  end,
  address = case when $2 is not null then
    $2::text
  else
    address
  end,
  city = case when $3 is not null then
    $3::varchar
  else
    city
  end,
  state = case when $4 is not null then
    $4::varchar
  else
    state
  end,
  postal_code = case when $5 is not null then
    $5::varchar
  else
    postal_code
  end,
  country = case when $6 is not null then
    $6::varchar
  else
    country
  end,
  timezone = case when $7 is not null then
    $7::varchar
  else
    timezone
  end,
  contact_person = case when $8 is not null then
    $8::varchar
  else
    contact_person
  end,
  contact_email = case when $9 is not null then
    $9::varchar
  else
    contact_email
  end,
  contact_phone = case when $10 is not null then
    $10::varchar
  else
    contact_phone
  end,
  is_active = case when $11 is not null then
    $11::boolean
  else
    is_active
  end
where
  id = $12::uuid
returning
  id, name, address, city, state, postal_code, country, timezone, contact_person, contact_email, contact_phone, is_active, created_at, updated_at
`

type WmsUpdateWarehouseParams struct {
	Name          string
	Address       pgtype.Text
	City          pgtype.Text
	State         pgtype.Text
	PostalCode    pgtype.Text
	Country       pgtype.Text
	Timezone      pgtype.Text
	ContactPerson pgtype.Text
	ContactEmail  pgtype.Text
	ContactPhone  pgtype.Text
	IsActive      pgtype.Bool
	ID            pgtype.UUID
}

func (q *Queries) WmsUpdateWarehouse(ctx context.Context, arg WmsUpdateWarehouseParams) (WmsWarehouse, error) {
	row := q.db.QueryRow(ctx, wmsUpdateWarehouse,
		arg.Name,
		arg.Address,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Timezone,
		arg.ContactPerson,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.IsActive,
		arg.ID,
	)
	var i WmsWarehouse
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Timezone,
		&i.ContactPerson,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
