// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package models

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BillingDisputeStatusEnum string

const (
	BillingDisputeStatusEnumOpen        BillingDisputeStatusEnum = "open"
	BillingDisputeStatusEnumUnderReview BillingDisputeStatusEnum = "under-review"
	BillingDisputeStatusEnumApproved    BillingDisputeStatusEnum = "approved"
	BillingDisputeStatusEnumDenied      BillingDisputeStatusEnum = "denied"
	BillingDisputeStatusEnumEscalated   BillingDisputeStatusEnum = "escalated"
	BillingDisputeStatusEnumClosed      BillingDisputeStatusEnum = "closed"
)

func (e *BillingDisputeStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingDisputeStatusEnum(s)
	case string:
		*e = BillingDisputeStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingDisputeStatusEnum: %T", src)
	}
	return nil
}

type NullBillingDisputeStatusEnum struct {
	BillingDisputeStatusEnum BillingDisputeStatusEnum
	Valid                    bool // Valid is true if BillingDisputeStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingDisputeStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingDisputeStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingDisputeStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingDisputeStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingDisputeStatusEnum), nil
}

type BillingDocumentTypeEnum string

const (
	BillingDocumentTypeEnumBol                BillingDocumentTypeEnum = "bol"
	BillingDocumentTypeEnumCommercialInvoice  BillingDocumentTypeEnum = "commercial-invoice"
	BillingDocumentTypeEnumPackingList        BillingDocumentTypeEnum = "packing-list"
	BillingDocumentTypeEnumReceipt            BillingDocumentTypeEnum = "receipt"
	BillingDocumentTypeEnumCreditNote         BillingDocumentTypeEnum = "credit-note"
	BillingDocumentTypeEnumShippingLabel      BillingDocumentTypeEnum = "shipping-label"
	BillingDocumentTypeEnumCustomsDeclaration BillingDocumentTypeEnum = "customs-declaration"
	BillingDocumentTypeEnumProofOfDelivery    BillingDocumentTypeEnum = "proof-of-delivery"
)

func (e *BillingDocumentTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingDocumentTypeEnum(s)
	case string:
		*e = BillingDocumentTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingDocumentTypeEnum: %T", src)
	}
	return nil
}

type NullBillingDocumentTypeEnum struct {
	BillingDocumentTypeEnum BillingDocumentTypeEnum
	Valid                   bool // Valid is true if BillingDocumentTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingDocumentTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingDocumentTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingDocumentTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingDocumentTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingDocumentTypeEnum), nil
}

type BillingInvoiceStatusEnum string

const (
	BillingInvoiceStatusEnumDraft       BillingInvoiceStatusEnum = "draft"
	BillingInvoiceStatusEnumSent        BillingInvoiceStatusEnum = "sent"
	BillingInvoiceStatusEnumViewed      BillingInvoiceStatusEnum = "viewed"
	BillingInvoiceStatusEnumPaid        BillingInvoiceStatusEnum = "paid"
	BillingInvoiceStatusEnumPartialPaid BillingInvoiceStatusEnum = "partial-paid"
	BillingInvoiceStatusEnumPastDue     BillingInvoiceStatusEnum = "past-due"
	BillingInvoiceStatusEnumDisputed    BillingInvoiceStatusEnum = "disputed"
	BillingInvoiceStatusEnumCancelled   BillingInvoiceStatusEnum = "cancelled"
	BillingInvoiceStatusEnumVoid        BillingInvoiceStatusEnum = "void"
)

func (e *BillingInvoiceStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingInvoiceStatusEnum(s)
	case string:
		*e = BillingInvoiceStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingInvoiceStatusEnum: %T", src)
	}
	return nil
}

type NullBillingInvoiceStatusEnum struct {
	BillingInvoiceStatusEnum BillingInvoiceStatusEnum
	Valid                    bool // Valid is true if BillingInvoiceStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingInvoiceStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingInvoiceStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingInvoiceStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingInvoiceStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingInvoiceStatusEnum), nil
}

type BillingPaymentMethodEnum string

const (
	BillingPaymentMethodEnumCreditCard   BillingPaymentMethodEnum = "credit-card"
	BillingPaymentMethodEnumDebitCard    BillingPaymentMethodEnum = "debit-card"
	BillingPaymentMethodEnumWallet       BillingPaymentMethodEnum = "wallet"
	BillingPaymentMethodEnumQrPh         BillingPaymentMethodEnum = "qr-ph"
	BillingPaymentMethodEnumClientCredit BillingPaymentMethodEnum = "client-credit"
	BillingPaymentMethodEnumBankTransfer BillingPaymentMethodEnum = "bank-transfer"
	BillingPaymentMethodEnumCash         BillingPaymentMethodEnum = "cash"
	BillingPaymentMethodEnumCheck        BillingPaymentMethodEnum = "check"
)

func (e *BillingPaymentMethodEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingPaymentMethodEnum(s)
	case string:
		*e = BillingPaymentMethodEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingPaymentMethodEnum: %T", src)
	}
	return nil
}

type NullBillingPaymentMethodEnum struct {
	BillingPaymentMethodEnum BillingPaymentMethodEnum
	Valid                    bool // Valid is true if BillingPaymentMethodEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingPaymentMethodEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingPaymentMethodEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingPaymentMethodEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingPaymentMethodEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingPaymentMethodEnum), nil
}

type BillingPaymentStatusEnum string

const (
	BillingPaymentStatusEnumPending    BillingPaymentStatusEnum = "pending"
	BillingPaymentStatusEnumProcessing BillingPaymentStatusEnum = "processing"
	BillingPaymentStatusEnumSuccessful BillingPaymentStatusEnum = "successful"
	BillingPaymentStatusEnumFailed     BillingPaymentStatusEnum = "failed"
	BillingPaymentStatusEnumCancelled  BillingPaymentStatusEnum = "cancelled"
	BillingPaymentStatusEnumRefunded   BillingPaymentStatusEnum = "refunded"
)

func (e *BillingPaymentStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingPaymentStatusEnum(s)
	case string:
		*e = BillingPaymentStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingPaymentStatusEnum: %T", src)
	}
	return nil
}

type NullBillingPaymentStatusEnum struct {
	BillingPaymentStatusEnum BillingPaymentStatusEnum
	Valid                    bool // Valid is true if BillingPaymentStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingPaymentStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingPaymentStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingPaymentStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingPaymentStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingPaymentStatusEnum), nil
}

type BillingPricingModelEnum string

const (
	BillingPricingModelEnumPerKg         BillingPricingModelEnum = "per-kg"
	BillingPricingModelEnumPerItem       BillingPricingModelEnum = "per-item"
	BillingPricingModelEnumFlatRate      BillingPricingModelEnum = "flat-rate"
	BillingPricingModelEnumPerCubicMeter BillingPricingModelEnum = "per-cubic-meter"
	BillingPricingModelEnumPerZone       BillingPricingModelEnum = "per-zone"
	BillingPricingModelEnumPercentage    BillingPricingModelEnum = "percentage"
	BillingPricingModelEnumTiered        BillingPricingModelEnum = "tiered"
)

func (e *BillingPricingModelEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingPricingModelEnum(s)
	case string:
		*e = BillingPricingModelEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingPricingModelEnum: %T", src)
	}
	return nil
}

type NullBillingPricingModelEnum struct {
	BillingPricingModelEnum BillingPricingModelEnum
	Valid                   bool // Valid is true if BillingPricingModelEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingPricingModelEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingPricingModelEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingPricingModelEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingPricingModelEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingPricingModelEnum), nil
}

type BillingQuoteStatusEnum string

const (
	BillingQuoteStatusEnumPending   BillingQuoteStatusEnum = "pending"
	BillingQuoteStatusEnumAccepted  BillingQuoteStatusEnum = "accepted"
	BillingQuoteStatusEnumExpired   BillingQuoteStatusEnum = "expired"
	BillingQuoteStatusEnumCancelled BillingQuoteStatusEnum = "cancelled"
	BillingQuoteStatusEnumConverted BillingQuoteStatusEnum = "converted"
)

func (e *BillingQuoteStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingQuoteStatusEnum(s)
	case string:
		*e = BillingQuoteStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingQuoteStatusEnum: %T", src)
	}
	return nil
}

type NullBillingQuoteStatusEnum struct {
	BillingQuoteStatusEnum BillingQuoteStatusEnum
	Valid                  bool // Valid is true if BillingQuoteStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingQuoteStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingQuoteStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingQuoteStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingQuoteStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingQuoteStatusEnum), nil
}

type BillingServiceTypeEnum string

const (
	BillingServiceTypeEnumShipping    BillingServiceTypeEnum = "shipping"
	BillingServiceTypeEnumStorage     BillingServiceTypeEnum = "storage"
	BillingServiceTypeEnumFulfillment BillingServiceTypeEnum = "fulfillment"
	BillingServiceTypeEnumHandling    BillingServiceTypeEnum = "handling"
	BillingServiceTypeEnumInsurance   BillingServiceTypeEnum = "insurance"
	BillingServiceTypeEnumCustoms     BillingServiceTypeEnum = "customs"
	BillingServiceTypeEnumPackaging   BillingServiceTypeEnum = "packaging"
	BillingServiceTypeEnumReturns     BillingServiceTypeEnum = "returns"
)

func (e *BillingServiceTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingServiceTypeEnum(s)
	case string:
		*e = BillingServiceTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingServiceTypeEnum: %T", src)
	}
	return nil
}

type NullBillingServiceTypeEnum struct {
	BillingServiceTypeEnum BillingServiceTypeEnum
	Valid                  bool // Valid is true if BillingServiceTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingServiceTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingServiceTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingServiceTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingServiceTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingServiceTypeEnum), nil
}

type BillingSurchargeCalculationMethodEnum string

const (
	BillingSurchargeCalculationMethodEnumPercentage   BillingSurchargeCalculationMethodEnum = "percentage"
	BillingSurchargeCalculationMethodEnumFixed        BillingSurchargeCalculationMethodEnum = "fixed"
	BillingSurchargeCalculationMethodEnumPerUnit      BillingSurchargeCalculationMethodEnum = "per-unit"
	BillingSurchargeCalculationMethodEnumSlidingScale BillingSurchargeCalculationMethodEnum = "sliding-scale"
)

func (e *BillingSurchargeCalculationMethodEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingSurchargeCalculationMethodEnum(s)
	case string:
		*e = BillingSurchargeCalculationMethodEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingSurchargeCalculationMethodEnum: %T", src)
	}
	return nil
}

type NullBillingSurchargeCalculationMethodEnum struct {
	BillingSurchargeCalculationMethodEnum BillingSurchargeCalculationMethodEnum
	Valid                                 bool // Valid is true if BillingSurchargeCalculationMethodEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingSurchargeCalculationMethodEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingSurchargeCalculationMethodEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingSurchargeCalculationMethodEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingSurchargeCalculationMethodEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingSurchargeCalculationMethodEnum), nil
}

type BillingSyncStatusEnum string

const (
	BillingSyncStatusEnumPending    BillingSyncStatusEnum = "pending"
	BillingSyncStatusEnumInProgress BillingSyncStatusEnum = "in-progress"
	BillingSyncStatusEnumSuccess    BillingSyncStatusEnum = "success"
	BillingSyncStatusEnumFailed     BillingSyncStatusEnum = "failed"
	BillingSyncStatusEnumRetry      BillingSyncStatusEnum = "retry"
)

func (e *BillingSyncStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingSyncStatusEnum(s)
	case string:
		*e = BillingSyncStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingSyncStatusEnum: %T", src)
	}
	return nil
}

type NullBillingSyncStatusEnum struct {
	BillingSyncStatusEnum BillingSyncStatusEnum
	Valid                 bool // Valid is true if BillingSyncStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingSyncStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingSyncStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingSyncStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingSyncStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingSyncStatusEnum), nil
}

type BillingTransactionTypeEnum string

const (
	BillingTransactionTypeEnumCredit     BillingTransactionTypeEnum = "credit"
	BillingTransactionTypeEnumDebit      BillingTransactionTypeEnum = "debit"
	BillingTransactionTypeEnumTopUp      BillingTransactionTypeEnum = "top-up"
	BillingTransactionTypeEnumRefund     BillingTransactionTypeEnum = "refund"
	BillingTransactionTypeEnumAdjustment BillingTransactionTypeEnum = "adjustment"
	BillingTransactionTypeEnumFee        BillingTransactionTypeEnum = "fee"
)

func (e *BillingTransactionTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingTransactionTypeEnum(s)
	case string:
		*e = BillingTransactionTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingTransactionTypeEnum: %T", src)
	}
	return nil
}

type NullBillingTransactionTypeEnum struct {
	BillingTransactionTypeEnum BillingTransactionTypeEnum
	Valid                      bool // Valid is true if BillingTransactionTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingTransactionTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingTransactionTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingTransactionTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingTransactionTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingTransactionTypeEnum), nil
}

type CrmCasePriority string

const (
	CrmCasePriorityCritical CrmCasePriority = "critical"
	CrmCasePriorityHigh     CrmCasePriority = "high"
	CrmCasePriorityMedium   CrmCasePriority = "medium"
	CrmCasePriorityLow      CrmCasePriority = "low"
)

func (e *CrmCasePriority) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmCasePriority(s)
	case string:
		*e = CrmCasePriority(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmCasePriority: %T", src)
	}
	return nil
}

type NullCrmCasePriority struct {
	CrmCasePriority CrmCasePriority
	Valid           bool // Valid is true if CrmCasePriority is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmCasePriority) Scan(value interface{}) error {
	if value == nil {
		ns.CrmCasePriority, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmCasePriority.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmCasePriority) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmCasePriority), nil
}

type CrmCaseStatus string

const (
	CrmCaseStatusNew                CrmCaseStatus = "new"
	CrmCaseStatusInProgress         CrmCaseStatus = "in-progress"
	CrmCaseStatusWaitingForCustomer CrmCaseStatus = "waiting-for-customer"
	CrmCaseStatusWaitingForInternal CrmCaseStatus = "waiting-for-internal"
	CrmCaseStatusEscalated          CrmCaseStatus = "escalated"
	CrmCaseStatusResolved           CrmCaseStatus = "resolved"
	CrmCaseStatusClosed             CrmCaseStatus = "closed"
	CrmCaseStatusCancelled          CrmCaseStatus = "cancelled"
)

func (e *CrmCaseStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmCaseStatus(s)
	case string:
		*e = CrmCaseStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmCaseStatus: %T", src)
	}
	return nil
}

type NullCrmCaseStatus struct {
	CrmCaseStatus CrmCaseStatus
	Valid         bool // Valid is true if CrmCaseStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmCaseStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CrmCaseStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmCaseStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmCaseStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmCaseStatus), nil
}

type CrmCaseType string

const (
	CrmCaseTypeQuestion         CrmCaseType = "question"
	CrmCaseTypeProblem          CrmCaseType = "problem"
	CrmCaseTypeComplaint        CrmCaseType = "complaint"
	CrmCaseTypeFeatureRequest   CrmCaseType = "feature-request"
	CrmCaseTypeBugReport        CrmCaseType = "bug-report"
	CrmCaseTypeTechnicalSupport CrmCaseType = "technical-support"
)

func (e *CrmCaseType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmCaseType(s)
	case string:
		*e = CrmCaseType(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmCaseType: %T", src)
	}
	return nil
}

type NullCrmCaseType struct {
	CrmCaseType CrmCaseType
	Valid       bool // Valid is true if CrmCaseType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmCaseType) Scan(value interface{}) error {
	if value == nil {
		ns.CrmCaseType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmCaseType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmCaseType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmCaseType), nil
}

type CrmInteractionType string

const (
	CrmInteractionTypeCall    CrmInteractionType = "call"
	CrmInteractionTypeMeeting CrmInteractionType = "meeting"
	CrmInteractionTypeText    CrmInteractionType = "text"
	CrmInteractionTypeEmail   CrmInteractionType = "email"
)

func (e *CrmInteractionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmInteractionType(s)
	case string:
		*e = CrmInteractionType(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmInteractionType: %T", src)
	}
	return nil
}

type NullCrmInteractionType struct {
	CrmInteractionType CrmInteractionType
	Valid              bool // Valid is true if CrmInteractionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmInteractionType) Scan(value interface{}) error {
	if value == nil {
		ns.CrmInteractionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmInteractionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmInteractionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmInteractionType), nil
}

type CrmInvoiceStatus string

const (
	CrmInvoiceStatusDraft     CrmInvoiceStatus = "draft"
	CrmInvoiceStatusSent      CrmInvoiceStatus = "sent"
	CrmInvoiceStatusPaid      CrmInvoiceStatus = "paid"
	CrmInvoiceStatusOverdue   CrmInvoiceStatus = "overdue"
	CrmInvoiceStatusCancelled CrmInvoiceStatus = "cancelled"
)

func (e *CrmInvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmInvoiceStatus(s)
	case string:
		*e = CrmInvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmInvoiceStatus: %T", src)
	}
	return nil
}

type NullCrmInvoiceStatus struct {
	CrmInvoiceStatus CrmInvoiceStatus
	Valid            bool // Valid is true if CrmInvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CrmInvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmInvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmInvoiceStatus), nil
}

type CrmLeadSource string

const (
	CrmLeadSourceWebsite       CrmLeadSource = "website"
	CrmLeadSourceReferral      CrmLeadSource = "referral"
	CrmLeadSourceSocialMedia   CrmLeadSource = "social-media"
	CrmLeadSourceEmailCampaign CrmLeadSource = "email-campaign"
	CrmLeadSourceColdCall      CrmLeadSource = "cold-call"
	CrmLeadSourceEvent         CrmLeadSource = "event"
	CrmLeadSourceAdvertisement CrmLeadSource = "advertisement"
	CrmLeadSourcePartner       CrmLeadSource = "partner"
	CrmLeadSourceOther         CrmLeadSource = "other"
)

func (e *CrmLeadSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmLeadSource(s)
	case string:
		*e = CrmLeadSource(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmLeadSource: %T", src)
	}
	return nil
}

type NullCrmLeadSource struct {
	CrmLeadSource CrmLeadSource
	Valid         bool // Valid is true if CrmLeadSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmLeadSource) Scan(value interface{}) error {
	if value == nil {
		ns.CrmLeadSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmLeadSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmLeadSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmLeadSource), nil
}

type CrmLeadStatus string

const (
	CrmLeadStatusNew         CrmLeadStatus = "new"
	CrmLeadStatusContacted   CrmLeadStatus = "contacted"
	CrmLeadStatusQualified   CrmLeadStatus = "qualified"
	CrmLeadStatusUnqualified CrmLeadStatus = "unqualified"
	CrmLeadStatusConverted   CrmLeadStatus = "converted"
)

func (e *CrmLeadStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmLeadStatus(s)
	case string:
		*e = CrmLeadStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmLeadStatus: %T", src)
	}
	return nil
}

type NullCrmLeadStatus struct {
	CrmLeadStatus CrmLeadStatus
	Valid         bool // Valid is true if CrmLeadStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmLeadStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CrmLeadStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmLeadStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmLeadStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmLeadStatus), nil
}

type CrmOpportunitySource string

const (
	CrmOpportunitySourceWebsite          CrmOpportunitySource = "website"
	CrmOpportunitySourceReferral         CrmOpportunitySource = "referral"
	CrmOpportunitySourceSocialMedia      CrmOpportunitySource = "social-media"
	CrmOpportunitySourceEmailCampaign    CrmOpportunitySource = "email-campaign"
	CrmOpportunitySourceColdCall         CrmOpportunitySource = "cold-call"
	CrmOpportunitySourceEvent            CrmOpportunitySource = "event"
	CrmOpportunitySourceAdvertisement    CrmOpportunitySource = "advertisement"
	CrmOpportunitySourcePartner          CrmOpportunitySource = "partner"
	CrmOpportunitySourceExistingCustomer CrmOpportunitySource = "existing-customer"
	CrmOpportunitySourceOther            CrmOpportunitySource = "other"
)

func (e *CrmOpportunitySource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmOpportunitySource(s)
	case string:
		*e = CrmOpportunitySource(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmOpportunitySource: %T", src)
	}
	return nil
}

type NullCrmOpportunitySource struct {
	CrmOpportunitySource CrmOpportunitySource
	Valid                bool // Valid is true if CrmOpportunitySource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmOpportunitySource) Scan(value interface{}) error {
	if value == nil {
		ns.CrmOpportunitySource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmOpportunitySource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmOpportunitySource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmOpportunitySource), nil
}

type CrmOpportunityStage string

const (
	CrmOpportunityStageProspecting   CrmOpportunityStage = "prospecting"
	CrmOpportunityStageQualification CrmOpportunityStage = "qualification"
	CrmOpportunityStageNeedAnalysis  CrmOpportunityStage = "need-analysis"
	CrmOpportunityStageDemo          CrmOpportunityStage = "demo"
	CrmOpportunityStageProposal      CrmOpportunityStage = "proposal"
	CrmOpportunityStageNegotiation   CrmOpportunityStage = "negotiation"
	CrmOpportunityStageClosedWon     CrmOpportunityStage = "closed-won"
	CrmOpportunityStageClosedLost    CrmOpportunityStage = "closed-lost"
)

func (e *CrmOpportunityStage) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmOpportunityStage(s)
	case string:
		*e = CrmOpportunityStage(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmOpportunityStage: %T", src)
	}
	return nil
}

type NullCrmOpportunityStage struct {
	CrmOpportunityStage CrmOpportunityStage
	Valid               bool // Valid is true if CrmOpportunityStage is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmOpportunityStage) Scan(value interface{}) error {
	if value == nil {
		ns.CrmOpportunityStage, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmOpportunityStage.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmOpportunityStage) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmOpportunityStage), nil
}

type CrmPaymentMethod string

const (
	CrmPaymentMethodCreditCard   CrmPaymentMethod = "credit-card"
	CrmPaymentMethodBankTransfer CrmPaymentMethod = "bank-transfer"
	CrmPaymentMethodCash         CrmPaymentMethod = "cash"
	CrmPaymentMethodCheck        CrmPaymentMethod = "check"
	CrmPaymentMethodPaypal       CrmPaymentMethod = "paypal"
	CrmPaymentMethodStripe       CrmPaymentMethod = "stripe"
	CrmPaymentMethodWireTransfer CrmPaymentMethod = "wire-transfer"
)

func (e *CrmPaymentMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmPaymentMethod(s)
	case string:
		*e = CrmPaymentMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmPaymentMethod: %T", src)
	}
	return nil
}

type NullCrmPaymentMethod struct {
	CrmPaymentMethod CrmPaymentMethod
	Valid            bool // Valid is true if CrmPaymentMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmPaymentMethod) Scan(value interface{}) error {
	if value == nil {
		ns.CrmPaymentMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmPaymentMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmPaymentMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmPaymentMethod), nil
}

type CrmProductType string

const (
	CrmProductTypeService      CrmProductType = "service"
	CrmProductTypeGood         CrmProductType = "good"
	CrmProductTypeDigital      CrmProductType = "digital"
	CrmProductTypeSubscription CrmProductType = "subscription"
)

func (e *CrmProductType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmProductType(s)
	case string:
		*e = CrmProductType(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmProductType: %T", src)
	}
	return nil
}

type NullCrmProductType struct {
	CrmProductType CrmProductType
	Valid          bool // Valid is true if CrmProductType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmProductType) Scan(value interface{}) error {
	if value == nil {
		ns.CrmProductType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmProductType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmProductType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmProductType), nil
}

type CrmRecordType string

const (
	CrmRecordTypeCompanies     CrmRecordType = "companies"
	CrmRecordTypeContacts      CrmRecordType = "contacts"
	CrmRecordTypeLeads         CrmRecordType = "leads"
	CrmRecordTypeOpportunities CrmRecordType = "opportunities"
	CrmRecordTypeCases         CrmRecordType = "cases"
	CrmRecordTypeInteractions  CrmRecordType = "interactions"
	CrmRecordTypeCampaigns     CrmRecordType = "campaigns"
	CrmRecordTypeProducts      CrmRecordType = "products"
	CrmRecordTypeInvoices      CrmRecordType = "invoices"
)

func (e *CrmRecordType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmRecordType(s)
	case string:
		*e = CrmRecordType(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmRecordType: %T", src)
	}
	return nil
}

type NullCrmRecordType struct {
	CrmRecordType CrmRecordType
	Valid         bool // Valid is true if CrmRecordType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmRecordType) Scan(value interface{}) error {
	if value == nil {
		ns.CrmRecordType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmRecordType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmRecordType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmRecordType), nil
}

type DmsDeliveryFailureReasonEnum string

const (
	DmsDeliveryFailureReasonEnumRecipientNotHome  DmsDeliveryFailureReasonEnum = "recipient_not_home"
	DmsDeliveryFailureReasonEnumAddressNotFound   DmsDeliveryFailureReasonEnum = "address_not_found"
	DmsDeliveryFailureReasonEnumRefusedDelivery   DmsDeliveryFailureReasonEnum = "refused_delivery"
	DmsDeliveryFailureReasonEnumDamagedPackage    DmsDeliveryFailureReasonEnum = "damaged_package"
	DmsDeliveryFailureReasonEnumAccessDenied      DmsDeliveryFailureReasonEnum = "access_denied"
	DmsDeliveryFailureReasonEnumWeatherConditions DmsDeliveryFailureReasonEnum = "weather_conditions"
	DmsDeliveryFailureReasonEnumVehicleBreakdown  DmsDeliveryFailureReasonEnum = "vehicle_breakdown"
	DmsDeliveryFailureReasonEnumOther             DmsDeliveryFailureReasonEnum = "other"
)

func (e *DmsDeliveryFailureReasonEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsDeliveryFailureReasonEnum(s)
	case string:
		*e = DmsDeliveryFailureReasonEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsDeliveryFailureReasonEnum: %T", src)
	}
	return nil
}

type NullDmsDeliveryFailureReasonEnum struct {
	DmsDeliveryFailureReasonEnum DmsDeliveryFailureReasonEnum
	Valid                        bool // Valid is true if DmsDeliveryFailureReasonEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsDeliveryFailureReasonEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsDeliveryFailureReasonEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsDeliveryFailureReasonEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsDeliveryFailureReasonEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsDeliveryFailureReasonEnum), nil
}

type DmsDeliveryRouteStatusEnum string

const (
	DmsDeliveryRouteStatusEnumPlanned    DmsDeliveryRouteStatusEnum = "planned"
	DmsDeliveryRouteStatusEnumInProgress DmsDeliveryRouteStatusEnum = "in_progress"
	DmsDeliveryRouteStatusEnumCompleted  DmsDeliveryRouteStatusEnum = "completed"
	DmsDeliveryRouteStatusEnumCancelled  DmsDeliveryRouteStatusEnum = "cancelled"
	DmsDeliveryRouteStatusEnumPaused     DmsDeliveryRouteStatusEnum = "paused"
)

func (e *DmsDeliveryRouteStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsDeliveryRouteStatusEnum(s)
	case string:
		*e = DmsDeliveryRouteStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsDeliveryRouteStatusEnum: %T", src)
	}
	return nil
}

type NullDmsDeliveryRouteStatusEnum struct {
	DmsDeliveryRouteStatusEnum DmsDeliveryRouteStatusEnum
	Valid                      bool // Valid is true if DmsDeliveryRouteStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsDeliveryRouteStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsDeliveryRouteStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsDeliveryRouteStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsDeliveryRouteStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsDeliveryRouteStatusEnum), nil
}

type DmsDeliveryTaskStatusEnum string

const (
	DmsDeliveryTaskStatusEnumPending        DmsDeliveryTaskStatusEnum = "pending"
	DmsDeliveryTaskStatusEnumAssigned       DmsDeliveryTaskStatusEnum = "assigned"
	DmsDeliveryTaskStatusEnumOutForDelivery DmsDeliveryTaskStatusEnum = "out_for_delivery"
	DmsDeliveryTaskStatusEnumDelivered      DmsDeliveryTaskStatusEnum = "delivered"
	DmsDeliveryTaskStatusEnumFailed         DmsDeliveryTaskStatusEnum = "failed"
	DmsDeliveryTaskStatusEnumCancelled      DmsDeliveryTaskStatusEnum = "cancelled"
	DmsDeliveryTaskStatusEnumRescheduled    DmsDeliveryTaskStatusEnum = "rescheduled"
)

func (e *DmsDeliveryTaskStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsDeliveryTaskStatusEnum(s)
	case string:
		*e = DmsDeliveryTaskStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsDeliveryTaskStatusEnum: %T", src)
	}
	return nil
}

type NullDmsDeliveryTaskStatusEnum struct {
	DmsDeliveryTaskStatusEnum DmsDeliveryTaskStatusEnum
	Valid                     bool // Valid is true if DmsDeliveryTaskStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsDeliveryTaskStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsDeliveryTaskStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsDeliveryTaskStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsDeliveryTaskStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsDeliveryTaskStatusEnum), nil
}

type DmsProofOfDeliveryTypeEnum string

const (
	DmsProofOfDeliveryTypeEnumSignature           DmsProofOfDeliveryTypeEnum = "signature"
	DmsProofOfDeliveryTypeEnumPhoto               DmsProofOfDeliveryTypeEnum = "photo"
	DmsProofOfDeliveryTypeEnumCodeVerification    DmsProofOfDeliveryTypeEnum = "code_verification"
	DmsProofOfDeliveryTypeEnumContactlessDelivery DmsProofOfDeliveryTypeEnum = "contactless_delivery"
	DmsProofOfDeliveryTypeEnumLeftAtDoor          DmsProofOfDeliveryTypeEnum = "left_at_door"
)

func (e *DmsProofOfDeliveryTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsProofOfDeliveryTypeEnum(s)
	case string:
		*e = DmsProofOfDeliveryTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsProofOfDeliveryTypeEnum: %T", src)
	}
	return nil
}

type NullDmsProofOfDeliveryTypeEnum struct {
	DmsProofOfDeliveryTypeEnum DmsProofOfDeliveryTypeEnum
	Valid                      bool // Valid is true if DmsProofOfDeliveryTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsProofOfDeliveryTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsProofOfDeliveryTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsProofOfDeliveryTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsProofOfDeliveryTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsProofOfDeliveryTypeEnum), nil
}

type DmsTaskEventStatusEnum string

const (
	DmsTaskEventStatusEnumAssigned    DmsTaskEventStatusEnum = "assigned"
	DmsTaskEventStatusEnumStarted     DmsTaskEventStatusEnum = "started"
	DmsTaskEventStatusEnumArrived     DmsTaskEventStatusEnum = "arrived"
	DmsTaskEventStatusEnumDelivered   DmsTaskEventStatusEnum = "delivered"
	DmsTaskEventStatusEnumFailed      DmsTaskEventStatusEnum = "failed"
	DmsTaskEventStatusEnumException   DmsTaskEventStatusEnum = "exception"
	DmsTaskEventStatusEnumCancelled   DmsTaskEventStatusEnum = "cancelled"
	DmsTaskEventStatusEnumRescheduled DmsTaskEventStatusEnum = "rescheduled"
)

func (e *DmsTaskEventStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsTaskEventStatusEnum(s)
	case string:
		*e = DmsTaskEventStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsTaskEventStatusEnum: %T", src)
	}
	return nil
}

type NullDmsTaskEventStatusEnum struct {
	DmsTaskEventStatusEnum DmsTaskEventStatusEnum
	Valid                  bool // Valid is true if DmsTaskEventStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsTaskEventStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsTaskEventStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsTaskEventStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsTaskEventStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsTaskEventStatusEnum), nil
}

type TmsCarrierRateUnitEnum string

const (
	TmsCarrierRateUnitEnumPerKg        TmsCarrierRateUnitEnum = "per_kg"
	TmsCarrierRateUnitEnumPerContainer TmsCarrierRateUnitEnum = "per_container"
	TmsCarrierRateUnitEnumPerMile      TmsCarrierRateUnitEnum = "per_mile"
	TmsCarrierRateUnitEnumPerKm        TmsCarrierRateUnitEnum = "per_km"
	TmsCarrierRateUnitEnumFlatRate     TmsCarrierRateUnitEnum = "flat_rate"
)

func (e *TmsCarrierRateUnitEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsCarrierRateUnitEnum(s)
	case string:
		*e = TmsCarrierRateUnitEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsCarrierRateUnitEnum: %T", src)
	}
	return nil
}

type NullTmsCarrierRateUnitEnum struct {
	TmsCarrierRateUnitEnum TmsCarrierRateUnitEnum
	Valid                  bool // Valid is true if TmsCarrierRateUnitEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsCarrierRateUnitEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsCarrierRateUnitEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsCarrierRateUnitEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsCarrierRateUnitEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsCarrierRateUnitEnum), nil
}

type TmsCurrencyEnum string

const (
	TmsCurrencyEnumUSD TmsCurrencyEnum = "USD"
	TmsCurrencyEnumEUR TmsCurrencyEnum = "EUR"
	TmsCurrencyEnumGBP TmsCurrencyEnum = "GBP"
	TmsCurrencyEnumCAD TmsCurrencyEnum = "CAD"
	TmsCurrencyEnumAUD TmsCurrencyEnum = "AUD"
	TmsCurrencyEnumJPY TmsCurrencyEnum = "JPY"
	TmsCurrencyEnumPHP TmsCurrencyEnum = "PHP"
)

func (e *TmsCurrencyEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsCurrencyEnum(s)
	case string:
		*e = TmsCurrencyEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsCurrencyEnum: %T", src)
	}
	return nil
}

type NullTmsCurrencyEnum struct {
	TmsCurrencyEnum TmsCurrencyEnum
	Valid           bool // Valid is true if TmsCurrencyEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsCurrencyEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsCurrencyEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsCurrencyEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsCurrencyEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsCurrencyEnum), nil
}

type TmsDriverScheduleReasonEnum string

const (
	TmsDriverScheduleReasonEnumVacation      TmsDriverScheduleReasonEnum = "vacation"
	TmsDriverScheduleReasonEnumSickLeave     TmsDriverScheduleReasonEnum = "sick_leave"
	TmsDriverScheduleReasonEnumTraining      TmsDriverScheduleReasonEnum = "training"
	TmsDriverScheduleReasonEnumPersonalLeave TmsDriverScheduleReasonEnum = "personal_leave"
)

func (e *TmsDriverScheduleReasonEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsDriverScheduleReasonEnum(s)
	case string:
		*e = TmsDriverScheduleReasonEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsDriverScheduleReasonEnum: %T", src)
	}
	return nil
}

type NullTmsDriverScheduleReasonEnum struct {
	TmsDriverScheduleReasonEnum TmsDriverScheduleReasonEnum
	Valid                       bool // Valid is true if TmsDriverScheduleReasonEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsDriverScheduleReasonEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsDriverScheduleReasonEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsDriverScheduleReasonEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsDriverScheduleReasonEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsDriverScheduleReasonEnum), nil
}

type TmsDriverStatusEnum string

const (
	TmsDriverStatusEnumActive   TmsDriverStatusEnum = "active"
	TmsDriverStatusEnumInactive TmsDriverStatusEnum = "inactive"
	TmsDriverStatusEnumOnLeave  TmsDriverStatusEnum = "on_leave"
)

func (e *TmsDriverStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsDriverStatusEnum(s)
	case string:
		*e = TmsDriverStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsDriverStatusEnum: %T", src)
	}
	return nil
}

type NullTmsDriverStatusEnum struct {
	TmsDriverStatusEnum TmsDriverStatusEnum
	Valid               bool // Valid is true if TmsDriverStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsDriverStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsDriverStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsDriverStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsDriverStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsDriverStatusEnum), nil
}

type TmsExpenseStatusEnum string

const (
	TmsExpenseStatusEnumPending    TmsExpenseStatusEnum = "pending"
	TmsExpenseStatusEnumApproved   TmsExpenseStatusEnum = "approved"
	TmsExpenseStatusEnumRejected   TmsExpenseStatusEnum = "rejected"
	TmsExpenseStatusEnumReimbursed TmsExpenseStatusEnum = "reimbursed"
)

func (e *TmsExpenseStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsExpenseStatusEnum(s)
	case string:
		*e = TmsExpenseStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsExpenseStatusEnum: %T", src)
	}
	return nil
}

type NullTmsExpenseStatusEnum struct {
	TmsExpenseStatusEnum TmsExpenseStatusEnum
	Valid                bool // Valid is true if TmsExpenseStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsExpenseStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsExpenseStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsExpenseStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsExpenseStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsExpenseStatusEnum), nil
}

type TmsExpenseTypeEnum string

const (
	TmsExpenseTypeEnumFuel          TmsExpenseTypeEnum = "fuel"
	TmsExpenseTypeEnumTolls         TmsExpenseTypeEnum = "tolls"
	TmsExpenseTypeEnumMaintenance   TmsExpenseTypeEnum = "maintenance"
	TmsExpenseTypeEnumParking       TmsExpenseTypeEnum = "parking"
	TmsExpenseTypeEnumMeals         TmsExpenseTypeEnum = "meals"
	TmsExpenseTypeEnumAccommodation TmsExpenseTypeEnum = "accommodation"
)

func (e *TmsExpenseTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsExpenseTypeEnum(s)
	case string:
		*e = TmsExpenseTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsExpenseTypeEnum: %T", src)
	}
	return nil
}

type NullTmsExpenseTypeEnum struct {
	TmsExpenseTypeEnum TmsExpenseTypeEnum
	Valid              bool // Valid is true if TmsExpenseTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsExpenseTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsExpenseTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsExpenseTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsExpenseTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsExpenseTypeEnum), nil
}

type TmsGeofenceEventTypeEnum string

const (
	TmsGeofenceEventTypeEnumEnter TmsGeofenceEventTypeEnum = "enter"
	TmsGeofenceEventTypeEnumExit  TmsGeofenceEventTypeEnum = "exit"
)

func (e *TmsGeofenceEventTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsGeofenceEventTypeEnum(s)
	case string:
		*e = TmsGeofenceEventTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsGeofenceEventTypeEnum: %T", src)
	}
	return nil
}

type NullTmsGeofenceEventTypeEnum struct {
	TmsGeofenceEventTypeEnum TmsGeofenceEventTypeEnum
	Valid                    bool // Valid is true if TmsGeofenceEventTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsGeofenceEventTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsGeofenceEventTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsGeofenceEventTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsGeofenceEventTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsGeofenceEventTypeEnum), nil
}

type TmsPartnerInvoiceStatusEnum string

const (
	TmsPartnerInvoiceStatusEnumPending   TmsPartnerInvoiceStatusEnum = "pending"
	TmsPartnerInvoiceStatusEnumPaid      TmsPartnerInvoiceStatusEnum = "paid"
	TmsPartnerInvoiceStatusEnumDisputed  TmsPartnerInvoiceStatusEnum = "disputed"
	TmsPartnerInvoiceStatusEnumOverdue   TmsPartnerInvoiceStatusEnum = "overdue"
	TmsPartnerInvoiceStatusEnumCancelled TmsPartnerInvoiceStatusEnum = "cancelled"
)

func (e *TmsPartnerInvoiceStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsPartnerInvoiceStatusEnum(s)
	case string:
		*e = TmsPartnerInvoiceStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsPartnerInvoiceStatusEnum: %T", src)
	}
	return nil
}

type NullTmsPartnerInvoiceStatusEnum struct {
	TmsPartnerInvoiceStatusEnum TmsPartnerInvoiceStatusEnum
	Valid                       bool // Valid is true if TmsPartnerInvoiceStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsPartnerInvoiceStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsPartnerInvoiceStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsPartnerInvoiceStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsPartnerInvoiceStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsPartnerInvoiceStatusEnum), nil
}

type TmsProofTypeEnum string

const (
	TmsProofTypeEnumSignature       TmsProofTypeEnum = "signature"
	TmsProofTypeEnumPhoto           TmsProofTypeEnum = "photo"
	TmsProofTypeEnumBarcodeScan     TmsProofTypeEnum = "barcode_scan"
	TmsProofTypeEnumPinVerification TmsProofTypeEnum = "pin_verification"
)

func (e *TmsProofTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsProofTypeEnum(s)
	case string:
		*e = TmsProofTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsProofTypeEnum: %T", src)
	}
	return nil
}

type NullTmsProofTypeEnum struct {
	TmsProofTypeEnum TmsProofTypeEnum
	Valid            bool // Valid is true if TmsProofTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsProofTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsProofTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsProofTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsProofTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsProofTypeEnum), nil
}

type TmsShipmentLegStatusEnum string

const (
	TmsShipmentLegStatusEnumPending   TmsShipmentLegStatusEnum = "pending"
	TmsShipmentLegStatusEnumInTransit TmsShipmentLegStatusEnum = "in_transit"
	TmsShipmentLegStatusEnumDelivered TmsShipmentLegStatusEnum = "delivered"
	TmsShipmentLegStatusEnumCancelled TmsShipmentLegStatusEnum = "cancelled"
	TmsShipmentLegStatusEnumFailed    TmsShipmentLegStatusEnum = "failed"
)

func (e *TmsShipmentLegStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsShipmentLegStatusEnum(s)
	case string:
		*e = TmsShipmentLegStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsShipmentLegStatusEnum: %T", src)
	}
	return nil
}

type NullTmsShipmentLegStatusEnum struct {
	TmsShipmentLegStatusEnum TmsShipmentLegStatusEnum
	Valid                    bool // Valid is true if TmsShipmentLegStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsShipmentLegStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsShipmentLegStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsShipmentLegStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsShipmentLegStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsShipmentLegStatusEnum), nil
}

type TmsTripStatusEnum string

const (
	TmsTripStatusEnumPlanned    TmsTripStatusEnum = "planned"
	TmsTripStatusEnumInProgress TmsTripStatusEnum = "in_progress"
	TmsTripStatusEnumCompleted  TmsTripStatusEnum = "completed"
	TmsTripStatusEnumCancelled  TmsTripStatusEnum = "cancelled"
)

func (e *TmsTripStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsTripStatusEnum(s)
	case string:
		*e = TmsTripStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsTripStatusEnum: %T", src)
	}
	return nil
}

type NullTmsTripStatusEnum struct {
	TmsTripStatusEnum TmsTripStatusEnum
	Valid             bool // Valid is true if TmsTripStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsTripStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsTripStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsTripStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsTripStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsTripStatusEnum), nil
}

type TmsTripStopStatusEnum string

const (
	TmsTripStopStatusEnumPending   TmsTripStopStatusEnum = "pending"
	TmsTripStopStatusEnumArrived   TmsTripStopStatusEnum = "arrived"
	TmsTripStopStatusEnumCompleted TmsTripStopStatusEnum = "completed"
	TmsTripStopStatusEnumSkipped   TmsTripStopStatusEnum = "skipped"
)

func (e *TmsTripStopStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsTripStopStatusEnum(s)
	case string:
		*e = TmsTripStopStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsTripStopStatusEnum: %T", src)
	}
	return nil
}

type NullTmsTripStopStatusEnum struct {
	TmsTripStopStatusEnum TmsTripStopStatusEnum
	Valid                 bool // Valid is true if TmsTripStopStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsTripStopStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsTripStopStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsTripStopStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsTripStopStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsTripStopStatusEnum), nil
}

type TmsVehicleServiceTypeEnum string

const (
	TmsVehicleServiceTypeEnumRoutineMaintenance TmsVehicleServiceTypeEnum = "routine_maintenance"
	TmsVehicleServiceTypeEnumRepair             TmsVehicleServiceTypeEnum = "repair"
	TmsVehicleServiceTypeEnumInspection         TmsVehicleServiceTypeEnum = "inspection"
	TmsVehicleServiceTypeEnumOilChange          TmsVehicleServiceTypeEnum = "oil_change"
	TmsVehicleServiceTypeEnumTireReplacement    TmsVehicleServiceTypeEnum = "tire_replacement"
	TmsVehicleServiceTypeEnumBrakeService       TmsVehicleServiceTypeEnum = "brake_service"
)

func (e *TmsVehicleServiceTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsVehicleServiceTypeEnum(s)
	case string:
		*e = TmsVehicleServiceTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsVehicleServiceTypeEnum: %T", src)
	}
	return nil
}

type NullTmsVehicleServiceTypeEnum struct {
	TmsVehicleServiceTypeEnum TmsVehicleServiceTypeEnum
	Valid                     bool // Valid is true if TmsVehicleServiceTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsVehicleServiceTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsVehicleServiceTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsVehicleServiceTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsVehicleServiceTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsVehicleServiceTypeEnum), nil
}

type TmsVehicleStatusEnum string

const (
	TmsVehicleStatusEnumAvailable     TmsVehicleStatusEnum = "available"
	TmsVehicleStatusEnumInMaintenance TmsVehicleStatusEnum = "in_maintenance"
	TmsVehicleStatusEnumOnTrip        TmsVehicleStatusEnum = "on_trip"
	TmsVehicleStatusEnumOutOfService  TmsVehicleStatusEnum = "out_of_service"
)

func (e *TmsVehicleStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsVehicleStatusEnum(s)
	case string:
		*e = TmsVehicleStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsVehicleStatusEnum: %T", src)
	}
	return nil
}

type NullTmsVehicleStatusEnum struct {
	TmsVehicleStatusEnum TmsVehicleStatusEnum
	Valid                bool // Valid is true if TmsVehicleStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsVehicleStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsVehicleStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsVehicleStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsVehicleStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsVehicleStatusEnum), nil
}

type UserRole string

const (
	UserRoleAdmin                UserRole = "admin"
	UserRoleDeveloper            UserRole = "developer"
	UserRoleUser                 UserRole = "user"
	UserRoleClient               UserRole = "client"
	UserRoleClientAdmin          UserRole = "client-admin"
	UserRoleEndCustomer          UserRole = "end-customer"
	UserRoleInventoryManager     UserRole = "inventory-manager"
	UserRoleWarehouseManager     UserRole = "warehouse-manager"
	UserRoleReceivingManager     UserRole = "receiving-manager"
	UserRoleWarehouseOperator    UserRole = "warehouse-operator"
	UserRolePicker               UserRole = "picker"
	UserRolePacker               UserRole = "packer"
	UserRoleReturnsProcessor     UserRole = "returns-processor"
	UserRoleQcManager            UserRole = "qc-manager"
	UserRoleLogisticsCoordinator UserRole = "logistics-coordinator"
	UserRoleLogisticsManager     UserRole = "logistics-manager"
	UserRoleLogisticsPlanner     UserRole = "logistics-planner"
	UserRoleDispatcher           UserRole = "dispatcher"
	UserRoleDriver               UserRole = "driver"
	UserRoleFleetManager         UserRole = "fleet-manager"
	UserRoleTransportManager     UserRole = "transport-manager"
	UserRoleAccountManager       UserRole = "account-manager"
	UserRolePricingAnalyst       UserRole = "pricing-analyst"
	UserRoleFinanceManager       UserRole = "finance-manager"
	UserRoleAccountant           UserRole = "accountant"
	UserRoleSdr                  UserRole = "sdr"
	UserRoleSalesRep             UserRole = "sales-rep"
	UserRoleSalesManager         UserRole = "sales-manager"
	UserRoleMarketingManager     UserRole = "marketing-manager"
	UserRoleCustomerSupportAgent UserRole = "customer-support-agent"
	UserRoleProductManager       UserRole = "product-manager"
	UserRoleCarrier              UserRole = "carrier"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole
	Valid    bool // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type WmsInboundShipmentStatusEnum string

const (
	WmsInboundShipmentStatusEnumPending    WmsInboundShipmentStatusEnum = "pending"
	WmsInboundShipmentStatusEnumArrived    WmsInboundShipmentStatusEnum = "arrived"
	WmsInboundShipmentStatusEnumProcessing WmsInboundShipmentStatusEnum = "processing"
	WmsInboundShipmentStatusEnumCompleted  WmsInboundShipmentStatusEnum = "completed"
	WmsInboundShipmentStatusEnumCancelled  WmsInboundShipmentStatusEnum = "cancelled"
)

func (e *WmsInboundShipmentStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsInboundShipmentStatusEnum(s)
	case string:
		*e = WmsInboundShipmentStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsInboundShipmentStatusEnum: %T", src)
	}
	return nil
}

type NullWmsInboundShipmentStatusEnum struct {
	WmsInboundShipmentStatusEnum WmsInboundShipmentStatusEnum
	Valid                        bool // Valid is true if WmsInboundShipmentStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsInboundShipmentStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsInboundShipmentStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsInboundShipmentStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsInboundShipmentStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsInboundShipmentStatusEnum), nil
}

type WmsInventoryAdjustmentReasonEnum string

const (
	WmsInventoryAdjustmentReasonEnumCycleCount       WmsInventoryAdjustmentReasonEnum = "cycle_count"
	WmsInventoryAdjustmentReasonEnumDamagedGoods     WmsInventoryAdjustmentReasonEnum = "damaged_goods"
	WmsInventoryAdjustmentReasonEnumTheft            WmsInventoryAdjustmentReasonEnum = "theft"
	WmsInventoryAdjustmentReasonEnumExpired          WmsInventoryAdjustmentReasonEnum = "expired"
	WmsInventoryAdjustmentReasonEnumReturnToVendor   WmsInventoryAdjustmentReasonEnum = "return_to_vendor"
	WmsInventoryAdjustmentReasonEnumManualCorrection WmsInventoryAdjustmentReasonEnum = "manual_correction"
)

func (e *WmsInventoryAdjustmentReasonEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsInventoryAdjustmentReasonEnum(s)
	case string:
		*e = WmsInventoryAdjustmentReasonEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsInventoryAdjustmentReasonEnum: %T", src)
	}
	return nil
}

type NullWmsInventoryAdjustmentReasonEnum struct {
	WmsInventoryAdjustmentReasonEnum WmsInventoryAdjustmentReasonEnum
	Valid                            bool // Valid is true if WmsInventoryAdjustmentReasonEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsInventoryAdjustmentReasonEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsInventoryAdjustmentReasonEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsInventoryAdjustmentReasonEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsInventoryAdjustmentReasonEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsInventoryAdjustmentReasonEnum), nil
}

type WmsInventoryStockStatusEnum string

const (
	WmsInventoryStockStatusEnumAvailable  WmsInventoryStockStatusEnum = "available"
	WmsInventoryStockStatusEnumAllocated  WmsInventoryStockStatusEnum = "allocated"
	WmsInventoryStockStatusEnumDamaged    WmsInventoryStockStatusEnum = "damaged"
	WmsInventoryStockStatusEnumQuarantine WmsInventoryStockStatusEnum = "quarantine"
	WmsInventoryStockStatusEnumHold       WmsInventoryStockStatusEnum = "hold"
	WmsInventoryStockStatusEnumShipped    WmsInventoryStockStatusEnum = "shipped"
	WmsInventoryStockStatusEnumExpired    WmsInventoryStockStatusEnum = "expired"
)

func (e *WmsInventoryStockStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsInventoryStockStatusEnum(s)
	case string:
		*e = WmsInventoryStockStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsInventoryStockStatusEnum: %T", src)
	}
	return nil
}

type NullWmsInventoryStockStatusEnum struct {
	WmsInventoryStockStatusEnum WmsInventoryStockStatusEnum
	Valid                       bool // Valid is true if WmsInventoryStockStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsInventoryStockStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsInventoryStockStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsInventoryStockStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsInventoryStockStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsInventoryStockStatusEnum), nil
}

type WmsLocationTypeEnum string

const (
	WmsLocationTypeEnumReceivingDock  WmsLocationTypeEnum = "receiving_dock"
	WmsLocationTypeEnumPickBin        WmsLocationTypeEnum = "pick_bin"
	WmsLocationTypeEnumPackingStation WmsLocationTypeEnum = "packing_station"
	WmsLocationTypeEnumCrossDockArea  WmsLocationTypeEnum = "cross_dock_area"
	WmsLocationTypeEnumBulkStorage    WmsLocationTypeEnum = "bulk_storage"
	WmsLocationTypeEnumReserveStorage WmsLocationTypeEnum = "reserve_storage"
	WmsLocationTypeEnumDamagedGoods   WmsLocationTypeEnum = "damaged_goods"
	WmsLocationTypeEnumStagingArea    WmsLocationTypeEnum = "staging_area"
	WmsLocationTypeEnumQualityControl WmsLocationTypeEnum = "quality_control"
	WmsLocationTypeEnumReturnsArea    WmsLocationTypeEnum = "returns_area"
)

func (e *WmsLocationTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsLocationTypeEnum(s)
	case string:
		*e = WmsLocationTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsLocationTypeEnum: %T", src)
	}
	return nil
}

type NullWmsLocationTypeEnum struct {
	WmsLocationTypeEnum WmsLocationTypeEnum
	Valid               bool // Valid is true if WmsLocationTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsLocationTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsLocationTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsLocationTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsLocationTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsLocationTypeEnum), nil
}

type WmsOutboundShipmentStatusEnum string

const (
	WmsOutboundShipmentStatusEnumPicking   WmsOutboundShipmentStatusEnum = "picking"
	WmsOutboundShipmentStatusEnumPacked    WmsOutboundShipmentStatusEnum = "packed"
	WmsOutboundShipmentStatusEnumShipped   WmsOutboundShipmentStatusEnum = "shipped"
	WmsOutboundShipmentStatusEnumDelivered WmsOutboundShipmentStatusEnum = "delivered"
	WmsOutboundShipmentStatusEnumCancelled WmsOutboundShipmentStatusEnum = "cancelled"
)

func (e *WmsOutboundShipmentStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsOutboundShipmentStatusEnum(s)
	case string:
		*e = WmsOutboundShipmentStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsOutboundShipmentStatusEnum: %T", src)
	}
	return nil
}

type NullWmsOutboundShipmentStatusEnum struct {
	WmsOutboundShipmentStatusEnum WmsOutboundShipmentStatusEnum
	Valid                         bool // Valid is true if WmsOutboundShipmentStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsOutboundShipmentStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsOutboundShipmentStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsOutboundShipmentStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsOutboundShipmentStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsOutboundShipmentStatusEnum), nil
}

type WmsPickBatchStatusEnum string

const (
	WmsPickBatchStatusEnumOpen       WmsPickBatchStatusEnum = "open"
	WmsPickBatchStatusEnumInProgress WmsPickBatchStatusEnum = "in_progress"
	WmsPickBatchStatusEnumCompleted  WmsPickBatchStatusEnum = "completed"
	WmsPickBatchStatusEnumCancelled  WmsPickBatchStatusEnum = "cancelled"
)

func (e *WmsPickBatchStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsPickBatchStatusEnum(s)
	case string:
		*e = WmsPickBatchStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsPickBatchStatusEnum: %T", src)
	}
	return nil
}

type NullWmsPickBatchStatusEnum struct {
	WmsPickBatchStatusEnum WmsPickBatchStatusEnum
	Valid                  bool // Valid is true if WmsPickBatchStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsPickBatchStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsPickBatchStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsPickBatchStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsPickBatchStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsPickBatchStatusEnum), nil
}

type WmsPickStrategyEnum string

const (
	WmsPickStrategyEnumBatchPicking       WmsPickStrategyEnum = "batch_picking"
	WmsPickStrategyEnumZonePicking        WmsPickStrategyEnum = "zone_picking"
	WmsPickStrategyEnumWavePicking        WmsPickStrategyEnum = "wave_picking"
	WmsPickStrategyEnumSingleOrderPicking WmsPickStrategyEnum = "single_order_picking"
	WmsPickStrategyEnumClusterPicking     WmsPickStrategyEnum = "cluster_picking"
)

func (e *WmsPickStrategyEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsPickStrategyEnum(s)
	case string:
		*e = WmsPickStrategyEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsPickStrategyEnum: %T", src)
	}
	return nil
}

type NullWmsPickStrategyEnum struct {
	WmsPickStrategyEnum WmsPickStrategyEnum
	Valid               bool // Valid is true if WmsPickStrategyEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsPickStrategyEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsPickStrategyEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsPickStrategyEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsPickStrategyEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsPickStrategyEnum), nil
}

type WmsProductStatusEnum string

const (
	WmsProductStatusEnumActive       WmsProductStatusEnum = "active"
	WmsProductStatusEnumDiscontinued WmsProductStatusEnum = "discontinued"
	WmsProductStatusEnumObsolete     WmsProductStatusEnum = "obsolete"
	WmsProductStatusEnumInactive     WmsProductStatusEnum = "inactive"
)

func (e *WmsProductStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsProductStatusEnum(s)
	case string:
		*e = WmsProductStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsProductStatusEnum: %T", src)
	}
	return nil
}

type NullWmsProductStatusEnum struct {
	WmsProductStatusEnum WmsProductStatusEnum
	Valid                bool // Valid is true if WmsProductStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsProductStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsProductStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsProductStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsProductStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsProductStatusEnum), nil
}

type WmsReturnItemConditionEnum string

const (
	WmsReturnItemConditionEnumSellable   WmsReturnItemConditionEnum = "sellable"
	WmsReturnItemConditionEnumDamaged    WmsReturnItemConditionEnum = "damaged"
	WmsReturnItemConditionEnumDefective  WmsReturnItemConditionEnum = "defective"
	WmsReturnItemConditionEnumExpired    WmsReturnItemConditionEnum = "expired"
	WmsReturnItemConditionEnumUnsellable WmsReturnItemConditionEnum = "unsellable"
)

func (e *WmsReturnItemConditionEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsReturnItemConditionEnum(s)
	case string:
		*e = WmsReturnItemConditionEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsReturnItemConditionEnum: %T", src)
	}
	return nil
}

type NullWmsReturnItemConditionEnum struct {
	WmsReturnItemConditionEnum WmsReturnItemConditionEnum
	Valid                      bool // Valid is true if WmsReturnItemConditionEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsReturnItemConditionEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsReturnItemConditionEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsReturnItemConditionEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsReturnItemConditionEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsReturnItemConditionEnum), nil
}

type WmsReturnStatusEnum string

const (
	WmsReturnStatusEnumRequested WmsReturnStatusEnum = "requested"
	WmsReturnStatusEnumApproved  WmsReturnStatusEnum = "approved"
	WmsReturnStatusEnumRejected  WmsReturnStatusEnum = "rejected"
	WmsReturnStatusEnumReceived  WmsReturnStatusEnum = "received"
	WmsReturnStatusEnumProcessed WmsReturnStatusEnum = "processed"
)

func (e *WmsReturnStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsReturnStatusEnum(s)
	case string:
		*e = WmsReturnStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsReturnStatusEnum: %T", src)
	}
	return nil
}

type NullWmsReturnStatusEnum struct {
	WmsReturnStatusEnum WmsReturnStatusEnum
	Valid               bool // Valid is true if WmsReturnStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsReturnStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsReturnStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsReturnStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsReturnStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsReturnStatusEnum), nil
}

type WmsSalesOrderStatusEnum string

const (
	WmsSalesOrderStatusEnumPending    WmsSalesOrderStatusEnum = "pending"
	WmsSalesOrderStatusEnumProcessing WmsSalesOrderStatusEnum = "processing"
	WmsSalesOrderStatusEnumShipped    WmsSalesOrderStatusEnum = "shipped"
	WmsSalesOrderStatusEnumCompleted  WmsSalesOrderStatusEnum = "completed"
	WmsSalesOrderStatusEnumCancelled  WmsSalesOrderStatusEnum = "cancelled"
)

func (e *WmsSalesOrderStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsSalesOrderStatusEnum(s)
	case string:
		*e = WmsSalesOrderStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsSalesOrderStatusEnum: %T", src)
	}
	return nil
}

type NullWmsSalesOrderStatusEnum struct {
	WmsSalesOrderStatusEnum WmsSalesOrderStatusEnum
	Valid                   bool // Valid is true if WmsSalesOrderStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsSalesOrderStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsSalesOrderStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsSalesOrderStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsSalesOrderStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsSalesOrderStatusEnum), nil
}

type WmsStockTransferStatusEnum string

const (
	WmsStockTransferStatusEnumPending   WmsStockTransferStatusEnum = "pending"
	WmsStockTransferStatusEnumInTransit WmsStockTransferStatusEnum = "in_transit"
	WmsStockTransferStatusEnumReceived  WmsStockTransferStatusEnum = "received"
	WmsStockTransferStatusEnumCancelled WmsStockTransferStatusEnum = "cancelled"
)

func (e *WmsStockTransferStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsStockTransferStatusEnum(s)
	case string:
		*e = WmsStockTransferStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsStockTransferStatusEnum: %T", src)
	}
	return nil
}

type NullWmsStockTransferStatusEnum struct {
	WmsStockTransferStatusEnum WmsStockTransferStatusEnum
	Valid                      bool // Valid is true if WmsStockTransferStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsStockTransferStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsStockTransferStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsStockTransferStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsStockTransferStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsStockTransferStatusEnum), nil
}

type WmsTaskItemStatusEnum string

const (
	WmsTaskItemStatusEnumPending     WmsTaskItemStatusEnum = "pending"
	WmsTaskItemStatusEnumInProgress  WmsTaskItemStatusEnum = "in_progress"
	WmsTaskItemStatusEnumCompleted   WmsTaskItemStatusEnum = "completed"
	WmsTaskItemStatusEnumShortPicked WmsTaskItemStatusEnum = "short_picked"
	WmsTaskItemStatusEnumDamaged     WmsTaskItemStatusEnum = "damaged"
	WmsTaskItemStatusEnumNotFound    WmsTaskItemStatusEnum = "not_found"
)

func (e *WmsTaskItemStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsTaskItemStatusEnum(s)
	case string:
		*e = WmsTaskItemStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsTaskItemStatusEnum: %T", src)
	}
	return nil
}

type NullWmsTaskItemStatusEnum struct {
	WmsTaskItemStatusEnum WmsTaskItemStatusEnum
	Valid                 bool // Valid is true if WmsTaskItemStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsTaskItemStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsTaskItemStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsTaskItemStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsTaskItemStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsTaskItemStatusEnum), nil
}

type WmsTaskStatusEnum string

const (
	WmsTaskStatusEnumPending    WmsTaskStatusEnum = "pending"
	WmsTaskStatusEnumAssigned   WmsTaskStatusEnum = "assigned"
	WmsTaskStatusEnumInProgress WmsTaskStatusEnum = "in_progress"
	WmsTaskStatusEnumCompleted  WmsTaskStatusEnum = "completed"
	WmsTaskStatusEnumCancelled  WmsTaskStatusEnum = "cancelled"
	WmsTaskStatusEnumError      WmsTaskStatusEnum = "error"
)

func (e *WmsTaskStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsTaskStatusEnum(s)
	case string:
		*e = WmsTaskStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsTaskStatusEnum: %T", src)
	}
	return nil
}

type NullWmsTaskStatusEnum struct {
	WmsTaskStatusEnum WmsTaskStatusEnum
	Valid             bool // Valid is true if WmsTaskStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsTaskStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsTaskStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsTaskStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsTaskStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsTaskStatusEnum), nil
}

type WmsTaskTypeEnum string

const (
	WmsTaskTypeEnumPutaway           WmsTaskTypeEnum = "putaway"
	WmsTaskTypeEnumPick              WmsTaskTypeEnum = "pick"
	WmsTaskTypeEnumPack              WmsTaskTypeEnum = "pack"
	WmsTaskTypeEnumReplenishment     WmsTaskTypeEnum = "replenishment"
	WmsTaskTypeEnumCycleCount        WmsTaskTypeEnum = "cycle_count"
	WmsTaskTypeEnumCrossDock         WmsTaskTypeEnum = "cross_dock"
	WmsTaskTypeEnumReturnsProcessing WmsTaskTypeEnum = "returns_processing"
	WmsTaskTypeEnumDamageInspection  WmsTaskTypeEnum = "damage_inspection"
	WmsTaskTypeEnumQualityCheck      WmsTaskTypeEnum = "quality_check"
)

func (e *WmsTaskTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsTaskTypeEnum(s)
	case string:
		*e = WmsTaskTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsTaskTypeEnum: %T", src)
	}
	return nil
}

type NullWmsTaskTypeEnum struct {
	WmsTaskTypeEnum WmsTaskTypeEnum
	Valid           bool // Valid is true if WmsTaskTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsTaskTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsTaskTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsTaskTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsTaskTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsTaskTypeEnum), nil
}

type Account struct {
	ID                    string
	AccountID             string
	ProviderID            string
	UserID                string
	AccessToken           pgtype.Text
	RefreshToken          pgtype.Text
	IDToken               pgtype.Text
	AccessTokenExpiresAt  pgtype.Timestamptz
	RefreshTokenExpiresAt pgtype.Timestamptz
	Scope                 pgtype.Text
	Password              pgtype.Text
	CreatedAt             pgtype.Timestamptz
	UpdatedAt             pgtype.Timestamptz
}

// Records all financial transactions affecting client accounts.
type BillingAccountTransaction struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the affected client account.
	ClientAccountID pgtype.UUID
	// Type of transaction using transaction_type_enum.
	Type BillingTransactionTypeEnum
	// Transaction amount (positive for credits, negative for debits).
	Amount pgtype.Numeric
	// Account balance after this transaction.
	RunningBalance pgtype.Numeric
	// Reference to the source document (e.g., invoice_id, payment_id).
	SourceRecordID pgtype.UUID
	// Type of source document.
	SourceRecordType pgtype.Text
	// Description of the transaction.
	Description pgtype.Text
	// External reference number.
	ReferenceNumber pgtype.Text
	// When the transaction occurred.
	TransactionDate pgtype.Timestamp
	// User who processed this transaction.
	ProcessedByUserID pgtype.Text
	// Timestamp when the transaction was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the transaction was last updated.
	UpdatedAt pgtype.Timestamp
}

// Tracks synchronization of financial data with external accounting systems.
type BillingAccountingSyncLog struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the record being synchronized.
	RecordID pgtype.UUID
	// Type of record being synchronized.
	RecordType string
	// Target accounting system (e.g., quickbooks, xero).
	ExternalSystem string
	// ID assigned by the external system.
	ExternalID pgtype.Text
	// Synchronization status using sync_status_enum.
	Status NullBillingSyncStatusEnum
	// Details of any synchronization errors.
	ErrorMessage pgtype.Text
	// Request data sent to external system.
	RequestPayload pgtype.Text
	// Response data received from external system.
	ResponsePayload pgtype.Text
	// Timestamp of the last synchronization attempt.
	LastSyncAt pgtype.Timestamp
	// Number of retry attempts made.
	RetryCount pgtype.Int4
	// When the next retry should be attempted.
	NextRetryAt pgtype.Timestamp
	// Timestamp when the sync log was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the sync log was last updated.
	UpdatedAt pgtype.Timestamp
}

// Financial account information for clients, including credit limits and wallet balances.
type BillingClientAccount struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the client company.
	ClientID pgtype.UUID
	// Maximum credit amount allowed for the client.
	CreditLimit pgtype.Numeric
	// Current available credit balance.
	AvailableCredit pgtype.Numeric
	// Prepaid balance available for services.
	WalletBalance pgtype.Numeric
	// Currency code for the account.
	Currency pgtype.Text
	// Number of days for payment terms.
	PaymentTermsDays pgtype.Int4
	// Whether the client is approved for credit.
	IsCreditApproved pgtype.Bool
	// Date of the last payment received.
	LastPaymentDate pgtype.Date
	// Timestamp when the client account was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the client account was last updated.
	UpdatedAt pgtype.Timestamp
}

type BillingClientAccountsView struct {
	ID                  pgtype.UUID
	ClientID            pgtype.UUID
	CreditLimit         pgtype.Numeric
	AvailableCredit     pgtype.Numeric
	WalletBalance       pgtype.Numeric
	Currency            pgtype.Text
	PaymentTermsDays    pgtype.Int4
	IsCreditApproved    pgtype.Bool
	LastPaymentDate     pgtype.Date
	CreatedAt           pgtype.Timestamp
	UpdatedAt           pgtype.Timestamp
	AccountTransactions []byte
}

// Credits issued to clients for adjustments, refunds, or dispute resolutions.
type BillingCreditNote struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the related invoice.
	InvoiceID pgtype.UUID
	// Reference to the dispute (if applicable).
	DisputeID pgtype.UUID
	// Unique credit note reference number.
	CreditNoteNumber string
	// Credit amount being issued.
	Amount pgtype.Numeric
	// Explanation for the credit note.
	Reason string
	// Date the credit note was created.
	IssueDate pgtype.Date
	// When the credit was applied to the account.
	AppliedAt pgtype.Timestamp
	// Currency of the credit note.
	Currency pgtype.Text
	// Additional notes about the credit note.
	Notes pgtype.Text
	// User who created this credit note.
	CreatedByUserID pgtype.Text
	// Timestamp when the credit note was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the credit note was last updated.
	UpdatedAt pgtype.Timestamp
}

// Records of client disputes regarding invoice charges.
type BillingDispute struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the disputed invoice line item.
	LineItemID pgtype.UUID
	// Reference to the client raising the dispute.
	ClientID pgtype.UUID
	// Explanation of why the charge is being disputed.
	Reason string
	// Current dispute status using dispute_status_enum.
	Status NullBillingDisputeStatusEnum
	// Amount being disputed.
	DisputedAmount pgtype.Numeric
	// Notes about the dispute resolution.
	ResolutionNotes pgtype.Text
	// When the dispute was submitted.
	SubmittedAt pgtype.Timestamp
	// When the dispute was resolved.
	ResolvedAt pgtype.Timestamp
	// User who resolved the dispute.
	ResolvedByUserID pgtype.Text
	// Timestamp when the dispute was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the dispute was last updated.
	UpdatedAt pgtype.Timestamp
}

// Manages document attachments related to billing and shipping records.
type BillingDocument struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the record the document is attached to.
	RecordID pgtype.UUID
	// Type of record (e.g., ims_outbound_shipments, billing_invoices).
	RecordType string
	// Type of document using document_type_enum.
	DocumentType BillingDocumentTypeEnum
	// Storage location of the document file.
	FilePath string
	// Original file name.
	FileName string
	// File size in bytes.
	FileSize pgtype.Int4
	// MIME type of the file.
	MimeType pgtype.Text
	// User who uploaded this document.
	UploadedByUserID pgtype.Text
	// Timestamp when the document was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the document was last updated.
	UpdatedAt pgtype.Timestamp
}

// Bills sent to clients for services rendered or goods provided.
type BillingInvoice struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the client being billed.
	ClientID pgtype.UUID
	// Reference to the original quote (if applicable).
	QuoteID pgtype.UUID
	// Unique invoice reference number.
	InvoiceNumber string
	// Current invoice status using invoice_status_enum.
	Status NullBillingInvoiceStatusEnum
	// Date the invoice was created.
	IssueDate pgtype.Date
	// Payment due date.
	DueDate pgtype.Date
	// Total amount due on the invoice.
	TotalAmount pgtype.Numeric
	// Amount already paid against the invoice.
	AmountPaid pgtype.Numeric
	// Outstanding amount (automatically calculated).
	AmountOutstanding pgtype.Numeric
	// Currency code for the invoice.
	Currency pgtype.Text
	// Total tax amount on the invoice.
	TaxAmount pgtype.Numeric
	// Total discount applied to the invoice.
	DiscountAmount pgtype.Numeric
	// Subtotal before tax and discounts.
	Subtotal pgtype.Numeric
	// Payment terms and conditions.
	PaymentTerms pgtype.Text
	// Additional notes on the invoice.
	Notes pgtype.Text
	// When the invoice was sent to the client.
	SentAt pgtype.Timestamp
	// When the invoice was fully paid.
	PaidAt pgtype.Timestamp
	// User who created this invoice.
	CreatedByUserID pgtype.Text
	// Timestamp when the invoice was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the invoice was last updated.
	UpdatedAt pgtype.Timestamp
}

// Individual charges and services detailed on an invoice.
type BillingInvoiceLineItem struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the parent invoice.
	InvoiceID pgtype.UUID
	// Reference to the source of the charge (e.g., shipment_id).
	SourceRecordID pgtype.UUID
	// Type of source record.
	SourceRecordType pgtype.Text
	// Description of the service or charge.
	Description string
	// Number of units being charged.
	Quantity pgtype.Numeric
	// Price per unit.
	UnitPrice pgtype.Numeric
	// Total amount for this line item (automatically calculated).
	TotalPrice pgtype.Numeric
	// Tax rate applied to this line item.
	TaxRate pgtype.Numeric
	// Tax amount for this line item (automatically calculated).
	TaxAmount pgtype.Numeric
	// Discount rate applied to this line item.
	DiscountRate pgtype.Numeric
	// Discount amount for this line item (automatically calculated).
	DiscountAmount pgtype.Numeric
	// Final total including tax and discounts (automatically calculated).
	LineTotal pgtype.Numeric
	// Timestamp when the line item was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the line item was last updated.
	UpdatedAt pgtype.Timestamp
}

type BillingInvoiceLineItemsView struct {
	ID               pgtype.UUID
	InvoiceID        pgtype.UUID
	SourceRecordID   pgtype.UUID
	SourceRecordType pgtype.Text
	Description      string
	Quantity         pgtype.Numeric
	UnitPrice        pgtype.Numeric
	TotalPrice       pgtype.Numeric
	TaxRate          pgtype.Numeric
	TaxAmount        pgtype.Numeric
	DiscountRate     pgtype.Numeric
	DiscountAmount   pgtype.Numeric
	LineTotal        pgtype.Numeric
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	Disputes         []byte
}

type BillingInvoicesView struct {
	ID                pgtype.UUID
	ClientID          pgtype.UUID
	QuoteID           pgtype.UUID
	InvoiceNumber     string
	Status            NullBillingInvoiceStatusEnum
	IssueDate         pgtype.Date
	DueDate           pgtype.Date
	TotalAmount       pgtype.Numeric
	AmountPaid        pgtype.Numeric
	AmountOutstanding pgtype.Numeric
	Currency          pgtype.Text
	TaxAmount         pgtype.Numeric
	DiscountAmount    pgtype.Numeric
	Subtotal          pgtype.Numeric
	PaymentTerms      pgtype.Text
	Notes             pgtype.Text
	SentAt            pgtype.Timestamp
	PaidAt            pgtype.Timestamp
	CreatedByUserID   pgtype.Text
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
	InvoiceLineItems  []byte
	Payments          []byte
	CreditNotes       []byte
}

// Records of payments received against invoices.
type BillingPayment struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the invoice being paid.
	InvoiceID pgtype.UUID
	// Payment amount.
	Amount pgtype.Numeric
	// How the payment was made using payment_method_enum.
	PaymentMethod BillingPaymentMethodEnum
	// Reference from payment gateway or internal system.
	TransactionID pgtype.Text
	// Payment gateway transaction reference.
	GatewayReference pgtype.Text
	// Payment processing status using payment_status_enum.
	Status NullBillingPaymentStatusEnum
	// When the payment was initiated.
	PaymentDate pgtype.Timestamp
	// When the payment was successfully processed.
	ProcessedAt pgtype.Timestamp
	// Currency of the payment.
	Currency pgtype.Text
	// Exchange rate used for currency conversion.
	ExchangeRate pgtype.Numeric
	// Processing fees deducted from the payment.
	Fees pgtype.Numeric
	// Net amount after fees (automatically calculated).
	NetAmount pgtype.Numeric
	// Additional notes about the payment.
	Notes pgtype.Text
	// User who processed this payment.
	ProcessedByUserID pgtype.Text
	// Timestamp when the payment was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the payment was last updated.
	UpdatedAt pgtype.Timestamp
}

// Price estimates provided to clients before services are performed.
type BillingQuote struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the client requesting the quote (optional for anonymous quotes).
	ClientID pgtype.UUID
	// Pickup location information.
	OriginDetails string
	// Delivery location information.
	DestinationDetails string
	// Package weight for pricing calculation.
	Weight pgtype.Numeric
	// Package length dimension.
	Length pgtype.Numeric
	// Package width dimension.
	Width pgtype.Numeric
	// Package height dimension.
	Height pgtype.Numeric
	// Package volume (automatically calculated from dimensions).
	Volume pgtype.Numeric
	// Calculated price for the requested service.
	QuotedPrice pgtype.Numeric
	// Type of service quoted (e.g., standard, express).
	ServiceLevel pgtype.Text
	// When the quote becomes invalid.
	ExpiresAt pgtype.Timestamp
	// Current quote status using quote_status_enum.
	Status NullBillingQuoteStatusEnum
	// Unique quote reference number.
	QuoteNumber pgtype.Text
	// Additional notes about the quote.
	Notes pgtype.Text
	// User who created this quote.
	CreatedByUserID pgtype.Text
	// Timestamp when the quote was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the quote was last updated.
	UpdatedAt pgtype.Timestamp
}

type BillingQuotesView struct {
	ID                 pgtype.UUID
	ClientID           pgtype.UUID
	OriginDetails      string
	DestinationDetails string
	Weight             pgtype.Numeric
	Length             pgtype.Numeric
	Width              pgtype.Numeric
	Height             pgtype.Numeric
	Volume             pgtype.Numeric
	QuotedPrice        pgtype.Numeric
	ServiceLevel       pgtype.Text
	ExpiresAt          pgtype.Timestamp
	Status             NullBillingQuoteStatusEnum
	QuoteNumber        pgtype.Text
	Notes              pgtype.Text
	CreatedByUserID    pgtype.Text
	CreatedAt          pgtype.Timestamp
	UpdatedAt          pgtype.Timestamp
	Invoices           []byte
}

// Defines pricing structures for different services offered by the logistics company.
type BillingRateCard struct {
	// Primary key
	ID pgtype.UUID
	// Descriptive name for the rate card (e.g., "Standard Shipping Rates 2025").
	Name string
	// Category of service being priced using service_type_enum.
	ServiceType BillingServiceTypeEnum
	// Whether this rate card is currently in use.
	IsActive pgtype.Bool
	// Date when the rate card becomes effective.
	ValidFrom pgtype.Date
	// Date when the rate card expires.
	ValidTo pgtype.Date
	// Additional details about the rate card.
	Description pgtype.Text
	// User who created this rate card.
	CreatedByUserID pgtype.Text
	// Timestamp when the rate card was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the rate card was last updated.
	UpdatedAt pgtype.Timestamp
}

type BillingRateCardsView struct {
	ID              pgtype.UUID
	Name            string
	ServiceType     BillingServiceTypeEnum
	IsActive        pgtype.Bool
	ValidFrom       pgtype.Date
	ValidTo         pgtype.Date
	Description     pgtype.Text
	CreatedByUserID pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	RateRules       []byte
}

// Specific pricing rules within a rate card that determine costs based on various conditions.
type BillingRateRule struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the parent rate card.
	RateCardID pgtype.UUID
	// Condition that must be met for this rule to apply (e.g., weight_gt, zone_eq).
	Condition string
	// Value for the condition (e.g., "5kg", "Zone A").
	Value string
	// Price amount when this rule applies.
	Price pgtype.Numeric
	// How the price is calculated using pricing_model_enum.
	PricingModel BillingPricingModelEnum
	// Minimum value for range-based conditions.
	MinValue pgtype.Numeric
	// Maximum value for range-based conditions.
	MaxValue pgtype.Numeric
	// Rule precedence when multiple rules could apply (lower = higher priority).
	Priority pgtype.Int4
	// Whether this rule is currently active.
	IsActive pgtype.Bool
	// Timestamp when the rate rule was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the rate rule was last updated.
	UpdatedAt pgtype.Timestamp
}

// Additional charges that can be applied to base pricing for special circumstances.
type BillingSurcharge struct {
	// Primary key
	ID pgtype.UUID
	// Name of the surcharge (e.g., "Fuel Surcharge", "Peak Season Fee").
	Name string
	// Category of surcharge (e.g., fuel, seasonal, handling).
	Type string
	// Surcharge amount or percentage.
	Amount pgtype.Numeric
	// How the surcharge is calculated using surcharge_calculation_method_enum.
	CalculationMethod BillingSurchargeCalculationMethodEnum
	// Whether this surcharge is currently being applied.
	IsActive pgtype.Bool
	// Date when the surcharge becomes effective.
	ValidFrom pgtype.Date
	// Date when the surcharge expires.
	ValidTo pgtype.Date
	// Additional details about the surcharge.
	Description pgtype.Text
	// Timestamp when the surcharge was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the surcharge was last updated.
	UpdatedAt pgtype.Timestamp
}

// Allows files to be attached to various records (e.g., contacts, opportunities, cases) for additional context.
type CrmAttachment struct {
	// Primary key
	ID pgtype.UUID
	// Name of the attached file.
	FileName string
	// Storage path for the file.
	FilePath string
	// File MIME type (e.g., image/png, application/pdf).
	MimeType pgtype.Text
	// Identifier for the record the attachment is associated with.
	RecordID pgtype.UUID
	// Type of record (polymorphic).
	RecordType NullCrmRecordType
	// timestamptz when the attachment was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the attachment was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Tracks marketing initiatives to measure their effectiveness in generating leads and opportunities.
type CrmCampaign struct {
	// Primary key
	ID pgtype.UUID
	// Campaign title.
	Name string
	// Allocated budget for the campaign.
	Budget pgtype.Numeric
	// Campaign start date.
	StartDate pgtype.Date
	// Campaign end date.
	EndDate pgtype.Date
	// timestamptz when the campaign was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the campaign was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Tracks customer support issues or requests from creation to resolution.
type CrmCase struct {
	// Primary key
	ID pgtype.UUID
	// Unique number assigned to the case.
	CaseNumber string
	// Current case status.
	Status NullCrmCaseStatus
	// Level of urgency (e.g., low, medium, high).
	Priority NullCrmCasePriority
	// Type of case (e.g., question, problem).
	Type NullCrmCaseType
	// User responsible for handling the case.
	OwnerID string
	// Linked contact for context.
	ContactID pgtype.UUID
	// Detailed description of the issue.
	Description pgtype.Text
	// timestamptz when the case was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the case was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Stores information about customer organizations. This is a central entity for linking contacts, opportunities, and cases.
type CrmCompany struct {
	// Primary key
	ID pgtype.UUID
	// Company name.
	Name string
	// Street address.
	Street pgtype.Text
	// City location.
	City pgtype.Text
	// State or province.
	State pgtype.Text
	// Postal or ZIP code.
	PostalCode pgtype.Text
	// Country of operation.
	Country pgtype.Text
	// Company contact number.
	PhoneNumber pgtype.Text
	// Sector or industry type.
	Industry pgtype.Text
	// Company website URL.
	Website pgtype.Text
	// Yearly revenue figure.
	AnnualRevenue pgtype.Numeric
	// Reference to the user who owns the company record.
	OwnerID pgtype.Text
	// timestamptz when the company was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the company was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Represents individuals associated with companies, serving as the primary points of interaction.
type CrmContact struct {
	// Primary key
	ID pgtype.UUID
	// Full name of the contact.
	Name string
	// Contact's email address.
	Email string
	// Contact's telephone number.
	PhoneNumber pgtype.Text
	// Job designation or position.
	JobTitle pgtype.Text
	// Identifier linking to the associated company.
	CompanyID pgtype.UUID
	// Reference to the user responsible for the contact.
	OwnerID string
	// timestamptz when the contact was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the contact was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Logs all communications and activities with contacts, providing a complete history of customer engagement.
type CrmInteraction struct {
	// Primary key
	ID pgtype.UUID
	// Linked contact for the interaction.
	ContactID pgtype.UUID
	// User who performed the interaction.
	UserID string
	// Associated case (if applicable).
	CaseID pgtype.UUID
	// Type of interaction (e.g., call, meeting, email).
	Type NullCrmInteractionType
	// Result of the interaction (e.g., meeting scheduled).
	Outcome pgtype.Text
	// Additional details or comments.
	Notes pgtype.Text
	// Date and time of the interaction.
	InteractionDate pgtype.Timestamptz
	// timestamptz when the interaction was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the interaction was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Generates and tracks billing records for products or services sold in an opportunity.
type CrmInvoice struct {
	// Primary key
	ID pgtype.UUID
	// Associated sales opportunity.
	OpportunityID pgtype.UUID
	// Current status of the invoice (e.g., draft, sent, paid).
	Status NullCrmInvoiceStatus
	// Total amount billed.
	Total pgtype.Numeric
	// Date on which the invoice was issued.
	IssueDate pgtype.Date
	// Payment due date.
	DueDate pgtype.Date
	// timestamptz when the invoice was sent.
	SentAt pgtype.Timestamptz
	// timestamptz when payment was received.
	PaidAt pgtype.Timestamptz
	// Method used for payment.
	PaymentMethod NullCrmPaymentMethod
	// timestamptz when the invoice was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the invoice was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Details the line items on an invoice, including products, quantities, and prices.
type CrmInvoiceItem struct {
	// Primary key
	ID pgtype.UUID
	// Linked invoice record.
	InvoiceID pgtype.UUID
	// Associated product for the line item.
	ProductID pgtype.UUID
	// Quantity of the product.
	Quantity int32
	// Price per unit for the product.
	Price pgtype.Numeric
	// timestamptz when the invoice item was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the invoice item was last updated.
	UpdatedAt pgtype.Timestamptz
}

type CrmInvoicesView struct {
	ID            pgtype.UUID
	OpportunityID pgtype.UUID
	Status        NullCrmInvoiceStatus
	Total         pgtype.Numeric
	IssueDate     pgtype.Date
	DueDate       pgtype.Date
	SentAt        pgtype.Timestamptz
	PaidAt        pgtype.Timestamptz
	PaymentMethod NullCrmPaymentMethod
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Items         []byte
}

// Captures potential customers who have shown interest but are not yet qualified.
type CrmLead struct {
	// Primary key
	ID pgtype.UUID
	// Lead's full name.
	Name string
	// Lead's email address.
	Email string
	// Origin of the lead information.
	LeadSource NullCrmLeadSource
	// Current qualification status.
	Status NullCrmLeadStatus
	// Numerical score reflecting lead quality.
	LeadScore pgtype.Int4
	// User responsible for the lead.
	OwnerID string
	// Associated marketing campaign.
	CampaignID pgtype.UUID
	// timestamptz when the lead was converted.
	ConvertedAt pgtype.Timestamptz
	// Reference to the created contact upon conversion.
	ConvertedContactID pgtype.UUID
	// Reference to the company record created upon conversion.
	ConvertedCompanyID pgtype.UUID
	// Reference to the opportunity created upon conversion.
	ConvertedOpportunityID pgtype.UUID
	// timestamptz when the lead was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the lead was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Provides an in-app system for alerting users about important events, such as new lead assignments.
type CrmNotification struct {
	// Primary key
	ID pgtype.UUID
	// User receiving the notification.
	UserID string
	// Notification content.
	Message string
	// Boolean indicating if the notification has been read.
	IsRead pgtype.Bool
	// timestamptz when the notification was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the notification was last updated.
	UpdatedAt pgtype.Timestamptz
	// URL or path for further action/reference.
	Link pgtype.Text
}

type CrmOpportunitiesView struct {
	ID                pgtype.UUID
	Name              string
	Stage             NullCrmOpportunityStage
	DealValue         pgtype.Numeric
	Probability       pgtype.Float4
	ExpectedCloseDate pgtype.Date
	LostReason        pgtype.Text
	Source            NullCrmOpportunitySource
	OwnerID           string
	ContactID         pgtype.UUID
	CompanyID         pgtype.UUID
	CampaignID        pgtype.UUID
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	Products          []byte
}

// Represents potential sales deals, tracked through various stages of the sales pipeline.
type CrmOpportunity struct {
	// Primary key
	ID pgtype.UUID
	// Opportunity title.
	Name string
	// Current stage in the sales pipeline.
	Stage NullCrmOpportunityStage
	// Potential deal amount.
	DealValue pgtype.Numeric
	// Likelihood of closing, represented as a fraction or percentage.
	Probability pgtype.Float4
	// Anticipated date for closing the opportunity.
	ExpectedCloseDate pgtype.Date
	// Explanation for why the opportunity was lost.
	LostReason pgtype.Text
	// Origin of the opportunity (e.g., website, referral).
	Source NullCrmOpportunitySource
	// User responsible for the opportunity.
	OwnerID string
	// Associated contact.
	ContactID pgtype.UUID
	// Linked company record.
	CompanyID pgtype.UUID
	// Related campaign.
	CampaignID pgtype.UUID
	// timestamptz when the opportunity was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the opportunity was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Links products from the catalog to specific sales opportunities, detailing what is being sold.
type CrmOpportunityProduct struct {
	// Identifier linking to the related opportunity.
	OpportunityID pgtype.UUID
	// Identifier linking to the product.
	ProductID pgtype.UUID
	// Number of units associated with the opportunity.
	Quantity int32
	ID       pgtype.UUID
}

// Manages the catalog of goods or services that can be sold to customers.
type CrmProduct struct {
	// Primary key
	ID pgtype.UUID
	// Name of the product or service.
	Name string
	// Stock keeping unit identifier.
	Sku pgtype.Text
	// Cost of the product.
	Price pgtype.Numeric
	// Type of offering (e.g., service, good).
	Type NullCrmProductType
	// Description or details about the product.
	Description pgtype.Text
	// timestamptz when the product was created.
	CreatedAt pgtype.Timestamptz
	// timestamptz when the product was last updated.
	UpdatedAt pgtype.Timestamptz
}

// Provides customers with secure, unique links to track their deliveries in real-time.
type DmsCustomerTrackingLink struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the delivery task being tracked.
	DeliveryTaskID pgtype.UUID
	// Unique, unguessable identifier for secure access.
	TrackingToken string
	// Whether the tracking link is currently valid.
	IsActive pgtype.Bool
	// Number of times the tracking link has been accessed.
	AccessCount pgtype.Int4
	// When the tracking link was last accessed.
	LastAccessedAt pgtype.Timestamp
	// When the tracking link will expire.
	ExpiresAt pgtype.Timestamp
	// Timestamp when the customer tracking link was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the customer tracking link was last updated.
	UpdatedAt pgtype.Timestamp
}

// Represents planned routes for drivers, optimized for efficiency and containing multiple delivery tasks.
type DmsDeliveryRoute struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the assigned driver from the TMS.
	DriverID pgtype.UUID
	// Scheduled date for the delivery route.
	RouteDate pgtype.Date
	// Current state of the route using delivery_route_status_enum.
	Status NullDmsDeliveryRouteStatusEnum
	// Stored route optimization data such as polylines and turn-by-turn directions.
	OptimizedRouteData pgtype.Text
	// Total distance of the route in kilometers.
	TotalDistanceKm pgtype.Float4
	// Estimated time to complete the entire route in minutes.
	EstimatedDurationMinutes pgtype.Int4
	// Actual time taken to complete the route in minutes (automatically calculated from start and completion times).
	ActualDurationMinutes pgtype.Int4
	// When the route was started.
	StartedAt pgtype.Timestamp
	// When the route was completed.
	CompletedAt pgtype.Timestamp
	// Timestamp when the delivery route was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the delivery route was last updated.
	UpdatedAt pgtype.Timestamp
}

type DmsDeliveryRoutesView struct {
	ID                       pgtype.UUID
	DriverID                 pgtype.UUID
	RouteDate                pgtype.Date
	Status                   NullDmsDeliveryRouteStatusEnum
	OptimizedRouteData       pgtype.Text
	TotalDistanceKm          pgtype.Float4
	EstimatedDurationMinutes pgtype.Int4
	ActualDurationMinutes    pgtype.Int4
	StartedAt                pgtype.Timestamp
	CompletedAt              pgtype.Timestamp
	CreatedAt                pgtype.Timestamp
	UpdatedAt                pgtype.Timestamp
	DeliveryTasks            []byte
}

// Individual delivery tasks within a route, each corresponding to a specific package that needs to be delivered.
type DmsDeliveryTask struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the package from the WMS.
	PackageID pgtype.UUID
	// Reference to the delivery route this task belongs to.
	DeliveryRouteID pgtype.UUID
	// Order of this delivery within the route.
	RouteSequence int32
	// The address where the package should be delivered.
	DeliveryAddress string
	// Name of the person receiving the package.
	RecipientName pgtype.Text
	// Phone number of the recipient.
	RecipientPhone pgtype.Text
	// Special instructions for the delivery.
	DeliveryInstructions pgtype.Text
	// Calculated time when the delivery is expected.
	EstimatedArrivalTime pgtype.Timestamp
	// When the driver actually arrived at the delivery location.
	ActualArrivalTime pgtype.Timestamp
	// When the package was successfully delivered.
	DeliveryTime pgtype.Timestamp
	// Current status of the delivery task using delivery_task_status_enum.
	Status NullDmsDeliveryTaskStatusEnum
	// Reason for delivery failure using delivery_failure_reason_enum.
	FailureReason NullDmsDeliveryFailureReasonEnum
	// Number of delivery attempts made.
	AttemptCount pgtype.Int4
	// Timestamp when the delivery task was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the delivery task was last updated.
	UpdatedAt pgtype.Timestamp
}

type DmsDeliveryTasksView struct {
	ID                    pgtype.UUID
	PackageID             pgtype.UUID
	DeliveryRouteID       pgtype.UUID
	RouteSequence         int32
	DeliveryAddress       string
	RecipientName         pgtype.Text
	RecipientPhone        pgtype.Text
	DeliveryInstructions  pgtype.Text
	EstimatedArrivalTime  pgtype.Timestamp
	ActualArrivalTime     pgtype.Timestamp
	DeliveryTime          pgtype.Timestamp
	Status                NullDmsDeliveryTaskStatusEnum
	FailureReason         NullDmsDeliveryFailureReasonEnum
	AttemptCount          pgtype.Int4
	CreatedAt             pgtype.Timestamp
	UpdatedAt             pgtype.Timestamp
	TaskEvents            []byte
	ProofOfDeliveries     []byte
	CustomerTrackingLinks []byte
}

// Real-time location tracking for drivers, enabling accurate ETAs and route monitoring.
type DmsDriverLocation struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the driver from the TMS.
	DriverID pgtype.UUID
	// Geographic latitude coordinate.
	Latitude float32
	// Geographic longitude coordinate.
	Longitude float32
	// Altitude in meters above sea level.
	Altitude pgtype.Float4
	// GPS accuracy in meters.
	Accuracy pgtype.Float4
	// Current speed in kilometers per hour.
	SpeedKmh pgtype.Float4
	// Direction of travel in degrees (0-359).
	Heading pgtype.Float4
	// When the location was recorded.
	Timestamp pgtype.Timestamp
	// Timestamp when the driver location was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the driver location was last updated.
	UpdatedAt pgtype.Timestamp
}

// Stores evidence of successful deliveries, such as signatures or photos, ensuring accountability and customer satisfaction.
type DmsProofOfDelivery struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the completed delivery task.
	DeliveryTaskID pgtype.UUID
	// Type of proof collected using proof_of_delivery_type_enum.
	Type DmsProofOfDeliveryTypeEnum
	// Storage location of the proof file (for photos).
	FilePath pgtype.Text
	// Digital signature data (for signature proofs).
	SignatureData pgtype.Text
	// Name of the person who received the package.
	RecipientName pgtype.Text
	// Code used for verification deliveries.
	VerificationCode pgtype.Text
	// Geographic latitude where proof was collected.
	Latitude pgtype.Float4
	// Geographic longitude where proof was collected.
	Longitude pgtype.Float4
	// When the proof was collected.
	Timestamp pgtype.Timestamp
	// Timestamp when the proof of delivery was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the proof of delivery was last updated.
	UpdatedAt pgtype.Timestamp
}

// Tracks status changes and events for delivery tasks, providing a detailed audit trail of the delivery process.
type DmsTaskEvent struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the associated delivery task.
	DeliveryTaskID pgtype.UUID
	// The event status being recorded using task_event_status_enum.
	Status DmsTaskEventStatusEnum
	// Additional context for the status change (e.g., "recipient not home").
	Reason pgtype.Text
	// Additional notes about the event.
	Notes pgtype.Text
	// Geographic latitude where the event occurred.
	Latitude pgtype.Float4
	// Geographic longitude where the event occurred.
	Longitude pgtype.Float4
	// When the event occurred.
	Timestamp pgtype.Timestamp
	// Timestamp when the task event was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the task event was last updated.
	UpdatedAt pgtype.Timestamp
}

type Session struct {
	ID             string
	ExpiresAt      pgtype.Timestamptz
	Token          string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	IpAddress      pgtype.Text
	UserAgent      pgtype.Text
	UserID         string
	ImpersonatedBy pgtype.Text
}

// Information about third-party transportation providers and partners.
type TmsCarrier struct {
	// Primary key
	ID pgtype.UUID
	// Carrier company name.
	Name string
	// Contact information for the carrier.
	ContactDetails pgtype.Text
	// Description of transportation services provided.
	ServicesOffered pgtype.Text
	// Timestamp when the carrier was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the carrier was last updated.
	UpdatedAt     pgtype.Timestamp
	ContactPerson pgtype.Text
	ContactEmail  pgtype.Text
	ContactPhone  pgtype.Text
}

// Pricing information for services provided by third-party carriers.
type TmsCarrierRate struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the carrier providing the service.
	CarrierID pgtype.UUID
	// Type of transportation service.
	ServiceType pgtype.Text
	// Starting location for the service.
	Origin pgtype.Text
	// Ending location for the service.
	Destination pgtype.Text
	// Cost for the service.
	Rate pgtype.Numeric
	// Pricing unit using carrier_rate_unit_enum.
	Unit NullTmsCarrierRateUnitEnum
	// Timestamp when the rate was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the rate was last updated.
	UpdatedAt pgtype.Timestamp
}

type TmsCarriersView struct {
	ID              pgtype.UUID
	Name            string
	ContactDetails  pgtype.Text
	ServicesOffered pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	ContactPerson   pgtype.Text
	ContactEmail    pgtype.Text
	ContactPhone    pgtype.Text
	CarrierRates    []byte
	ShipmentLegs    []byte
	PartnerInvoices []byte
}

// Represents drivers who operate vehicles within the transportation fleet.
type TmsDriver struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the user account in the system.
	UserID string
	// Driver's license identification number.
	LicenseNumber string
	// When the driver's license expires.
	LicenseExpiryDate pgtype.Date
	// Current availability status using driver_status_enum.
	Status NullTmsDriverStatusEnum
	// Timestamp when the driver was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the driver was last updated.
	UpdatedAt    pgtype.Timestamp
	ContactPhone pgtype.Text
}

// Tracks driver availability and planned time off for scheduling purposes.
type TmsDriverSchedule struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the associated driver.
	DriverID pgtype.UUID
	// Beginning of the schedule period.
	StartDate pgtype.Date
	// End of the schedule period.
	EndDate pgtype.Date
	// Purpose of the schedule entry using driver_schedule_reason_enum.
	Reason NullTmsDriverScheduleReasonEnum
	// Timestamp when the schedule was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the schedule was last updated.
	UpdatedAt pgtype.Timestamp
}

type TmsDriversView struct {
	ID                pgtype.UUID
	UserID            string
	LicenseNumber     string
	LicenseExpiryDate pgtype.Date
	Status            NullTmsDriverStatusEnum
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
	ContactPhone      pgtype.Text
	DriverSchedules   []byte
	Expenses          []byte
	Trips             []byte
}

// Tracks transportation-related expenses incurred during trips.
type TmsExpense struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the associated trip.
	TripID pgtype.UUID
	// Reference to the driver who logged the expense.
	DriverID pgtype.UUID
	// Category of expense using expense_type_enum.
	Type NullTmsExpenseTypeEnum
	// Financial amount of the expense.
	Amount pgtype.Numeric
	// Currency denomination using currency_enum.
	Currency NullTmsCurrencyEnum
	// Link to receipt or proof of purchase.
	ReceiptUrl pgtype.Text
	// Amount of fuel purchased (if applicable).
	FuelQuantity pgtype.Float4
	// Vehicle odometer reading at time of expense.
	OdometerReading pgtype.Int4
	// Approval status using expense_status_enum.
	Status NullTmsExpenseStatusEnum
	// Timestamp when the expense was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the expense was last updated.
	UpdatedAt   pgtype.Timestamp
	Description pgtype.Text
	ExpenseDate pgtype.Date
}

// Defines geographic boundaries for monitoring vehicle movements and triggering events.
type TmsGeofence struct {
	// Primary key
	ID pgtype.UUID
	// Descriptive name for the geofenced area.
	Name string
	// Timestamp when the geofence was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the geofence was last updated.
	UpdatedAt pgtype.Timestamp
	Longitude pgtype.Float4
	Latitude  pgtype.Float4
}

// Records when vehicles enter or exit predefined geographic areas.
type TmsGeofenceEvent struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the vehicle that triggered the event.
	VehicleID pgtype.UUID
	// Reference to the geofenced area.
	GeofenceID pgtype.UUID
	// Type of boundary event using geofence_event_type_enum.
	EventType TmsGeofenceEventTypeEnum
	// When the event occurred.
	Timestamp pgtype.Timestamp
}

type TmsGeofencesView struct {
	ID             pgtype.UUID
	Name           string
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	Longitude      pgtype.Float4
	Latitude       pgtype.Float4
	GeofenceEvents []byte
}

// Real-time location data from vehicles for tracking and monitoring purposes.
type TmsGpsPing struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the vehicle sending the location data.
	VehicleID pgtype.UUID
	// Geographic latitude coordinate.
	Latitude float32
	// Geographic longitude coordinate.
	Longitude float32
	// When the location was recorded.
	Timestamp pgtype.Timestamp
}

// Billing records from third-party carriers for transportation services.
type TmsPartnerInvoice struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the carrier sending the invoice.
	CarrierID pgtype.UUID
	// Carrier's invoice identifier.
	InvoiceNumber string
	// Date the invoice was issued.
	InvoiceDate pgtype.Date
	// Total amount billed on the invoice.
	TotalAmount pgtype.Numeric
	// Payment status using partner_invoice_status_enum.
	Status NullTmsPartnerInvoiceStatusEnum
	// Timestamp when the invoice was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the invoice was last updated.
	UpdatedAt pgtype.Timestamp
}

// Individual line items on carrier invoices, detailing specific shipment leg charges.
type TmsPartnerInvoiceItem struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the parent invoice.
	PartnerInvoiceID pgtype.UUID
	// Reference to the specific shipment leg being billed.
	ShipmentLegID pgtype.UUID
	// Amount charged for this specific shipment leg.
	Amount pgtype.Numeric
}

type TmsPartnerInvoicesView struct {
	ID                  pgtype.UUID
	CarrierID           pgtype.UUID
	InvoiceNumber       string
	InvoiceDate         pgtype.Date
	TotalAmount         pgtype.Numeric
	Status              NullTmsPartnerInvoiceStatusEnum
	CreatedAt           pgtype.Timestamp
	UpdatedAt           pgtype.Timestamp
	PartnerInvoiceItems []byte
}

// Evidence of successful deliveries or pickups at trip stops.
type TmsProofOfDelivery struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the trip stop where proof was collected.
	TripStopID pgtype.UUID
	// Type of proof collected using proof_type_enum.
	Type NullTmsProofTypeEnum
	// Storage location of the proof file.
	FilePath pgtype.Text
	// When the proof was collected.
	Timestamp pgtype.Timestamp
	// Geographic latitude where proof was collected.
	Latitude pgtype.Float4
	// Geographic longitude where proof was collected.
	Longitude pgtype.Float4
	// Timestamp when the proof was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the proof was last updated.
	UpdatedAt pgtype.Timestamp
}

// Optimized route information for trips, including navigation data.
type TmsRoute struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the associated trip.
	TripID pgtype.UUID
	// Route optimization data such as polylines and turn-by-turn directions.
	OptimizedRouteData pgtype.Text
	// Calculated total distance of the route.
	TotalDistance pgtype.Float4
	// Estimated total time for the route.
	TotalDuration pgtype.Float4
	// Timestamp when the route was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the route was last updated.
	UpdatedAt pgtype.Timestamp
}

// Represents individual segments of multi-leg shipments that may involve different carriers or internal fleet.
type TmsShipmentLeg struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the overall shipment.
	ShipmentID pgtype.UUID
	// Order of this leg within the shipment journey.
	LegSequence int32
	// Starting point of this leg.
	StartLocation pgtype.Text
	// Ending point of this leg.
	EndLocation pgtype.Text
	// Reference to third-party carrier (if external).
	CarrierID pgtype.UUID
	// Reference to internal trip (if using own fleet).
	InternalTripID pgtype.UUID
	// Current status of this shipment leg using shipment_leg_status_enum.
	Status NullTmsShipmentLegStatusEnum
	// Timestamp when the shipment leg was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the shipment leg was last updated.
	UpdatedAt pgtype.Timestamp
}

// Tracks status updates and events for individual shipment legs.
type TmsShipmentLegEvent struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the associated shipment leg.
	ShipmentLegID pgtype.UUID
	// Description of the status or event.
	StatusMessage pgtype.Text
	// Geographic location where the event occurred.
	Location pgtype.Text
	// When the event was recorded.
	EventTimestamp pgtype.Timestamp
}

type TmsShipmentLegsView struct {
	ID                pgtype.UUID
	ShipmentID        pgtype.UUID
	LegSequence       int32
	StartLocation     pgtype.Text
	EndLocation       pgtype.Text
	CarrierID         pgtype.UUID
	InternalTripID    pgtype.UUID
	Status            NullTmsShipmentLegStatusEnum
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
	ShipmentLegEvents []byte
}

// Represents planned or active transportation journeys with assigned drivers and vehicles.
type TmsTrip struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the assigned driver.
	DriverID pgtype.UUID
	// Reference to the assigned vehicle.
	VehicleID pgtype.UUID
	// Current trip status using trip_status_enum.
	Status NullTmsTripStatusEnum
	// Timestamp when the trip was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the trip was last updated.
	UpdatedAt     pgtype.Timestamp
	EndLocation   pgtype.Text
	EndTime       pgtype.Timestamptz
	StartLocation pgtype.Text
	StartTime     pgtype.Timestamptz
}

// Individual stops within a trip, typically for pickups or deliveries.
type TmsTripStop struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the parent trip.
	TripID pgtype.UUID
	// Reference to the shipment being handled at this stop.
	ShipmentID pgtype.UUID
	// Order of this stop within the trip.
	Sequence int32
	// Physical location of the stop.
	Address pgtype.Text
	// Current stop status using trip_stop_status_enum.
	Status NullTmsTripStopStatusEnum
	// Planned arrival time at the stop.
	EstimatedArrivalTime pgtype.Timestamp
	// Actual recorded arrival time.
	ActualArrivalTime pgtype.Timestamp
	// Planned departure time from the stop.
	EstimatedDepartureTime pgtype.Timestamp
	// Actual recorded departure time.
	ActualDepartureTime pgtype.Timestamp
	// Timestamp when the trip stop was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the trip stop was last updated.
	UpdatedAt pgtype.Timestamp
}

type TmsTripStopsView struct {
	ID                     pgtype.UUID
	TripID                 pgtype.UUID
	ShipmentID             pgtype.UUID
	Sequence               int32
	Address                pgtype.Text
	Status                 NullTmsTripStopStatusEnum
	EstimatedArrivalTime   pgtype.Timestamp
	ActualArrivalTime      pgtype.Timestamp
	EstimatedDepartureTime pgtype.Timestamp
	ActualDepartureTime    pgtype.Timestamp
	CreatedAt              pgtype.Timestamp
	UpdatedAt              pgtype.Timestamp
	ProofOfDeliveries      []byte
}

type TmsTripsView struct {
	ID            pgtype.UUID
	DriverID      pgtype.UUID
	VehicleID     pgtype.UUID
	Status        NullTmsTripStatusEnum
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	EndLocation   pgtype.Text
	EndTime       pgtype.Timestamptz
	StartLocation pgtype.Text
	StartTime     pgtype.Timestamptz
	TripStops     []byte
	Routes        []byte
	Expenses      []byte
}

// Manages the fleet of vehicles available for transportation operations.
type TmsVehicle struct {
	// Primary key
	ID pgtype.UUID
	// Vehicle's license plate or registration identifier.
	RegistrationNumber string
	// Vehicle make and model information.
	Model pgtype.Text
	// Maximum cargo volume the vehicle can carry.
	CapacityVolume pgtype.Float4
	// Maximum weight capacity of the vehicle.
	CapacityWeight pgtype.Float4
	// Current vehicle status using vehicle_status_enum.
	Status NullTmsVehicleStatusEnum
	// Timestamp when the vehicle was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the vehicle was last updated.
	UpdatedAt           pgtype.Timestamp
	Make                pgtype.Text
	Year                pgtype.Int4
	Vin                 pgtype.Text
	CurrentMileage      pgtype.Int4
	LastMaintenanceDate pgtype.Date
}

// Tracks maintenance activities and service history for fleet vehicles.
type TmsVehicleMaintenance struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the vehicle being serviced.
	VehicleID pgtype.UUID
	// Date when maintenance was performed.
	ServiceDate pgtype.Date
	// Type of maintenance or repair work using vehicle_service_type_enum.
	ServiceType NullTmsVehicleServiceTypeEnum
	// Financial cost of the maintenance service.
	Cost pgtype.Numeric
	// Additional details about the maintenance work.
	Notes pgtype.Text
	// Timestamp when the maintenance record was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the maintenance record was last updated.
	UpdatedAt pgtype.Timestamp
}

type TmsVehiclesView struct {
	ID                  pgtype.UUID
	RegistrationNumber  string
	Model               pgtype.Text
	CapacityVolume      pgtype.Float4
	CapacityWeight      pgtype.Float4
	Status              NullTmsVehicleStatusEnum
	CreatedAt           pgtype.Timestamp
	UpdatedAt           pgtype.Timestamp
	Make                pgtype.Text
	Year                pgtype.Int4
	Vin                 pgtype.Text
	CurrentMileage      pgtype.Int4
	LastMaintenanceDate pgtype.Date
	VehicleMaintenance  []byte
	GpsPings            []byte
	GeofenceEvents      []byte
}

type User struct {
	ID            string
	Name          string
	Email         string
	EmailVerified bool
	Image         pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Role          NullUserRole
	Banned        pgtype.Bool
	BanReason     pgtype.Text
	BanExpires    pgtype.Timestamptz
}

type Verification struct {
	ID         string
	Identifier string
	Value      string
	ExpiresAt  pgtype.Timestamptz
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
}

// Defines minimum and maximum stock levels for specific products at specific locations to trigger replenishment.
type WmsBinThreshold struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the storage location.
	LocationID pgtype.UUID
	// Reference to the product being monitored (from IMS).
	ProductID pgtype.UUID
	// Minimum stock level that triggers replenishment.
	MinQuantity int32
	// Maximum stock level for the location.
	MaxQuantity int32
	// Suggested quantity to reorder when minimum is reached.
	ReorderQuantity pgtype.Int4
	// Quantity that triggers low stock alerts.
	AlertThreshold pgtype.Int4
	// Whether this threshold monitoring is active.
	IsActive pgtype.Bool
	// Timestamp when the threshold was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the threshold was last updated.
	UpdatedAt pgtype.Timestamp
}

// Represents an expected inbound shipment from a client or supplier (also known as an Advance Shipping Notice or ASN).
type WmsInboundShipment struct {
	// Primary key
	ID pgtype.UUID
	// The client company sending the inventory.
	ClientID pgtype.UUID
	// The destination warehouse.
	WarehouseID pgtype.UUID
	// The current status of the shipment using inbound_shipment_status_enum.
	Status NullWmsInboundShipmentStatusEnum
	// The planned arrival date.
	ExpectedArrivalDate pgtype.Date
	// The date the shipment actually arrived.
	ActualArrivalDate pgtype.Date
	// Timestamp when the inbound shipment was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the inbound shipment was last updated.
	UpdatedAt pgtype.Timestamp
}

// Details the specific products and quantities expected in an inbound shipment.
type WmsInboundShipmentItem struct {
	// Primary key
	ID pgtype.UUID
	// A reference to the parent inbound shipment.
	InboundShipmentID pgtype.UUID
	// The product included in the shipment.
	ProductID pgtype.UUID
	// The quantity declared on the ASN.
	ExpectedQuantity int32
	// The actual quantity counted upon receipt.
	ReceivedQuantity pgtype.Int4
	// The difference between received and expected quantities (automatically calculated).
	DiscrepancyQuantity pgtype.Int4
	// Notes detailing any differences between expected and received quantities.
	DiscrepancyNotes pgtype.Text
	// Timestamp when the inbound shipment item was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the inbound shipment item was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsInboundShipmentsView struct {
	ID                   pgtype.UUID
	ClientID             pgtype.UUID
	WarehouseID          pgtype.UUID
	Status               NullWmsInboundShipmentStatusEnum
	ExpectedArrivalDate  pgtype.Date
	ActualArrivalDate    pgtype.Date
	CreatedAt            pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
	InboundShipmentItems []byte
}

// Logs any manual changes made to inventory levels to maintain accuracy.
type WmsInventoryAdjustment struct {
	// Primary key
	ID pgtype.UUID
	// The product being adjusted.
	ProductID pgtype.UUID
	// The warehouse where the adjustment occurred.
	WarehouseID pgtype.UUID
	// The user who performed the adjustment.
	UserID string
	// The amount by which the quantity was changed (can be positive or negative).
	QuantityChange int32
	// The reason for the adjustment using inventory_adjustment_reason_enum.
	Reason NullWmsInventoryAdjustmentReasonEnum
	// Additional details about the adjustment.
	Notes pgtype.Text
	// Timestamp when the adjustment was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the adjustment was last updated.
	UpdatedAt pgtype.Timestamp
}

// Stores information for products that are tracked by batch or lot, essential for quality control and recalls.
type WmsInventoryBatch struct {
	// Primary key
	ID pgtype.UUID
	// The product associated with this batch.
	ProductID pgtype.UUID
	// The unique identifier for the batch/lot.
	BatchNumber string
	// The expiration date of the products in this batch.
	ExpirationDate pgtype.Date
	// Timestamp when the batch was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the batch was last updated.
	UpdatedAt pgtype.Timestamp
}

// Tracks actual physical inventory quantities at specific warehouse locations.
type WmsInventoryStock struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the physical location where stock is stored.
	LocationID pgtype.UUID
	// Reference to the product being stored (from IMS).
	ProductID pgtype.UUID
	// Reference to the inventory batch (if applicable for lot tracking).
	BatchID pgtype.UUID
	// Current total quantity of product at this location.
	Quantity int32
	// Quantity reserved for pending orders or tasks.
	ReservedQuantity int32
	// Available quantity (quantity - reserved_quantity, automatically calculated).
	AvailableQuantity pgtype.Int4
	// Current state of the inventory using inventory_stock_status_enum.
	Status NullWmsInventoryStockStatusEnum
	// When this inventory was last physically counted.
	LastCountedAt pgtype.Timestamp
	// When inventory was last moved in/out of this location.
	LastMovementAt pgtype.Timestamp
	// Timestamp when the inventory record was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the inventory record was last updated.
	UpdatedAt pgtype.Timestamp
}

// Represents physical storage locations within the warehouse, organized in a hierarchical structure.
type WmsLocation struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the warehouse facility.
	WarehouseID pgtype.UUID
	// Reference to parent location for hierarchical organization (e.g., zone > aisle > shelf > bin).
	ParentLocationID pgtype.UUID
	// Human-readable location identifier (e.g., A-01-B-101).
	Name string
	// Machine-readable location identifier for scanning operations.
	Barcode pgtype.Text
	// Classification of location purpose using location_type_enum.
	Type WmsLocationTypeEnum
	// The hierarchy level (0=zone, 1=aisle, 2=shelf, 3=bin, etc.).
	Level pgtype.Int4
	// Full hierarchical path for quick lookups (e.g., "Zone A/Aisle 01/Shelf B/Bin 101").
	Path pgtype.Text
	// Maximum weight capacity for the location.
	MaxWeight pgtype.Float4
	// Maximum volume capacity for the location.
	MaxVolume pgtype.Float4
	// Maximum number of pallets the location can hold.
	MaxPallets pgtype.Int4
	// X coordinate for warehouse mapping and optimization.
	XCoordinate pgtype.Float4
	// Y coordinate for warehouse mapping and optimization.
	YCoordinate pgtype.Float4
	// Z coordinate for warehouse mapping and optimization.
	ZCoordinate pgtype.Float4
	// Whether items can be picked from this location.
	IsPickable pgtype.Bool
	// Whether items can be received into this location.
	IsReceivable pgtype.Bool
	// Whether this location has temperature control.
	TemperatureControlled pgtype.Bool
	// Whether this location is approved for hazardous materials.
	HazmatApproved pgtype.Bool
	// Whether the location is currently active and available for use.
	IsActive pgtype.Bool
	// Timestamp when the location was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the location was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsLocationsView struct {
	ID                    pgtype.UUID
	WarehouseID           pgtype.UUID
	ParentLocationID      pgtype.UUID
	Name                  string
	Barcode               pgtype.Text
	Type                  WmsLocationTypeEnum
	Level                 pgtype.Int4
	Path                  pgtype.Text
	MaxWeight             pgtype.Float4
	MaxVolume             pgtype.Float4
	MaxPallets            pgtype.Int4
	XCoordinate           pgtype.Float4
	YCoordinate           pgtype.Float4
	ZCoordinate           pgtype.Float4
	IsPickable            pgtype.Bool
	IsReceivable          pgtype.Bool
	TemperatureControlled pgtype.Bool
	HazmatApproved        pgtype.Bool
	IsActive              pgtype.Bool
	CreatedAt             pgtype.Timestamp
	UpdatedAt             pgtype.Timestamp
	InventoryStock        []byte
	PutawayRules          []byte
	BinThresholds         []byte
}

// Represents the physical shipment created to fulfill a sales order.
type WmsOutboundShipment struct {
	// Primary key
	ID pgtype.UUID
	// The sales order being fulfilled.
	SalesOrderID pgtype.UUID
	// The warehouse the shipment is being sent from.
	WarehouseID pgtype.UUID
	// The status of the outbound shipment using outbound_shipment_status_enum.
	Status NullWmsOutboundShipmentStatusEnum
	// The carrier tracking number for the shipment.
	TrackingNumber pgtype.Text
	// The shipping carrier (e.g., FedEx, UPS).
	Carrier pgtype.Text
	// Timestamp when the outbound shipment was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the outbound shipment was last updated.
	UpdatedAt pgtype.Timestamp
}

// Details the specific items, quantities, and batches included in an outbound shipment.
type WmsOutboundShipmentItem struct {
	// Primary key
	ID pgtype.UUID
	// A reference to the parent outbound shipment.
	OutboundShipmentID pgtype.UUID
	// A link to the specific line item on the sales order.
	SalesOrderItemID pgtype.UUID
	// The product being shipped.
	ProductID pgtype.UUID
	// The specific batch the item was picked from (if applicable).
	BatchID pgtype.UUID
	// The quantity of the product included in this shipment.
	QuantityShipped int32
	// Timestamp when the outbound shipment item was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the outbound shipment item was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsOutboundShipmentsView struct {
	ID                    pgtype.UUID
	SalesOrderID          pgtype.UUID
	WarehouseID           pgtype.UUID
	Status                NullWmsOutboundShipmentStatusEnum
	TrackingNumber        pgtype.Text
	Carrier               pgtype.Text
	CreatedAt             pgtype.Timestamp
	UpdatedAt             pgtype.Timestamp
	OutboundShipmentItems []byte
}

// Represents physical packages created during the packing process for sales orders.
type WmsPackage struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the sales order being packaged (from IMS).
	SalesOrderID pgtype.UUID
	// Unique identifier for tracking the package.
	PackageNumber string
	// Reference to the warehouse where the package was created.
	WarehouseID pgtype.UUID
	// Type of package (e.g., "box", "envelope", "pallet").
	PackageType pgtype.Text
	// Total weight of the packed package.
	Weight pgtype.Float4
	// Package length dimension.
	Length pgtype.Float4
	// Package width dimension.
	Width pgtype.Float4
	// Package height dimension.
	Height pgtype.Float4
	// Package volume (automatically calculated from length * width * height).
	Volume pgtype.Float4
	// Carrier tracking number for the package.
	TrackingNumber pgtype.Text
	// Shipping carrier (e.g., "FedEx", "UPS", "DHL").
	Carrier pgtype.Text
	// Shipping service level (e.g., "Ground", "Express", "Overnight").
	ServiceLevel pgtype.Text
	// Reference to the user who packed the package.
	PackedByUserID pgtype.Text
	// When the package was packed.
	PackedAt pgtype.Timestamp
	// When the package was shipped.
	ShippedAt pgtype.Timestamp
	// Whether the package contains fragile items.
	IsFragile pgtype.Bool
	// Whether the package contains hazardous materials.
	IsHazmat pgtype.Bool
	// Whether delivery requires signature.
	RequiresSignature pgtype.Bool
	// Declared insurance value for the package.
	InsuranceValue pgtype.Numeric
	// Timestamp when the package was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the package was last updated.
	UpdatedAt pgtype.Timestamp
}

// Details the contents of each package, specifying which products and quantities are included.
type WmsPackageItem struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the package container.
	PackageID pgtype.UUID
	// Reference to the product included in the package (from IMS).
	ProductID pgtype.UUID
	// Reference to the batch of the product (from IMS).
	BatchID pgtype.UUID
	// Number of units of the product in the package.
	Quantity int32
	// Lot number for traceability.
	LotNumber pgtype.Text
	// Array of serial numbers for serialized items.
	SerialNumbers []string
	// Expiry date of the packaged items.
	ExpiryDate pgtype.Date
	// Weight per unit of the product.
	UnitWeight pgtype.Float4
	// Total weight of this line item (automatically calculated from quantity * unit_weight).
	TotalWeight pgtype.Float4
	// Timestamp when the package item was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the package item was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsPackagesView struct {
	ID                pgtype.UUID
	SalesOrderID      pgtype.UUID
	PackageNumber     string
	WarehouseID       pgtype.UUID
	PackageType       pgtype.Text
	Weight            pgtype.Float4
	Length            pgtype.Float4
	Width             pgtype.Float4
	Height            pgtype.Float4
	Volume            pgtype.Float4
	TrackingNumber    pgtype.Text
	Carrier           pgtype.Text
	ServiceLevel      pgtype.Text
	PackedByUserID    pgtype.Text
	PackedAt          pgtype.Timestamp
	ShippedAt         pgtype.Timestamp
	IsFragile         pgtype.Bool
	IsHazmat          pgtype.Bool
	RequiresSignature pgtype.Bool
	InsuranceValue    pgtype.Numeric
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
	PackageItems      []byte
}

// Groups multiple sales orders together for efficient batch picking operations.
type WmsPickBatch struct {
	// Primary key
	ID pgtype.UUID
	// Unique identifier for the pick batch.
	BatchNumber string
	// Reference to the warehouse where picking occurs.
	WarehouseID pgtype.UUID
	// Current batch status using pick_batch_status_enum.
	Status NullWmsPickBatchStatusEnum
	// Picking strategy employed using pick_strategy_enum.
	Strategy WmsPickStrategyEnum
	// Batch priority for execution order (lower = higher priority).
	Priority pgtype.Int4
	// Reference to the user assigned to this pick batch.
	AssignedUserID pgtype.Text
	// Wave identifier for grouping batches.
	WaveID pgtype.Text
	// Array of zone restrictions for this batch.
	ZoneRestrictions []string
	// Estimated time to complete the batch (in minutes).
	EstimatedDuration pgtype.Int4
	// Actual time taken to complete the batch (in minutes).
	ActualDuration pgtype.Int4
	// Total number of items in the batch.
	TotalItems pgtype.Int4
	// Number of completed items in the batch.
	CompletedItems pgtype.Int4
	// When the batch picking was started.
	StartedAt pgtype.Timestamp
	// When the batch picking was completed.
	CompletedAt pgtype.Timestamp
	// Timestamp when the batch was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the batch was last updated.
	UpdatedAt pgtype.Timestamp
}

// Associates individual sales orders with pick batches for grouped picking.
type WmsPickBatchItem struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the pick batch.
	PickBatchID pgtype.UUID
	// Reference to the sales order included in the batch (from IMS).
	SalesOrderID pgtype.UUID
	// Priority of this order within the batch.
	OrderPriority pgtype.Int4
	// Estimated time to pick this order (in minutes).
	EstimatedPickTime pgtype.Int4
	// Actual time taken to pick this order (in minutes).
	ActualPickTime pgtype.Int4
	// Timestamp when the batch item was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the batch item was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsPickBatchesView struct {
	ID                pgtype.UUID
	BatchNumber       string
	WarehouseID       pgtype.UUID
	Status            NullWmsPickBatchStatusEnum
	Strategy          WmsPickStrategyEnum
	Priority          pgtype.Int4
	AssignedUserID    pgtype.Text
	WaveID            pgtype.Text
	ZoneRestrictions  []string
	EstimatedDuration pgtype.Int4
	ActualDuration    pgtype.Int4
	TotalItems        pgtype.Int4
	CompletedItems    pgtype.Int4
	StartedAt         pgtype.Timestamp
	CompletedAt       pgtype.Timestamp
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
	PickBatchItems    []byte
}

// Represents the master record for each unique product (SKU) managed in the inventory.
type WmsProduct struct {
	// Primary key
	ID pgtype.UUID
	// The common name of the product.
	Name string
	// The unique Stock Keeping Unit identifier.
	Sku string
	// The product's barcode (e.g., UPC, EAN) for scanning.
	Barcode pgtype.Text
	// Detailed information about the product.
	Description pgtype.Text
	// The purchase price or cost of the product.
	CostPrice pgtype.Numeric
	// Physical length dimension.
	Length pgtype.Float4
	// Physical width dimension.
	Width pgtype.Float4
	// Physical height dimension.
	Height pgtype.Float4
	// Product volume (automatically calculated from length * width * height).
	Volume pgtype.Float4
	// Physical weight.
	Weight pgtype.Float4
	// The product's lifecycle status using product_status_enum.
	Status NullWmsProductStatusEnum
	// A reference to the product's supplier.
	SupplierID pgtype.UUID
	// A reference to the client company (from CRM) that owns this inventory.
	ClientID pgtype.UUID
	// Timestamp when the product was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the product was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsProductsView struct {
	ID                    pgtype.UUID
	Name                  string
	Sku                   string
	Barcode               pgtype.Text
	Description           pgtype.Text
	CostPrice             pgtype.Numeric
	Length                pgtype.Float4
	Width                 pgtype.Float4
	Height                pgtype.Float4
	Volume                pgtype.Float4
	Weight                pgtype.Float4
	Status                NullWmsProductStatusEnum
	SupplierID            pgtype.UUID
	ClientID              pgtype.UUID
	CreatedAt             pgtype.Timestamp
	UpdatedAt             pgtype.Timestamp
	InventoryBatches      []byte
	InventoryAdjustments  []byte
	ReorderPoints         []byte
	InboundShipmentItems  []byte
	StockTransfers        []byte
	SalesOrderItems       []byte
	OutboundShipmentItems []byte
	ReturnItems           []byte
	InventoryStock        []byte
	PutawayRules          []byte
	BinThresholds         []byte
	TaskItems             []byte
	PackageItems          []byte
}

// Defines automated rules for determining where incoming inventory should be stored.
type WmsPutawayRule struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the product the rule applies to (from IMS).
	ProductID pgtype.UUID
	// Reference to the client (for multi-tenant warehouses).
	ClientID pgtype.UUID
	// Reference to the warehouse this rule applies to.
	WarehouseID pgtype.UUID
	// Reference to the preferred storage location.
	PreferredLocationID pgtype.UUID
	// Preferred location type for this product.
	LocationType NullWmsLocationTypeEnum
	// Rule precedence when multiple rules could apply (lower = higher priority).
	Priority int32
	// Minimum quantity threshold for this rule to apply.
	MinQuantity pgtype.Int4
	// Maximum quantity threshold for this rule to apply.
	MaxQuantity pgtype.Int4
	// Weight threshold for this rule to apply.
	WeightThreshold pgtype.Float4
	// Volume threshold for this rule to apply.
	VolumeThreshold pgtype.Float4
	// Whether this rule requires temperature controlled locations.
	RequiresTemperatureControl pgtype.Bool
	// Whether this rule requires hazmat approved locations.
	RequiresHazmatApproval pgtype.Bool
	// Whether this rule is currently active.
	IsActive pgtype.Bool
	// Timestamp when the rule was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the rule was last updated.
	UpdatedAt pgtype.Timestamp
}

// Defines the minimum stock level for a product that triggers a low stock alert.
type WmsReorderPoint struct {
	// Primary key
	ID pgtype.UUID
	// The product to monitor.
	ProductID pgtype.UUID
	// The specific warehouse to monitor the stock level in.
	WarehouseID pgtype.UUID
	// The minimum quantity that triggers the alert.
	Threshold int32
	// Timestamp when the reorder point was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the reorder point was last updated.
	UpdatedAt pgtype.Timestamp
}

// Represents a return request from a client (Reverse Logistics).
type WmsReturn struct {
	// Primary key
	ID pgtype.UUID
	// A unique identifier for the return.
	ReturnNumber string
	// A reference to the original sales order being returned.
	SalesOrderID pgtype.UUID
	// The client initiating the return.
	ClientID pgtype.UUID
	// The status of the return using return_status_enum.
	Status NullWmsReturnStatusEnum
	// The reason for the return.
	Reason pgtype.Text
	// Timestamp when the return was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the return was last updated.
	UpdatedAt pgtype.Timestamp
}

// Details the specific products and quantities being returned.
type WmsReturnItem struct {
	// Primary key
	ID pgtype.UUID
	// A reference to the parent return record.
	ReturnID pgtype.UUID
	// The product being returned.
	ProductID pgtype.UUID
	// The quantity the client stated they would return.
	QuantityExpected int32
	// The actual quantity received at the warehouse.
	QuantityReceived pgtype.Int4
	// The difference between received and expected return quantities (automatically calculated).
	QuantityVariance pgtype.Int4
	// The condition of the returned item using return_item_condition_enum.
	Condition NullWmsReturnItemConditionEnum
	// Timestamp when the return item was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the return item was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsReturnsView struct {
	ID           pgtype.UUID
	ReturnNumber string
	SalesOrderID pgtype.UUID
	ClientID     pgtype.UUID
	Status       NullWmsReturnStatusEnum
	Reason       pgtype.Text
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
	ReturnItems  []byte
}

// Represents a customer's order, often originating from the CRM, which needs to be fulfilled from inventory.
type WmsSalesOrder struct {
	// Primary key
	ID pgtype.UUID
	// A unique identifier for the sales order.
	OrderNumber string
	// The client company that placed the order.
	ClientID pgtype.UUID
	// A link back to the original opportunity in the CRM.
	CrmOpportunityID pgtype.UUID
	// The fulfillment status of the order using sales_order_status_enum.
	Status NullWmsSalesOrderStatusEnum
	// The address where the order should be shipped.
	ShippingAddress pgtype.Text
	// Timestamp when the sales order was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the sales order was last updated.
	UpdatedAt pgtype.Timestamp
}

// Details the specific products and quantities required for a sales order.
type WmsSalesOrderItem struct {
	// Primary key
	ID pgtype.UUID
	// A reference to the parent sales order.
	SalesOrderID pgtype.UUID
	// The product being ordered.
	ProductID pgtype.UUID
	// The quantity of the product requested by the customer.
	QuantityOrdered int32
	// Timestamp when the sales order item was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the sales order item was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsSalesOrdersView struct {
	ID               pgtype.UUID
	OrderNumber      string
	ClientID         pgtype.UUID
	CrmOpportunityID pgtype.UUID
	Status           NullWmsSalesOrderStatusEnum
	ShippingAddress  pgtype.Text
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	SalesOrderItems  []byte
}

// Tracks the movement of inventory from one warehouse to another.
type WmsStockTransfer struct {
	// Primary key
	ID pgtype.UUID
	// The product being transferred.
	ProductID pgtype.UUID
	// The warehouse the stock is moving from.
	SourceWarehouseID pgtype.UUID
	// The warehouse the stock is moving to.
	DestinationWarehouseID pgtype.UUID
	// The amount of stock being transferred.
	Quantity int32
	// The status of the transfer using stock_transfer_status_enum.
	Status NullWmsStockTransferStatusEnum
	// Timestamp when the stock transfer was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the stock transfer was last updated.
	UpdatedAt pgtype.Timestamp
}

// Stores information about the suppliers who provide the products.
type WmsSupplier struct {
	// Primary key
	ID pgtype.UUID
	// The name of the supplier company.
	Name string
	// The primary contact at the supplier.
	ContactPerson pgtype.Text
	// The supplier's contact email.
	Email pgtype.Text
	// The supplier's contact phone number.
	PhoneNumber pgtype.Text
	// Timestamp when the supplier was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the supplier was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsSuppliersView struct {
	ID            pgtype.UUID
	Name          string
	ContactPerson pgtype.Text
	Email         pgtype.Text
	PhoneNumber   pgtype.Text
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	Products      []byte
}

// Represents individual work assignments for warehouse personnel.
type WmsTask struct {
	// Primary key
	ID pgtype.UUID
	// Unique identifier for the task.
	TaskNumber string
	// Reference to the warehouse where the task is performed.
	WarehouseID pgtype.UUID
	// Reference to the assigned warehouse worker.
	UserID pgtype.Text
	// Category of warehouse task using task_type_enum.
	Type WmsTaskTypeEnum
	// Current task status using task_status_enum.
	Status NullWmsTaskStatusEnum
	// Task priority for execution order (lower = higher priority).
	Priority pgtype.Int4
	// Reference to the entity that triggered the task (e.g., inbound_shipment_id, pick_batch_id).
	SourceEntityID pgtype.UUID
	// Type of the source entity (e.g., "inbound_shipment", "pick_batch", "return").
	SourceEntityType pgtype.Text
	// Reference to associated pick batch if applicable.
	PickBatchID pgtype.UUID
	// Estimated time to complete the task (in minutes).
	EstimatedDuration pgtype.Int4
	// Actual time taken to complete the task (in minutes).
	ActualDuration pgtype.Int4
	// Detailed instructions for completing the task.
	Instructions pgtype.Text
	// Additional notes or comments about the task.
	Notes pgtype.Text
	// When the task was started.
	StartTime pgtype.Timestamp
	// When the task was completed.
	EndTime pgtype.Timestamp
	// Total time taken to complete the task in seconds (automatically calculated from start_time and end_time).
	DurationSeconds pgtype.Int4
	// Timestamp when the task was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the task was last updated.
	UpdatedAt pgtype.Timestamp
}

// Individual line items within a warehouse task, specifying exactly what needs to be moved or processed.
type WmsTaskItem struct {
	// Primary key
	ID pgtype.UUID
	// Reference to the parent task.
	TaskID pgtype.UUID
	// Reference to the product being handled (from IMS).
	ProductID pgtype.UUID
	// Reference to the specific batch being handled (from IMS).
	BatchID pgtype.UUID
	// Reference to where the product should be picked from.
	SourceLocationID pgtype.UUID
	// Reference to where the product should be moved to.
	DestinationLocationID pgtype.UUID
	// Amount of product that needs to be handled.
	QuantityRequired int32
	// Amount of product actually handled.
	QuantityCompleted int32
	// Remaining quantity to be handled (automatically calculated from quantity_required - quantity_completed).
	QuantityRemaining pgtype.Int4
	// Completion status of this specific item using task_item_status_enum.
	Status NullWmsTaskItemStatusEnum
	// Lot number for traceability.
	LotNumber pgtype.Text
	// Array of serial numbers for serialized items.
	SerialNumbers []string
	// Expiry date of the items being handled.
	ExpiryDate pgtype.Date
	// Additional notes about this task item.
	Notes pgtype.Text
	// When this task item was completed.
	CompletedAt pgtype.Timestamp
	// Timestamp when the task item was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the task item was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsTasksView struct {
	ID                pgtype.UUID
	TaskNumber        string
	WarehouseID       pgtype.UUID
	UserID            pgtype.Text
	Type              WmsTaskTypeEnum
	Status            NullWmsTaskStatusEnum
	Priority          pgtype.Int4
	SourceEntityID    pgtype.UUID
	SourceEntityType  pgtype.Text
	PickBatchID       pgtype.UUID
	EstimatedDuration pgtype.Int4
	ActualDuration    pgtype.Int4
	Instructions      pgtype.Text
	Notes             pgtype.Text
	StartTime         pgtype.Timestamp
	EndTime           pgtype.Timestamp
	DurationSeconds   pgtype.Int4
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
	TaskItems         []byte
}

// Represents the physical warehouse facilities where inventory and locations are organized and managed by the WMS.
type WmsWarehouse struct {
	// Primary key
	ID pgtype.UUID
	// The name of the warehouse (e.g., "West Coast Distribution Center").
	Name string
	// The physical street address of the warehouse.
	Address pgtype.Text
	// The city where the warehouse is located.
	City pgtype.Text
	// The state or province where the warehouse is located.
	State pgtype.Text
	// The postal code or ZIP code of the warehouse.
	PostalCode pgtype.Text
	// The country where the warehouse is located.
	Country pgtype.Text
	// The timezone of the warehouse for scheduling operations.
	Timezone pgtype.Text
	// The primary contact person at the warehouse.
	ContactPerson pgtype.Text
	// The contact email for the warehouse.
	ContactEmail pgtype.Text
	// The contact phone number for the warehouse.
	ContactPhone pgtype.Text
	// Whether the warehouse is currently active and operational.
	IsActive pgtype.Bool
	// Timestamp when the warehouse was created.
	CreatedAt pgtype.Timestamp
	// Timestamp when the warehouse was last updated.
	UpdatedAt pgtype.Timestamp
}

type WmsWarehousesView struct {
	ID                pgtype.UUID
	Name              string
	Address           pgtype.Text
	City              pgtype.Text
	State             pgtype.Text
	PostalCode        pgtype.Text
	Country           pgtype.Text
	Timezone          pgtype.Text
	ContactPerson     pgtype.Text
	ContactEmail      pgtype.Text
	ContactPhone      pgtype.Text
	IsActive          pgtype.Bool
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
	InboundShipments  []byte
	OutboundShipments []byte
	Locations         []byte
	PutawayRules      []byte
	PickBatches       []byte
	Tasks             []byte
}
