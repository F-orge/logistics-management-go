// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package models

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BillingDisputeStatusEnum string

const (
	BillingDisputeStatusEnumOpen        BillingDisputeStatusEnum = "open"
	BillingDisputeStatusEnumUnderReview BillingDisputeStatusEnum = "under-review"
	BillingDisputeStatusEnumApproved    BillingDisputeStatusEnum = "approved"
	BillingDisputeStatusEnumDenied      BillingDisputeStatusEnum = "denied"
	BillingDisputeStatusEnumEscalated   BillingDisputeStatusEnum = "escalated"
	BillingDisputeStatusEnumClosed      BillingDisputeStatusEnum = "closed"
)

func (e *BillingDisputeStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingDisputeStatusEnum(s)
	case string:
		*e = BillingDisputeStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingDisputeStatusEnum: %T", src)
	}
	return nil
}

type NullBillingDisputeStatusEnum struct {
	BillingDisputeStatusEnum BillingDisputeStatusEnum `json:"billing_dispute_status_enum"`
	Valid                    bool                     `json:"valid"` // Valid is true if BillingDisputeStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingDisputeStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingDisputeStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingDisputeStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingDisputeStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingDisputeStatusEnum), nil
}

type BillingDocumentTypeEnum string

const (
	BillingDocumentTypeEnumBol                BillingDocumentTypeEnum = "bol"
	BillingDocumentTypeEnumCommercialInvoice  BillingDocumentTypeEnum = "commercial-invoice"
	BillingDocumentTypeEnumPackingList        BillingDocumentTypeEnum = "packing-list"
	BillingDocumentTypeEnumReceipt            BillingDocumentTypeEnum = "receipt"
	BillingDocumentTypeEnumCreditNote         BillingDocumentTypeEnum = "credit-note"
	BillingDocumentTypeEnumShippingLabel      BillingDocumentTypeEnum = "shipping-label"
	BillingDocumentTypeEnumCustomsDeclaration BillingDocumentTypeEnum = "customs-declaration"
	BillingDocumentTypeEnumProofOfDelivery    BillingDocumentTypeEnum = "proof-of-delivery"
)

func (e *BillingDocumentTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingDocumentTypeEnum(s)
	case string:
		*e = BillingDocumentTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingDocumentTypeEnum: %T", src)
	}
	return nil
}

type NullBillingDocumentTypeEnum struct {
	BillingDocumentTypeEnum BillingDocumentTypeEnum `json:"billing_document_type_enum"`
	Valid                   bool                    `json:"valid"` // Valid is true if BillingDocumentTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingDocumentTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingDocumentTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingDocumentTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingDocumentTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingDocumentTypeEnum), nil
}

type BillingInvoiceStatusEnum string

const (
	BillingInvoiceStatusEnumDraft       BillingInvoiceStatusEnum = "draft"
	BillingInvoiceStatusEnumSent        BillingInvoiceStatusEnum = "sent"
	BillingInvoiceStatusEnumViewed      BillingInvoiceStatusEnum = "viewed"
	BillingInvoiceStatusEnumPaid        BillingInvoiceStatusEnum = "paid"
	BillingInvoiceStatusEnumPartialPaid BillingInvoiceStatusEnum = "partial-paid"
	BillingInvoiceStatusEnumPastDue     BillingInvoiceStatusEnum = "past-due"
	BillingInvoiceStatusEnumDisputed    BillingInvoiceStatusEnum = "disputed"
	BillingInvoiceStatusEnumCancelled   BillingInvoiceStatusEnum = "cancelled"
	BillingInvoiceStatusEnumVoid        BillingInvoiceStatusEnum = "void"
)

func (e *BillingInvoiceStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingInvoiceStatusEnum(s)
	case string:
		*e = BillingInvoiceStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingInvoiceStatusEnum: %T", src)
	}
	return nil
}

type NullBillingInvoiceStatusEnum struct {
	BillingInvoiceStatusEnum BillingInvoiceStatusEnum `json:"billing_invoice_status_enum"`
	Valid                    bool                     `json:"valid"` // Valid is true if BillingInvoiceStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingInvoiceStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingInvoiceStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingInvoiceStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingInvoiceStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingInvoiceStatusEnum), nil
}

type BillingPaymentMethodEnum string

const (
	BillingPaymentMethodEnumCreditCard   BillingPaymentMethodEnum = "credit-card"
	BillingPaymentMethodEnumDebitCard    BillingPaymentMethodEnum = "debit-card"
	BillingPaymentMethodEnumWallet       BillingPaymentMethodEnum = "wallet"
	BillingPaymentMethodEnumQrPh         BillingPaymentMethodEnum = "qr-ph"
	BillingPaymentMethodEnumClientCredit BillingPaymentMethodEnum = "client-credit"
	BillingPaymentMethodEnumBankTransfer BillingPaymentMethodEnum = "bank-transfer"
	BillingPaymentMethodEnumCash         BillingPaymentMethodEnum = "cash"
	BillingPaymentMethodEnumCheck        BillingPaymentMethodEnum = "check"
)

func (e *BillingPaymentMethodEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingPaymentMethodEnum(s)
	case string:
		*e = BillingPaymentMethodEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingPaymentMethodEnum: %T", src)
	}
	return nil
}

type NullBillingPaymentMethodEnum struct {
	BillingPaymentMethodEnum BillingPaymentMethodEnum `json:"billing_payment_method_enum"`
	Valid                    bool                     `json:"valid"` // Valid is true if BillingPaymentMethodEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingPaymentMethodEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingPaymentMethodEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingPaymentMethodEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingPaymentMethodEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingPaymentMethodEnum), nil
}

type BillingPaymentStatusEnum string

const (
	BillingPaymentStatusEnumPending    BillingPaymentStatusEnum = "pending"
	BillingPaymentStatusEnumProcessing BillingPaymentStatusEnum = "processing"
	BillingPaymentStatusEnumSuccessful BillingPaymentStatusEnum = "successful"
	BillingPaymentStatusEnumFailed     BillingPaymentStatusEnum = "failed"
	BillingPaymentStatusEnumCancelled  BillingPaymentStatusEnum = "cancelled"
	BillingPaymentStatusEnumRefunded   BillingPaymentStatusEnum = "refunded"
)

func (e *BillingPaymentStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingPaymentStatusEnum(s)
	case string:
		*e = BillingPaymentStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingPaymentStatusEnum: %T", src)
	}
	return nil
}

type NullBillingPaymentStatusEnum struct {
	BillingPaymentStatusEnum BillingPaymentStatusEnum `json:"billing_payment_status_enum"`
	Valid                    bool                     `json:"valid"` // Valid is true if BillingPaymentStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingPaymentStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingPaymentStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingPaymentStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingPaymentStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingPaymentStatusEnum), nil
}

type BillingPricingModelEnum string

const (
	BillingPricingModelEnumPerKg         BillingPricingModelEnum = "per-kg"
	BillingPricingModelEnumPerItem       BillingPricingModelEnum = "per-item"
	BillingPricingModelEnumFlatRate      BillingPricingModelEnum = "flat-rate"
	BillingPricingModelEnumPerCubicMeter BillingPricingModelEnum = "per-cubic-meter"
	BillingPricingModelEnumPerZone       BillingPricingModelEnum = "per-zone"
	BillingPricingModelEnumPercentage    BillingPricingModelEnum = "percentage"
	BillingPricingModelEnumTiered        BillingPricingModelEnum = "tiered"
)

func (e *BillingPricingModelEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingPricingModelEnum(s)
	case string:
		*e = BillingPricingModelEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingPricingModelEnum: %T", src)
	}
	return nil
}

type NullBillingPricingModelEnum struct {
	BillingPricingModelEnum BillingPricingModelEnum `json:"billing_pricing_model_enum"`
	Valid                   bool                    `json:"valid"` // Valid is true if BillingPricingModelEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingPricingModelEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingPricingModelEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingPricingModelEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingPricingModelEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingPricingModelEnum), nil
}

type BillingQuoteStatusEnum string

const (
	BillingQuoteStatusEnumPending   BillingQuoteStatusEnum = "pending"
	BillingQuoteStatusEnumAccepted  BillingQuoteStatusEnum = "accepted"
	BillingQuoteStatusEnumExpired   BillingQuoteStatusEnum = "expired"
	BillingQuoteStatusEnumCancelled BillingQuoteStatusEnum = "cancelled"
	BillingQuoteStatusEnumConverted BillingQuoteStatusEnum = "converted"
)

func (e *BillingQuoteStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingQuoteStatusEnum(s)
	case string:
		*e = BillingQuoteStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingQuoteStatusEnum: %T", src)
	}
	return nil
}

type NullBillingQuoteStatusEnum struct {
	BillingQuoteStatusEnum BillingQuoteStatusEnum `json:"billing_quote_status_enum"`
	Valid                  bool                   `json:"valid"` // Valid is true if BillingQuoteStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingQuoteStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingQuoteStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingQuoteStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingQuoteStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingQuoteStatusEnum), nil
}

type BillingServiceTypeEnum string

const (
	BillingServiceTypeEnumShipping    BillingServiceTypeEnum = "shipping"
	BillingServiceTypeEnumStorage     BillingServiceTypeEnum = "storage"
	BillingServiceTypeEnumFulfillment BillingServiceTypeEnum = "fulfillment"
	BillingServiceTypeEnumHandling    BillingServiceTypeEnum = "handling"
	BillingServiceTypeEnumInsurance   BillingServiceTypeEnum = "insurance"
	BillingServiceTypeEnumCustoms     BillingServiceTypeEnum = "customs"
	BillingServiceTypeEnumPackaging   BillingServiceTypeEnum = "packaging"
	BillingServiceTypeEnumReturns     BillingServiceTypeEnum = "returns"
)

func (e *BillingServiceTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingServiceTypeEnum(s)
	case string:
		*e = BillingServiceTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingServiceTypeEnum: %T", src)
	}
	return nil
}

type NullBillingServiceTypeEnum struct {
	BillingServiceTypeEnum BillingServiceTypeEnum `json:"billing_service_type_enum"`
	Valid                  bool                   `json:"valid"` // Valid is true if BillingServiceTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingServiceTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingServiceTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingServiceTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingServiceTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingServiceTypeEnum), nil
}

type BillingSurchargeCalculationMethodEnum string

const (
	BillingSurchargeCalculationMethodEnumPercentage   BillingSurchargeCalculationMethodEnum = "percentage"
	BillingSurchargeCalculationMethodEnumFixed        BillingSurchargeCalculationMethodEnum = "fixed"
	BillingSurchargeCalculationMethodEnumPerUnit      BillingSurchargeCalculationMethodEnum = "per-unit"
	BillingSurchargeCalculationMethodEnumSlidingScale BillingSurchargeCalculationMethodEnum = "sliding-scale"
)

func (e *BillingSurchargeCalculationMethodEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingSurchargeCalculationMethodEnum(s)
	case string:
		*e = BillingSurchargeCalculationMethodEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingSurchargeCalculationMethodEnum: %T", src)
	}
	return nil
}

type NullBillingSurchargeCalculationMethodEnum struct {
	BillingSurchargeCalculationMethodEnum BillingSurchargeCalculationMethodEnum `json:"billing_surcharge_calculation_method_enum"`
	Valid                                 bool                                  `json:"valid"` // Valid is true if BillingSurchargeCalculationMethodEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingSurchargeCalculationMethodEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingSurchargeCalculationMethodEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingSurchargeCalculationMethodEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingSurchargeCalculationMethodEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingSurchargeCalculationMethodEnum), nil
}

type BillingSyncStatusEnum string

const (
	BillingSyncStatusEnumPending    BillingSyncStatusEnum = "pending"
	BillingSyncStatusEnumInProgress BillingSyncStatusEnum = "in-progress"
	BillingSyncStatusEnumSuccess    BillingSyncStatusEnum = "success"
	BillingSyncStatusEnumFailed     BillingSyncStatusEnum = "failed"
	BillingSyncStatusEnumRetry      BillingSyncStatusEnum = "retry"
)

func (e *BillingSyncStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingSyncStatusEnum(s)
	case string:
		*e = BillingSyncStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingSyncStatusEnum: %T", src)
	}
	return nil
}

type NullBillingSyncStatusEnum struct {
	BillingSyncStatusEnum BillingSyncStatusEnum `json:"billing_sync_status_enum"`
	Valid                 bool                  `json:"valid"` // Valid is true if BillingSyncStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingSyncStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingSyncStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingSyncStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingSyncStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingSyncStatusEnum), nil
}

type BillingTransactionTypeEnum string

const (
	BillingTransactionTypeEnumCredit     BillingTransactionTypeEnum = "credit"
	BillingTransactionTypeEnumDebit      BillingTransactionTypeEnum = "debit"
	BillingTransactionTypeEnumTopUp      BillingTransactionTypeEnum = "top-up"
	BillingTransactionTypeEnumRefund     BillingTransactionTypeEnum = "refund"
	BillingTransactionTypeEnumAdjustment BillingTransactionTypeEnum = "adjustment"
	BillingTransactionTypeEnumFee        BillingTransactionTypeEnum = "fee"
)

func (e *BillingTransactionTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingTransactionTypeEnum(s)
	case string:
		*e = BillingTransactionTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingTransactionTypeEnum: %T", src)
	}
	return nil
}

type NullBillingTransactionTypeEnum struct {
	BillingTransactionTypeEnum BillingTransactionTypeEnum `json:"billing_transaction_type_enum"`
	Valid                      bool                       `json:"valid"` // Valid is true if BillingTransactionTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingTransactionTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.BillingTransactionTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingTransactionTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingTransactionTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingTransactionTypeEnum), nil
}

type CrmCasePriority string

const (
	CrmCasePriorityCritical CrmCasePriority = "critical"
	CrmCasePriorityHigh     CrmCasePriority = "high"
	CrmCasePriorityMedium   CrmCasePriority = "medium"
	CrmCasePriorityLow      CrmCasePriority = "low"
)

func (e *CrmCasePriority) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmCasePriority(s)
	case string:
		*e = CrmCasePriority(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmCasePriority: %T", src)
	}
	return nil
}

type NullCrmCasePriority struct {
	CrmCasePriority CrmCasePriority `json:"crm_case_priority"`
	Valid           bool            `json:"valid"` // Valid is true if CrmCasePriority is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmCasePriority) Scan(value interface{}) error {
	if value == nil {
		ns.CrmCasePriority, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmCasePriority.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmCasePriority) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmCasePriority), nil
}

type CrmCaseStatus string

const (
	CrmCaseStatusNew                CrmCaseStatus = "new"
	CrmCaseStatusInProgress         CrmCaseStatus = "in-progress"
	CrmCaseStatusWaitingForCustomer CrmCaseStatus = "waiting-for-customer"
	CrmCaseStatusWaitingForInternal CrmCaseStatus = "waiting-for-internal"
	CrmCaseStatusEscalated          CrmCaseStatus = "escalated"
	CrmCaseStatusResolved           CrmCaseStatus = "resolved"
	CrmCaseStatusClosed             CrmCaseStatus = "closed"
	CrmCaseStatusCancelled          CrmCaseStatus = "cancelled"
)

func (e *CrmCaseStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmCaseStatus(s)
	case string:
		*e = CrmCaseStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmCaseStatus: %T", src)
	}
	return nil
}

type NullCrmCaseStatus struct {
	CrmCaseStatus CrmCaseStatus `json:"crm_case_status"`
	Valid         bool          `json:"valid"` // Valid is true if CrmCaseStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmCaseStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CrmCaseStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmCaseStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmCaseStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmCaseStatus), nil
}

type CrmCaseType string

const (
	CrmCaseTypeQuestion         CrmCaseType = "question"
	CrmCaseTypeProblem          CrmCaseType = "problem"
	CrmCaseTypeComplaint        CrmCaseType = "complaint"
	CrmCaseTypeFeatureRequest   CrmCaseType = "feature-request"
	CrmCaseTypeBugReport        CrmCaseType = "bug-report"
	CrmCaseTypeTechnicalSupport CrmCaseType = "technical-support"
)

func (e *CrmCaseType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmCaseType(s)
	case string:
		*e = CrmCaseType(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmCaseType: %T", src)
	}
	return nil
}

type NullCrmCaseType struct {
	CrmCaseType CrmCaseType `json:"crm_case_type"`
	Valid       bool        `json:"valid"` // Valid is true if CrmCaseType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmCaseType) Scan(value interface{}) error {
	if value == nil {
		ns.CrmCaseType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmCaseType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmCaseType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmCaseType), nil
}

type CrmInteractionType string

const (
	CrmInteractionTypeCall    CrmInteractionType = "call"
	CrmInteractionTypeMeeting CrmInteractionType = "meeting"
	CrmInteractionTypeText    CrmInteractionType = "text"
	CrmInteractionTypeEmail   CrmInteractionType = "email"
)

func (e *CrmInteractionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmInteractionType(s)
	case string:
		*e = CrmInteractionType(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmInteractionType: %T", src)
	}
	return nil
}

type NullCrmInteractionType struct {
	CrmInteractionType CrmInteractionType `json:"crm_interaction_type"`
	Valid              bool               `json:"valid"` // Valid is true if CrmInteractionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmInteractionType) Scan(value interface{}) error {
	if value == nil {
		ns.CrmInteractionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmInteractionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmInteractionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmInteractionType), nil
}

type CrmInvoiceStatus string

const (
	CrmInvoiceStatusDraft     CrmInvoiceStatus = "draft"
	CrmInvoiceStatusSent      CrmInvoiceStatus = "sent"
	CrmInvoiceStatusPaid      CrmInvoiceStatus = "paid"
	CrmInvoiceStatusOverdue   CrmInvoiceStatus = "overdue"
	CrmInvoiceStatusCancelled CrmInvoiceStatus = "cancelled"
)

func (e *CrmInvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmInvoiceStatus(s)
	case string:
		*e = CrmInvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmInvoiceStatus: %T", src)
	}
	return nil
}

type NullCrmInvoiceStatus struct {
	CrmInvoiceStatus CrmInvoiceStatus `json:"crm_invoice_status"`
	Valid            bool             `json:"valid"` // Valid is true if CrmInvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CrmInvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmInvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmInvoiceStatus), nil
}

type CrmLeadSource string

const (
	CrmLeadSourceWebsite       CrmLeadSource = "website"
	CrmLeadSourceReferral      CrmLeadSource = "referral"
	CrmLeadSourceSocialMedia   CrmLeadSource = "social-media"
	CrmLeadSourceEmailCampaign CrmLeadSource = "email-campaign"
	CrmLeadSourceColdCall      CrmLeadSource = "cold-call"
	CrmLeadSourceEvent         CrmLeadSource = "event"
	CrmLeadSourceAdvertisement CrmLeadSource = "advertisement"
	CrmLeadSourcePartner       CrmLeadSource = "partner"
	CrmLeadSourceOther         CrmLeadSource = "other"
)

func (e *CrmLeadSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmLeadSource(s)
	case string:
		*e = CrmLeadSource(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmLeadSource: %T", src)
	}
	return nil
}

type NullCrmLeadSource struct {
	CrmLeadSource CrmLeadSource `json:"crm_lead_source"`
	Valid         bool          `json:"valid"` // Valid is true if CrmLeadSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmLeadSource) Scan(value interface{}) error {
	if value == nil {
		ns.CrmLeadSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmLeadSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmLeadSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmLeadSource), nil
}

type CrmLeadStatus string

const (
	CrmLeadStatusNew         CrmLeadStatus = "new"
	CrmLeadStatusContacted   CrmLeadStatus = "contacted"
	CrmLeadStatusQualified   CrmLeadStatus = "qualified"
	CrmLeadStatusUnqualified CrmLeadStatus = "unqualified"
	CrmLeadStatusConverted   CrmLeadStatus = "converted"
)

func (e *CrmLeadStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmLeadStatus(s)
	case string:
		*e = CrmLeadStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmLeadStatus: %T", src)
	}
	return nil
}

type NullCrmLeadStatus struct {
	CrmLeadStatus CrmLeadStatus `json:"crm_lead_status"`
	Valid         bool          `json:"valid"` // Valid is true if CrmLeadStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmLeadStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CrmLeadStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmLeadStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmLeadStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmLeadStatus), nil
}

type CrmOpportunitySource string

const (
	CrmOpportunitySourceWebsite          CrmOpportunitySource = "website"
	CrmOpportunitySourceReferral         CrmOpportunitySource = "referral"
	CrmOpportunitySourceSocialMedia      CrmOpportunitySource = "social-media"
	CrmOpportunitySourceEmailCampaign    CrmOpportunitySource = "email-campaign"
	CrmOpportunitySourceColdCall         CrmOpportunitySource = "cold-call"
	CrmOpportunitySourceEvent            CrmOpportunitySource = "event"
	CrmOpportunitySourceAdvertisement    CrmOpportunitySource = "advertisement"
	CrmOpportunitySourcePartner          CrmOpportunitySource = "partner"
	CrmOpportunitySourceExistingCustomer CrmOpportunitySource = "existing-customer"
	CrmOpportunitySourceOther            CrmOpportunitySource = "other"
)

func (e *CrmOpportunitySource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmOpportunitySource(s)
	case string:
		*e = CrmOpportunitySource(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmOpportunitySource: %T", src)
	}
	return nil
}

type NullCrmOpportunitySource struct {
	CrmOpportunitySource CrmOpportunitySource `json:"crm_opportunity_source"`
	Valid                bool                 `json:"valid"` // Valid is true if CrmOpportunitySource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmOpportunitySource) Scan(value interface{}) error {
	if value == nil {
		ns.CrmOpportunitySource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmOpportunitySource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmOpportunitySource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmOpportunitySource), nil
}

type CrmOpportunityStage string

const (
	CrmOpportunityStageProspecting   CrmOpportunityStage = "prospecting"
	CrmOpportunityStageQualification CrmOpportunityStage = "qualification"
	CrmOpportunityStageNeedAnalysis  CrmOpportunityStage = "need-analysis"
	CrmOpportunityStageDemo          CrmOpportunityStage = "demo"
	CrmOpportunityStageProposal      CrmOpportunityStage = "proposal"
	CrmOpportunityStageNegotiation   CrmOpportunityStage = "negotiation"
	CrmOpportunityStageClosedWon     CrmOpportunityStage = "closed-won"
	CrmOpportunityStageClosedLost    CrmOpportunityStage = "closed-lost"
)

func (e *CrmOpportunityStage) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmOpportunityStage(s)
	case string:
		*e = CrmOpportunityStage(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmOpportunityStage: %T", src)
	}
	return nil
}

type NullCrmOpportunityStage struct {
	CrmOpportunityStage CrmOpportunityStage `json:"crm_opportunity_stage"`
	Valid               bool                `json:"valid"` // Valid is true if CrmOpportunityStage is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmOpportunityStage) Scan(value interface{}) error {
	if value == nil {
		ns.CrmOpportunityStage, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmOpportunityStage.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmOpportunityStage) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmOpportunityStage), nil
}

type CrmPaymentMethod string

const (
	CrmPaymentMethodCreditCard   CrmPaymentMethod = "credit-card"
	CrmPaymentMethodBankTransfer CrmPaymentMethod = "bank-transfer"
	CrmPaymentMethodCash         CrmPaymentMethod = "cash"
	CrmPaymentMethodCheck        CrmPaymentMethod = "check"
	CrmPaymentMethodPaypal       CrmPaymentMethod = "paypal"
	CrmPaymentMethodStripe       CrmPaymentMethod = "stripe"
	CrmPaymentMethodWireTransfer CrmPaymentMethod = "wire-transfer"
)

func (e *CrmPaymentMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmPaymentMethod(s)
	case string:
		*e = CrmPaymentMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmPaymentMethod: %T", src)
	}
	return nil
}

type NullCrmPaymentMethod struct {
	CrmPaymentMethod CrmPaymentMethod `json:"crm_payment_method"`
	Valid            bool             `json:"valid"` // Valid is true if CrmPaymentMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmPaymentMethod) Scan(value interface{}) error {
	if value == nil {
		ns.CrmPaymentMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmPaymentMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmPaymentMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmPaymentMethod), nil
}

type CrmProductType string

const (
	CrmProductTypeService      CrmProductType = "service"
	CrmProductTypeGood         CrmProductType = "good"
	CrmProductTypeDigital      CrmProductType = "digital"
	CrmProductTypeSubscription CrmProductType = "subscription"
)

func (e *CrmProductType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmProductType(s)
	case string:
		*e = CrmProductType(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmProductType: %T", src)
	}
	return nil
}

type NullCrmProductType struct {
	CrmProductType CrmProductType `json:"crm_product_type"`
	Valid          bool           `json:"valid"` // Valid is true if CrmProductType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmProductType) Scan(value interface{}) error {
	if value == nil {
		ns.CrmProductType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmProductType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmProductType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmProductType), nil
}

type CrmRecordType string

const (
	CrmRecordTypeCompanies     CrmRecordType = "companies"
	CrmRecordTypeContacts      CrmRecordType = "contacts"
	CrmRecordTypeLeads         CrmRecordType = "leads"
	CrmRecordTypeOpportunities CrmRecordType = "opportunities"
	CrmRecordTypeCases         CrmRecordType = "cases"
	CrmRecordTypeInteractions  CrmRecordType = "interactions"
	CrmRecordTypeCampaigns     CrmRecordType = "campaigns"
	CrmRecordTypeProducts      CrmRecordType = "products"
	CrmRecordTypeInvoices      CrmRecordType = "invoices"
)

func (e *CrmRecordType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CrmRecordType(s)
	case string:
		*e = CrmRecordType(s)
	default:
		return fmt.Errorf("unsupported scan type for CrmRecordType: %T", src)
	}
	return nil
}

type NullCrmRecordType struct {
	CrmRecordType CrmRecordType `json:"crm_record_type"`
	Valid         bool          `json:"valid"` // Valid is true if CrmRecordType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCrmRecordType) Scan(value interface{}) error {
	if value == nil {
		ns.CrmRecordType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CrmRecordType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCrmRecordType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CrmRecordType), nil
}

type DmsDeliveryFailureReasonEnum string

const (
	DmsDeliveryFailureReasonEnumRecipientNotHome  DmsDeliveryFailureReasonEnum = "recipient_not_home"
	DmsDeliveryFailureReasonEnumAddressNotFound   DmsDeliveryFailureReasonEnum = "address_not_found"
	DmsDeliveryFailureReasonEnumRefusedDelivery   DmsDeliveryFailureReasonEnum = "refused_delivery"
	DmsDeliveryFailureReasonEnumDamagedPackage    DmsDeliveryFailureReasonEnum = "damaged_package"
	DmsDeliveryFailureReasonEnumAccessDenied      DmsDeliveryFailureReasonEnum = "access_denied"
	DmsDeliveryFailureReasonEnumWeatherConditions DmsDeliveryFailureReasonEnum = "weather_conditions"
	DmsDeliveryFailureReasonEnumVehicleBreakdown  DmsDeliveryFailureReasonEnum = "vehicle_breakdown"
	DmsDeliveryFailureReasonEnumOther             DmsDeliveryFailureReasonEnum = "other"
)

func (e *DmsDeliveryFailureReasonEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsDeliveryFailureReasonEnum(s)
	case string:
		*e = DmsDeliveryFailureReasonEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsDeliveryFailureReasonEnum: %T", src)
	}
	return nil
}

type NullDmsDeliveryFailureReasonEnum struct {
	DmsDeliveryFailureReasonEnum DmsDeliveryFailureReasonEnum `json:"dms_delivery_failure_reason_enum"`
	Valid                        bool                         `json:"valid"` // Valid is true if DmsDeliveryFailureReasonEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsDeliveryFailureReasonEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsDeliveryFailureReasonEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsDeliveryFailureReasonEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsDeliveryFailureReasonEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsDeliveryFailureReasonEnum), nil
}

type DmsDeliveryRouteStatusEnum string

const (
	DmsDeliveryRouteStatusEnumPlanned    DmsDeliveryRouteStatusEnum = "planned"
	DmsDeliveryRouteStatusEnumInProgress DmsDeliveryRouteStatusEnum = "in_progress"
	DmsDeliveryRouteStatusEnumCompleted  DmsDeliveryRouteStatusEnum = "completed"
	DmsDeliveryRouteStatusEnumCancelled  DmsDeliveryRouteStatusEnum = "cancelled"
	DmsDeliveryRouteStatusEnumPaused     DmsDeliveryRouteStatusEnum = "paused"
)

func (e *DmsDeliveryRouteStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsDeliveryRouteStatusEnum(s)
	case string:
		*e = DmsDeliveryRouteStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsDeliveryRouteStatusEnum: %T", src)
	}
	return nil
}

type NullDmsDeliveryRouteStatusEnum struct {
	DmsDeliveryRouteStatusEnum DmsDeliveryRouteStatusEnum `json:"dms_delivery_route_status_enum"`
	Valid                      bool                       `json:"valid"` // Valid is true if DmsDeliveryRouteStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsDeliveryRouteStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsDeliveryRouteStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsDeliveryRouteStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsDeliveryRouteStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsDeliveryRouteStatusEnum), nil
}

type DmsDeliveryTaskStatusEnum string

const (
	DmsDeliveryTaskStatusEnumPending        DmsDeliveryTaskStatusEnum = "pending"
	DmsDeliveryTaskStatusEnumAssigned       DmsDeliveryTaskStatusEnum = "assigned"
	DmsDeliveryTaskStatusEnumOutForDelivery DmsDeliveryTaskStatusEnum = "out_for_delivery"
	DmsDeliveryTaskStatusEnumDelivered      DmsDeliveryTaskStatusEnum = "delivered"
	DmsDeliveryTaskStatusEnumFailed         DmsDeliveryTaskStatusEnum = "failed"
	DmsDeliveryTaskStatusEnumCancelled      DmsDeliveryTaskStatusEnum = "cancelled"
	DmsDeliveryTaskStatusEnumRescheduled    DmsDeliveryTaskStatusEnum = "rescheduled"
)

func (e *DmsDeliveryTaskStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsDeliveryTaskStatusEnum(s)
	case string:
		*e = DmsDeliveryTaskStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsDeliveryTaskStatusEnum: %T", src)
	}
	return nil
}

type NullDmsDeliveryTaskStatusEnum struct {
	DmsDeliveryTaskStatusEnum DmsDeliveryTaskStatusEnum `json:"dms_delivery_task_status_enum"`
	Valid                     bool                      `json:"valid"` // Valid is true if DmsDeliveryTaskStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsDeliveryTaskStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsDeliveryTaskStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsDeliveryTaskStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsDeliveryTaskStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsDeliveryTaskStatusEnum), nil
}

type DmsProofOfDeliveryTypeEnum string

const (
	DmsProofOfDeliveryTypeEnumSignature           DmsProofOfDeliveryTypeEnum = "signature"
	DmsProofOfDeliveryTypeEnumPhoto               DmsProofOfDeliveryTypeEnum = "photo"
	DmsProofOfDeliveryTypeEnumCodeVerification    DmsProofOfDeliveryTypeEnum = "code_verification"
	DmsProofOfDeliveryTypeEnumContactlessDelivery DmsProofOfDeliveryTypeEnum = "contactless_delivery"
	DmsProofOfDeliveryTypeEnumLeftAtDoor          DmsProofOfDeliveryTypeEnum = "left_at_door"
)

func (e *DmsProofOfDeliveryTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsProofOfDeliveryTypeEnum(s)
	case string:
		*e = DmsProofOfDeliveryTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsProofOfDeliveryTypeEnum: %T", src)
	}
	return nil
}

type NullDmsProofOfDeliveryTypeEnum struct {
	DmsProofOfDeliveryTypeEnum DmsProofOfDeliveryTypeEnum `json:"dms_proof_of_delivery_type_enum"`
	Valid                      bool                       `json:"valid"` // Valid is true if DmsProofOfDeliveryTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsProofOfDeliveryTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsProofOfDeliveryTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsProofOfDeliveryTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsProofOfDeliveryTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsProofOfDeliveryTypeEnum), nil
}

type DmsTaskEventStatusEnum string

const (
	DmsTaskEventStatusEnumAssigned    DmsTaskEventStatusEnum = "assigned"
	DmsTaskEventStatusEnumStarted     DmsTaskEventStatusEnum = "started"
	DmsTaskEventStatusEnumArrived     DmsTaskEventStatusEnum = "arrived"
	DmsTaskEventStatusEnumDelivered   DmsTaskEventStatusEnum = "delivered"
	DmsTaskEventStatusEnumFailed      DmsTaskEventStatusEnum = "failed"
	DmsTaskEventStatusEnumException   DmsTaskEventStatusEnum = "exception"
	DmsTaskEventStatusEnumCancelled   DmsTaskEventStatusEnum = "cancelled"
	DmsTaskEventStatusEnumRescheduled DmsTaskEventStatusEnum = "rescheduled"
)

func (e *DmsTaskEventStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DmsTaskEventStatusEnum(s)
	case string:
		*e = DmsTaskEventStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DmsTaskEventStatusEnum: %T", src)
	}
	return nil
}

type NullDmsTaskEventStatusEnum struct {
	DmsTaskEventStatusEnum DmsTaskEventStatusEnum `json:"dms_task_event_status_enum"`
	Valid                  bool                   `json:"valid"` // Valid is true if DmsTaskEventStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDmsTaskEventStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DmsTaskEventStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DmsTaskEventStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDmsTaskEventStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DmsTaskEventStatusEnum), nil
}

type TmsCarrierRateUnitEnum string

const (
	TmsCarrierRateUnitEnumPerKg        TmsCarrierRateUnitEnum = "per_kg"
	TmsCarrierRateUnitEnumPerContainer TmsCarrierRateUnitEnum = "per_container"
	TmsCarrierRateUnitEnumPerMile      TmsCarrierRateUnitEnum = "per_mile"
	TmsCarrierRateUnitEnumPerKm        TmsCarrierRateUnitEnum = "per_km"
	TmsCarrierRateUnitEnumFlatRate     TmsCarrierRateUnitEnum = "flat_rate"
)

func (e *TmsCarrierRateUnitEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsCarrierRateUnitEnum(s)
	case string:
		*e = TmsCarrierRateUnitEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsCarrierRateUnitEnum: %T", src)
	}
	return nil
}

type NullTmsCarrierRateUnitEnum struct {
	TmsCarrierRateUnitEnum TmsCarrierRateUnitEnum `json:"tms_carrier_rate_unit_enum"`
	Valid                  bool                   `json:"valid"` // Valid is true if TmsCarrierRateUnitEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsCarrierRateUnitEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsCarrierRateUnitEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsCarrierRateUnitEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsCarrierRateUnitEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsCarrierRateUnitEnum), nil
}

type TmsCurrencyEnum string

const (
	TmsCurrencyEnumUSD TmsCurrencyEnum = "USD"
	TmsCurrencyEnumEUR TmsCurrencyEnum = "EUR"
	TmsCurrencyEnumGBP TmsCurrencyEnum = "GBP"
	TmsCurrencyEnumCAD TmsCurrencyEnum = "CAD"
	TmsCurrencyEnumAUD TmsCurrencyEnum = "AUD"
	TmsCurrencyEnumJPY TmsCurrencyEnum = "JPY"
	TmsCurrencyEnumPHP TmsCurrencyEnum = "PHP"
)

func (e *TmsCurrencyEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsCurrencyEnum(s)
	case string:
		*e = TmsCurrencyEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsCurrencyEnum: %T", src)
	}
	return nil
}

type NullTmsCurrencyEnum struct {
	TmsCurrencyEnum TmsCurrencyEnum `json:"tms_currency_enum"`
	Valid           bool            `json:"valid"` // Valid is true if TmsCurrencyEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsCurrencyEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsCurrencyEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsCurrencyEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsCurrencyEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsCurrencyEnum), nil
}

type TmsDriverScheduleReasonEnum string

const (
	TmsDriverScheduleReasonEnumVacation      TmsDriverScheduleReasonEnum = "vacation"
	TmsDriverScheduleReasonEnumSickLeave     TmsDriverScheduleReasonEnum = "sick_leave"
	TmsDriverScheduleReasonEnumTraining      TmsDriverScheduleReasonEnum = "training"
	TmsDriverScheduleReasonEnumPersonalLeave TmsDriverScheduleReasonEnum = "personal_leave"
)

func (e *TmsDriverScheduleReasonEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsDriverScheduleReasonEnum(s)
	case string:
		*e = TmsDriverScheduleReasonEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsDriverScheduleReasonEnum: %T", src)
	}
	return nil
}

type NullTmsDriverScheduleReasonEnum struct {
	TmsDriverScheduleReasonEnum TmsDriverScheduleReasonEnum `json:"tms_driver_schedule_reason_enum"`
	Valid                       bool                        `json:"valid"` // Valid is true if TmsDriverScheduleReasonEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsDriverScheduleReasonEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsDriverScheduleReasonEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsDriverScheduleReasonEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsDriverScheduleReasonEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsDriverScheduleReasonEnum), nil
}

type TmsDriverStatusEnum string

const (
	TmsDriverStatusEnumActive   TmsDriverStatusEnum = "active"
	TmsDriverStatusEnumInactive TmsDriverStatusEnum = "inactive"
	TmsDriverStatusEnumOnLeave  TmsDriverStatusEnum = "on_leave"
)

func (e *TmsDriverStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsDriverStatusEnum(s)
	case string:
		*e = TmsDriverStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsDriverStatusEnum: %T", src)
	}
	return nil
}

type NullTmsDriverStatusEnum struct {
	TmsDriverStatusEnum TmsDriverStatusEnum `json:"tms_driver_status_enum"`
	Valid               bool                `json:"valid"` // Valid is true if TmsDriverStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsDriverStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsDriverStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsDriverStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsDriverStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsDriverStatusEnum), nil
}

type TmsExpenseStatusEnum string

const (
	TmsExpenseStatusEnumPending    TmsExpenseStatusEnum = "pending"
	TmsExpenseStatusEnumApproved   TmsExpenseStatusEnum = "approved"
	TmsExpenseStatusEnumRejected   TmsExpenseStatusEnum = "rejected"
	TmsExpenseStatusEnumReimbursed TmsExpenseStatusEnum = "reimbursed"
)

func (e *TmsExpenseStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsExpenseStatusEnum(s)
	case string:
		*e = TmsExpenseStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsExpenseStatusEnum: %T", src)
	}
	return nil
}

type NullTmsExpenseStatusEnum struct {
	TmsExpenseStatusEnum TmsExpenseStatusEnum `json:"tms_expense_status_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if TmsExpenseStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsExpenseStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsExpenseStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsExpenseStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsExpenseStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsExpenseStatusEnum), nil
}

type TmsExpenseTypeEnum string

const (
	TmsExpenseTypeEnumFuel          TmsExpenseTypeEnum = "fuel"
	TmsExpenseTypeEnumTolls         TmsExpenseTypeEnum = "tolls"
	TmsExpenseTypeEnumMaintenance   TmsExpenseTypeEnum = "maintenance"
	TmsExpenseTypeEnumParking       TmsExpenseTypeEnum = "parking"
	TmsExpenseTypeEnumMeals         TmsExpenseTypeEnum = "meals"
	TmsExpenseTypeEnumAccommodation TmsExpenseTypeEnum = "accommodation"
)

func (e *TmsExpenseTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsExpenseTypeEnum(s)
	case string:
		*e = TmsExpenseTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsExpenseTypeEnum: %T", src)
	}
	return nil
}

type NullTmsExpenseTypeEnum struct {
	TmsExpenseTypeEnum TmsExpenseTypeEnum `json:"tms_expense_type_enum"`
	Valid              bool               `json:"valid"` // Valid is true if TmsExpenseTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsExpenseTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsExpenseTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsExpenseTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsExpenseTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsExpenseTypeEnum), nil
}

type TmsGeofenceEventTypeEnum string

const (
	TmsGeofenceEventTypeEnumEnter TmsGeofenceEventTypeEnum = "enter"
	TmsGeofenceEventTypeEnumExit  TmsGeofenceEventTypeEnum = "exit"
)

func (e *TmsGeofenceEventTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsGeofenceEventTypeEnum(s)
	case string:
		*e = TmsGeofenceEventTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsGeofenceEventTypeEnum: %T", src)
	}
	return nil
}

type NullTmsGeofenceEventTypeEnum struct {
	TmsGeofenceEventTypeEnum TmsGeofenceEventTypeEnum `json:"tms_geofence_event_type_enum"`
	Valid                    bool                     `json:"valid"` // Valid is true if TmsGeofenceEventTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsGeofenceEventTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsGeofenceEventTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsGeofenceEventTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsGeofenceEventTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsGeofenceEventTypeEnum), nil
}

type TmsPartnerInvoiceStatusEnum string

const (
	TmsPartnerInvoiceStatusEnumPending   TmsPartnerInvoiceStatusEnum = "pending"
	TmsPartnerInvoiceStatusEnumPaid      TmsPartnerInvoiceStatusEnum = "paid"
	TmsPartnerInvoiceStatusEnumDisputed  TmsPartnerInvoiceStatusEnum = "disputed"
	TmsPartnerInvoiceStatusEnumOverdue   TmsPartnerInvoiceStatusEnum = "overdue"
	TmsPartnerInvoiceStatusEnumCancelled TmsPartnerInvoiceStatusEnum = "cancelled"
)

func (e *TmsPartnerInvoiceStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsPartnerInvoiceStatusEnum(s)
	case string:
		*e = TmsPartnerInvoiceStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsPartnerInvoiceStatusEnum: %T", src)
	}
	return nil
}

type NullTmsPartnerInvoiceStatusEnum struct {
	TmsPartnerInvoiceStatusEnum TmsPartnerInvoiceStatusEnum `json:"tms_partner_invoice_status_enum"`
	Valid                       bool                        `json:"valid"` // Valid is true if TmsPartnerInvoiceStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsPartnerInvoiceStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsPartnerInvoiceStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsPartnerInvoiceStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsPartnerInvoiceStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsPartnerInvoiceStatusEnum), nil
}

type TmsProofTypeEnum string

const (
	TmsProofTypeEnumSignature       TmsProofTypeEnum = "signature"
	TmsProofTypeEnumPhoto           TmsProofTypeEnum = "photo"
	TmsProofTypeEnumBarcodeScan     TmsProofTypeEnum = "barcode_scan"
	TmsProofTypeEnumPinVerification TmsProofTypeEnum = "pin_verification"
)

func (e *TmsProofTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsProofTypeEnum(s)
	case string:
		*e = TmsProofTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsProofTypeEnum: %T", src)
	}
	return nil
}

type NullTmsProofTypeEnum struct {
	TmsProofTypeEnum TmsProofTypeEnum `json:"tms_proof_type_enum"`
	Valid            bool             `json:"valid"` // Valid is true if TmsProofTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsProofTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsProofTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsProofTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsProofTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsProofTypeEnum), nil
}

type TmsShipmentLegStatusEnum string

const (
	TmsShipmentLegStatusEnumPending   TmsShipmentLegStatusEnum = "pending"
	TmsShipmentLegStatusEnumInTransit TmsShipmentLegStatusEnum = "in_transit"
	TmsShipmentLegStatusEnumDelivered TmsShipmentLegStatusEnum = "delivered"
	TmsShipmentLegStatusEnumCancelled TmsShipmentLegStatusEnum = "cancelled"
	TmsShipmentLegStatusEnumFailed    TmsShipmentLegStatusEnum = "failed"
)

func (e *TmsShipmentLegStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsShipmentLegStatusEnum(s)
	case string:
		*e = TmsShipmentLegStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsShipmentLegStatusEnum: %T", src)
	}
	return nil
}

type NullTmsShipmentLegStatusEnum struct {
	TmsShipmentLegStatusEnum TmsShipmentLegStatusEnum `json:"tms_shipment_leg_status_enum"`
	Valid                    bool                     `json:"valid"` // Valid is true if TmsShipmentLegStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsShipmentLegStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsShipmentLegStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsShipmentLegStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsShipmentLegStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsShipmentLegStatusEnum), nil
}

type TmsTripStatusEnum string

const (
	TmsTripStatusEnumPlanned    TmsTripStatusEnum = "planned"
	TmsTripStatusEnumInProgress TmsTripStatusEnum = "in_progress"
	TmsTripStatusEnumCompleted  TmsTripStatusEnum = "completed"
	TmsTripStatusEnumCancelled  TmsTripStatusEnum = "cancelled"
)

func (e *TmsTripStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsTripStatusEnum(s)
	case string:
		*e = TmsTripStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsTripStatusEnum: %T", src)
	}
	return nil
}

type NullTmsTripStatusEnum struct {
	TmsTripStatusEnum TmsTripStatusEnum `json:"tms_trip_status_enum"`
	Valid             bool              `json:"valid"` // Valid is true if TmsTripStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsTripStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsTripStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsTripStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsTripStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsTripStatusEnum), nil
}

type TmsTripStopStatusEnum string

const (
	TmsTripStopStatusEnumPending   TmsTripStopStatusEnum = "pending"
	TmsTripStopStatusEnumArrived   TmsTripStopStatusEnum = "arrived"
	TmsTripStopStatusEnumCompleted TmsTripStopStatusEnum = "completed"
	TmsTripStopStatusEnumSkipped   TmsTripStopStatusEnum = "skipped"
)

func (e *TmsTripStopStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsTripStopStatusEnum(s)
	case string:
		*e = TmsTripStopStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsTripStopStatusEnum: %T", src)
	}
	return nil
}

type NullTmsTripStopStatusEnum struct {
	TmsTripStopStatusEnum TmsTripStopStatusEnum `json:"tms_trip_stop_status_enum"`
	Valid                 bool                  `json:"valid"` // Valid is true if TmsTripStopStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsTripStopStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsTripStopStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsTripStopStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsTripStopStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsTripStopStatusEnum), nil
}

type TmsVehicleServiceTypeEnum string

const (
	TmsVehicleServiceTypeEnumRoutineMaintenance TmsVehicleServiceTypeEnum = "routine_maintenance"
	TmsVehicleServiceTypeEnumRepair             TmsVehicleServiceTypeEnum = "repair"
	TmsVehicleServiceTypeEnumInspection         TmsVehicleServiceTypeEnum = "inspection"
	TmsVehicleServiceTypeEnumOilChange          TmsVehicleServiceTypeEnum = "oil_change"
	TmsVehicleServiceTypeEnumTireReplacement    TmsVehicleServiceTypeEnum = "tire_replacement"
	TmsVehicleServiceTypeEnumBrakeService       TmsVehicleServiceTypeEnum = "brake_service"
)

func (e *TmsVehicleServiceTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsVehicleServiceTypeEnum(s)
	case string:
		*e = TmsVehicleServiceTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsVehicleServiceTypeEnum: %T", src)
	}
	return nil
}

type NullTmsVehicleServiceTypeEnum struct {
	TmsVehicleServiceTypeEnum TmsVehicleServiceTypeEnum `json:"tms_vehicle_service_type_enum"`
	Valid                     bool                      `json:"valid"` // Valid is true if TmsVehicleServiceTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsVehicleServiceTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsVehicleServiceTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsVehicleServiceTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsVehicleServiceTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsVehicleServiceTypeEnum), nil
}

type TmsVehicleStatusEnum string

const (
	TmsVehicleStatusEnumAvailable     TmsVehicleStatusEnum = "available"
	TmsVehicleStatusEnumInMaintenance TmsVehicleStatusEnum = "in_maintenance"
	TmsVehicleStatusEnumOnTrip        TmsVehicleStatusEnum = "on_trip"
	TmsVehicleStatusEnumOutOfService  TmsVehicleStatusEnum = "out_of_service"
)

func (e *TmsVehicleStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TmsVehicleStatusEnum(s)
	case string:
		*e = TmsVehicleStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for TmsVehicleStatusEnum: %T", src)
	}
	return nil
}

type NullTmsVehicleStatusEnum struct {
	TmsVehicleStatusEnum TmsVehicleStatusEnum `json:"tms_vehicle_status_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if TmsVehicleStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTmsVehicleStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.TmsVehicleStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TmsVehicleStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTmsVehicleStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TmsVehicleStatusEnum), nil
}

type UserRole string

const (
	UserRoleAdmin                UserRole = "admin"
	UserRoleDeveloper            UserRole = "developer"
	UserRoleUser                 UserRole = "user"
	UserRoleClient               UserRole = "client"
	UserRoleClientAdmin          UserRole = "client-admin"
	UserRoleEndCustomer          UserRole = "end-customer"
	UserRoleInventoryManager     UserRole = "inventory-manager"
	UserRoleWarehouseManager     UserRole = "warehouse-manager"
	UserRoleReceivingManager     UserRole = "receiving-manager"
	UserRoleWarehouseOperator    UserRole = "warehouse-operator"
	UserRolePicker               UserRole = "picker"
	UserRolePacker               UserRole = "packer"
	UserRoleReturnsProcessor     UserRole = "returns-processor"
	UserRoleQcManager            UserRole = "qc-manager"
	UserRoleLogisticsCoordinator UserRole = "logistics-coordinator"
	UserRoleLogisticsManager     UserRole = "logistics-manager"
	UserRoleLogisticsPlanner     UserRole = "logistics-planner"
	UserRoleDispatcher           UserRole = "dispatcher"
	UserRoleDriver               UserRole = "driver"
	UserRoleFleetManager         UserRole = "fleet-manager"
	UserRoleTransportManager     UserRole = "transport-manager"
	UserRoleAccountManager       UserRole = "account-manager"
	UserRolePricingAnalyst       UserRole = "pricing-analyst"
	UserRoleFinanceManager       UserRole = "finance-manager"
	UserRoleAccountant           UserRole = "accountant"
	UserRoleSdr                  UserRole = "sdr"
	UserRoleSalesRep             UserRole = "sales-rep"
	UserRoleSalesManager         UserRole = "sales-manager"
	UserRoleMarketingManager     UserRole = "marketing-manager"
	UserRoleCustomerSupportAgent UserRole = "customer-support-agent"
	UserRoleProductManager       UserRole = "product-manager"
	UserRoleCarrier              UserRole = "carrier"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type WmsInboundShipmentStatusEnum string

const (
	WmsInboundShipmentStatusEnumPending    WmsInboundShipmentStatusEnum = "pending"
	WmsInboundShipmentStatusEnumArrived    WmsInboundShipmentStatusEnum = "arrived"
	WmsInboundShipmentStatusEnumProcessing WmsInboundShipmentStatusEnum = "processing"
	WmsInboundShipmentStatusEnumCompleted  WmsInboundShipmentStatusEnum = "completed"
	WmsInboundShipmentStatusEnumCancelled  WmsInboundShipmentStatusEnum = "cancelled"
)

func (e *WmsInboundShipmentStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsInboundShipmentStatusEnum(s)
	case string:
		*e = WmsInboundShipmentStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsInboundShipmentStatusEnum: %T", src)
	}
	return nil
}

type NullWmsInboundShipmentStatusEnum struct {
	WmsInboundShipmentStatusEnum WmsInboundShipmentStatusEnum `json:"wms_inbound_shipment_status_enum"`
	Valid                        bool                         `json:"valid"` // Valid is true if WmsInboundShipmentStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsInboundShipmentStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsInboundShipmentStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsInboundShipmentStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsInboundShipmentStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsInboundShipmentStatusEnum), nil
}

type WmsInventoryAdjustmentReasonEnum string

const (
	WmsInventoryAdjustmentReasonEnumCycleCount       WmsInventoryAdjustmentReasonEnum = "cycle_count"
	WmsInventoryAdjustmentReasonEnumDamagedGoods     WmsInventoryAdjustmentReasonEnum = "damaged_goods"
	WmsInventoryAdjustmentReasonEnumTheft            WmsInventoryAdjustmentReasonEnum = "theft"
	WmsInventoryAdjustmentReasonEnumExpired          WmsInventoryAdjustmentReasonEnum = "expired"
	WmsInventoryAdjustmentReasonEnumReturnToVendor   WmsInventoryAdjustmentReasonEnum = "return_to_vendor"
	WmsInventoryAdjustmentReasonEnumManualCorrection WmsInventoryAdjustmentReasonEnum = "manual_correction"
)

func (e *WmsInventoryAdjustmentReasonEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsInventoryAdjustmentReasonEnum(s)
	case string:
		*e = WmsInventoryAdjustmentReasonEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsInventoryAdjustmentReasonEnum: %T", src)
	}
	return nil
}

type NullWmsInventoryAdjustmentReasonEnum struct {
	WmsInventoryAdjustmentReasonEnum WmsInventoryAdjustmentReasonEnum `json:"wms_inventory_adjustment_reason_enum"`
	Valid                            bool                             `json:"valid"` // Valid is true if WmsInventoryAdjustmentReasonEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsInventoryAdjustmentReasonEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsInventoryAdjustmentReasonEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsInventoryAdjustmentReasonEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsInventoryAdjustmentReasonEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsInventoryAdjustmentReasonEnum), nil
}

type WmsInventoryStockStatusEnum string

const (
	WmsInventoryStockStatusEnumAvailable  WmsInventoryStockStatusEnum = "available"
	WmsInventoryStockStatusEnumAllocated  WmsInventoryStockStatusEnum = "allocated"
	WmsInventoryStockStatusEnumDamaged    WmsInventoryStockStatusEnum = "damaged"
	WmsInventoryStockStatusEnumQuarantine WmsInventoryStockStatusEnum = "quarantine"
	WmsInventoryStockStatusEnumHold       WmsInventoryStockStatusEnum = "hold"
	WmsInventoryStockStatusEnumShipped    WmsInventoryStockStatusEnum = "shipped"
	WmsInventoryStockStatusEnumExpired    WmsInventoryStockStatusEnum = "expired"
)

func (e *WmsInventoryStockStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsInventoryStockStatusEnum(s)
	case string:
		*e = WmsInventoryStockStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsInventoryStockStatusEnum: %T", src)
	}
	return nil
}

type NullWmsInventoryStockStatusEnum struct {
	WmsInventoryStockStatusEnum WmsInventoryStockStatusEnum `json:"wms_inventory_stock_status_enum"`
	Valid                       bool                        `json:"valid"` // Valid is true if WmsInventoryStockStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsInventoryStockStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsInventoryStockStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsInventoryStockStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsInventoryStockStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsInventoryStockStatusEnum), nil
}

type WmsLocationTypeEnum string

const (
	WmsLocationTypeEnumReceivingDock  WmsLocationTypeEnum = "receiving_dock"
	WmsLocationTypeEnumPickBin        WmsLocationTypeEnum = "pick_bin"
	WmsLocationTypeEnumPackingStation WmsLocationTypeEnum = "packing_station"
	WmsLocationTypeEnumCrossDockArea  WmsLocationTypeEnum = "cross_dock_area"
	WmsLocationTypeEnumBulkStorage    WmsLocationTypeEnum = "bulk_storage"
	WmsLocationTypeEnumReserveStorage WmsLocationTypeEnum = "reserve_storage"
	WmsLocationTypeEnumDamagedGoods   WmsLocationTypeEnum = "damaged_goods"
	WmsLocationTypeEnumStagingArea    WmsLocationTypeEnum = "staging_area"
	WmsLocationTypeEnumQualityControl WmsLocationTypeEnum = "quality_control"
	WmsLocationTypeEnumReturnsArea    WmsLocationTypeEnum = "returns_area"
)

func (e *WmsLocationTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsLocationTypeEnum(s)
	case string:
		*e = WmsLocationTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsLocationTypeEnum: %T", src)
	}
	return nil
}

type NullWmsLocationTypeEnum struct {
	WmsLocationTypeEnum WmsLocationTypeEnum `json:"wms_location_type_enum"`
	Valid               bool                `json:"valid"` // Valid is true if WmsLocationTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsLocationTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsLocationTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsLocationTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsLocationTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsLocationTypeEnum), nil
}

type WmsOutboundShipmentStatusEnum string

const (
	WmsOutboundShipmentStatusEnumPicking   WmsOutboundShipmentStatusEnum = "picking"
	WmsOutboundShipmentStatusEnumPacked    WmsOutboundShipmentStatusEnum = "packed"
	WmsOutboundShipmentStatusEnumShipped   WmsOutboundShipmentStatusEnum = "shipped"
	WmsOutboundShipmentStatusEnumDelivered WmsOutboundShipmentStatusEnum = "delivered"
	WmsOutboundShipmentStatusEnumCancelled WmsOutboundShipmentStatusEnum = "cancelled"
)

func (e *WmsOutboundShipmentStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsOutboundShipmentStatusEnum(s)
	case string:
		*e = WmsOutboundShipmentStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsOutboundShipmentStatusEnum: %T", src)
	}
	return nil
}

type NullWmsOutboundShipmentStatusEnum struct {
	WmsOutboundShipmentStatusEnum WmsOutboundShipmentStatusEnum `json:"wms_outbound_shipment_status_enum"`
	Valid                         bool                          `json:"valid"` // Valid is true if WmsOutboundShipmentStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsOutboundShipmentStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsOutboundShipmentStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsOutboundShipmentStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsOutboundShipmentStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsOutboundShipmentStatusEnum), nil
}

type WmsPickBatchStatusEnum string

const (
	WmsPickBatchStatusEnumOpen       WmsPickBatchStatusEnum = "open"
	WmsPickBatchStatusEnumInProgress WmsPickBatchStatusEnum = "in_progress"
	WmsPickBatchStatusEnumCompleted  WmsPickBatchStatusEnum = "completed"
	WmsPickBatchStatusEnumCancelled  WmsPickBatchStatusEnum = "cancelled"
)

func (e *WmsPickBatchStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsPickBatchStatusEnum(s)
	case string:
		*e = WmsPickBatchStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsPickBatchStatusEnum: %T", src)
	}
	return nil
}

type NullWmsPickBatchStatusEnum struct {
	WmsPickBatchStatusEnum WmsPickBatchStatusEnum `json:"wms_pick_batch_status_enum"`
	Valid                  bool                   `json:"valid"` // Valid is true if WmsPickBatchStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsPickBatchStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsPickBatchStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsPickBatchStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsPickBatchStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsPickBatchStatusEnum), nil
}

type WmsPickStrategyEnum string

const (
	WmsPickStrategyEnumBatchPicking       WmsPickStrategyEnum = "batch_picking"
	WmsPickStrategyEnumZonePicking        WmsPickStrategyEnum = "zone_picking"
	WmsPickStrategyEnumWavePicking        WmsPickStrategyEnum = "wave_picking"
	WmsPickStrategyEnumSingleOrderPicking WmsPickStrategyEnum = "single_order_picking"
	WmsPickStrategyEnumClusterPicking     WmsPickStrategyEnum = "cluster_picking"
)

func (e *WmsPickStrategyEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsPickStrategyEnum(s)
	case string:
		*e = WmsPickStrategyEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsPickStrategyEnum: %T", src)
	}
	return nil
}

type NullWmsPickStrategyEnum struct {
	WmsPickStrategyEnum WmsPickStrategyEnum `json:"wms_pick_strategy_enum"`
	Valid               bool                `json:"valid"` // Valid is true if WmsPickStrategyEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsPickStrategyEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsPickStrategyEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsPickStrategyEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsPickStrategyEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsPickStrategyEnum), nil
}

type WmsProductStatusEnum string

const (
	WmsProductStatusEnumActive       WmsProductStatusEnum = "active"
	WmsProductStatusEnumDiscontinued WmsProductStatusEnum = "discontinued"
	WmsProductStatusEnumObsolete     WmsProductStatusEnum = "obsolete"
	WmsProductStatusEnumInactive     WmsProductStatusEnum = "inactive"
)

func (e *WmsProductStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsProductStatusEnum(s)
	case string:
		*e = WmsProductStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsProductStatusEnum: %T", src)
	}
	return nil
}

type NullWmsProductStatusEnum struct {
	WmsProductStatusEnum WmsProductStatusEnum `json:"wms_product_status_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if WmsProductStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsProductStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsProductStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsProductStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsProductStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsProductStatusEnum), nil
}

type WmsReturnItemConditionEnum string

const (
	WmsReturnItemConditionEnumSellable   WmsReturnItemConditionEnum = "sellable"
	WmsReturnItemConditionEnumDamaged    WmsReturnItemConditionEnum = "damaged"
	WmsReturnItemConditionEnumDefective  WmsReturnItemConditionEnum = "defective"
	WmsReturnItemConditionEnumExpired    WmsReturnItemConditionEnum = "expired"
	WmsReturnItemConditionEnumUnsellable WmsReturnItemConditionEnum = "unsellable"
)

func (e *WmsReturnItemConditionEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsReturnItemConditionEnum(s)
	case string:
		*e = WmsReturnItemConditionEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsReturnItemConditionEnum: %T", src)
	}
	return nil
}

type NullWmsReturnItemConditionEnum struct {
	WmsReturnItemConditionEnum WmsReturnItemConditionEnum `json:"wms_return_item_condition_enum"`
	Valid                      bool                       `json:"valid"` // Valid is true if WmsReturnItemConditionEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsReturnItemConditionEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsReturnItemConditionEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsReturnItemConditionEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsReturnItemConditionEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsReturnItemConditionEnum), nil
}

type WmsReturnStatusEnum string

const (
	WmsReturnStatusEnumRequested WmsReturnStatusEnum = "requested"
	WmsReturnStatusEnumApproved  WmsReturnStatusEnum = "approved"
	WmsReturnStatusEnumRejected  WmsReturnStatusEnum = "rejected"
	WmsReturnStatusEnumReceived  WmsReturnStatusEnum = "received"
	WmsReturnStatusEnumProcessed WmsReturnStatusEnum = "processed"
)

func (e *WmsReturnStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsReturnStatusEnum(s)
	case string:
		*e = WmsReturnStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsReturnStatusEnum: %T", src)
	}
	return nil
}

type NullWmsReturnStatusEnum struct {
	WmsReturnStatusEnum WmsReturnStatusEnum `json:"wms_return_status_enum"`
	Valid               bool                `json:"valid"` // Valid is true if WmsReturnStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsReturnStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsReturnStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsReturnStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsReturnStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsReturnStatusEnum), nil
}

type WmsSalesOrderStatusEnum string

const (
	WmsSalesOrderStatusEnumPending    WmsSalesOrderStatusEnum = "pending"
	WmsSalesOrderStatusEnumProcessing WmsSalesOrderStatusEnum = "processing"
	WmsSalesOrderStatusEnumShipped    WmsSalesOrderStatusEnum = "shipped"
	WmsSalesOrderStatusEnumCompleted  WmsSalesOrderStatusEnum = "completed"
	WmsSalesOrderStatusEnumCancelled  WmsSalesOrderStatusEnum = "cancelled"
)

func (e *WmsSalesOrderStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsSalesOrderStatusEnum(s)
	case string:
		*e = WmsSalesOrderStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsSalesOrderStatusEnum: %T", src)
	}
	return nil
}

type NullWmsSalesOrderStatusEnum struct {
	WmsSalesOrderStatusEnum WmsSalesOrderStatusEnum `json:"wms_sales_order_status_enum"`
	Valid                   bool                    `json:"valid"` // Valid is true if WmsSalesOrderStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsSalesOrderStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsSalesOrderStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsSalesOrderStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsSalesOrderStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsSalesOrderStatusEnum), nil
}

type WmsStockTransferStatusEnum string

const (
	WmsStockTransferStatusEnumPending   WmsStockTransferStatusEnum = "pending"
	WmsStockTransferStatusEnumInTransit WmsStockTransferStatusEnum = "in_transit"
	WmsStockTransferStatusEnumReceived  WmsStockTransferStatusEnum = "received"
	WmsStockTransferStatusEnumCancelled WmsStockTransferStatusEnum = "cancelled"
)

func (e *WmsStockTransferStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsStockTransferStatusEnum(s)
	case string:
		*e = WmsStockTransferStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsStockTransferStatusEnum: %T", src)
	}
	return nil
}

type NullWmsStockTransferStatusEnum struct {
	WmsStockTransferStatusEnum WmsStockTransferStatusEnum `json:"wms_stock_transfer_status_enum"`
	Valid                      bool                       `json:"valid"` // Valid is true if WmsStockTransferStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsStockTransferStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsStockTransferStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsStockTransferStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsStockTransferStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsStockTransferStatusEnum), nil
}

type WmsTaskItemStatusEnum string

const (
	WmsTaskItemStatusEnumPending     WmsTaskItemStatusEnum = "pending"
	WmsTaskItemStatusEnumInProgress  WmsTaskItemStatusEnum = "in_progress"
	WmsTaskItemStatusEnumCompleted   WmsTaskItemStatusEnum = "completed"
	WmsTaskItemStatusEnumShortPicked WmsTaskItemStatusEnum = "short_picked"
	WmsTaskItemStatusEnumDamaged     WmsTaskItemStatusEnum = "damaged"
	WmsTaskItemStatusEnumNotFound    WmsTaskItemStatusEnum = "not_found"
)

func (e *WmsTaskItemStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsTaskItemStatusEnum(s)
	case string:
		*e = WmsTaskItemStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsTaskItemStatusEnum: %T", src)
	}
	return nil
}

type NullWmsTaskItemStatusEnum struct {
	WmsTaskItemStatusEnum WmsTaskItemStatusEnum `json:"wms_task_item_status_enum"`
	Valid                 bool                  `json:"valid"` // Valid is true if WmsTaskItemStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsTaskItemStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsTaskItemStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsTaskItemStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsTaskItemStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsTaskItemStatusEnum), nil
}

type WmsTaskStatusEnum string

const (
	WmsTaskStatusEnumPending    WmsTaskStatusEnum = "pending"
	WmsTaskStatusEnumAssigned   WmsTaskStatusEnum = "assigned"
	WmsTaskStatusEnumInProgress WmsTaskStatusEnum = "in_progress"
	WmsTaskStatusEnumCompleted  WmsTaskStatusEnum = "completed"
	WmsTaskStatusEnumCancelled  WmsTaskStatusEnum = "cancelled"
	WmsTaskStatusEnumError      WmsTaskStatusEnum = "error"
)

func (e *WmsTaskStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsTaskStatusEnum(s)
	case string:
		*e = WmsTaskStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsTaskStatusEnum: %T", src)
	}
	return nil
}

type NullWmsTaskStatusEnum struct {
	WmsTaskStatusEnum WmsTaskStatusEnum `json:"wms_task_status_enum"`
	Valid             bool              `json:"valid"` // Valid is true if WmsTaskStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsTaskStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsTaskStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsTaskStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsTaskStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsTaskStatusEnum), nil
}

type WmsTaskTypeEnum string

const (
	WmsTaskTypeEnumPutaway           WmsTaskTypeEnum = "putaway"
	WmsTaskTypeEnumPick              WmsTaskTypeEnum = "pick"
	WmsTaskTypeEnumPack              WmsTaskTypeEnum = "pack"
	WmsTaskTypeEnumReplenishment     WmsTaskTypeEnum = "replenishment"
	WmsTaskTypeEnumCycleCount        WmsTaskTypeEnum = "cycle_count"
	WmsTaskTypeEnumCrossDock         WmsTaskTypeEnum = "cross_dock"
	WmsTaskTypeEnumReturnsProcessing WmsTaskTypeEnum = "returns_processing"
	WmsTaskTypeEnumDamageInspection  WmsTaskTypeEnum = "damage_inspection"
	WmsTaskTypeEnumQualityCheck      WmsTaskTypeEnum = "quality_check"
)

func (e *WmsTaskTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WmsTaskTypeEnum(s)
	case string:
		*e = WmsTaskTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for WmsTaskTypeEnum: %T", src)
	}
	return nil
}

type NullWmsTaskTypeEnum struct {
	WmsTaskTypeEnum WmsTaskTypeEnum `json:"wms_task_type_enum"`
	Valid           bool            `json:"valid"` // Valid is true if WmsTaskTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWmsTaskTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.WmsTaskTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WmsTaskTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWmsTaskTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WmsTaskTypeEnum), nil
}

type Account struct {
	ID                    string             `db:"id" json:"id"`
	AccountID             string             `db:"account_id" json:"account_id"`
	ProviderID            string             `db:"provider_id" json:"provider_id"`
	UserID                string             `db:"user_id" json:"user_id"`
	AccessToken           pgtype.Text        `db:"access_token" json:"access_token"`
	RefreshToken          pgtype.Text        `db:"refresh_token" json:"refresh_token"`
	IDToken               pgtype.Text        `db:"id_token" json:"id_token"`
	AccessTokenExpiresAt  pgtype.Timestamptz `db:"access_token_expires_at" json:"access_token_expires_at"`
	RefreshTokenExpiresAt pgtype.Timestamptz `db:"refresh_token_expires_at" json:"refresh_token_expires_at"`
	Scope                 pgtype.Text        `db:"scope" json:"scope"`
	Password              pgtype.Text        `db:"password" json:"password"`
	CreatedAt             pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Records all financial transactions affecting client accounts.
type BillingAccountTransaction struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the affected client account.
	ClientAccountID pgtype.UUID `db:"client_account_id" json:"client_account_id"`
	// Type of transaction using transaction_type_enum.
	Type BillingTransactionTypeEnum `db:"type" json:"type"`
	// Transaction amount (positive for credits, negative for debits).
	Amount pgtype.Numeric `db:"amount" json:"amount"`
	// Account balance after this transaction.
	RunningBalance pgtype.Numeric `db:"running_balance" json:"running_balance"`
	// Reference to the source document (e.g., invoice_id, payment_id).
	SourceRecordID pgtype.UUID `db:"source_record_id" json:"source_record_id"`
	// Type of source document.
	SourceRecordType pgtype.Text `db:"source_record_type" json:"source_record_type"`
	// Description of the transaction.
	Description pgtype.Text `db:"description" json:"description"`
	// External reference number.
	ReferenceNumber pgtype.Text `db:"reference_number" json:"reference_number"`
	// When the transaction occurred.
	TransactionDate pgtype.Timestamp `db:"transaction_date" json:"transaction_date"`
	// User who processed this transaction.
	ProcessedByUserID pgtype.Text `db:"processed_by_user_id" json:"processed_by_user_id"`
	// Timestamp when the transaction was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the transaction was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Tracks synchronization of financial data with external accounting systems.
type BillingAccountingSyncLog struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the record being synchronized.
	RecordID pgtype.UUID `db:"record_id" json:"record_id"`
	// Type of record being synchronized.
	RecordType string `db:"record_type" json:"record_type"`
	// Target accounting system (e.g., quickbooks, xero).
	ExternalSystem string `db:"external_system" json:"external_system"`
	// ID assigned by the external system.
	ExternalID pgtype.Text `db:"external_id" json:"external_id"`
	// Synchronization status using sync_status_enum.
	Status NullBillingSyncStatusEnum `db:"status" json:"status"`
	// Details of any synchronization errors.
	ErrorMessage pgtype.Text `db:"error_message" json:"error_message"`
	// Request data sent to external system.
	RequestPayload pgtype.Text `db:"request_payload" json:"request_payload"`
	// Response data received from external system.
	ResponsePayload pgtype.Text `db:"response_payload" json:"response_payload"`
	// Timestamp of the last synchronization attempt.
	LastSyncAt pgtype.Timestamp `db:"last_sync_at" json:"last_sync_at"`
	// Number of retry attempts made.
	RetryCount pgtype.Int4 `db:"retry_count" json:"retry_count"`
	// When the next retry should be attempted.
	NextRetryAt pgtype.Timestamp `db:"next_retry_at" json:"next_retry_at"`
	// Timestamp when the sync log was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the sync log was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Financial account information for clients, including credit limits and wallet balances.
type BillingClientAccount struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the client company.
	ClientID pgtype.UUID `db:"client_id" json:"client_id"`
	// Maximum credit amount allowed for the client.
	CreditLimit pgtype.Numeric `db:"credit_limit" json:"credit_limit"`
	// Current available credit balance.
	AvailableCredit pgtype.Numeric `db:"available_credit" json:"available_credit"`
	// Prepaid balance available for services.
	WalletBalance pgtype.Numeric `db:"wallet_balance" json:"wallet_balance"`
	// Currency code for the account.
	Currency pgtype.Text `db:"currency" json:"currency"`
	// Number of days for payment terms.
	PaymentTermsDays pgtype.Int4 `db:"payment_terms_days" json:"payment_terms_days"`
	// Whether the client is approved for credit.
	IsCreditApproved pgtype.Bool `db:"is_credit_approved" json:"is_credit_approved"`
	// Date of the last payment received.
	LastPaymentDate pgtype.Date `db:"last_payment_date" json:"last_payment_date"`
	// Timestamp when the client account was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the client account was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type BillingClientAccountsView struct {
	ID                  pgtype.UUID                 `db:"id" json:"id"`
	ClientID            pgtype.UUID                 `db:"client_id" json:"client_id"`
	CreditLimit         pgtype.Numeric              `db:"credit_limit" json:"credit_limit"`
	AvailableCredit     pgtype.Numeric              `db:"available_credit" json:"available_credit"`
	WalletBalance       pgtype.Numeric              `db:"wallet_balance" json:"wallet_balance"`
	Currency            pgtype.Text                 `db:"currency" json:"currency"`
	PaymentTermsDays    pgtype.Int4                 `db:"payment_terms_days" json:"payment_terms_days"`
	IsCreditApproved    pgtype.Bool                 `db:"is_credit_approved" json:"is_credit_approved"`
	LastPaymentDate     pgtype.Date                 `db:"last_payment_date" json:"last_payment_date"`
	CreatedAt           pgtype.Timestamp            `db:"created_at" json:"created_at"`
	UpdatedAt           pgtype.Timestamp            `db:"updated_at" json:"updated_at"`
	AccountTransactions []BillingAccountTransaction `db:"account_transactions" json:"account_transactions"`
}

// Credits issued to clients for adjustments, refunds, or dispute resolutions.
type BillingCreditNote struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the related invoice.
	InvoiceID pgtype.UUID `db:"invoice_id" json:"invoice_id"`
	// Reference to the dispute (if applicable).
	DisputeID pgtype.UUID `db:"dispute_id" json:"dispute_id"`
	// Unique credit note reference number.
	CreditNoteNumber string `db:"credit_note_number" json:"credit_note_number"`
	// Credit amount being issued.
	Amount pgtype.Numeric `db:"amount" json:"amount"`
	// Explanation for the credit note.
	Reason string `db:"reason" json:"reason"`
	// Date the credit note was created.
	IssueDate pgtype.Date `db:"issue_date" json:"issue_date"`
	// When the credit was applied to the account.
	AppliedAt pgtype.Timestamp `db:"applied_at" json:"applied_at"`
	// Currency of the credit note.
	Currency pgtype.Text `db:"currency" json:"currency"`
	// Additional notes about the credit note.
	Notes pgtype.Text `db:"notes" json:"notes"`
	// User who created this credit note.
	CreatedByUserID pgtype.Text `db:"created_by_user_id" json:"created_by_user_id"`
	// Timestamp when the credit note was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the credit note was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Records of client disputes regarding invoice charges.
type BillingDispute struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the disputed invoice line item.
	LineItemID pgtype.UUID `db:"line_item_id" json:"line_item_id"`
	// Reference to the client raising the dispute.
	ClientID pgtype.UUID `db:"client_id" json:"client_id"`
	// Explanation of why the charge is being disputed.
	Reason string `db:"reason" json:"reason"`
	// Current dispute status using dispute_status_enum.
	Status NullBillingDisputeStatusEnum `db:"status" json:"status"`
	// Amount being disputed.
	DisputedAmount pgtype.Numeric `db:"disputed_amount" json:"disputed_amount"`
	// Notes about the dispute resolution.
	ResolutionNotes pgtype.Text `db:"resolution_notes" json:"resolution_notes"`
	// When the dispute was submitted.
	SubmittedAt pgtype.Timestamp `db:"submitted_at" json:"submitted_at"`
	// When the dispute was resolved.
	ResolvedAt pgtype.Timestamp `db:"resolved_at" json:"resolved_at"`
	// User who resolved the dispute.
	ResolvedByUserID pgtype.Text `db:"resolved_by_user_id" json:"resolved_by_user_id"`
	// Timestamp when the dispute was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the dispute was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Manages document attachments related to billing and shipping records.
type BillingDocument struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the record the document is attached to.
	RecordID pgtype.UUID `db:"record_id" json:"record_id"`
	// Type of record (e.g., ims_outbound_shipments, billing_invoices).
	RecordType string `db:"record_type" json:"record_type"`
	// Type of document using document_type_enum.
	DocumentType BillingDocumentTypeEnum `db:"document_type" json:"document_type"`
	// Storage location of the document file.
	FilePath string `db:"file_path" json:"file_path"`
	// Original file name.
	FileName string `db:"file_name" json:"file_name"`
	// File size in bytes.
	FileSize pgtype.Int4 `db:"file_size" json:"file_size"`
	// MIME type of the file.
	MimeType pgtype.Text `db:"mime_type" json:"mime_type"`
	// User who uploaded this document.
	UploadedByUserID pgtype.Text `db:"uploaded_by_user_id" json:"uploaded_by_user_id"`
	// Timestamp when the document was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the document was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Bills sent to clients for services rendered or goods provided.
type BillingInvoice struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the client being billed.
	ClientID pgtype.UUID `db:"client_id" json:"client_id"`
	// Reference to the original quote (if applicable).
	QuoteID pgtype.UUID `db:"quote_id" json:"quote_id"`
	// Unique invoice reference number.
	InvoiceNumber string `db:"invoice_number" json:"invoice_number"`
	// Current invoice status using invoice_status_enum.
	Status NullBillingInvoiceStatusEnum `db:"status" json:"status"`
	// Date the invoice was created.
	IssueDate pgtype.Date `db:"issue_date" json:"issue_date"`
	// Payment due date.
	DueDate pgtype.Date `db:"due_date" json:"due_date"`
	// Total amount due on the invoice.
	TotalAmount pgtype.Numeric `db:"total_amount" json:"total_amount"`
	// Amount already paid against the invoice.
	AmountPaid pgtype.Numeric `db:"amount_paid" json:"amount_paid"`
	// Outstanding amount (automatically calculated).
	AmountOutstanding pgtype.Numeric `db:"amount_outstanding" json:"amount_outstanding"`
	// Currency code for the invoice.
	Currency pgtype.Text `db:"currency" json:"currency"`
	// Total tax amount on the invoice.
	TaxAmount pgtype.Numeric `db:"tax_amount" json:"tax_amount"`
	// Total discount applied to the invoice.
	DiscountAmount pgtype.Numeric `db:"discount_amount" json:"discount_amount"`
	// Subtotal before tax and discounts.
	Subtotal pgtype.Numeric `db:"subtotal" json:"subtotal"`
	// Payment terms and conditions.
	PaymentTerms pgtype.Text `db:"payment_terms" json:"payment_terms"`
	// Additional notes on the invoice.
	Notes pgtype.Text `db:"notes" json:"notes"`
	// When the invoice was sent to the client.
	SentAt pgtype.Timestamp `db:"sent_at" json:"sent_at"`
	// When the invoice was fully paid.
	PaidAt pgtype.Timestamp `db:"paid_at" json:"paid_at"`
	// User who created this invoice.
	CreatedByUserID pgtype.Text `db:"created_by_user_id" json:"created_by_user_id"`
	// Timestamp when the invoice was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the invoice was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Individual charges and services detailed on an invoice.
type BillingInvoiceLineItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the parent invoice.
	InvoiceID pgtype.UUID `db:"invoice_id" json:"invoice_id"`
	// Reference to the source of the charge (e.g., shipment_id).
	SourceRecordID pgtype.UUID `db:"source_record_id" json:"source_record_id"`
	// Type of source record.
	SourceRecordType pgtype.Text `db:"source_record_type" json:"source_record_type"`
	// Description of the service or charge.
	Description string `db:"description" json:"description"`
	// Number of units being charged.
	Quantity pgtype.Numeric `db:"quantity" json:"quantity"`
	// Price per unit.
	UnitPrice pgtype.Numeric `db:"unit_price" json:"unit_price"`
	// Total amount for this line item (automatically calculated).
	TotalPrice pgtype.Numeric `db:"total_price" json:"total_price"`
	// Tax rate applied to this line item.
	TaxRate pgtype.Numeric `db:"tax_rate" json:"tax_rate"`
	// Tax amount for this line item (automatically calculated).
	TaxAmount pgtype.Numeric `db:"tax_amount" json:"tax_amount"`
	// Discount rate applied to this line item.
	DiscountRate pgtype.Numeric `db:"discount_rate" json:"discount_rate"`
	// Discount amount for this line item (automatically calculated).
	DiscountAmount pgtype.Numeric `db:"discount_amount" json:"discount_amount"`
	// Final total including tax and discounts (automatically calculated).
	LineTotal pgtype.Numeric `db:"line_total" json:"line_total"`
	// Timestamp when the line item was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the line item was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type BillingInvoiceLineItemsView struct {
	ID               pgtype.UUID      `db:"id" json:"id"`
	InvoiceID        pgtype.UUID      `db:"invoice_id" json:"invoice_id"`
	SourceRecordID   pgtype.UUID      `db:"source_record_id" json:"source_record_id"`
	SourceRecordType pgtype.Text      `db:"source_record_type" json:"source_record_type"`
	Description      string           `db:"description" json:"description"`
	Quantity         pgtype.Numeric   `db:"quantity" json:"quantity"`
	UnitPrice        pgtype.Numeric   `db:"unit_price" json:"unit_price"`
	TotalPrice       pgtype.Numeric   `db:"total_price" json:"total_price"`
	TaxRate          pgtype.Numeric   `db:"tax_rate" json:"tax_rate"`
	TaxAmount        pgtype.Numeric   `db:"tax_amount" json:"tax_amount"`
	DiscountRate     pgtype.Numeric   `db:"discount_rate" json:"discount_rate"`
	DiscountAmount   pgtype.Numeric   `db:"discount_amount" json:"discount_amount"`
	LineTotal        pgtype.Numeric   `db:"line_total" json:"line_total"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Disputes         []BillingDispute `db:"disputes" json:"disputes"`
}

type BillingInvoicesView struct {
	ID                pgtype.UUID                   `db:"id" json:"id"`
	ClientID          pgtype.UUID                   `db:"client_id" json:"client_id"`
	QuoteID           pgtype.UUID                   `db:"quote_id" json:"quote_id"`
	InvoiceNumber     string                        `db:"invoice_number" json:"invoice_number"`
	Status            NullBillingInvoiceStatusEnum  `db:"status" json:"status"`
	IssueDate         pgtype.Date                   `db:"issue_date" json:"issue_date"`
	DueDate           pgtype.Date                   `db:"due_date" json:"due_date"`
	TotalAmount       pgtype.Numeric                `db:"total_amount" json:"total_amount"`
	AmountPaid        pgtype.Numeric                `db:"amount_paid" json:"amount_paid"`
	AmountOutstanding pgtype.Numeric                `db:"amount_outstanding" json:"amount_outstanding"`
	Currency          pgtype.Text                   `db:"currency" json:"currency"`
	TaxAmount         pgtype.Numeric                `db:"tax_amount" json:"tax_amount"`
	DiscountAmount    pgtype.Numeric                `db:"discount_amount" json:"discount_amount"`
	Subtotal          pgtype.Numeric                `db:"subtotal" json:"subtotal"`
	PaymentTerms      pgtype.Text                   `db:"payment_terms" json:"payment_terms"`
	Notes             pgtype.Text                   `db:"notes" json:"notes"`
	SentAt            pgtype.Timestamp              `db:"sent_at" json:"sent_at"`
	PaidAt            pgtype.Timestamp              `db:"paid_at" json:"paid_at"`
	CreatedByUserID   pgtype.Text                   `db:"created_by_user_id" json:"created_by_user_id"`
	CreatedAt         pgtype.Timestamp              `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp              `db:"updated_at" json:"updated_at"`
	InvoiceLineItems  []BillingInvoiceLineItemsView `db:"invoice_line_items" json:"invoice_line_items"`
	Payments          []BillingPayment              `db:"payments" json:"payments"`
	CreditNotes       []BillingCreditNote           `db:"credit_notes" json:"credit_notes"`
}

// Records of payments received against invoices.
type BillingPayment struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the invoice being paid.
	InvoiceID pgtype.UUID `db:"invoice_id" json:"invoice_id"`
	// Payment amount.
	Amount pgtype.Numeric `db:"amount" json:"amount"`
	// How the payment was made using payment_method_enum.
	PaymentMethod BillingPaymentMethodEnum `db:"payment_method" json:"payment_method"`
	// Reference from payment gateway or internal system.
	TransactionID pgtype.Text `db:"transaction_id" json:"transaction_id"`
	// Payment gateway transaction reference.
	GatewayReference pgtype.Text `db:"gateway_reference" json:"gateway_reference"`
	// Payment processing status using payment_status_enum.
	Status NullBillingPaymentStatusEnum `db:"status" json:"status"`
	// When the payment was initiated.
	PaymentDate pgtype.Timestamp `db:"payment_date" json:"payment_date"`
	// When the payment was successfully processed.
	ProcessedAt pgtype.Timestamp `db:"processed_at" json:"processed_at"`
	// Currency of the payment.
	Currency pgtype.Text `db:"currency" json:"currency"`
	// Exchange rate used for currency conversion.
	ExchangeRate pgtype.Numeric `db:"exchange_rate" json:"exchange_rate"`
	// Processing fees deducted from the payment.
	Fees pgtype.Numeric `db:"fees" json:"fees"`
	// Net amount after fees (automatically calculated).
	NetAmount pgtype.Numeric `db:"net_amount" json:"net_amount"`
	// Additional notes about the payment.
	Notes pgtype.Text `db:"notes" json:"notes"`
	// User who processed this payment.
	ProcessedByUserID pgtype.Text `db:"processed_by_user_id" json:"processed_by_user_id"`
	// Timestamp when the payment was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the payment was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Price estimates provided to clients before services are performed.
type BillingQuote struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the client requesting the quote (optional for anonymous quotes).
	ClientID pgtype.UUID `db:"client_id" json:"client_id"`
	// Pickup location information.
	OriginDetails string `db:"origin_details" json:"origin_details"`
	// Delivery location information.
	DestinationDetails string `db:"destination_details" json:"destination_details"`
	// Package weight for pricing calculation.
	Weight pgtype.Numeric `db:"weight" json:"weight"`
	// Package length dimension.
	Length pgtype.Numeric `db:"length" json:"length"`
	// Package width dimension.
	Width pgtype.Numeric `db:"width" json:"width"`
	// Package height dimension.
	Height pgtype.Numeric `db:"height" json:"height"`
	// Package volume (automatically calculated from dimensions).
	Volume pgtype.Numeric `db:"volume" json:"volume"`
	// Calculated price for the requested service.
	QuotedPrice pgtype.Numeric `db:"quoted_price" json:"quoted_price"`
	// Type of service quoted (e.g., standard, express).
	ServiceLevel pgtype.Text `db:"service_level" json:"service_level"`
	// When the quote becomes invalid.
	ExpiresAt pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	// Current quote status using quote_status_enum.
	Status NullBillingQuoteStatusEnum `db:"status" json:"status"`
	// Unique quote reference number.
	QuoteNumber pgtype.Text `db:"quote_number" json:"quote_number"`
	// Additional notes about the quote.
	Notes pgtype.Text `db:"notes" json:"notes"`
	// User who created this quote.
	CreatedByUserID pgtype.Text `db:"created_by_user_id" json:"created_by_user_id"`
	// Timestamp when the quote was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the quote was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type BillingQuotesView struct {
	ID                 pgtype.UUID                `db:"id" json:"id"`
	ClientID           pgtype.UUID                `db:"client_id" json:"client_id"`
	OriginDetails      string                     `db:"origin_details" json:"origin_details"`
	DestinationDetails string                     `db:"destination_details" json:"destination_details"`
	Weight             pgtype.Numeric             `db:"weight" json:"weight"`
	Length             pgtype.Numeric             `db:"length" json:"length"`
	Width              pgtype.Numeric             `db:"width" json:"width"`
	Height             pgtype.Numeric             `db:"height" json:"height"`
	Volume             pgtype.Numeric             `db:"volume" json:"volume"`
	QuotedPrice        pgtype.Numeric             `db:"quoted_price" json:"quoted_price"`
	ServiceLevel       pgtype.Text                `db:"service_level" json:"service_level"`
	ExpiresAt          pgtype.Timestamp           `db:"expires_at" json:"expires_at"`
	Status             NullBillingQuoteStatusEnum `db:"status" json:"status"`
	QuoteNumber        pgtype.Text                `db:"quote_number" json:"quote_number"`
	Notes              pgtype.Text                `db:"notes" json:"notes"`
	CreatedByUserID    pgtype.Text                `db:"created_by_user_id" json:"created_by_user_id"`
	CreatedAt          pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt          pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	Invoices           []BillingInvoicesView      `db:"invoices" json:"invoices"`
}

// Defines pricing structures for different services offered by the logistics company.
type BillingRateCard struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Descriptive name for the rate card (e.g., "Standard Shipping Rates 2025").
	Name string `db:"name" json:"name"`
	// Category of service being priced using service_type_enum.
	ServiceType BillingServiceTypeEnum `db:"service_type" json:"service_type"`
	// Whether this rate card is currently in use.
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
	// Date when the rate card becomes effective.
	ValidFrom pgtype.Date `db:"valid_from" json:"valid_from"`
	// Date when the rate card expires.
	ValidTo pgtype.Date `db:"valid_to" json:"valid_to"`
	// Additional details about the rate card.
	Description pgtype.Text `db:"description" json:"description"`
	// User who created this rate card.
	CreatedByUserID pgtype.Text `db:"created_by_user_id" json:"created_by_user_id"`
	// Timestamp when the rate card was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the rate card was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type BillingRateCardsView struct {
	ID              pgtype.UUID            `db:"id" json:"id"`
	Name            string                 `db:"name" json:"name"`
	ServiceType     BillingServiceTypeEnum `db:"service_type" json:"service_type"`
	IsActive        pgtype.Bool            `db:"is_active" json:"is_active"`
	ValidFrom       pgtype.Date            `db:"valid_from" json:"valid_from"`
	ValidTo         pgtype.Date            `db:"valid_to" json:"valid_to"`
	Description     pgtype.Text            `db:"description" json:"description"`
	CreatedByUserID pgtype.Text            `db:"created_by_user_id" json:"created_by_user_id"`
	CreatedAt       pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	RateRules       []BillingRateRule      `db:"rate_rules" json:"rate_rules"`
}

// Specific pricing rules within a rate card that determine costs based on various conditions.
type BillingRateRule struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the parent rate card.
	RateCardID pgtype.UUID `db:"rate_card_id" json:"rate_card_id"`
	// Condition that must be met for this rule to apply (e.g., weight_gt, zone_eq).
	Condition string `db:"condition" json:"condition"`
	// Value for the condition (e.g., "5kg", "Zone A").
	Value string `db:"value" json:"value"`
	// Price amount when this rule applies.
	Price pgtype.Numeric `db:"price" json:"price"`
	// How the price is calculated using pricing_model_enum.
	PricingModel BillingPricingModelEnum `db:"pricing_model" json:"pricing_model"`
	// Minimum value for range-based conditions.
	MinValue pgtype.Numeric `db:"min_value" json:"min_value"`
	// Maximum value for range-based conditions.
	MaxValue pgtype.Numeric `db:"max_value" json:"max_value"`
	// Rule precedence when multiple rules could apply (lower = higher priority).
	Priority pgtype.Int4 `db:"priority" json:"priority"`
	// Whether this rule is currently active.
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
	// Timestamp when the rate rule was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the rate rule was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Additional charges that can be applied to base pricing for special circumstances.
type BillingSurcharge struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Name of the surcharge (e.g., "Fuel Surcharge", "Peak Season Fee").
	Name string `db:"name" json:"name"`
	// Category of surcharge (e.g., fuel, seasonal, handling).
	Type string `db:"type" json:"type"`
	// Surcharge amount or percentage.
	Amount pgtype.Numeric `db:"amount" json:"amount"`
	// How the surcharge is calculated using surcharge_calculation_method_enum.
	CalculationMethod BillingSurchargeCalculationMethodEnum `db:"calculation_method" json:"calculation_method"`
	// Whether this surcharge is currently being applied.
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
	// Date when the surcharge becomes effective.
	ValidFrom pgtype.Date `db:"valid_from" json:"valid_from"`
	// Date when the surcharge expires.
	ValidTo pgtype.Date `db:"valid_to" json:"valid_to"`
	// Additional details about the surcharge.
	Description pgtype.Text `db:"description" json:"description"`
	// Timestamp when the surcharge was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the surcharge was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Allows files to be attached to various records (e.g., contacts, opportunities, cases) for additional context.
type CrmAttachment struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Name of the attached file.
	FileName string `db:"file_name" fake:"{word}.{fileextension}" json:"file_name"`
	// Storage path for the file.
	FilePath string `db:"file_path" fake:"/{hackerphrase}" json:"file_path"`
	// File MIME type (e.g., image/png, application/pdf).
	MimeType pgtype.Text `db:"mime_type" fake:"{filemimetype}" json:"mime_type"`
	// Identifier for the record the attachment is associated with.
	RecordID pgtype.UUID `db:"record_id" json:"record_id"`
	// Type of record (polymorphic).
	RecordType NullCrmRecordType `db:"record_type" json:"record_type"`
	// timestamptz when the attachment was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the attachment was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Tracks marketing initiatives to measure their effectiveness in generating leads and opportunities.
type CrmCampaign struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Campaign title.
	Name string `db:"name" fake:"{hackerphrase}" json:"name"`
	// Allocated budget for the campaign.
	Budget pgtype.Numeric `db:"budget" fake:"{price:1000,100000}" json:"budget"`
	// Campaign start date.
	StartDate pgtype.Date `db:"start_date" fake:"{date}" json:"start_date"`
	// Campaign end date.
	EndDate pgtype.Date `db:"end_date" fake:"{date}" json:"end_date"`
	// timestamptz when the campaign was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the campaign was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Tracks customer support issues or requests from creation to resolution.
type CrmCase struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Unique number assigned to the case.
	CaseNumber string `db:"case_number" fake:"{uuid}" json:"case_number"`
	// Current case status.
	Status NullCrmCaseStatus `db:"status" json:"status"`
	// Level of urgency (e.g., low, medium, high).
	Priority NullCrmCasePriority `db:"priority" json:"priority"`
	// Type of case (e.g., question, problem).
	Type NullCrmCaseType `db:"type" json:"type"`
	// User responsible for handling the case.
	OwnerID string `db:"owner_id" json:"owner_id"`
	// Linked contact for context.
	ContactID pgtype.UUID `db:"contact_id" json:"contact_id"`
	// Detailed description of the issue.
	Description pgtype.Text `db:"description" fake:"{sentence}" json:"description"`
	// timestamptz when the case was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the case was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Stores information about customer organizations. This is a central entity for linking contacts, opportunities, and cases.
type CrmCompany struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Company name.
	Name string `db:"name" fake:"{company}" json:"name"`
	// Street address.
	Street pgtype.Text `db:"street" fake:"{street}" json:"street"`
	// City location.
	City pgtype.Text `db:"city" fake:"{city}" json:"city"`
	// State or province.
	State pgtype.Text `db:"state" fake:"{state}" json:"state"`
	// Postal or ZIP code.
	PostalCode pgtype.Text `db:"postal_code" fake:"{zip}" json:"postal_code"`
	// Country of operation.
	Country pgtype.Text `db:"country" fake:"{country}" json:"country"`
	// Company contact number.
	PhoneNumber pgtype.Text `db:"phone_number" fake:"{phone}" json:"phone_number"`
	// Sector or industry type.
	Industry pgtype.Text `db:"industry" fake:"{jobdescriptor}" json:"industry"`
	// Company website URL.
	Website pgtype.Text `db:"website" fake:"{url}" json:"website"`
	// Yearly revenue figure.
	AnnualRevenue pgtype.Numeric `db:"annual_revenue" fake:"{price:100000,100000000}" json:"annual_revenue"`
	// Reference to the user who owns the company record.
	OwnerID pgtype.Text `db:"owner_id" json:"owner_id"`
	// timestamptz when the company was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the company was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Represents individuals associated with companies, serving as the primary points of interaction.
type CrmContact struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Full name of the contact.
	Name string `db:"name" fake:"{name}" json:"name"`
	// Contact's email address.
	Email string `db:"email" fake:"{email}" json:"email"`
	// Contact's telephone number.
	PhoneNumber pgtype.Text `db:"phone_number" fake:"{phone}" json:"phone_number"`
	// Job designation or position.
	JobTitle pgtype.Text `db:"job_title" fake:"{jobtitle}" json:"job_title"`
	// Identifier linking to the associated company.
	CompanyID pgtype.UUID `db:"company_id" json:"company_id"`
	// Reference to the user responsible for the contact.
	OwnerID string `db:"owner_id" json:"owner_id"`
	// timestamptz when the contact was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the contact was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Logs all communications and activities with contacts, providing a complete history of customer engagement.
type CrmInteraction struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Linked contact for the interaction.
	ContactID pgtype.UUID `db:"contact_id" json:"contact_id"`
	// User who performed the interaction.
	UserID string `db:"user_id" json:"user_id"`
	// Associated case (if applicable).
	CaseID pgtype.UUID `db:"case_id" json:"case_id"`
	// Type of interaction (e.g., call, meeting, email).
	Type NullCrmInteractionType `db:"type" json:"type"`
	// Result of the interaction (e.g., meeting scheduled).
	Outcome pgtype.Text `db:"outcome" fake:"{randomstring:[meeting scheduled,call back later,deal closed,deal lost]}" json:"outcome"`
	// Additional details or comments.
	Notes pgtype.Text `db:"notes" fake:"{paragraph}" json:"notes"`
	// Date and time of the interaction.
	InteractionDate pgtype.Timestamptz `db:"interaction_date" fake:"{date}" json:"interaction_date"`
	// timestamptz when the interaction was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the interaction was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Generates and tracks billing records for products or services sold in an opportunity.
type CrmInvoice struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Associated sales opportunity.
	OpportunityID pgtype.UUID `db:"opportunity_id" json:"opportunity_id"`
	// Current status of the invoice (e.g., draft, sent, paid).
	Status NullCrmInvoiceStatus `db:"status" json:"status"`
	// Total amount billed.
	Total pgtype.Numeric `db:"total" fake:"{price:100,10000}" json:"total"`
	// Date on which the invoice was issued.
	IssueDate pgtype.Date `db:"issue_date" fake:"{date}" json:"issue_date"`
	// Payment due date.
	DueDate pgtype.Date `db:"due_date" fake:"{date}" json:"due_date"`
	// timestamptz when the invoice was sent.
	SentAt pgtype.Timestamptz `db:"sent_at" fake:"{date}" json:"sent_at"`
	// timestamptz when payment was received.
	PaidAt pgtype.Timestamptz `db:"paid_at" fake:"{date}" json:"paid_at"`
	// Method used for payment.
	PaymentMethod NullCrmPaymentMethod `db:"payment_method" json:"payment_method"`
	// timestamptz when the invoice was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the invoice was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Details the line items on an invoice, including products, quantities, and prices.
type CrmInvoiceItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Linked invoice record.
	InvoiceID pgtype.UUID `db:"invoice_id" json:"invoice_id"`
	// Associated product for the line item.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// Quantity of the product.
	Quantity int32 `db:"quantity" fake:"{number:1,20}" json:"quantity"`
	// Price per unit for the product.
	Price pgtype.Numeric `db:"price" fake:"{price:10,500}" json:"price"`
	// timestamptz when the invoice item was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the invoice item was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

type CrmInvoicesView struct {
	ID            pgtype.UUID          `db:"id" json:"id"`
	OpportunityID pgtype.UUID          `db:"opportunity_id" json:"opportunity_id"`
	Status        NullCrmInvoiceStatus `db:"status" json:"status"`
	Total         pgtype.Numeric       `db:"total" json:"total"`
	IssueDate     pgtype.Date          `db:"issue_date" json:"issue_date"`
	DueDate       pgtype.Date          `db:"due_date" json:"due_date"`
	SentAt        pgtype.Timestamptz   `db:"sent_at" json:"sent_at"`
	PaidAt        pgtype.Timestamptz   `db:"paid_at" json:"paid_at"`
	PaymentMethod NullCrmPaymentMethod `db:"payment_method" json:"payment_method"`
	CreatedAt     pgtype.Timestamptz   `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamptz   `db:"updated_at" json:"updated_at"`
	Items         []CrmInvoiceItem     `db:"items" json:"items"`
}

// Captures potential customers who have shown interest but are not yet qualified.
type CrmLead struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Lead's full name.
	Name string `db:"name" fake:"{name}" json:"name"`
	// Lead's email address.
	Email string `db:"email" fake:"{email}" json:"email"`
	// Origin of the lead information.
	LeadSource NullCrmLeadSource `db:"lead_source" json:"lead_source"`
	// Current qualification status.
	Status NullCrmLeadStatus `db:"status" json:"status"`
	// Numerical score reflecting lead quality.
	LeadScore pgtype.Int4 `db:"lead_score" fake:"{number:1,100}" json:"lead_score"`
	// User responsible for the lead.
	OwnerID string `db:"owner_id" json:"owner_id"`
	// Associated marketing campaign.
	CampaignID pgtype.UUID `db:"campaign_id" json:"campaign_id"`
	// timestamptz when the lead was converted.
	ConvertedAt pgtype.Timestamptz `db:"converted_at" fake:"{date}" json:"converted_at"`
	// Reference to the created contact upon conversion.
	ConvertedContactID pgtype.UUID `db:"converted_contact_id" json:"converted_contact_id"`
	// Reference to the company record created upon conversion.
	ConvertedCompanyID pgtype.UUID `db:"converted_company_id" json:"converted_company_id"`
	// Reference to the opportunity created upon conversion.
	ConvertedOpportunityID pgtype.UUID `db:"converted_opportunity_id" json:"converted_opportunity_id"`
	// timestamptz when the lead was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the lead was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Provides an in-app system for alerting users about important events, such as new lead assignments.
type CrmNotification struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// User receiving the notification.
	UserID string `db:"user_id" json:"user_id"`
	// Notification content.
	Message string `db:"message" fake:"{sentence}" json:"message"`
	// Boolean indicating if the notification has been read.
	IsRead pgtype.Bool `db:"is_read" json:"is_read"`
	// timestamptz when the notification was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the notification was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	// URL or path for further action/reference.
	Link pgtype.Text `db:"link" fake:"{url}" json:"link"`
}

type CrmOpportunitiesView struct {
	ID                pgtype.UUID              `db:"id" json:"id"`
	Name              string                   `db:"name" json:"name"`
	Stage             NullCrmOpportunityStage  `db:"stage" json:"stage"`
	DealValue         pgtype.Numeric           `db:"deal_value" json:"deal_value"`
	Probability       pgtype.Float4            `db:"probability" json:"probability"`
	ExpectedCloseDate pgtype.Date              `db:"expected_close_date" json:"expected_close_date"`
	LostReason        pgtype.Text              `db:"lost_reason" json:"lost_reason"`
	Source            NullCrmOpportunitySource `db:"source" json:"source"`
	OwnerID           string                   `db:"owner_id" json:"owner_id"`
	ContactID         pgtype.UUID              `db:"contact_id" json:"contact_id"`
	CompanyID         pgtype.UUID              `db:"company_id" json:"company_id"`
	CampaignID        pgtype.UUID              `db:"campaign_id" json:"campaign_id"`
	CreatedAt         pgtype.Timestamptz       `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamptz       `db:"updated_at" json:"updated_at"`
	Products          []CrmOpportunityProduct  `db:"products" json:"products"`
}

// Represents potential sales deals, tracked through various stages of the sales pipeline.
type CrmOpportunity struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Opportunity title.
	Name string `db:"name" fake:"{bs}" json:"name"`
	// Current stage in the sales pipeline.
	Stage NullCrmOpportunityStage `db:"stage" json:"stage"`
	// Potential deal amount.
	DealValue pgtype.Numeric `db:"deal_value" fake:"{price:1000,500000}" json:"deal_value"`
	// Likelihood of closing, represented as a fraction or percentage.
	Probability pgtype.Float4 `db:"probability" fake:"{float32range:0,1}" json:"probability"`
	// Anticipated date for closing the opportunity.
	ExpectedCloseDate pgtype.Date `db:"expected_close_date" fake:"{date}" json:"expected_close_date"`
	// Explanation for why the opportunity was lost.
	LostReason pgtype.Text `db:"lost_reason" fake:"{sentence}" json:"lost_reason"`
	// Origin of the opportunity (e.g., website, referral).
	Source NullCrmOpportunitySource `db:"source" json:"source"`
	// User responsible for the opportunity.
	OwnerID string `db:"owner_id" json:"owner_id"`
	// Associated contact.
	ContactID pgtype.UUID `db:"contact_id" json:"contact_id"`
	// Linked company record.
	CompanyID pgtype.UUID `db:"company_id" json:"company_id"`
	// Related campaign.
	CampaignID pgtype.UUID `db:"campaign_id" json:"campaign_id"`
	// timestamptz when the opportunity was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the opportunity was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Links products from the catalog to specific sales opportunities, detailing what is being sold.
type CrmOpportunityProduct struct {
	// Identifier linking to the related opportunity.
	OpportunityID pgtype.UUID `db:"opportunity_id" json:"opportunity_id"`
	// Identifier linking to the product.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// Number of units associated with the opportunity.
	Quantity int32       `db:"quantity" fake:"{number:1,10}" json:"quantity"`
	ID       pgtype.UUID `db:"id" json:"id"`
}

// Manages the catalog of goods or services that can be sold to customers.
type CrmProduct struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Name of the product or service.
	Name string `db:"name" fake:"{productname}" json:"name"`
	// Stock keeping unit identifier.
	Sku pgtype.Text `db:"sku" fake:"{productupc}" json:"sku"`
	// Cost of the product.
	Price pgtype.Numeric `db:"price" fake:"{price:1,1000}" json:"price"`
	// Type of offering (e.g., service, good).
	Type NullCrmProductType `db:"type" json:"type"`
	// Description or details about the product.
	Description pgtype.Text `db:"description" fake:"{productdescription}" json:"description"`
	// timestamptz when the product was created.
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	// timestamptz when the product was last updated.
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Provides customers with secure, unique links to track their deliveries in real-time.
type DmsCustomerTrackingLink struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the delivery task being tracked.
	DeliveryTaskID pgtype.UUID `db:"delivery_task_id" json:"delivery_task_id"`
	// Unique, unguessable identifier for secure access.
	TrackingToken string `db:"tracking_token" fake:"{uuid}" json:"tracking_token"`
	// Whether the tracking link is currently valid.
	IsActive pgtype.Bool `db:"is_active" fake:"{bool}" json:"is_active"`
	// Number of times the tracking link has been accessed.
	AccessCount pgtype.Int4 `db:"access_count" fake:"{number:0,100}" json:"access_count"`
	// When the tracking link was last accessed.
	LastAccessedAt pgtype.Timestamp `db:"last_accessed_at" fake:"{date}" json:"last_accessed_at"`
	// When the tracking link will expire.
	ExpiresAt pgtype.Timestamp `db:"expires_at" fake:"{date}" json:"expires_at"`
	// Timestamp when the customer tracking link was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the customer tracking link was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Represents planned routes for drivers, optimized for efficiency and containing multiple delivery tasks.
type DmsDeliveryRoute struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the assigned driver from the TMS.
	DriverID pgtype.UUID `db:"driver_id" json:"driver_id"`
	// Scheduled date for the delivery route.
	RouteDate pgtype.Date `db:"route_date" fake:"{date}" json:"route_date"`
	// Current state of the route using delivery_route_status_enum.
	Status NullDmsDeliveryRouteStatusEnum `db:"status" json:"status"`
	// Stored route optimization data such as polylines and turn-by-turn directions.
	OptimizedRouteData pgtype.Text `db:"optimized_route_data" fake:"{sentence}" json:"optimized_route_data"`
	// Total distance of the route in kilometers.
	TotalDistanceKm pgtype.Float4 `db:"total_distance_km" fake:"{float64range:5,100}" json:"total_distance_km"`
	// Estimated time to complete the entire route in minutes.
	EstimatedDurationMinutes pgtype.Int4 `db:"estimated_duration_minutes" fake:"{number:30,240}" json:"estimated_duration_minutes"`
	// Actual time taken to complete the route in minutes (automatically calculated from start and completion times).
	ActualDurationMinutes pgtype.Int4 `db:"actual_duration_minutes" json:"actual_duration_minutes"`
	// When the route was started.
	StartedAt pgtype.Timestamp `db:"started_at" fake:"{date}" json:"started_at"`
	// When the route was completed.
	CompletedAt pgtype.Timestamp `db:"completed_at" fake:"{date}" json:"completed_at"`
	// Timestamp when the delivery route was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the delivery route was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type DmsDeliveryRoutesView struct {
	ID                       pgtype.UUID                    `db:"id" json:"id"`
	DriverID                 pgtype.UUID                    `db:"driver_id" json:"driver_id"`
	RouteDate                pgtype.Date                    `db:"route_date" json:"route_date"`
	Status                   NullDmsDeliveryRouteStatusEnum `db:"status" json:"status"`
	OptimizedRouteData       pgtype.Text                    `db:"optimized_route_data" json:"optimized_route_data"`
	TotalDistanceKm          pgtype.Float4                  `db:"total_distance_km" json:"total_distance_km"`
	EstimatedDurationMinutes pgtype.Int4                    `db:"estimated_duration_minutes" json:"estimated_duration_minutes"`
	ActualDurationMinutes    pgtype.Int4                    `db:"actual_duration_minutes" json:"actual_duration_minutes"`
	StartedAt                pgtype.Timestamp               `db:"started_at" json:"started_at"`
	CompletedAt              pgtype.Timestamp               `db:"completed_at" json:"completed_at"`
	CreatedAt                pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt                pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	DeliveryTasks            []DmsDeliveryTasksView         `db:"delivery_tasks" json:"delivery_tasks"`
}

// Individual delivery tasks within a route, each corresponding to a specific package that needs to be delivered.
type DmsDeliveryTask struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the package from the WMS.
	PackageID pgtype.UUID `db:"package_id" json:"package_id"`
	// Reference to the delivery route this task belongs to.
	DeliveryRouteID pgtype.UUID `db:"delivery_route_id" json:"delivery_route_id"`
	// Order of this delivery within the route.
	RouteSequence int32 `db:"route_sequence" fake:"{number:1,20}" json:"route_sequence"`
	// The address where the package should be delivered.
	DeliveryAddress string `db:"delivery_address" fake:"{streetaddress}" json:"delivery_address"`
	// Name of the person receiving the package.
	RecipientName pgtype.Text `db:"recipient_name" fake:"{name}" json:"recipient_name"`
	// Phone number of the recipient.
	RecipientPhone pgtype.Text `db:"recipient_phone" fake:"{phone}" json:"recipient_phone"`
	// Special instructions for the delivery.
	DeliveryInstructions pgtype.Text `db:"delivery_instructions" fake:"{sentence}" json:"delivery_instructions"`
	// Calculated time when the delivery is expected.
	EstimatedArrivalTime pgtype.Timestamp `db:"estimated_arrival_time" fake:"{date}" json:"estimated_arrival_time"`
	// When the driver actually arrived at the delivery location.
	ActualArrivalTime pgtype.Timestamp `db:"actual_arrival_time" fake:"{date}" json:"actual_arrival_time"`
	// When the package was successfully delivered.
	DeliveryTime pgtype.Timestamp `db:"delivery_time" fake:"{date}" json:"delivery_time"`
	// Current status of the delivery task using delivery_task_status_enum.
	Status NullDmsDeliveryTaskStatusEnum `db:"status" json:"status"`
	// Reason for delivery failure using delivery_failure_reason_enum.
	FailureReason NullDmsDeliveryFailureReasonEnum `db:"failure_reason" json:"failure_reason"`
	// Number of delivery attempts made.
	AttemptCount pgtype.Int4 `db:"attempt_count" fake:"{number:0,3}" json:"attempt_count"`
	// Timestamp when the delivery task was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the delivery task was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type DmsDeliveryTasksView struct {
	ID                    pgtype.UUID                      `db:"id" json:"id"`
	PackageID             pgtype.UUID                      `db:"package_id" json:"package_id"`
	DeliveryRouteID       pgtype.UUID                      `db:"delivery_route_id" json:"delivery_route_id"`
	RouteSequence         int32                            `db:"route_sequence" json:"route_sequence"`
	DeliveryAddress       string                           `db:"delivery_address" json:"delivery_address"`
	RecipientName         pgtype.Text                      `db:"recipient_name" json:"recipient_name"`
	RecipientPhone        pgtype.Text                      `db:"recipient_phone" json:"recipient_phone"`
	DeliveryInstructions  pgtype.Text                      `db:"delivery_instructions" json:"delivery_instructions"`
	EstimatedArrivalTime  pgtype.Timestamp                 `db:"estimated_arrival_time" json:"estimated_arrival_time"`
	ActualArrivalTime     pgtype.Timestamp                 `db:"actual_arrival_time" json:"actual_arrival_time"`
	DeliveryTime          pgtype.Timestamp                 `db:"delivery_time" json:"delivery_time"`
	Status                NullDmsDeliveryTaskStatusEnum    `db:"status" json:"status"`
	FailureReason         NullDmsDeliveryFailureReasonEnum `db:"failure_reason" json:"failure_reason"`
	AttemptCount          pgtype.Int4                      `db:"attempt_count" json:"attempt_count"`
	CreatedAt             pgtype.Timestamp                 `db:"created_at" json:"created_at"`
	UpdatedAt             pgtype.Timestamp                 `db:"updated_at" json:"updated_at"`
	TaskEvents            []DmsTaskEvent                   `db:"task_events" json:"task_events"`
	ProofOfDeliveries     []DmsProofOfDelivery             `db:"proof_of_deliveries" json:"proof_of_deliveries"`
	CustomerTrackingLinks []DmsCustomerTrackingLink        `db:"customer_tracking_links" json:"customer_tracking_links"`
}

// Real-time location tracking for drivers, enabling accurate ETAs and route monitoring.
type DmsDriverLocation struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the driver from the TMS.
	DriverID pgtype.UUID `db:"driver_id" json:"driver_id"`
	// Geographic latitude coordinate.
	Latitude float32 `db:"latitude" fake:"{latitude}" json:"latitude"`
	// Geographic longitude coordinate.
	Longitude float32 `db:"longitude" fake:"{longitude}" json:"longitude"`
	// Altitude in meters above sea level.
	Altitude pgtype.Float4 `db:"altitude" fake:"{float64range:0,1000}" json:"altitude"`
	// GPS accuracy in meters.
	Accuracy pgtype.Float4 `db:"accuracy" fake:"{float64range:0,100}" json:"accuracy"`
	// Current speed in kilometers per hour.
	SpeedKmh pgtype.Float4 `db:"speed_kmh" fake:"{float64range:0,120}" json:"speed_kmh"`
	// Direction of travel in degrees (0-359).
	Heading pgtype.Float4 `db:"heading" fake:"{float64range:0,360}" json:"heading"`
	// When the location was recorded.
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
	// Timestamp when the driver location was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the driver location was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Stores evidence of successful deliveries, such as signatures or photos, ensuring accountability and customer satisfaction.
type DmsProofOfDelivery struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the completed delivery task.
	DeliveryTaskID pgtype.UUID `db:"delivery_task_id" json:"delivery_task_id"`
	// Type of proof collected using proof_of_delivery_type_enum.
	Type DmsProofOfDeliveryTypeEnum `db:"type" json:"type"`
	// Storage location of the proof file (for photos).
	FilePath pgtype.Text `db:"file_path" fake:"/{hackerphrase}" json:"file_path"`
	// Digital signature data (for signature proofs).
	SignatureData pgtype.Text `db:"signature_data" fake:"{sentence}" json:"signature_data"`
	// Name of the person who received the package.
	RecipientName pgtype.Text `db:"recipient_name" fake:"{name}" json:"recipient_name"`
	// Code used for verification deliveries.
	VerificationCode pgtype.Text `db:"verification_code" fake:"{uuid}" json:"verification_code"`
	// Geographic latitude where proof was collected.
	Latitude pgtype.Float4 `db:"latitude" fake:"{latitude}" json:"latitude"`
	// Geographic longitude where proof was collected.
	Longitude pgtype.Float4 `db:"longitude" fake:"{longitude}" json:"longitude"`
	// When the proof was collected.
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
	// Timestamp when the proof of delivery was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the proof of delivery was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Tracks status changes and events for delivery tasks, providing a detailed audit trail of the delivery process.
type DmsTaskEvent struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the associated delivery task.
	DeliveryTaskID pgtype.UUID `db:"delivery_task_id" json:"delivery_task_id"`
	// The event status being recorded using task_event_status_enum.
	Status DmsTaskEventStatusEnum `db:"status" json:"status"`
	// Additional context for the status change (e.g., "recipient not home").
	Reason pgtype.Text `db:"reason" fake:"{sentence}" json:"reason"`
	// Additional notes about the event.
	Notes pgtype.Text `db:"notes" fake:"{paragraph}" json:"notes"`
	// Geographic latitude where the event occurred.
	Latitude pgtype.Float4 `db:"latitude" fake:"{latitude}" json:"latitude"`
	// Geographic longitude where the event occurred.
	Longitude pgtype.Float4 `db:"longitude" fake:"{longitude}" json:"longitude"`
	// When the event occurred.
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
	// Timestamp when the task event was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the task event was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type Session struct {
	ID             string             `db:"id" json:"id"`
	ExpiresAt      pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	Token          string             `db:"token" json:"token"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	IpAddress      pgtype.Text        `db:"ip_address" json:"ip_address"`
	UserAgent      pgtype.Text        `db:"user_agent" json:"user_agent"`
	UserID         string             `db:"user_id" json:"user_id"`
	ImpersonatedBy pgtype.Text        `db:"impersonated_by" json:"impersonated_by"`
}

// Information about third-party transportation providers and partners.
type TmsCarrier struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Carrier company name.
	Name string `db:"name" fake:"{company}" json:"name"`
	// Contact information for the carrier.
	ContactDetails pgtype.Text `db:"contact_details" fake:"{phone}" json:"contact_details"`
	// Description of transportation services provided.
	ServicesOffered pgtype.Text `db:"services_offered" fake:"{bs}" json:"services_offered"`
	// Timestamp when the carrier was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the carrier was last updated.
	UpdatedAt     pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	ContactPerson pgtype.Text      `db:"contact_person" json:"contact_person"`
	ContactEmail  pgtype.Text      `db:"contact_email" json:"contact_email"`
	ContactPhone  pgtype.Text      `db:"contact_phone" json:"contact_phone"`
}

// Pricing information for services provided by third-party carriers.
type TmsCarrierRate struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the carrier providing the service.
	CarrierID pgtype.UUID `db:"carrier_id" json:"carrier_id"`
	// Type of transportation service.
	ServiceType pgtype.Text `db:"service_type" fake:"{jobtitle}" json:"service_type"`
	// Starting location for the service.
	Origin pgtype.Text `db:"origin" fake:"{city}" json:"origin"`
	// Ending location for the service.
	Destination pgtype.Text `db:"destination" fake:"{city}" json:"destination"`
	// Cost for the service.
	Rate pgtype.Numeric `db:"rate" fake:"{price:100,5000}" json:"rate"`
	// Pricing unit using carrier_rate_unit_enum.
	Unit NullTmsCarrierRateUnitEnum `db:"unit" json:"unit"`
	// Timestamp when the rate was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the rate was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type TmsCarriersView struct {
	ID              pgtype.UUID         `db:"id" json:"id"`
	Name            string              `db:"name" json:"name"`
	ContactDetails  pgtype.Text         `db:"contact_details" json:"contact_details"`
	ServicesOffered pgtype.Text         `db:"services_offered" json:"services_offered"`
	CreatedAt       pgtype.Timestamp    `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp    `db:"updated_at" json:"updated_at"`
	ContactPerson   pgtype.Text         `db:"contact_person" json:"contact_person"`
	ContactEmail    pgtype.Text         `db:"contact_email" json:"contact_email"`
	ContactPhone    pgtype.Text         `db:"contact_phone" json:"contact_phone"`
	CarrierRates    []TmsCarrierRate    `db:"carrier_rates" json:"carrier_rates"`
	ShipmentLegs    []TmsShipmentLeg    `db:"shipment_legs" json:"shipment_legs"`
	PartnerInvoices []TmsPartnerInvoice `db:"partner_invoices" json:"partner_invoices"`
}

// Represents drivers who operate vehicles within the transportation fleet.
type TmsDriver struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the user account in the system.
	UserID string `db:"user_id" json:"user_id"`
	// Driver's license identification number.
	LicenseNumber string `db:"license_number" fake:"{uuid}" json:"license_number"`
	// When the driver's license expires.
	LicenseExpiryDate pgtype.Date `db:"license_expiry_date" fake:"{date}" json:"license_expiry_date"`
	// Current availability status using driver_status_enum.
	Status NullTmsDriverStatusEnum `db:"status" json:"status"`
	// Timestamp when the driver was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the driver was last updated.
	UpdatedAt    pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	ContactPhone pgtype.Text      `db:"contact_phone" json:"contact_phone"`
}

// Tracks driver availability and planned time off for scheduling purposes.
type TmsDriverSchedule struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the associated driver.
	DriverID pgtype.UUID `db:"driver_id" json:"driver_id"`
	// Beginning of the schedule period.
	StartDate pgtype.Date `db:"start_date" fake:"{date}" json:"start_date"`
	// End of the schedule period.
	EndDate pgtype.Date `db:"end_date" fake:"{date}" json:"end_date"`
	// Purpose of the schedule entry using driver_schedule_reason_enum.
	Reason NullTmsDriverScheduleReasonEnum `db:"reason" json:"reason"`
	// Timestamp when the schedule was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the schedule was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type TmsDriversView struct {
	ID                pgtype.UUID             `db:"id" json:"id"`
	UserID            string                  `db:"user_id" json:"user_id"`
	LicenseNumber     string                  `db:"license_number" json:"license_number"`
	LicenseExpiryDate pgtype.Date             `db:"license_expiry_date" json:"license_expiry_date"`
	Status            NullTmsDriverStatusEnum `db:"status" json:"status"`
	CreatedAt         pgtype.Timestamp        `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp        `db:"updated_at" json:"updated_at"`
	ContactPhone      pgtype.Text             `db:"contact_phone" json:"contact_phone"`
	DriverSchedules   []TmsDriverSchedule     `db:"driver_schedules" json:"driver_schedules"`
	Expenses          []TmsExpense            `db:"expenses" json:"expenses"`
	Trips             []TmsTrip               `db:"trips" json:"trips"`
}

// Tracks transportation-related expenses incurred during trips.
type TmsExpense struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the associated trip.
	TripID pgtype.UUID `db:"trip_id" json:"trip_id"`
	// Reference to the driver who logged the expense.
	DriverID pgtype.UUID `db:"driver_id" json:"driver_id"`
	// Category of expense using expense_type_enum.
	Type NullTmsExpenseTypeEnum `db:"type" json:"type"`
	// Financial amount of the expense.
	Amount pgtype.Numeric `db:"amount" fake:"{price:10,500}" json:"amount"`
	// Currency denomination using currency_enum.
	Currency NullTmsCurrencyEnum `db:"currency" json:"currency"`
	// Link to receipt or proof of purchase.
	ReceiptUrl pgtype.Text `db:"receipt_url" fake:"{url}" json:"receipt_url"`
	// Amount of fuel purchased (if applicable).
	FuelQuantity pgtype.Float4 `db:"fuel_quantity" fake:"{float64range:10,100}" json:"fuel_quantity"`
	// Vehicle odometer reading at time of expense.
	OdometerReading pgtype.Int4 `db:"odometer_reading" fake:"{number:10000,200000}" json:"odometer_reading"`
	// Approval status using expense_status_enum.
	Status NullTmsExpenseStatusEnum `db:"status" json:"status"`
	// Timestamp when the expense was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the expense was last updated.
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Description pgtype.Text      `db:"description" json:"description"`
	ExpenseDate pgtype.Date      `db:"expense_date" json:"expense_date"`
}

// Defines geographic boundaries for monitoring vehicle movements and triggering events.
type TmsGeofence struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Descriptive name for the geofenced area.
	Name string `db:"name" fake:"{city}" json:"name"`
	// Timestamp when the geofence was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the geofence was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Longitude pgtype.Float4    `db:"longitude" json:"longitude"`
	Latitude  pgtype.Float4    `db:"latitude" json:"latitude"`
}

// Records when vehicles enter or exit predefined geographic areas.
type TmsGeofenceEvent struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the vehicle that triggered the event.
	VehicleID pgtype.UUID `db:"vehicle_id" json:"vehicle_id"`
	// Reference to the geofenced area.
	GeofenceID pgtype.UUID `db:"geofence_id" json:"geofence_id"`
	// Type of boundary event using geofence_event_type_enum.
	EventType TmsGeofenceEventTypeEnum `db:"event_type" json:"event_type"`
	// When the event occurred.
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
}

type TmsGeofencesView struct {
	ID             pgtype.UUID      `db:"id" json:"id"`
	Name           string           `db:"name" json:"name"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Longitude      pgtype.Float4    `db:"longitude" json:"longitude"`
	Latitude       pgtype.Float4    `db:"latitude" json:"latitude"`
	GeofenceEvents []byte           `db:"geofence_events" json:"geofence_events"`
}

// Real-time location data from vehicles for tracking and monitoring purposes.
type TmsGpsPing struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the vehicle sending the location data.
	VehicleID pgtype.UUID `db:"vehicle_id" json:"vehicle_id"`
	// Geographic latitude coordinate.
	Latitude float32 `db:"latitude" fake:"{latitude}" json:"latitude"`
	// Geographic longitude coordinate.
	Longitude float32 `db:"longitude" fake:"{longitude}" json:"longitude"`
	// When the location was recorded.
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
}

// Billing records from third-party carriers for transportation services.
type TmsPartnerInvoice struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the carrier sending the invoice.
	CarrierID pgtype.UUID `db:"carrier_id" json:"carrier_id"`
	// Carrier's invoice identifier.
	InvoiceNumber string `db:"invoice_number" fake:"{uuid}" json:"invoice_number"`
	// Date the invoice was issued.
	InvoiceDate pgtype.Date `db:"invoice_date" fake:"{date}" json:"invoice_date"`
	// Total amount billed on the invoice.
	TotalAmount pgtype.Numeric `db:"total_amount" fake:"{price:1000,50000}" json:"total_amount"`
	// Payment status using partner_invoice_status_enum.
	Status NullTmsPartnerInvoiceStatusEnum `db:"status" json:"status"`
	// Timestamp when the invoice was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the invoice was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Individual line items on carrier invoices, detailing specific shipment leg charges.
type TmsPartnerInvoiceItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the parent invoice.
	PartnerInvoiceID pgtype.UUID `db:"partner_invoice_id" json:"partner_invoice_id"`
	// Reference to the specific shipment leg being billed.
	ShipmentLegID pgtype.UUID `db:"shipment_leg_id" json:"shipment_leg_id"`
	// Amount charged for this specific shipment leg.
	Amount pgtype.Numeric `db:"amount" fake:"{price:100,5000}" json:"amount"`
}

type TmsPartnerInvoicesView struct {
	ID                  pgtype.UUID                     `db:"id" json:"id"`
	CarrierID           pgtype.UUID                     `db:"carrier_id" json:"carrier_id"`
	InvoiceNumber       string                          `db:"invoice_number" json:"invoice_number"`
	InvoiceDate         pgtype.Date                     `db:"invoice_date" json:"invoice_date"`
	TotalAmount         pgtype.Numeric                  `db:"total_amount" json:"total_amount"`
	Status              NullTmsPartnerInvoiceStatusEnum `db:"status" json:"status"`
	CreatedAt           pgtype.Timestamp                `db:"created_at" json:"created_at"`
	UpdatedAt           pgtype.Timestamp                `db:"updated_at" json:"updated_at"`
	PartnerInvoiceItems []TmsPartnerInvoiceItem         `db:"partner_invoice_items" json:"partner_invoice_items"`
}

// Evidence of successful deliveries or pickups at trip stops.
type TmsProofOfDelivery struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the trip stop where proof was collected.
	TripStopID pgtype.UUID `db:"trip_stop_id" json:"trip_stop_id"`
	// Type of proof collected using proof_type_enum.
	Type NullTmsProofTypeEnum `db:"type" json:"type"`
	// Storage location of the proof file.
	FilePath pgtype.Text `db:"file_path" fake:"/{hackerphrase}" json:"file_path"`
	// When the proof was collected.
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
	// Geographic latitude where proof was collected.
	Latitude pgtype.Float4 `db:"latitude" fake:"{latitude}" json:"latitude"`
	// Geographic longitude where proof was collected.
	Longitude pgtype.Float4 `db:"longitude" fake:"{longitude}" json:"longitude"`
	// Timestamp when the proof was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the proof was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Optimized route information for trips, including navigation data.
type TmsRoute struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the associated trip.
	TripID pgtype.UUID `db:"trip_id" json:"trip_id"`
	// Route optimization data such as polylines and turn-by-turn directions.
	OptimizedRouteData pgtype.Text `db:"optimized_route_data" fake:"{sentence}" json:"optimized_route_data"`
	// Calculated total distance of the route.
	TotalDistance pgtype.Float4 `db:"total_distance" fake:"{float64range:10,500}" json:"total_distance"`
	// Estimated total time for the route.
	TotalDuration pgtype.Float4 `db:"total_duration" fake:"{float64range:30,600}" json:"total_duration"`
	// Timestamp when the route was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the route was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Represents individual segments of multi-leg shipments that may involve different carriers or internal fleet.
type TmsShipmentLeg struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the overall shipment.
	ShipmentID pgtype.UUID `db:"shipment_id" json:"shipment_id"`
	// Order of this leg within the shipment journey.
	LegSequence int32 `db:"leg_sequence" fake:"{number:1,5}" json:"leg_sequence"`
	// Starting point of this leg.
	StartLocation pgtype.Text `db:"start_location" fake:"{city}" json:"start_location"`
	// Ending point of this leg.
	EndLocation pgtype.Text `db:"end_location" fake:"{city}" json:"end_location"`
	// Reference to third-party carrier (if external).
	CarrierID pgtype.UUID `db:"carrier_id" json:"carrier_id"`
	// Reference to internal trip (if using own fleet).
	InternalTripID pgtype.UUID `db:"internal_trip_id" json:"internal_trip_id"`
	// Current status of this shipment leg using shipment_leg_status_enum.
	Status NullTmsShipmentLegStatusEnum `db:"status" json:"status"`
	// Timestamp when the shipment leg was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the shipment leg was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Tracks status updates and events for individual shipment legs.
type TmsShipmentLegEvent struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the associated shipment leg.
	ShipmentLegID pgtype.UUID `db:"shipment_leg_id" json:"shipment_leg_id"`
	// Description of the status or event.
	StatusMessage pgtype.Text `db:"status_message" fake:"{sentence}" json:"status_message"`
	// Geographic location where the event occurred.
	Location pgtype.Text `db:"location" fake:"{city}" json:"location"`
	// When the event was recorded.
	EventTimestamp pgtype.Timestamp `db:"event_timestamp" fake:"{date}" json:"event_timestamp"`
}

type TmsShipmentLegsView struct {
	ID                pgtype.UUID                  `db:"id" json:"id"`
	ShipmentID        pgtype.UUID                  `db:"shipment_id" json:"shipment_id"`
	LegSequence       int32                        `db:"leg_sequence" json:"leg_sequence"`
	StartLocation     pgtype.Text                  `db:"start_location" json:"start_location"`
	EndLocation       pgtype.Text                  `db:"end_location" json:"end_location"`
	CarrierID         pgtype.UUID                  `db:"carrier_id" json:"carrier_id"`
	InternalTripID    pgtype.UUID                  `db:"internal_trip_id" json:"internal_trip_id"`
	Status            NullTmsShipmentLegStatusEnum `db:"status" json:"status"`
	CreatedAt         pgtype.Timestamp             `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp             `db:"updated_at" json:"updated_at"`
	ShipmentLegEvents []TmsShipmentLegEvent        `db:"shipment_leg_events" json:"shipment_leg_events"`
}

// Represents planned or active transportation journeys with assigned drivers and vehicles.
type TmsTrip struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the assigned driver.
	DriverID pgtype.UUID `db:"driver_id" json:"driver_id"`
	// Reference to the assigned vehicle.
	VehicleID pgtype.UUID `db:"vehicle_id" json:"vehicle_id"`
	// Current trip status using trip_status_enum.
	Status NullTmsTripStatusEnum `db:"status" json:"status"`
	// Timestamp when the trip was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the trip was last updated.
	UpdatedAt     pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	EndLocation   pgtype.Text        `db:"end_location" json:"end_location"`
	EndTime       pgtype.Timestamptz `db:"end_time" json:"end_time"`
	StartLocation pgtype.Text        `db:"start_location" json:"start_location"`
	StartTime     pgtype.Timestamptz `db:"start_time" json:"start_time"`
}

// Individual stops within a trip, typically for pickups or deliveries.
type TmsTripStop struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the parent trip.
	TripID pgtype.UUID `db:"trip_id" json:"trip_id"`
	// Reference to the shipment being handled at this stop.
	ShipmentID pgtype.UUID `db:"shipment_id" json:"shipment_id"`
	// Order of this stop within the trip.
	Sequence int32 `db:"sequence" fake:"{number:1,10}" json:"sequence"`
	// Physical location of the stop.
	Address pgtype.Text `db:"address" fake:"{streetaddress}" json:"address"`
	// Current stop status using trip_stop_status_enum.
	Status NullTmsTripStopStatusEnum `db:"status" json:"status"`
	// Planned arrival time at the stop.
	EstimatedArrivalTime pgtype.Timestamp `db:"estimated_arrival_time" fake:"{date}" json:"estimated_arrival_time"`
	// Actual recorded arrival time.
	ActualArrivalTime pgtype.Timestamp `db:"actual_arrival_time" fake:"{date}" json:"actual_arrival_time"`
	// Planned departure time from the stop.
	EstimatedDepartureTime pgtype.Timestamp `db:"estimated_departure_time" fake:"{date}" json:"estimated_departure_time"`
	// Actual recorded departure time.
	ActualDepartureTime pgtype.Timestamp `db:"actual_departure_time" fake:"{date}" json:"actual_departure_time"`
	// Timestamp when the trip stop was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the trip stop was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type TmsTripStopsView struct {
	ID                     pgtype.UUID               `db:"id" json:"id"`
	TripID                 pgtype.UUID               `db:"trip_id" json:"trip_id"`
	ShipmentID             pgtype.UUID               `db:"shipment_id" json:"shipment_id"`
	Sequence               int32                     `db:"sequence" json:"sequence"`
	Address                pgtype.Text               `db:"address" json:"address"`
	Status                 NullTmsTripStopStatusEnum `db:"status" json:"status"`
	EstimatedArrivalTime   pgtype.Timestamp          `db:"estimated_arrival_time" json:"estimated_arrival_time"`
	ActualArrivalTime      pgtype.Timestamp          `db:"actual_arrival_time" json:"actual_arrival_time"`
	EstimatedDepartureTime pgtype.Timestamp          `db:"estimated_departure_time" json:"estimated_departure_time"`
	ActualDepartureTime    pgtype.Timestamp          `db:"actual_departure_time" json:"actual_departure_time"`
	CreatedAt              pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	ProofOfDeliveries      []TmsProofOfDelivery      `db:"proof_of_deliveries" json:"proof_of_deliveries"`
}

type TmsTripsView struct {
	ID            pgtype.UUID           `db:"id" json:"id"`
	DriverID      pgtype.UUID           `db:"driver_id" json:"driver_id"`
	VehicleID     pgtype.UUID           `db:"vehicle_id" json:"vehicle_id"`
	Status        NullTmsTripStatusEnum `db:"status" json:"status"`
	CreatedAt     pgtype.Timestamp      `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamp      `db:"updated_at" json:"updated_at"`
	EndLocation   pgtype.Text           `db:"end_location" json:"end_location"`
	EndTime       pgtype.Timestamptz    `db:"end_time" json:"end_time"`
	StartLocation pgtype.Text           `db:"start_location" json:"start_location"`
	StartTime     pgtype.Timestamptz    `db:"start_time" json:"start_time"`
	TripStops     []TmsTripStop         `db:"trip_stops" json:"trip_stops"`
	Routes        []TmsRoute            `db:"routes" json:"routes"`
	Expenses      []TmsExpense          `db:"expenses" json:"expenses"`
}

// Manages the fleet of vehicles available for transportation operations.
type TmsVehicle struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Vehicle's license plate or registration identifier.
	RegistrationNumber string `db:"registration_number" fake:"{uuid}" json:"registration_number"`
	// Vehicle make and model information.
	Model pgtype.Text `db:"model" fake:"{carmodel}" json:"model"`
	// Maximum cargo volume the vehicle can carry.
	CapacityVolume pgtype.Float4 `db:"capacity_volume" fake:"{float64range:10,100}" json:"capacity_volume"`
	// Maximum weight capacity of the vehicle.
	CapacityWeight pgtype.Float4 `db:"capacity_weight" fake:"{float64range:1000,5000}" json:"capacity_weight"`
	// Current vehicle status using vehicle_status_enum.
	Status NullTmsVehicleStatusEnum `db:"status" json:"status"`
	// Timestamp when the vehicle was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the vehicle was last updated.
	UpdatedAt           pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Make                pgtype.Text      `db:"make" json:"make"`
	Year                pgtype.Int4      `db:"year" json:"year"`
	Vin                 pgtype.Text      `db:"vin" json:"vin"`
	CurrentMileage      pgtype.Int4      `db:"current_mileage" json:"current_mileage"`
	LastMaintenanceDate pgtype.Date      `db:"last_maintenance_date" json:"last_maintenance_date"`
}

// Tracks maintenance activities and service history for fleet vehicles.
type TmsVehicleMaintenance struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the vehicle being serviced.
	VehicleID pgtype.UUID `db:"vehicle_id" json:"vehicle_id"`
	// Date when maintenance was performed.
	ServiceDate pgtype.Date `db:"service_date" fake:"{date}" json:"service_date"`
	// Type of maintenance or repair work using vehicle_service_type_enum.
	ServiceType NullTmsVehicleServiceTypeEnum `db:"service_type" json:"service_type"`
	// Financial cost of the maintenance service.
	Cost pgtype.Numeric `db:"cost" fake:"{price:100,2000}" json:"cost"`
	// Additional details about the maintenance work.
	Notes pgtype.Text `db:"notes" fake:"{sentence}" json:"notes"`
	// Timestamp when the maintenance record was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the maintenance record was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type TmsVehiclesView struct {
	ID                  pgtype.UUID              `db:"id" json:"id"`
	RegistrationNumber  string                   `db:"registration_number" json:"registration_number"`
	Model               pgtype.Text              `db:"model" json:"model"`
	CapacityVolume      pgtype.Float4            `db:"capacity_volume" json:"capacity_volume"`
	CapacityWeight      pgtype.Float4            `db:"capacity_weight" json:"capacity_weight"`
	Status              NullTmsVehicleStatusEnum `db:"status" json:"status"`
	CreatedAt           pgtype.Timestamp         `db:"created_at" json:"created_at"`
	UpdatedAt           pgtype.Timestamp         `db:"updated_at" json:"updated_at"`
	Make                pgtype.Text              `db:"make" json:"make"`
	Year                pgtype.Int4              `db:"year" json:"year"`
	Vin                 pgtype.Text              `db:"vin" json:"vin"`
	CurrentMileage      pgtype.Int4              `db:"current_mileage" json:"current_mileage"`
	LastMaintenanceDate pgtype.Date              `db:"last_maintenance_date" json:"last_maintenance_date"`
	VehicleMaintenance  []TmsVehicleMaintenance  `db:"vehicle_maintenance" json:"vehicle_maintenance"`
	GpsPings            []TmsGpsPing             `db:"gps_pings" json:"gps_pings"`
	GeofenceEvents      []TmsGeofenceEvent       `db:"geofence_events" json:"geofence_events"`
}

type User struct {
	ID            string             `db:"id" json:"id"`
	Name          string             `db:"name" json:"name"`
	Email         string             `db:"email" json:"email"`
	EmailVerified bool               `db:"email_verified" json:"email_verified"`
	Image         pgtype.Text        `db:"image" json:"image"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Role          NullUserRole       `db:"role" json:"role"`
	Banned        pgtype.Bool        `db:"banned" json:"banned"`
	BanReason     pgtype.Text        `db:"ban_reason" json:"ban_reason"`
	BanExpires    pgtype.Timestamptz `db:"ban_expires" json:"ban_expires"`
}

type Verification struct {
	ID         string             `db:"id" json:"id"`
	Identifier string             `db:"identifier" json:"identifier"`
	Value      string             `db:"value" json:"value"`
	ExpiresAt  pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Defines minimum and maximum stock levels for specific products at specific locations to trigger replenishment.
type WmsBinThreshold struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the storage location.
	LocationID pgtype.UUID `db:"location_id" json:"location_id"`
	// Reference to the product being monitored (from IMS).
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// Minimum stock level that triggers replenishment.
	MinQuantity int32 `db:"min_quantity" fake:"{number:10,50}" json:"min_quantity"`
	// Maximum stock level for the location.
	MaxQuantity int32 `db:"max_quantity" fake:"{number:100,500}" json:"max_quantity"`
	// Suggested quantity to reorder when minimum is reached.
	ReorderQuantity pgtype.Int4 `db:"reorder_quantity" fake:"{number:50,200}" json:"reorder_quantity"`
	// Quantity that triggers low stock alerts.
	AlertThreshold pgtype.Int4 `db:"alert_threshold" fake:"{number:20,60}" json:"alert_threshold"`
	// Whether this threshold monitoring is active.
	IsActive pgtype.Bool `db:"is_active" fake:"{bool}" json:"is_active"`
	// Timestamp when the threshold was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the threshold was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Represents an expected inbound shipment from a client or supplier (also known as an Advance Shipping Notice or ASN).
type WmsInboundShipment struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// The client company sending the inventory.
	ClientID pgtype.UUID `db:"client_id" json:"client_id"`
	// The destination warehouse.
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	// The current status of the shipment using inbound_shipment_status_enum.
	Status NullWmsInboundShipmentStatusEnum `db:"status" json:"status"`
	// The planned arrival date.
	ExpectedArrivalDate pgtype.Date `db:"expected_arrival_date" fake:"{date}" json:"expected_arrival_date"`
	// The date the shipment actually arrived.
	ActualArrivalDate pgtype.Date `db:"actual_arrival_date" fake:"{date}" json:"actual_arrival_date"`
	// Timestamp when the inbound shipment was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the inbound shipment was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Details the specific products and quantities expected in an inbound shipment.
type WmsInboundShipmentItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// A reference to the parent inbound shipment.
	InboundShipmentID pgtype.UUID `db:"inbound_shipment_id" json:"inbound_shipment_id"`
	// The product included in the shipment.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// The quantity declared on the ASN.
	ExpectedQuantity int32 `db:"expected_quantity" fake:"{number:100,1000}" json:"expected_quantity"`
	// The actual quantity counted upon receipt.
	ReceivedQuantity pgtype.Int4 `db:"received_quantity" fake:"{number:100,1000}" json:"received_quantity"`
	// The difference between received and expected quantities (automatically calculated).
	DiscrepancyQuantity pgtype.Int4 `db:"discrepancy_quantity" json:"discrepancy_quantity"`
	// Notes detailing any differences between expected and received quantities.
	DiscrepancyNotes pgtype.Text `db:"discrepancy_notes" fake:"{sentence}" json:"discrepancy_notes"`
	// Timestamp when the inbound shipment item was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the inbound shipment item was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsInboundShipmentsView struct {
	ID                   pgtype.UUID                      `db:"id" json:"id"`
	ClientID             pgtype.UUID                      `db:"client_id" json:"client_id"`
	WarehouseID          pgtype.UUID                      `db:"warehouse_id" json:"warehouse_id"`
	Status               NullWmsInboundShipmentStatusEnum `db:"status" json:"status"`
	ExpectedArrivalDate  pgtype.Date                      `db:"expected_arrival_date" json:"expected_arrival_date"`
	ActualArrivalDate    pgtype.Date                      `db:"actual_arrival_date" json:"actual_arrival_date"`
	CreatedAt            pgtype.Timestamp                 `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp                 `db:"updated_at" json:"updated_at"`
	InboundShipmentItems []WmsInboundShipmentItem         `db:"inbound_shipment_items" json:"inbound_shipment_items"`
}

// Logs any manual changes made to inventory levels to maintain accuracy.
type WmsInventoryAdjustment struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// The product being adjusted.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// The warehouse where the adjustment occurred.
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	// The user who performed the adjustment.
	UserID string `db:"user_id" json:"user_id"`
	// The amount by which the quantity was changed (can be positive or negative).
	QuantityChange int32 `db:"quantity_change" fake:"{number:-100,100}" json:"quantity_change"`
	// The reason for the adjustment using inventory_adjustment_reason_enum.
	Reason NullWmsInventoryAdjustmentReasonEnum `db:"reason" json:"reason"`
	// Additional details about the adjustment.
	Notes pgtype.Text `db:"notes" fake:"{sentence}" json:"notes"`
	// Timestamp when the adjustment was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the adjustment was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Stores information for products that are tracked by batch or lot, essential for quality control and recalls.
type WmsInventoryBatch struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// The product associated with this batch.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// The unique identifier for the batch/lot.
	BatchNumber string `db:"batch_number" fake:"{uuid}" json:"batch_number"`
	// The expiration date of the products in this batch.
	ExpirationDate pgtype.Date `db:"expiration_date" fake:"{date}" json:"expiration_date"`
	// Timestamp when the batch was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the batch was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Tracks actual physical inventory quantities at specific warehouse locations.
type WmsInventoryStock struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the physical location where stock is stored.
	LocationID pgtype.UUID `db:"location_id" json:"location_id"`
	// Reference to the product being stored (from IMS).
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// Reference to the inventory batch (if applicable for lot tracking).
	BatchID pgtype.UUID `db:"batch_id" json:"batch_id"`
	// Current total quantity of product at this location.
	Quantity int32 `db:"quantity" fake:"{number:0,1000}" json:"quantity"`
	// Quantity reserved for pending orders or tasks.
	ReservedQuantity int32 `db:"reserved_quantity" fake:"{number:0,100}" json:"reserved_quantity"`
	// Available quantity (quantity - reserved_quantity, automatically calculated).
	AvailableQuantity pgtype.Int4 `db:"available_quantity" json:"available_quantity"`
	// Current state of the inventory using inventory_stock_status_enum.
	Status NullWmsInventoryStockStatusEnum `db:"status" json:"status"`
	// When this inventory was last physically counted.
	LastCountedAt pgtype.Timestamp `db:"last_counted_at" fake:"{date}" json:"last_counted_at"`
	// When inventory was last moved in/out of this location.
	LastMovementAt pgtype.Timestamp `db:"last_movement_at" fake:"{date}" json:"last_movement_at"`
	// Timestamp when the inventory record was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the inventory record was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Represents physical storage locations within the warehouse, organized in a hierarchical structure.
type WmsLocation struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the warehouse facility.
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	// Reference to parent location for hierarchical organization (e.g., zone > aisle > shelf > bin).
	ParentLocationID pgtype.UUID `db:"parent_location_id" json:"parent_location_id"`
	// Human-readable location identifier (e.g., A-01-B-101).
	Name string `db:"name" fake:"A-{number:1,10}-B-{number:1,100}" json:"name"`
	// Machine-readable location identifier for scanning operations.
	Barcode pgtype.Text `db:"barcode" fake:"{uuid}" json:"barcode"`
	// Classification of location purpose using location_type_enum.
	Type WmsLocationTypeEnum `db:"type" json:"type"`
	// The hierarchy level (0=zone, 1=aisle, 2=shelf, 3=bin, etc.).
	Level pgtype.Int4 `db:"level" fake:"{number:0,3}" json:"level"`
	// Full hierarchical path for quick lookups (e.g., "Zone A/Aisle 01/Shelf B/Bin 101").
	Path pgtype.Text `db:"path" fake:"Zone A/Aisle {number:1,10}/Shelf B/Bin {number:1,100}" json:"path"`
	// Maximum weight capacity for the location.
	MaxWeight pgtype.Float4 `db:"max_weight" fake:"{float64range:100,1000}" json:"max_weight"`
	// Maximum volume capacity for the location.
	MaxVolume pgtype.Float4 `db:"max_volume" fake:"{float64range:100,1000}" json:"max_volume"`
	// Maximum number of pallets the location can hold.
	MaxPallets pgtype.Int4 `db:"max_pallets" fake:"{number:1,10}" json:"max_pallets"`
	// X coordinate for warehouse mapping and optimization.
	XCoordinate pgtype.Float4 `db:"x_coordinate" fake:"{float64range:0,100}" json:"x_coordinate"`
	// Y coordinate for warehouse mapping and optimization.
	YCoordinate pgtype.Float4 `db:"y_coordinate" fake:"{float64range:0,100}" json:"y_coordinate"`
	// Z coordinate for warehouse mapping and optimization.
	ZCoordinate pgtype.Float4 `db:"z_coordinate" fake:"{float64range:0,10}" json:"z_coordinate"`
	// Whether items can be picked from this location.
	IsPickable pgtype.Bool `db:"is_pickable" fake:"{bool}" json:"is_pickable"`
	// Whether items can be received into this location.
	IsReceivable pgtype.Bool `db:"is_receivable" fake:"{bool}" json:"is_receivable"`
	// Whether this location has temperature control.
	TemperatureControlled pgtype.Bool `db:"temperature_controlled" fake:"{bool}" json:"temperature_controlled"`
	// Whether this location is approved for hazardous materials.
	HazmatApproved pgtype.Bool `db:"hazmat_approved" fake:"{bool}" json:"hazmat_approved"`
	// Whether the location is currently active and available for use.
	IsActive pgtype.Bool `db:"is_active" fake:"{bool}" json:"is_active"`
	// Timestamp when the location was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the location was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsLocationsView struct {
	ID                    pgtype.UUID         `db:"id" json:"id"`
	WarehouseID           pgtype.UUID         `db:"warehouse_id" json:"warehouse_id"`
	ParentLocationID      pgtype.UUID         `db:"parent_location_id" json:"parent_location_id"`
	Name                  string              `db:"name" json:"name"`
	Barcode               pgtype.Text         `db:"barcode" json:"barcode"`
	Type                  WmsLocationTypeEnum `db:"type" json:"type"`
	Level                 pgtype.Int4         `db:"level" json:"level"`
	Path                  pgtype.Text         `db:"path" json:"path"`
	MaxWeight             pgtype.Float4       `db:"max_weight" json:"max_weight"`
	MaxVolume             pgtype.Float4       `db:"max_volume" json:"max_volume"`
	MaxPallets            pgtype.Int4         `db:"max_pallets" json:"max_pallets"`
	XCoordinate           pgtype.Float4       `db:"x_coordinate" json:"x_coordinate"`
	YCoordinate           pgtype.Float4       `db:"y_coordinate" json:"y_coordinate"`
	ZCoordinate           pgtype.Float4       `db:"z_coordinate" json:"z_coordinate"`
	IsPickable            pgtype.Bool         `db:"is_pickable" json:"is_pickable"`
	IsReceivable          pgtype.Bool         `db:"is_receivable" json:"is_receivable"`
	TemperatureControlled pgtype.Bool         `db:"temperature_controlled" json:"temperature_controlled"`
	HazmatApproved        pgtype.Bool         `db:"hazmat_approved" json:"hazmat_approved"`
	IsActive              pgtype.Bool         `db:"is_active" json:"is_active"`
	CreatedAt             pgtype.Timestamp    `db:"created_at" json:"created_at"`
	UpdatedAt             pgtype.Timestamp    `db:"updated_at" json:"updated_at"`
	InventoryStock        []WmsInventoryStock `db:"inventory_stock" json:"inventory_stock"`
	PutawayRules          []WmsPutawayRule    `db:"putaway_rules" json:"putaway_rules"`
	BinThresholds         []WmsBinThreshold   `db:"bin_thresholds" json:"bin_thresholds"`
}

// Represents the physical shipment created to fulfill a sales order.
type WmsOutboundShipment struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// The sales order being fulfilled.
	SalesOrderID pgtype.UUID `db:"sales_order_id" json:"sales_order_id"`
	// The warehouse the shipment is being sent from.
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	// The status of the outbound shipment using outbound_shipment_status_enum.
	Status NullWmsOutboundShipmentStatusEnum `db:"status" json:"status"`
	// The carrier tracking number for the shipment.
	TrackingNumber pgtype.Text `db:"tracking_number" fake:"{uuid}" json:"tracking_number"`
	// The shipping carrier (e.g., FedEx, UPS).
	Carrier pgtype.Text `db:"carrier" fake:"{company}" json:"carrier"`
	// Timestamp when the outbound shipment was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the outbound shipment was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Details the specific items, quantities, and batches included in an outbound shipment.
type WmsOutboundShipmentItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// A reference to the parent outbound shipment.
	OutboundShipmentID pgtype.UUID `db:"outbound_shipment_id" json:"outbound_shipment_id"`
	// A link to the specific line item on the sales order.
	SalesOrderItemID pgtype.UUID `db:"sales_order_item_id" json:"sales_order_item_id"`
	// The product being shipped.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// The specific batch the item was picked from (if applicable).
	BatchID pgtype.UUID `db:"batch_id" json:"batch_id"`
	// The quantity of the product included in this shipment.
	QuantityShipped int32 `db:"quantity_shipped" fake:"{number:1,10}" json:"quantity_shipped"`
	// Timestamp when the outbound shipment item was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the outbound shipment item was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsOutboundShipmentsView struct {
	ID                    pgtype.UUID                       `db:"id" json:"id"`
	SalesOrderID          pgtype.UUID                       `db:"sales_order_id" json:"sales_order_id"`
	WarehouseID           pgtype.UUID                       `db:"warehouse_id" json:"warehouse_id"`
	Status                NullWmsOutboundShipmentStatusEnum `db:"status" json:"status"`
	TrackingNumber        pgtype.Text                       `db:"tracking_number" json:"tracking_number"`
	Carrier               pgtype.Text                       `db:"carrier" json:"carrier"`
	CreatedAt             pgtype.Timestamp                  `db:"created_at" json:"created_at"`
	UpdatedAt             pgtype.Timestamp                  `db:"updated_at" json:"updated_at"`
	OutboundShipmentItems []WmsOutboundShipmentItem         `db:"outbound_shipment_items" json:"outbound_shipment_items"`
}

// Represents physical packages created during the packing process for sales orders.
type WmsPackage struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the sales order being packaged (from IMS).
	SalesOrderID pgtype.UUID `db:"sales_order_id" json:"sales_order_id"`
	// Unique identifier for tracking the package.
	PackageNumber string `db:"package_number" fake:"{uuid}" json:"package_number"`
	// Reference to the warehouse where the package was created.
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	// Type of package (e.g., "box", "envelope", "pallet").
	PackageType pgtype.Text `db:"package_type" fake:"{randomstring:[box,envelope,pallet]}" json:"package_type"`
	// Total weight of the packed package.
	Weight pgtype.Float4 `db:"weight" fake:"{float64range:1,50}" json:"weight"`
	// Package length dimension.
	Length pgtype.Float4 `db:"length" fake:"{float64range:1,100}" json:"length"`
	// Package width dimension.
	Width pgtype.Float4 `db:"width" fake:"{float64range:1,100}" json:"width"`
	// Package height dimension.
	Height pgtype.Float4 `db:"height" fake:"{float64range:1,100}" json:"height"`
	// Package volume (automatically calculated from length * width * height).
	Volume pgtype.Float4 `db:"volume" json:"volume"`
	// Carrier tracking number for the package.
	TrackingNumber pgtype.Text `db:"tracking_number" fake:"{uuid}" json:"tracking_number"`
	// Shipping carrier (e.g., "FedEx", "UPS", "DHL").
	Carrier pgtype.Text `db:"carrier" fake:"{company}" json:"carrier"`
	// Shipping service level (e.g., "Ground", "Express", "Overnight").
	ServiceLevel pgtype.Text `db:"service_level" fake:"{randomstring:[Ground,Express,Overnight]}" json:"service_level"`
	// Reference to the user who packed the package.
	PackedByUserID pgtype.Text `db:"packed_by_user_id" json:"packed_by_user_id"`
	// When the package was packed.
	PackedAt pgtype.Timestamp `db:"packed_at" fake:"{date}" json:"packed_at"`
	// When the package was shipped.
	ShippedAt pgtype.Timestamp `db:"shipped_at" fake:"{date}" json:"shipped_at"`
	// Whether the package contains fragile items.
	IsFragile pgtype.Bool `db:"is_fragile" fake:"{bool}" json:"is_fragile"`
	// Whether the package contains hazardous materials.
	IsHazmat pgtype.Bool `db:"is_hazmat" fake:"{bool}" json:"is_hazmat"`
	// Whether delivery requires signature.
	RequiresSignature pgtype.Bool `db:"requires_signature" fake:"{bool}" json:"requires_signature"`
	// Declared insurance value for the package.
	InsuranceValue pgtype.Numeric `db:"insurance_value" fake:"{price:50,500}" json:"insurance_value"`
	// Timestamp when the package was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the package was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Details the contents of each package, specifying which products and quantities are included.
type WmsPackageItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the package container.
	PackageID pgtype.UUID `db:"package_id" json:"package_id"`
	// Reference to the product included in the package (from IMS).
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// Reference to the batch of the product (from IMS).
	BatchID pgtype.UUID `db:"batch_id" json:"batch_id"`
	// Number of units of the product in the package.
	Quantity int32 `db:"quantity" fake:"{number:1,10}" json:"quantity"`
	// Lot number for traceability.
	LotNumber pgtype.Text `db:"lot_number" fake:"{uuid}" json:"lot_number"`
	// Array of serial numbers for serialized items.
	SerialNumbers []string `db:"serial_numbers" json:"serial_numbers"`
	// Expiry date of the packaged items.
	ExpiryDate pgtype.Date `db:"expiry_date" fake:"{date}" json:"expiry_date"`
	// Weight per unit of the product.
	UnitWeight pgtype.Float4 `db:"unit_weight" fake:"{float64range:0.1,5}" json:"unit_weight"`
	// Total weight of this line item (automatically calculated from quantity * unit_weight).
	TotalWeight pgtype.Float4 `db:"total_weight" json:"total_weight"`
	// Timestamp when the package item was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the package item was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsPackagesView struct {
	ID                pgtype.UUID      `db:"id" json:"id"`
	SalesOrderID      pgtype.UUID      `db:"sales_order_id" json:"sales_order_id"`
	PackageNumber     string           `db:"package_number" json:"package_number"`
	WarehouseID       pgtype.UUID      `db:"warehouse_id" json:"warehouse_id"`
	PackageType       pgtype.Text      `db:"package_type" json:"package_type"`
	Weight            pgtype.Float4    `db:"weight" json:"weight"`
	Length            pgtype.Float4    `db:"length" json:"length"`
	Width             pgtype.Float4    `db:"width" json:"width"`
	Height            pgtype.Float4    `db:"height" json:"height"`
	Volume            pgtype.Float4    `db:"volume" json:"volume"`
	TrackingNumber    pgtype.Text      `db:"tracking_number" json:"tracking_number"`
	Carrier           pgtype.Text      `db:"carrier" json:"carrier"`
	ServiceLevel      pgtype.Text      `db:"service_level" json:"service_level"`
	PackedByUserID    pgtype.Text      `db:"packed_by_user_id" json:"packed_by_user_id"`
	PackedAt          pgtype.Timestamp `db:"packed_at" json:"packed_at"`
	ShippedAt         pgtype.Timestamp `db:"shipped_at" json:"shipped_at"`
	IsFragile         pgtype.Bool      `db:"is_fragile" json:"is_fragile"`
	IsHazmat          pgtype.Bool      `db:"is_hazmat" json:"is_hazmat"`
	RequiresSignature pgtype.Bool      `db:"requires_signature" json:"requires_signature"`
	InsuranceValue    pgtype.Numeric   `db:"insurance_value" json:"insurance_value"`
	CreatedAt         pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	PackageItems      []WmsPackageItem `db:"package_items" json:"package_items"`
}

// Groups multiple sales orders together for efficient batch picking operations.
type WmsPickBatch struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Unique identifier for the pick batch.
	BatchNumber string `db:"batch_number" fake:"{uuid}" json:"batch_number"`
	// Reference to the warehouse where picking occurs.
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	// Current batch status using pick_batch_status_enum.
	Status NullWmsPickBatchStatusEnum `db:"status" json:"status"`
	// Picking strategy employed using pick_strategy_enum.
	Strategy WmsPickStrategyEnum `db:"strategy" json:"strategy"`
	// Batch priority for execution order (lower = higher priority).
	Priority pgtype.Int4 `db:"priority" fake:"{number:1,100}" json:"priority"`
	// Reference to the user assigned to this pick batch.
	AssignedUserID pgtype.Text `db:"assigned_user_id" json:"assigned_user_id"`
	// Wave identifier for grouping batches.
	WaveID pgtype.Text `db:"wave_id" fake:"{uuid}" json:"wave_id"`
	// Array of zone restrictions for this batch.
	ZoneRestrictions []string `db:"zone_restrictions" json:"zone_restrictions"`
	// Estimated time to complete the batch (in minutes).
	EstimatedDuration pgtype.Int4 `db:"estimated_duration" fake:"{number:30,120}" json:"estimated_duration"`
	// Actual time taken to complete the batch (in minutes).
	ActualDuration pgtype.Int4 `db:"actual_duration" fake:"{number:30,120}" json:"actual_duration"`
	// Total number of items in the batch.
	TotalItems pgtype.Int4 `db:"total_items" fake:"{number:10,100}" json:"total_items"`
	// Number of completed items in the batch.
	CompletedItems pgtype.Int4 `db:"completed_items" fake:"{number:0,10}" json:"completed_items"`
	// When the batch picking was started.
	StartedAt pgtype.Timestamp `db:"started_at" fake:"{date}" json:"started_at"`
	// When the batch picking was completed.
	CompletedAt pgtype.Timestamp `db:"completed_at" fake:"{date}" json:"completed_at"`
	// Timestamp when the batch was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the batch was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Associates individual sales orders with pick batches for grouped picking.
type WmsPickBatchItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the pick batch.
	PickBatchID pgtype.UUID `db:"pick_batch_id" json:"pick_batch_id"`
	// Reference to the sales order included in the batch (from IMS).
	SalesOrderID pgtype.UUID `db:"sales_order_id" json:"sales_order_id"`
	// Priority of this order within the batch.
	OrderPriority pgtype.Int4 `db:"order_priority" fake:"{number:1,100}" json:"order_priority"`
	// Estimated time to pick this order (in minutes).
	EstimatedPickTime pgtype.Int4 `db:"estimated_pick_time" fake:"{number:5,30}" json:"estimated_pick_time"`
	// Actual time taken to pick this order (in minutes).
	ActualPickTime pgtype.Int4 `db:"actual_pick_time" fake:"{number:5,30}" json:"actual_pick_time"`
	// Timestamp when the batch item was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the batch item was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsPickBatchesView struct {
	ID                pgtype.UUID                `db:"id" json:"id"`
	BatchNumber       string                     `db:"batch_number" json:"batch_number"`
	WarehouseID       pgtype.UUID                `db:"warehouse_id" json:"warehouse_id"`
	Status            NullWmsPickBatchStatusEnum `db:"status" json:"status"`
	Strategy          WmsPickStrategyEnum        `db:"strategy" json:"strategy"`
	Priority          pgtype.Int4                `db:"priority" json:"priority"`
	AssignedUserID    pgtype.Text                `db:"assigned_user_id" json:"assigned_user_id"`
	WaveID            pgtype.Text                `db:"wave_id" json:"wave_id"`
	ZoneRestrictions  []string                   `db:"zone_restrictions" json:"zone_restrictions"`
	EstimatedDuration pgtype.Int4                `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4                `db:"actual_duration" json:"actual_duration"`
	TotalItems        pgtype.Int4                `db:"total_items" json:"total_items"`
	CompletedItems    pgtype.Int4                `db:"completed_items" json:"completed_items"`
	StartedAt         pgtype.Timestamp           `db:"started_at" json:"started_at"`
	CompletedAt       pgtype.Timestamp           `db:"completed_at" json:"completed_at"`
	CreatedAt         pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	PickBatchItems    []WmsPickBatchItem         `db:"pick_batch_items" json:"pick_batch_items"`
}

// Represents the master record for each unique product (SKU) managed in the inventory.
type WmsProduct struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// The common name of the product.
	Name string `db:"name" fake:"{productname}" json:"name"`
	// The unique Stock Keeping Unit identifier.
	Sku string `db:"sku" fake:"{productupc}" json:"sku"`
	// The product's barcode (e.g., UPC, EAN) for scanning.
	Barcode pgtype.Text `db:"barcode" fake:"{uuid}" json:"barcode"`
	// Detailed information about the product.
	Description pgtype.Text `db:"description" fake:"{productdescription}" json:"description"`
	// The purchase price or cost of the product.
	CostPrice pgtype.Numeric `db:"cost_price" fake:"{price:1,1000}" json:"cost_price"`
	// Physical length dimension.
	Length pgtype.Float4 `db:"length" fake:"{float64range:1,100}" json:"length"`
	// Physical width dimension.
	Width pgtype.Float4 `db:"width" fake:"{float64range:1,100}" json:"width"`
	// Physical height dimension.
	Height pgtype.Float4 `db:"height" fake:"{float64range:1,100}" json:"height"`
	// Product volume (automatically calculated from length * width * height).
	Volume pgtype.Float4 `db:"volume" json:"volume"`
	// Physical weight.
	Weight pgtype.Float4 `db:"weight" fake:"{float64range:0.1,50}" json:"weight"`
	// The product's lifecycle status using product_status_enum.
	Status NullWmsProductStatusEnum `db:"status" json:"status"`
	// A reference to the product's supplier.
	SupplierID pgtype.UUID `db:"supplier_id" json:"supplier_id"`
	// A reference to the client company (from CRM) that owns this inventory.
	ClientID pgtype.UUID `db:"client_id" json:"client_id"`
	// Timestamp when the product was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the product was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsProductsView struct {
	ID                    pgtype.UUID               `db:"id" json:"id"`
	Name                  string                    `db:"name" json:"name"`
	Sku                   string                    `db:"sku" json:"sku"`
	Barcode               pgtype.Text               `db:"barcode" json:"barcode"`
	Description           pgtype.Text               `db:"description" json:"description"`
	CostPrice             pgtype.Numeric            `db:"cost_price" json:"cost_price"`
	Length                pgtype.Float4             `db:"length" json:"length"`
	Width                 pgtype.Float4             `db:"width" json:"width"`
	Height                pgtype.Float4             `db:"height" json:"height"`
	Volume                pgtype.Float4             `db:"volume" json:"volume"`
	Weight                pgtype.Float4             `db:"weight" json:"weight"`
	Status                NullWmsProductStatusEnum  `db:"status" json:"status"`
	SupplierID            pgtype.UUID               `db:"supplier_id" json:"supplier_id"`
	ClientID              pgtype.UUID               `db:"client_id" json:"client_id"`
	CreatedAt             pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt             pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	InventoryBatches      []WmsInventoryBatch       `db:"inventory_batches" json:"inventory_batches"`
	InventoryAdjustments  []WmsInventoryAdjustment  `db:"inventory_adjustments" json:"inventory_adjustments"`
	ReorderPoints         []WmsReorderPoint         `db:"reorder_points" json:"reorder_points"`
	InboundShipmentItems  []WmsInboundShipmentItem  `db:"inbound_shipment_items" json:"inbound_shipment_items"`
	StockTransfers        []WmsStockTransfer        `db:"stock_transfers" json:"stock_transfers"`
	SalesOrderItems       []WmsSalesOrderItem       `db:"sales_order_items" json:"sales_order_items"`
	OutboundShipmentItems []WmsOutboundShipmentItem `db:"outbound_shipment_items" json:"outbound_shipment_items"`
	ReturnItems           []WmsReturnItem           `db:"return_items" json:"return_items"`
	InventoryStock        []WmsInventoryStock       `db:"inventory_stock" json:"inventory_stock"`
	PutawayRules          []WmsPutawayRule          `db:"putaway_rules" json:"putaway_rules"`
	BinThresholds         []WmsBinThreshold         `db:"bin_thresholds" json:"bin_thresholds"`
	TaskItems             []WmsTaskItem             `db:"task_items" json:"task_items"`
	PackageItems          []WmsPackageItem          `db:"package_items" json:"package_items"`
}

// Defines automated rules for determining where incoming inventory should be stored.
type WmsPutawayRule struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the product the rule applies to (from IMS).
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// Reference to the client (for multi-tenant warehouses).
	ClientID pgtype.UUID `db:"client_id" json:"client_id"`
	// Reference to the warehouse this rule applies to.
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	// Reference to the preferred storage location.
	PreferredLocationID pgtype.UUID `db:"preferred_location_id" json:"preferred_location_id"`
	// Preferred location type for this product.
	LocationType NullWmsLocationTypeEnum `db:"location_type" json:"location_type"`
	// Rule precedence when multiple rules could apply (lower = higher priority).
	Priority int32 `db:"priority" fake:"{number:1,100}" json:"priority"`
	// Minimum quantity threshold for this rule to apply.
	MinQuantity pgtype.Int4 `db:"min_quantity" fake:"{number:1,10}" json:"min_quantity"`
	// Maximum quantity threshold for this rule to apply.
	MaxQuantity pgtype.Int4 `db:"max_quantity" fake:"{number:100,1000}" json:"max_quantity"`
	// Weight threshold for this rule to apply.
	WeightThreshold pgtype.Float4 `db:"weight_threshold" fake:"{float64range:10,100}" json:"weight_threshold"`
	// Volume threshold for this rule to apply.
	VolumeThreshold pgtype.Float4 `db:"volume_threshold" fake:"{float64range:10,100}" json:"volume_threshold"`
	// Whether this rule requires temperature controlled locations.
	RequiresTemperatureControl pgtype.Bool `db:"requires_temperature_control" fake:"{bool}" json:"requires_temperature_control"`
	// Whether this rule requires hazmat approved locations.
	RequiresHazmatApproval pgtype.Bool `db:"requires_hazmat_approval" fake:"{bool}" json:"requires_hazmat_approval"`
	// Whether this rule is currently active.
	IsActive pgtype.Bool `db:"is_active" fake:"{bool}" json:"is_active"`
	// Timestamp when the rule was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the rule was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Defines the minimum stock level for a product that triggers a low stock alert.
type WmsReorderPoint struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// The product to monitor.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// The specific warehouse to monitor the stock level in.
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	// The minimum quantity that triggers the alert.
	Threshold int32 `db:"threshold" fake:"{number:10,50}" json:"threshold"`
	// Timestamp when the reorder point was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the reorder point was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Represents a return request from a client (Reverse Logistics).
type WmsReturn struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// A unique identifier for the return.
	ReturnNumber string `db:"return_number" fake:"{uuid}" json:"return_number"`
	// A reference to the original sales order being returned.
	SalesOrderID pgtype.UUID `db:"sales_order_id" json:"sales_order_id"`
	// The client initiating the return.
	ClientID pgtype.UUID `db:"client_id" json:"client_id"`
	// The status of the return using return_status_enum.
	Status NullWmsReturnStatusEnum `db:"status" json:"status"`
	// The reason for the return.
	Reason pgtype.Text `db:"reason" fake:"{sentence}" json:"reason"`
	// Timestamp when the return was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the return was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Details the specific products and quantities being returned.
type WmsReturnItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// A reference to the parent return record.
	ReturnID pgtype.UUID `db:"return_id" json:"return_id"`
	// The product being returned.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// The quantity the client stated they would return.
	QuantityExpected int32 `db:"quantity_expected" fake:"{number:1,5}" json:"quantity_expected"`
	// The actual quantity received at the warehouse.
	QuantityReceived pgtype.Int4 `db:"quantity_received" fake:"{number:1,5}" json:"quantity_received"`
	// The difference between received and expected return quantities (automatically calculated).
	QuantityVariance pgtype.Int4 `db:"quantity_variance" json:"quantity_variance"`
	// The condition of the returned item using return_item_condition_enum.
	Condition NullWmsReturnItemConditionEnum `db:"condition" json:"condition"`
	// Timestamp when the return item was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the return item was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsReturnsView struct {
	ID           pgtype.UUID             `db:"id" json:"id"`
	ReturnNumber string                  `db:"return_number" json:"return_number"`
	SalesOrderID pgtype.UUID             `db:"sales_order_id" json:"sales_order_id"`
	ClientID     pgtype.UUID             `db:"client_id" json:"client_id"`
	Status       NullWmsReturnStatusEnum `db:"status" json:"status"`
	Reason       pgtype.Text             `db:"reason" json:"reason"`
	CreatedAt    pgtype.Timestamp        `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp        `db:"updated_at" json:"updated_at"`
	ReturnItems  []WmsReturnItem         `db:"return_items" json:"return_items"`
}

// Represents a customer's order, often originating from the CRM, which needs to be fulfilled from inventory.
type WmsSalesOrder struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// A unique identifier for the sales order.
	OrderNumber string `db:"order_number" fake:"{uuid}" json:"order_number"`
	// The client company that placed the order.
	ClientID pgtype.UUID `db:"client_id" json:"client_id"`
	// A link back to the original opportunity in the CRM.
	CrmOpportunityID pgtype.UUID `db:"crm_opportunity_id" json:"crm_opportunity_id"`
	// The fulfillment status of the order using sales_order_status_enum.
	Status NullWmsSalesOrderStatusEnum `db:"status" json:"status"`
	// The address where the order should be shipped.
	ShippingAddress pgtype.Text `db:"shipping_address" fake:"{streetaddress}" json:"shipping_address"`
	// Timestamp when the sales order was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the sales order was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Details the specific products and quantities required for a sales order.
type WmsSalesOrderItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// A reference to the parent sales order.
	SalesOrderID pgtype.UUID `db:"sales_order_id" json:"sales_order_id"`
	// The product being ordered.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// The quantity of the product requested by the customer.
	QuantityOrdered int32 `db:"quantity_ordered" fake:"{number:1,10}" json:"quantity_ordered"`
	// Timestamp when the sales order item was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the sales order item was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsSalesOrdersView struct {
	ID               pgtype.UUID                 `db:"id" json:"id"`
	OrderNumber      string                      `db:"order_number" json:"order_number"`
	ClientID         pgtype.UUID                 `db:"client_id" json:"client_id"`
	CrmOpportunityID pgtype.UUID                 `db:"crm_opportunity_id" json:"crm_opportunity_id"`
	Status           NullWmsSalesOrderStatusEnum `db:"status" json:"status"`
	ShippingAddress  pgtype.Text                 `db:"shipping_address" json:"shipping_address"`
	CreatedAt        pgtype.Timestamp            `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp            `db:"updated_at" json:"updated_at"`
	SalesOrderItems  []WmsSalesOrderItem         `db:"sales_order_items" json:"sales_order_items"`
}

// Tracks the movement of inventory from one warehouse to another.
type WmsStockTransfer struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// The product being transferred.
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// The warehouse the stock is moving from.
	SourceWarehouseID pgtype.UUID `db:"source_warehouse_id" json:"source_warehouse_id"`
	// The warehouse the stock is moving to.
	DestinationWarehouseID pgtype.UUID `db:"destination_warehouse_id" json:"destination_warehouse_id"`
	// The amount of stock being transferred.
	Quantity int32 `db:"quantity" fake:"{number:10,200}" json:"quantity"`
	// The status of the transfer using stock_transfer_status_enum.
	Status NullWmsStockTransferStatusEnum `db:"status" json:"status"`
	// Timestamp when the stock transfer was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the stock transfer was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Stores information about the suppliers who provide the products.
type WmsSupplier struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// The name of the supplier company.
	Name string `db:"name" fake:"{company}" json:"name"`
	// The primary contact at the supplier.
	ContactPerson pgtype.Text `db:"contact_person" fake:"{name}" json:"contact_person"`
	// The supplier's contact email.
	Email pgtype.Text `db:"email" fake:"{email}" json:"email"`
	// The supplier's contact phone number.
	PhoneNumber pgtype.Text `db:"phone_number" fake:"{phone}" json:"phone_number"`
	// Timestamp when the supplier was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the supplier was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsSuppliersView struct {
	ID            pgtype.UUID       `db:"id" json:"id"`
	Name          string            `db:"name" json:"name"`
	ContactPerson pgtype.Text       `db:"contact_person" json:"contact_person"`
	Email         pgtype.Text       `db:"email" json:"email"`
	PhoneNumber   pgtype.Text       `db:"phone_number" json:"phone_number"`
	CreatedAt     pgtype.Timestamp  `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamp  `db:"updated_at" json:"updated_at"`
	Products      []WmsProductsView `db:"products" json:"products"`
}

// Represents individual work assignments for warehouse personnel.
type WmsTask struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Unique identifier for the task.
	TaskNumber string `db:"task_number" fake:"{uuid}" json:"task_number"`
	// Reference to the warehouse where the task is performed.
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	// Reference to the assigned warehouse worker.
	UserID pgtype.Text `db:"user_id" json:"user_id"`
	// Category of warehouse task using task_type_enum.
	Type WmsTaskTypeEnum `db:"type" json:"type"`
	// Current task status using task_status_enum.
	Status NullWmsTaskStatusEnum `db:"status" json:"status"`
	// Task priority for execution order (lower = higher priority).
	Priority pgtype.Int4 `db:"priority" fake:"{number:1,100}" json:"priority"`
	// Reference to the entity that triggered the task (e.g., inbound_shipment_id, pick_batch_id).
	SourceEntityID pgtype.UUID `db:"source_entity_id" json:"source_entity_id"`
	// Type of the source entity (e.g., "inbound_shipment", "pick_batch", "return").
	SourceEntityType pgtype.Text `db:"source_entity_type" fake:"{randomstring:[inbound_shipment,pick_batch,return]}" json:"source_entity_type"`
	// Reference to associated pick batch if applicable.
	PickBatchID pgtype.UUID `db:"pick_batch_id" json:"pick_batch_id"`
	// Estimated time to complete the task (in minutes).
	EstimatedDuration pgtype.Int4 `db:"estimated_duration" fake:"{number:10,60}" json:"estimated_duration"`
	// Actual time taken to complete the task (in minutes).
	ActualDuration pgtype.Int4 `db:"actual_duration" fake:"{number:10,60}" json:"actual_duration"`
	// Detailed instructions for completing the task.
	Instructions pgtype.Text `db:"instructions" fake:"{sentence}" json:"instructions"`
	// Additional notes or comments about the task.
	Notes pgtype.Text `db:"notes" fake:"{paragraph}" json:"notes"`
	// When the task was started.
	StartTime pgtype.Timestamp `db:"start_time" fake:"{date}" json:"start_time"`
	// When the task was completed.
	EndTime pgtype.Timestamp `db:"end_time" fake:"{date}" json:"end_time"`
	// Total time taken to complete the task in seconds (automatically calculated from start_time and end_time).
	DurationSeconds pgtype.Int4 `db:"duration_seconds" json:"duration_seconds"`
	// Timestamp when the task was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the task was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

// Individual line items within a warehouse task, specifying exactly what needs to be moved or processed.
type WmsTaskItem struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// Reference to the parent task.
	TaskID pgtype.UUID `db:"task_id" json:"task_id"`
	// Reference to the product being handled (from IMS).
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
	// Reference to the specific batch being handled (from IMS).
	BatchID pgtype.UUID `db:"batch_id" json:"batch_id"`
	// Reference to where the product should be picked from.
	SourceLocationID pgtype.UUID `db:"source_location_id" json:"source_location_id"`
	// Reference to where the product should be moved to.
	DestinationLocationID pgtype.UUID `db:"destination_location_id" json:"destination_location_id"`
	// Amount of product that needs to be handled.
	QuantityRequired int32 `db:"quantity_required" fake:"{number:1,20}" json:"quantity_required"`
	// Amount of product actually handled.
	QuantityCompleted int32 `db:"quantity_completed" fake:"{number:0,20}" json:"quantity_completed"`
	// Remaining quantity to be handled (automatically calculated from quantity_required - quantity_completed).
	QuantityRemaining pgtype.Int4 `db:"quantity_remaining" json:"quantity_remaining"`
	// Completion status of this specific item using task_item_status_enum.
	Status NullWmsTaskItemStatusEnum `db:"status" json:"status"`
	// Lot number for traceability.
	LotNumber pgtype.Text `db:"lot_number" fake:"{uuid}" json:"lot_number"`
	// Array of serial numbers for serialized items.
	SerialNumbers []string `db:"serial_numbers" json:"serial_numbers"`
	// Expiry date of the items being handled.
	ExpiryDate pgtype.Date `db:"expiry_date" fake:"{date}" json:"expiry_date"`
	// Additional notes about this task item.
	Notes pgtype.Text `db:"notes" fake:"{sentence}" json:"notes"`
	// When this task item was completed.
	CompletedAt pgtype.Timestamp `db:"completed_at" fake:"{date}" json:"completed_at"`
	// Timestamp when the task item was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the task item was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsTasksView struct {
	ID                pgtype.UUID           `db:"id" json:"id"`
	TaskNumber        string                `db:"task_number" json:"task_number"`
	WarehouseID       pgtype.UUID           `db:"warehouse_id" json:"warehouse_id"`
	UserID            pgtype.Text           `db:"user_id" json:"user_id"`
	Type              WmsTaskTypeEnum       `db:"type" json:"type"`
	Status            NullWmsTaskStatusEnum `db:"status" json:"status"`
	Priority          pgtype.Int4           `db:"priority" json:"priority"`
	SourceEntityID    pgtype.UUID           `db:"source_entity_id" json:"source_entity_id"`
	SourceEntityType  pgtype.Text           `db:"source_entity_type" json:"source_entity_type"`
	PickBatchID       pgtype.UUID           `db:"pick_batch_id" json:"pick_batch_id"`
	EstimatedDuration pgtype.Int4           `db:"estimated_duration" json:"estimated_duration"`
	ActualDuration    pgtype.Int4           `db:"actual_duration" json:"actual_duration"`
	Instructions      pgtype.Text           `db:"instructions" json:"instructions"`
	Notes             pgtype.Text           `db:"notes" json:"notes"`
	StartTime         pgtype.Timestamp      `db:"start_time" json:"start_time"`
	EndTime           pgtype.Timestamp      `db:"end_time" json:"end_time"`
	DurationSeconds   pgtype.Int4           `db:"duration_seconds" json:"duration_seconds"`
	CreatedAt         pgtype.Timestamp      `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp      `db:"updated_at" json:"updated_at"`
	TaskItems         []WmsTaskItem         `db:"task_items" json:"task_items"`
}

// Represents the physical warehouse facilities where inventory and locations are organized and managed by the WMS.
type WmsWarehouse struct {
	// Primary key
	ID pgtype.UUID `db:"id" json:"id"`
	// The name of the warehouse (e.g., "West Coast Distribution Center").
	Name string `db:"name" fake:"{company} Warehouse" json:"name"`
	// The physical street address of the warehouse.
	Address pgtype.Text `db:"address" fake:"{streetaddress}" json:"address"`
	// The city where the warehouse is located.
	City pgtype.Text `db:"city" fake:"{city}" json:"city"`
	// The state or province where the warehouse is located.
	State pgtype.Text `db:"state" fake:"{state}" json:"state"`
	// The postal code or ZIP code of the warehouse.
	PostalCode pgtype.Text `db:"postal_code" fake:"{zip}" json:"postal_code"`
	// The country where the warehouse is located.
	Country pgtype.Text `db:"country" fake:"{country}" json:"country"`
	// The timezone of the warehouse for scheduling operations.
	Timezone pgtype.Text `db:"timezone" fake:"{timezone}" json:"timezone"`
	// The primary contact person at the warehouse.
	ContactPerson pgtype.Text `db:"contact_person" fake:"{name}" json:"contact_person"`
	// The contact email for the warehouse.
	ContactEmail pgtype.Text `db:"contact_email" fake:"{email}" json:"contact_email"`
	// The contact phone number for the warehouse.
	ContactPhone pgtype.Text `db:"contact_phone" fake:"{phone}" json:"contact_phone"`
	// Whether the warehouse is currently active and operational.
	IsActive pgtype.Bool `db:"is_active" fake:"{bool}" json:"is_active"`
	// Timestamp when the warehouse was created.
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	// Timestamp when the warehouse was last updated.
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type WmsWarehousesView struct {
	ID                pgtype.UUID                `db:"id" json:"id"`
	Name              string                     `db:"name" json:"name"`
	Address           pgtype.Text                `db:"address" json:"address"`
	City              pgtype.Text                `db:"city" json:"city"`
	State             pgtype.Text                `db:"state" json:"state"`
	PostalCode        pgtype.Text                `db:"postal_code" json:"postal_code"`
	Country           pgtype.Text                `db:"country" json:"country"`
	Timezone          pgtype.Text                `db:"timezone" json:"timezone"`
	ContactPerson     pgtype.Text                `db:"contact_person" json:"contact_person"`
	ContactEmail      pgtype.Text                `db:"contact_email" json:"contact_email"`
	ContactPhone      pgtype.Text                `db:"contact_phone" json:"contact_phone"`
	IsActive          pgtype.Bool                `db:"is_active" json:"is_active"`
	CreatedAt         pgtype.Timestamp           `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp           `db:"updated_at" json:"updated_at"`
	InboundShipments  []WmsInboundShipmentsView  `db:"inbound_shipments" json:"inbound_shipments"`
	OutboundShipments []WmsOutboundShipmentsView `db:"outbound_shipments" json:"outbound_shipments"`
	Locations         []WmsLocationsView         `db:"locations" json:"locations"`
	PutawayRules      []WmsPutawayRule           `db:"putaway_rules" json:"putaway_rules"`
	PickBatches       []WmsPickBatchesView       `db:"pick_batches" json:"pick_batches"`
	Tasks             []WmsTasksView             `db:"tasks" json:"tasks"`
}
