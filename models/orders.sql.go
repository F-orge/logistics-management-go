// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: orders.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
insert into orders (custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse) values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type CreateOrderParams struct {
	CustomID          string
	Customer          pgtype.UUID
	OrderDate         pgtype.Timestamptz
	Status            string
	TotalAmount       pgtype.Numeric
	CreatedBy         pgtype.UUID
	ShippingAddress   string
	BillingAddress    string
	AssignedWarehouse pgtype.UUID
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.CustomID,
		arg.Customer,
		arg.OrderDate,
		arg.Status,
		arg.TotalAmount,
		arg.CreatedBy,
		arg.ShippingAddress,
		arg.BillingAddress,
		arg.AssignedWarehouse,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const createOrderLineItem = `-- name: CreateOrderLineItem :one
insert into order_line_items ("order", product, quantity, price_per_unit) values ($1, $2, $3, $4)
returning id, "order", product, quantity, price_per_unit, sub_total, created, updated
`

type CreateOrderLineItemParams struct {
	Order        pgtype.UUID
	Product      pgtype.UUID
	Quantity     int32
	PricePerUnit pgtype.Numeric
}

func (q *Queries) CreateOrderLineItem(ctx context.Context, arg CreateOrderLineItemParams) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, createOrderLineItem,
		arg.Order,
		arg.Product,
		arg.Quantity,
		arg.PricePerUnit,
	)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :one
delete from orders where id = $1 returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

func (q *Queries) DeleteOrder(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, deleteOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteOrderLineItem = `-- name: DeleteOrderLineItem :one
delete from order_line_items where id = $1 returning id, "order", product, quantity, price_per_unit, sub_total, created, updated
`

func (q *Queries) DeleteOrderLineItem(ctx context.Context, id pgtype.UUID) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, deleteOrderLineItem, id)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getOrderLineItemByID = `-- name: GetOrderLineItemByID :one
select id, "order", product, quantity, price_per_unit, sub_total, created, updated from order_line_items where id = $1
`

func (q *Queries) GetOrderLineItemByID(ctx context.Context, id pgtype.UUID) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, getOrderLineItemByID, id)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getOrderLineItems = `-- name: GetOrderLineItems :many
select id, "order", product, quantity, price_per_unit, sub_total, created, updated from order_line_items where "order" = $1 order by created desc offset $2 limit $3
`

type GetOrderLineItemsParams struct {
	Order  pgtype.UUID
	Offset int32
	Limit  int32
}

func (q *Queries) GetOrderLineItems(ctx context.Context, arg GetOrderLineItemsParams) ([]OrderLineItem, error) {
	rows, err := q.db.Query(ctx, getOrderLineItems, arg.Order, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderLineItem
	for rows.Next() {
		var i OrderLineItem
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.Product,
			&i.Quantity,
			&i.PricePerUnit,
			&i.SubTotal,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderLineItemsByOrder = `-- name: GetOrderLineItemsByOrder :many
select id, "order", product, quantity, price_per_unit, sub_total, created, updated from order_line_items where "order" = $1 order by created desc offset $2 limit $3
`

type GetOrderLineItemsByOrderParams struct {
	Order  pgtype.UUID
	Offset int32
	Limit  int32
}

func (q *Queries) GetOrderLineItemsByOrder(ctx context.Context, arg GetOrderLineItemsByOrderParams) ([]OrderLineItem, error) {
	rows, err := q.db.Query(ctx, getOrderLineItemsByOrder, arg.Order, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderLineItem
	for rows.Next() {
		var i OrderLineItem
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.Product,
			&i.Quantity,
			&i.PricePerUnit,
			&i.SubTotal,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderLineItemsByProduct = `-- name: GetOrderLineItemsByProduct :many
select id, "order", product, quantity, price_per_unit, sub_total, created, updated from order_line_items where product = $1 order by created desc offset $2 limit $3
`

type GetOrderLineItemsByProductParams struct {
	Product pgtype.UUID
	Offset  int32
	Limit   int32
}

func (q *Queries) GetOrderLineItemsByProduct(ctx context.Context, arg GetOrderLineItemsByProductParams) ([]OrderLineItem, error) {
	rows, err := q.db.Query(ctx, getOrderLineItemsByProduct, arg.Product, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderLineItem
	for rows.Next() {
		var i OrderLineItem
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.Product,
			&i.Quantity,
			&i.PricePerUnit,
			&i.SubTotal,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders order by created desc offset $1 limit $2
`

type GetOrdersParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrders, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByCustomer = `-- name: GetOrdersByCustomer :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where customer = $1 order by created desc offset $2 limit $3
`

type GetOrdersByCustomerParams struct {
	Customer pgtype.UUID
	Offset   int32
	Limit    int32
}

func (q *Queries) GetOrdersByCustomer(ctx context.Context, arg GetOrdersByCustomerParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByCustomer, arg.Customer, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByDateRange = `-- name: GetOrdersByDateRange :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where order_date >= $1 and order_date <= $2 order by created desc offset $3 limit $4
`

type GetOrdersByDateRangeParams struct {
	OrderDate   pgtype.Timestamptz
	OrderDate_2 pgtype.Timestamptz
	Offset      int32
	Limit       int32
}

func (q *Queries) GetOrdersByDateRange(ctx context.Context, arg GetOrdersByDateRangeParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByDateRange,
		arg.OrderDate,
		arg.OrderDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByStatus = `-- name: GetOrdersByStatus :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where status = $1 order by created desc offset $2 limit $3
`

type GetOrdersByStatusParams struct {
	Status string
	Offset int32
	Limit  int32
}

func (q *Queries) GetOrdersByStatus(ctx context.Context, arg GetOrdersByStatusParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByWarehouse = `-- name: GetOrdersByWarehouse :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where assigned_warehouse = $1 order by created desc offset $2 limit $3
`

type GetOrdersByWarehouseParams struct {
	AssignedWarehouse pgtype.UUID
	Offset            int32
	Limit             int32
}

func (q *Queries) GetOrdersByWarehouse(ctx context.Context, arg GetOrdersByWarehouseParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByWarehouse, arg.AssignedWarehouse, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOrders = `-- name: SearchOrders :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where custom_id ilike '%' || $1::text || '%' or shipping_address ilike '%' || $1::text || '%' or billing_address ilike '%' || $1::text || '%' order by created desc offset $2::integer limit $3::integer
`

type SearchOrdersParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchOrders(ctx context.Context, arg SearchOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, searchOrders, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderAssignedWarehouse = `-- name: UpdateOrderAssignedWarehouse :one
update orders set assigned_warehouse = $1 where id = $2 returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderAssignedWarehouseParams struct {
	AssignedWarehouse pgtype.UUID
	ID                pgtype.UUID
}

func (q *Queries) UpdateOrderAssignedWarehouse(ctx context.Context, arg UpdateOrderAssignedWarehouseParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderAssignedWarehouse, arg.AssignedWarehouse, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderBillingAddress = `-- name: UpdateOrderBillingAddress :one
update orders set billing_address = $1 where id = $2 returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderBillingAddressParams struct {
	BillingAddress string
	ID             pgtype.UUID
}

func (q *Queries) UpdateOrderBillingAddress(ctx context.Context, arg UpdateOrderBillingAddressParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderBillingAddress, arg.BillingAddress, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderLineItemPricePerUnit = `-- name: UpdateOrderLineItemPricePerUnit :one
update order_line_items set price_per_unit = $1 where id = $2 returning id, "order", product, quantity, price_per_unit, sub_total, created, updated
`

type UpdateOrderLineItemPricePerUnitParams struct {
	PricePerUnit pgtype.Numeric
	ID           pgtype.UUID
}

func (q *Queries) UpdateOrderLineItemPricePerUnit(ctx context.Context, arg UpdateOrderLineItemPricePerUnitParams) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, updateOrderLineItemPricePerUnit, arg.PricePerUnit, arg.ID)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderLineItemQuantity = `-- name: UpdateOrderLineItemQuantity :one
update order_line_items set quantity = $1 where id = $2 returning id, "order", product, quantity, price_per_unit, sub_total, created, updated
`

type UpdateOrderLineItemQuantityParams struct {
	Quantity int32
	ID       pgtype.UUID
}

func (q *Queries) UpdateOrderLineItemQuantity(ctx context.Context, arg UpdateOrderLineItemQuantityParams) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, updateOrderLineItemQuantity, arg.Quantity, arg.ID)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderShippingAddress = `-- name: UpdateOrderShippingAddress :one
update orders set shipping_address = $1 where id = $2 returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderShippingAddressParams struct {
	ShippingAddress string
	ID              pgtype.UUID
}

func (q *Queries) UpdateOrderShippingAddress(ctx context.Context, arg UpdateOrderShippingAddressParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderShippingAddress, arg.ShippingAddress, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
update orders set status = $1 where id = $2 returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.Status, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderTotalAmount = `-- name: UpdateOrderTotalAmount :one
update orders set total_amount = $1 where id = $2 returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderTotalAmountParams struct {
	TotalAmount pgtype.Numeric
	ID          pgtype.UUID
}

func (q *Queries) UpdateOrderTotalAmount(ctx context.Context, arg UpdateOrderTotalAmountParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderTotalAmount, arg.TotalAmount, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
