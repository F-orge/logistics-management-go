// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_campaigns.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyCampaign = `-- name: CrmAnyCampaign :many
select
  id, name, budget, start_date, end_date, created_at, updated_at
from
  "crm"."campaigns"
where
  id = any ($1::uuid[])
`

func (q *Queries) CrmAnyCampaign(ctx context.Context, ids []pgtype.UUID) ([]CrmCampaign, error) {
	rows, err := q.db.Query(ctx, crmAnyCampaign, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmCampaign
	for rows.Next() {
		var i CrmCampaign
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Budget,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindCampaign = `-- name: CrmFindCampaign :one
select
  id, name, budget, start_date, end_date, created_at, updated_at
from
  "crm"."campaigns"
where
  id = $1::uuid
`

func (q *Queries) CrmFindCampaign(ctx context.Context, id pgtype.UUID) (CrmCampaign, error) {
	row := q.db.QueryRow(ctx, crmFindCampaign, id)
	var i CrmCampaign
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Budget,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmInsertCampaign = `-- name: CrmInsertCampaign :one
insert into "crm"."campaigns"(name, budget, start_date, end_date)
  values ($1, $2, $3, $4)
returning
  id, name, budget, start_date, end_date, created_at, updated_at
`

type CrmInsertCampaignParams struct {
	Name      string
	Budget    pgtype.Numeric
	StartDate pgtype.Date
	EndDate   pgtype.Date
}

func (q *Queries) CrmInsertCampaign(ctx context.Context, arg CrmInsertCampaignParams) (CrmCampaign, error) {
	row := q.db.QueryRow(ctx, crmInsertCampaign,
		arg.Name,
		arg.Budget,
		arg.StartDate,
		arg.EndDate,
	)
	var i CrmCampaign
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Budget,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateCampaign = `-- name: CrmPaginateCampaign :many
select
  id, name, budget, start_date, end_date, created_at, updated_at
from
  "crm"."campaigns"
limit $2::int offset ($1::int - 1) * $2::int
`

type CrmPaginateCampaignParams struct {
	Page    int32
	Perpage int32
}

func (q *Queries) CrmPaginateCampaign(ctx context.Context, arg CrmPaginateCampaignParams) ([]CrmCampaign, error) {
	rows, err := q.db.Query(ctx, crmPaginateCampaign, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmCampaign
	for rows.Next() {
		var i CrmCampaign
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Budget,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeCampaign = `-- name: CrmRangeCampaign :many
select
  id, name, budget, start_date, end_date, created_at, updated_at
from
  "crm"."campaigns"
where
  created_at >= $1::date
  and created_at <= $2::date
`

type CrmRangeCampaignParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

func (q *Queries) CrmRangeCampaign(ctx context.Context, arg CrmRangeCampaignParams) ([]CrmCampaign, error) {
	rows, err := q.db.Query(ctx, crmRangeCampaign, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmCampaign
	for rows.Next() {
		var i CrmCampaign
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Budget,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveCampaign = `-- name: CrmRemoveCampaign :exec
delete from "crm"."campaigns"
where id = $1::uuid
`

func (q *Queries) CrmRemoveCampaign(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveCampaign, id)
	return err
}

const crmUpdateCampaign = `-- name: CrmUpdateCampaign :one
update
  "crm"."campaigns"
set
  name = case when $1::boolean then
    $2::text
  else
    name
  end,
  budget = case when $3::boolean then
    $4::numeric
  else
    budget
  end,
  start_date = case when $5::boolean then
    $6::date
  else
    start_date
  end,
  end_date = case when $7::boolean then
    $8::date
  else
    end_date
  end
where
  id = $9::uuid
returning
  id, name, budget, start_date, end_date, created_at, updated_at
`

type CrmUpdateCampaignParams struct {
	SetName      bool
	Name         string
	SetBudget    bool
	Budget       pgtype.Numeric
	SetStartDate bool
	StartDate    pgtype.Date
	SetEndDate   bool
	EndDate      pgtype.Date
	ID           pgtype.UUID
}

func (q *Queries) CrmUpdateCampaign(ctx context.Context, arg CrmUpdateCampaignParams) (CrmCampaign, error) {
	row := q.db.QueryRow(ctx, crmUpdateCampaign,
		arg.SetName,
		arg.Name,
		arg.SetBudget,
		arg.Budget,
		arg.SetStartDate,
		arg.StartDate,
		arg.SetEndDate,
		arg.EndDate,
		arg.ID,
	)
	var i CrmCampaign
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Budget,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
