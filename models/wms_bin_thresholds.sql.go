// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_bin_thresholds.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyBinThreshold = `-- name: WmsAnyBinThreshold :many
select
  bin_thresholds.id, bin_thresholds.location_id, bin_thresholds.product_id, bin_thresholds.min_quantity, bin_thresholds.max_quantity, bin_thresholds.reorder_quantity, bin_thresholds.alert_threshold, bin_thresholds.is_active, bin_thresholds.created_at, bin_thresholds.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."bin_thresholds" as bin_thresholds
  inner join "wms"."locations" as location on bin_thresholds.location_id = location.id
  inner join "wms"."products" as product on bin_thresholds.product_id = product.id
where
  bin_thresholds.id = any ($1::uuid[])
`

type WmsAnyBinThresholdRow struct {
	WmsBinThreshold WmsBinThreshold `db:"wms_bin_threshold" json:"wms_bin_threshold"`
	WmsLocation     WmsLocation     `db:"wms_location" json:"wms_location"`
	WmsProduct      WmsProduct      `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsAnyBinThreshold(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyBinThresholdRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyBinThreshold, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyBinThresholdRow
	for rows.Next() {
		var i WmsAnyBinThresholdRow
		if err := rows.Scan(
			&i.WmsBinThreshold.ID,
			&i.WmsBinThreshold.LocationID,
			&i.WmsBinThreshold.ProductID,
			&i.WmsBinThreshold.MinQuantity,
			&i.WmsBinThreshold.MaxQuantity,
			&i.WmsBinThreshold.ReorderQuantity,
			&i.WmsBinThreshold.AlertThreshold,
			&i.WmsBinThreshold.IsActive,
			&i.WmsBinThreshold.CreatedAt,
			&i.WmsBinThreshold.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindBinThreshold = `-- name: WmsFindBinThreshold :one
select
  bin_thresholds.id, bin_thresholds.location_id, bin_thresholds.product_id, bin_thresholds.min_quantity, bin_thresholds.max_quantity, bin_thresholds.reorder_quantity, bin_thresholds.alert_threshold, bin_thresholds.is_active, bin_thresholds.created_at, bin_thresholds.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."bin_thresholds" as bin_thresholds
  inner join "wms"."locations" as location on bin_thresholds.location_id = location.id
  inner join "wms"."products" as product on bin_thresholds.product_id = product.id
where
  bin_thresholds.id = $1::uuid
`

type WmsFindBinThresholdRow struct {
	WmsBinThreshold WmsBinThreshold `db:"wms_bin_threshold" json:"wms_bin_threshold"`
	WmsLocation     WmsLocation     `db:"wms_location" json:"wms_location"`
	WmsProduct      WmsProduct      `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsFindBinThreshold(ctx context.Context, id pgtype.UUID) (WmsFindBinThresholdRow, error) {
	row := q.db.QueryRow(ctx, wmsFindBinThreshold, id)
	var i WmsFindBinThresholdRow
	err := row.Scan(
		&i.WmsBinThreshold.ID,
		&i.WmsBinThreshold.LocationID,
		&i.WmsBinThreshold.ProductID,
		&i.WmsBinThreshold.MinQuantity,
		&i.WmsBinThreshold.MaxQuantity,
		&i.WmsBinThreshold.ReorderQuantity,
		&i.WmsBinThreshold.AlertThreshold,
		&i.WmsBinThreshold.IsActive,
		&i.WmsBinThreshold.CreatedAt,
		&i.WmsBinThreshold.UpdatedAt,
		&i.WmsLocation.ID,
		&i.WmsLocation.WarehouseID,
		&i.WmsLocation.ParentLocationID,
		&i.WmsLocation.Name,
		&i.WmsLocation.Barcode,
		&i.WmsLocation.Type,
		&i.WmsLocation.Level,
		&i.WmsLocation.Path,
		&i.WmsLocation.MaxWeight,
		&i.WmsLocation.MaxVolume,
		&i.WmsLocation.MaxPallets,
		&i.WmsLocation.XCoordinate,
		&i.WmsLocation.YCoordinate,
		&i.WmsLocation.ZCoordinate,
		&i.WmsLocation.IsPickable,
		&i.WmsLocation.IsReceivable,
		&i.WmsLocation.TemperatureControlled,
		&i.WmsLocation.HazmatApproved,
		&i.WmsLocation.IsActive,
		&i.WmsLocation.CreatedAt,
		&i.WmsLocation.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
	)
	return i, err
}

const wmsInsertBinThreshold = `-- name: WmsInsertBinThreshold :one
insert into "wms"."bin_thresholds"(location_id, product_id, min_quantity, max_quantity, reorder_quantity, alert_threshold, is_active)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, location_id, product_id, min_quantity, max_quantity, reorder_quantity, alert_threshold, is_active, created_at, updated_at
`

type WmsInsertBinThresholdParams struct {
	LocationID      pgtype.UUID `db:"location_id" json:"location_id"`
	ProductID       pgtype.UUID `db:"product_id" json:"product_id"`
	MinQuantity     int32       `db:"min_quantity" json:"min_quantity"`
	MaxQuantity     int32       `db:"max_quantity" json:"max_quantity"`
	ReorderQuantity pgtype.Int4 `db:"reorder_quantity" json:"reorder_quantity"`
	AlertThreshold  pgtype.Int4 `db:"alert_threshold" json:"alert_threshold"`
	IsActive        pgtype.Bool `db:"is_active" json:"is_active"`
}

func (q *Queries) WmsInsertBinThreshold(ctx context.Context, arg WmsInsertBinThresholdParams) (WmsBinThreshold, error) {
	row := q.db.QueryRow(ctx, wmsInsertBinThreshold,
		arg.LocationID,
		arg.ProductID,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.ReorderQuantity,
		arg.AlertThreshold,
		arg.IsActive,
	)
	var i WmsBinThreshold
	err := row.Scan(
		&i.ID,
		&i.LocationID,
		&i.ProductID,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.ReorderQuantity,
		&i.AlertThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateBinThreshold = `-- name: WmsPaginateBinThreshold :many
select
  bin_thresholds.id, bin_thresholds.location_id, bin_thresholds.product_id, bin_thresholds.min_quantity, bin_thresholds.max_quantity, bin_thresholds.reorder_quantity, bin_thresholds.alert_threshold, bin_thresholds.is_active, bin_thresholds.created_at, bin_thresholds.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."bin_thresholds" as bin_thresholds
  inner join "wms"."locations" as location on bin_thresholds.location_id = location.id
  inner join "wms"."products" as product on bin_thresholds.product_id = product.id
where (location.name ilike $1::text
  or product.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateBinThresholdParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type WmsPaginateBinThresholdRow struct {
	WmsBinThreshold WmsBinThreshold `db:"wms_bin_threshold" json:"wms_bin_threshold"`
	WmsLocation     WmsLocation     `db:"wms_location" json:"wms_location"`
	WmsProduct      WmsProduct      `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsPaginateBinThreshold(ctx context.Context, arg WmsPaginateBinThresholdParams) ([]WmsPaginateBinThresholdRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateBinThreshold, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateBinThresholdRow
	for rows.Next() {
		var i WmsPaginateBinThresholdRow
		if err := rows.Scan(
			&i.WmsBinThreshold.ID,
			&i.WmsBinThreshold.LocationID,
			&i.WmsBinThreshold.ProductID,
			&i.WmsBinThreshold.MinQuantity,
			&i.WmsBinThreshold.MaxQuantity,
			&i.WmsBinThreshold.ReorderQuantity,
			&i.WmsBinThreshold.AlertThreshold,
			&i.WmsBinThreshold.IsActive,
			&i.WmsBinThreshold.CreatedAt,
			&i.WmsBinThreshold.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeBinThreshold = `-- name: WmsRangeBinThreshold :many
select
  bin_thresholds.id, bin_thresholds.location_id, bin_thresholds.product_id, bin_thresholds.min_quantity, bin_thresholds.max_quantity, bin_thresholds.reorder_quantity, bin_thresholds.alert_threshold, bin_thresholds.is_active, bin_thresholds.created_at, bin_thresholds.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."bin_thresholds" as bin_thresholds
  inner join "wms"."locations" as location on bin_thresholds.location_id = location.id
  inner join "wms"."products" as product on bin_thresholds.product_id = product.id
where
  bin_thresholds.created_at >= $1::date
  and bin_thresholds.created_at <= $2::date
  and (location.name ilike $3::text
    or product.name ilike $3::text
    or $3::text is null)
`

type WmsRangeBinThresholdParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangeBinThresholdRow struct {
	WmsBinThreshold WmsBinThreshold `db:"wms_bin_threshold" json:"wms_bin_threshold"`
	WmsLocation     WmsLocation     `db:"wms_location" json:"wms_location"`
	WmsProduct      WmsProduct      `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsRangeBinThreshold(ctx context.Context, arg WmsRangeBinThresholdParams) ([]WmsRangeBinThresholdRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeBinThreshold, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeBinThresholdRow
	for rows.Next() {
		var i WmsRangeBinThresholdRow
		if err := rows.Scan(
			&i.WmsBinThreshold.ID,
			&i.WmsBinThreshold.LocationID,
			&i.WmsBinThreshold.ProductID,
			&i.WmsBinThreshold.MinQuantity,
			&i.WmsBinThreshold.MaxQuantity,
			&i.WmsBinThreshold.ReorderQuantity,
			&i.WmsBinThreshold.AlertThreshold,
			&i.WmsBinThreshold.IsActive,
			&i.WmsBinThreshold.CreatedAt,
			&i.WmsBinThreshold.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveBinThreshold = `-- name: WmsRemoveBinThreshold :exec
delete from "wms"."bin_thresholds"
where id = $1::uuid
`

func (q *Queries) WmsRemoveBinThreshold(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveBinThreshold, id)
	return err
}

const wmsUpdateBinThreshold = `-- name: WmsUpdateBinThreshold :one
update
  "wms"."bin_thresholds"
set
  updated_at = now(),
  location_id = case when $1 is not null then
    $1::uuid
  else
    location_id
  end,
  product_id = case when $2 is not null then
    $2::uuid
  else
    product_id
  end,
  min_quantity = case when $3 is not null then
    $3::integer
  else
    min_quantity
  end,
  max_quantity = case when $4 is not null then
    $4::integer
  else
    max_quantity
  end,
  reorder_quantity = case when $5 is not null then
    $5::integer
  else
    reorder_quantity
  end,
  alert_threshold = case when $6 is not null then
    $6::integer
  else
    alert_threshold
  end,
  is_active = case when $7 is not null then
    $7::boolean
  else
    is_active
  end
where
  id = $8::uuid
returning
  id, location_id, product_id, min_quantity, max_quantity, reorder_quantity, alert_threshold, is_active, created_at, updated_at
`

type WmsUpdateBinThresholdParams struct {
	LocationID      pgtype.UUID `db:"location_id" json:"location_id"`
	ProductID       pgtype.UUID `db:"product_id" json:"product_id"`
	MinQuantity     int32       `db:"min_quantity" json:"min_quantity"`
	MaxQuantity     int32       `db:"max_quantity" json:"max_quantity"`
	ReorderQuantity pgtype.Int4 `db:"reorder_quantity" json:"reorder_quantity"`
	AlertThreshold  pgtype.Int4 `db:"alert_threshold" json:"alert_threshold"`
	IsActive        pgtype.Bool `db:"is_active" json:"is_active"`
	ID              pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) WmsUpdateBinThreshold(ctx context.Context, arg WmsUpdateBinThresholdParams) (WmsBinThreshold, error) {
	row := q.db.QueryRow(ctx, wmsUpdateBinThreshold,
		arg.LocationID,
		arg.ProductID,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.ReorderQuantity,
		arg.AlertThreshold,
		arg.IsActive,
		arg.ID,
	)
	var i WmsBinThreshold
	err := row.Scan(
		&i.ID,
		&i.LocationID,
		&i.ProductID,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.ReorderQuantity,
		&i.AlertThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
