// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_bin_thresholds.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyBinThreshold = `-- name: WmsAnyBinThreshold :many
select
  bin_thresholds.id, bin_thresholds.location_id, bin_thresholds.product_id, bin_thresholds.min_quantity, bin_thresholds.max_quantity, bin_thresholds.reorder_quantity, bin_thresholds.alert_threshold, bin_thresholds.is_active, bin_thresholds.created_at, bin_thresholds.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."bin_thresholds" as bin_thresholds
  inner join "wms"."locations" as location on bin_thresholds.location_id = location.id
  inner join "wms"."products" as product on bin_thresholds.product_id = product.id
where
  bin_thresholds.id = any ($1::uuid[])
`

type WmsAnyBinThresholdRow struct {
	WmsBinThreshold WmsBinThreshold
	WmsLocation     WmsLocation
	WmsProduct      WmsProduct
}

func (q *Queries) WmsAnyBinThreshold(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyBinThresholdRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyBinThreshold, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyBinThresholdRow
	for rows.Next() {
		var i WmsAnyBinThresholdRow
		if err := rows.Scan(
			&i.WmsBinThreshold.ID,
			&i.WmsBinThreshold.LocationID,
			&i.WmsBinThreshold.ProductID,
			&i.WmsBinThreshold.MinQuantity,
			&i.WmsBinThreshold.MaxQuantity,
			&i.WmsBinThreshold.ReorderQuantity,
			&i.WmsBinThreshold.AlertThreshold,
			&i.WmsBinThreshold.IsActive,
			&i.WmsBinThreshold.CreatedAt,
			&i.WmsBinThreshold.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindBinThreshold = `-- name: WmsFindBinThreshold :one
select
  bin_thresholds.id, bin_thresholds.location_id, bin_thresholds.product_id, bin_thresholds.min_quantity, bin_thresholds.max_quantity, bin_thresholds.reorder_quantity, bin_thresholds.alert_threshold, bin_thresholds.is_active, bin_thresholds.created_at, bin_thresholds.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."bin_thresholds" as bin_thresholds
  inner join "wms"."locations" as location on bin_thresholds.location_id = location.id
  inner join "wms"."products" as product on bin_thresholds.product_id = product.id
where
  bin_thresholds.id = $1::uuid
`

type WmsFindBinThresholdRow struct {
	WmsBinThreshold WmsBinThreshold
	WmsLocation     WmsLocation
	WmsProduct      WmsProduct
}

func (q *Queries) WmsFindBinThreshold(ctx context.Context, id pgtype.UUID) (WmsFindBinThresholdRow, error) {
	row := q.db.QueryRow(ctx, wmsFindBinThreshold, id)
	var i WmsFindBinThresholdRow
	err := row.Scan(
		&i.WmsBinThreshold.ID,
		&i.WmsBinThreshold.LocationID,
		&i.WmsBinThreshold.ProductID,
		&i.WmsBinThreshold.MinQuantity,
		&i.WmsBinThreshold.MaxQuantity,
		&i.WmsBinThreshold.ReorderQuantity,
		&i.WmsBinThreshold.AlertThreshold,
		&i.WmsBinThreshold.IsActive,
		&i.WmsBinThreshold.CreatedAt,
		&i.WmsBinThreshold.UpdatedAt,
		&i.WmsLocation.ID,
		&i.WmsLocation.WarehouseID,
		&i.WmsLocation.ParentLocationID,
		&i.WmsLocation.Name,
		&i.WmsLocation.Barcode,
		&i.WmsLocation.Type,
		&i.WmsLocation.Level,
		&i.WmsLocation.Path,
		&i.WmsLocation.MaxWeight,
		&i.WmsLocation.MaxVolume,
		&i.WmsLocation.MaxPallets,
		&i.WmsLocation.XCoordinate,
		&i.WmsLocation.YCoordinate,
		&i.WmsLocation.ZCoordinate,
		&i.WmsLocation.IsPickable,
		&i.WmsLocation.IsReceivable,
		&i.WmsLocation.TemperatureControlled,
		&i.WmsLocation.HazmatApproved,
		&i.WmsLocation.IsActive,
		&i.WmsLocation.CreatedAt,
		&i.WmsLocation.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
	)
	return i, err
}

const wmsInsertBinThreshold = `-- name: WmsInsertBinThreshold :one
insert into "wms"."bin_thresholds"(location_id, product_id, min_quantity, max_quantity, reorder_quantity, alert_threshold, is_active)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, location_id, product_id, min_quantity, max_quantity, reorder_quantity, alert_threshold, is_active, created_at, updated_at
`

type WmsInsertBinThresholdParams struct {
	LocationID      pgtype.UUID
	ProductID       pgtype.UUID
	MinQuantity     int32
	MaxQuantity     int32
	ReorderQuantity pgtype.Int4
	AlertThreshold  pgtype.Int4
	IsActive        pgtype.Bool
}

func (q *Queries) WmsInsertBinThreshold(ctx context.Context, arg WmsInsertBinThresholdParams) (WmsBinThreshold, error) {
	row := q.db.QueryRow(ctx, wmsInsertBinThreshold,
		arg.LocationID,
		arg.ProductID,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.ReorderQuantity,
		arg.AlertThreshold,
		arg.IsActive,
	)
	var i WmsBinThreshold
	err := row.Scan(
		&i.ID,
		&i.LocationID,
		&i.ProductID,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.ReorderQuantity,
		&i.AlertThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateBinThreshold = `-- name: WmsPaginateBinThreshold :many
select
  bin_thresholds.id, bin_thresholds.location_id, bin_thresholds.product_id, bin_thresholds.min_quantity, bin_thresholds.max_quantity, bin_thresholds.reorder_quantity, bin_thresholds.alert_threshold, bin_thresholds.is_active, bin_thresholds.created_at, bin_thresholds.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."bin_thresholds" as bin_thresholds
  inner join "wms"."locations" as location on bin_thresholds.location_id = location.id
  inner join "wms"."products" as product on bin_thresholds.product_id = product.id
limit $2::int offset ($1::int - 1) * $2::int
`

type WmsPaginateBinThresholdParams struct {
	Page    int32
	Perpage int32
}

type WmsPaginateBinThresholdRow struct {
	WmsBinThreshold WmsBinThreshold
	WmsLocation     WmsLocation
	WmsProduct      WmsProduct
}

func (q *Queries) WmsPaginateBinThreshold(ctx context.Context, arg WmsPaginateBinThresholdParams) ([]WmsPaginateBinThresholdRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateBinThreshold, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateBinThresholdRow
	for rows.Next() {
		var i WmsPaginateBinThresholdRow
		if err := rows.Scan(
			&i.WmsBinThreshold.ID,
			&i.WmsBinThreshold.LocationID,
			&i.WmsBinThreshold.ProductID,
			&i.WmsBinThreshold.MinQuantity,
			&i.WmsBinThreshold.MaxQuantity,
			&i.WmsBinThreshold.ReorderQuantity,
			&i.WmsBinThreshold.AlertThreshold,
			&i.WmsBinThreshold.IsActive,
			&i.WmsBinThreshold.CreatedAt,
			&i.WmsBinThreshold.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeBinThreshold = `-- name: WmsRangeBinThreshold :many
select
  bin_thresholds.id, bin_thresholds.location_id, bin_thresholds.product_id, bin_thresholds.min_quantity, bin_thresholds.max_quantity, bin_thresholds.reorder_quantity, bin_thresholds.alert_threshold, bin_thresholds.is_active, bin_thresholds.created_at, bin_thresholds.updated_at,
  location.id, location.warehouse_id, location.parent_location_id, location.name, location.barcode, location.type, location.level, location.path, location.max_weight, location.max_volume, location.max_pallets, location.x_coordinate, location.y_coordinate, location.z_coordinate, location.is_pickable, location.is_receivable, location.temperature_controlled, location.hazmat_approved, location.is_active, location.created_at, location.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."bin_thresholds" as bin_thresholds
  inner join "wms"."locations" as location on bin_thresholds.location_id = location.id
  inner join "wms"."products" as product on bin_thresholds.product_id = product.id
where
  bin_thresholds.created_at >= $1::date
  and bin_thresholds.created_at <= $2::date
`

type WmsRangeBinThresholdParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type WmsRangeBinThresholdRow struct {
	WmsBinThreshold WmsBinThreshold
	WmsLocation     WmsLocation
	WmsProduct      WmsProduct
}

func (q *Queries) WmsRangeBinThreshold(ctx context.Context, arg WmsRangeBinThresholdParams) ([]WmsRangeBinThresholdRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeBinThreshold, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeBinThresholdRow
	for rows.Next() {
		var i WmsRangeBinThresholdRow
		if err := rows.Scan(
			&i.WmsBinThreshold.ID,
			&i.WmsBinThreshold.LocationID,
			&i.WmsBinThreshold.ProductID,
			&i.WmsBinThreshold.MinQuantity,
			&i.WmsBinThreshold.MaxQuantity,
			&i.WmsBinThreshold.ReorderQuantity,
			&i.WmsBinThreshold.AlertThreshold,
			&i.WmsBinThreshold.IsActive,
			&i.WmsBinThreshold.CreatedAt,
			&i.WmsBinThreshold.UpdatedAt,
			&i.WmsLocation.ID,
			&i.WmsLocation.WarehouseID,
			&i.WmsLocation.ParentLocationID,
			&i.WmsLocation.Name,
			&i.WmsLocation.Barcode,
			&i.WmsLocation.Type,
			&i.WmsLocation.Level,
			&i.WmsLocation.Path,
			&i.WmsLocation.MaxWeight,
			&i.WmsLocation.MaxVolume,
			&i.WmsLocation.MaxPallets,
			&i.WmsLocation.XCoordinate,
			&i.WmsLocation.YCoordinate,
			&i.WmsLocation.ZCoordinate,
			&i.WmsLocation.IsPickable,
			&i.WmsLocation.IsReceivable,
			&i.WmsLocation.TemperatureControlled,
			&i.WmsLocation.HazmatApproved,
			&i.WmsLocation.IsActive,
			&i.WmsLocation.CreatedAt,
			&i.WmsLocation.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveBinThreshold = `-- name: WmsRemoveBinThreshold :exec
delete from "wms"."bin_thresholds"
where id = $1::uuid
`

func (q *Queries) WmsRemoveBinThreshold(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveBinThreshold, id)
	return err
}

const wmsUpdateBinThreshold = `-- name: WmsUpdateBinThreshold :one
update
  "wms"."bin_thresholds"
set
  location_id = case when $1::boolean then
    $2::uuid
  else
    location_id
  end,
  product_id = case when $3::boolean then
    $4::uuid
  else
    product_id
  end,
  min_quantity = case when $5::boolean then
    $6::integer
  else
    min_quantity
  end,
  max_quantity = case when $7::boolean then
    $8::integer
  else
    max_quantity
  end,
  reorder_quantity = case when $9::boolean then
    $10::integer
  else
    reorder_quantity
  end,
  alert_threshold = case when $11::boolean then
    $12::integer
  else
    alert_threshold
  end,
  is_active = case when $13::boolean then
    $14::boolean
  else
    is_active
  end
where
  id = $15::uuid
returning
  id, location_id, product_id, min_quantity, max_quantity, reorder_quantity, alert_threshold, is_active, created_at, updated_at
`

type WmsUpdateBinThresholdParams struct {
	SetLocationID      bool
	LocationID         pgtype.UUID
	SetProductID       bool
	ProductID          pgtype.UUID
	SetMinQuantity     bool
	MinQuantity        int32
	SetMaxQuantity     bool
	MaxQuantity        int32
	SetReorderQuantity bool
	ReorderQuantity    int32
	SetAlertThreshold  bool
	AlertThreshold     int32
	SetIsActive        bool
	IsActive           bool
	ID                 pgtype.UUID
}

func (q *Queries) WmsUpdateBinThreshold(ctx context.Context, arg WmsUpdateBinThresholdParams) (WmsBinThreshold, error) {
	row := q.db.QueryRow(ctx, wmsUpdateBinThreshold,
		arg.SetLocationID,
		arg.LocationID,
		arg.SetProductID,
		arg.ProductID,
		arg.SetMinQuantity,
		arg.MinQuantity,
		arg.SetMaxQuantity,
		arg.MaxQuantity,
		arg.SetReorderQuantity,
		arg.ReorderQuantity,
		arg.SetAlertThreshold,
		arg.AlertThreshold,
		arg.SetIsActive,
		arg.IsActive,
		arg.ID,
	)
	var i WmsBinThreshold
	err := row.Scan(
		&i.ID,
		&i.LocationID,
		&i.ProductID,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.ReorderQuantity,
		&i.AlertThreshold,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
