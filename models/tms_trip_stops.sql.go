// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_trip_stops.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyTripStop = `-- name: TmsAnyTripStop :many
select
  trip_stops.id, trip_stops.trip_id, trip_stops.shipment_id, trip_stops.sequence, trip_stops.address, trip_stops.status, trip_stops.estimated_arrival_time, trip_stops.actual_arrival_time, trip_stops.estimated_departure_time, trip_stops.actual_departure_time, trip_stops.created_at, trip_stops.updated_at, trip_stops.proof_of_deliveries,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time
from
  "tms"."trip_stops_view" as trip_stops
  inner join "tms"."trips" as trip on trip_stops.trip_id = trip.id
where
  trip_stops.id = any ($1::uuid[])
`

type TmsAnyTripStopRow struct {
	ID                     pgtype.UUID               `db:"id" json:"id"`
	TripID                 pgtype.UUID               `db:"trip_id" json:"trip_id"`
	ShipmentID             pgtype.UUID               `db:"shipment_id" json:"shipment_id"`
	Sequence               int32                     `db:"sequence" json:"sequence"`
	Address                pgtype.Text               `db:"address" json:"address"`
	Status                 NullTmsTripStopStatusEnum `db:"status" json:"status"`
	EstimatedArrivalTime   pgtype.Timestamp          `db:"estimated_arrival_time" json:"estimated_arrival_time"`
	ActualArrivalTime      pgtype.Timestamp          `db:"actual_arrival_time" json:"actual_arrival_time"`
	EstimatedDepartureTime pgtype.Timestamp          `db:"estimated_departure_time" json:"estimated_departure_time"`
	ActualDepartureTime    pgtype.Timestamp          `db:"actual_departure_time" json:"actual_departure_time"`
	CreatedAt              pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	ProofOfDeliveries      []TmsProofOfDelivery      `db:"proof_of_deliveries" json:"proof_of_deliveries"`
	TmsTrip                TmsTrip                   `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsAnyTripStop(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyTripStopRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyTripStop, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyTripStopRow
	for rows.Next() {
		var i TmsAnyTripStopRow
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.ShipmentID,
			&i.Sequence,
			&i.Address,
			&i.Status,
			&i.EstimatedArrivalTime,
			&i.ActualArrivalTime,
			&i.EstimatedDepartureTime,
			&i.ActualDepartureTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProofOfDeliveries,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindTripStop = `-- name: TmsFindTripStop :one
select
  trip_stops.id, trip_stops.trip_id, trip_stops.shipment_id, trip_stops.sequence, trip_stops.address, trip_stops.status, trip_stops.estimated_arrival_time, trip_stops.actual_arrival_time, trip_stops.estimated_departure_time, trip_stops.actual_departure_time, trip_stops.created_at, trip_stops.updated_at, trip_stops.proof_of_deliveries,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time
from
  "tms"."trip_stops_view" as trip_stops
  inner join "tms"."trips" as trip on trip_stops.trip_id = trip.id
where
  trip_stops.id = $1::uuid
`

type TmsFindTripStopRow struct {
	ID                     pgtype.UUID               `db:"id" json:"id"`
	TripID                 pgtype.UUID               `db:"trip_id" json:"trip_id"`
	ShipmentID             pgtype.UUID               `db:"shipment_id" json:"shipment_id"`
	Sequence               int32                     `db:"sequence" json:"sequence"`
	Address                pgtype.Text               `db:"address" json:"address"`
	Status                 NullTmsTripStopStatusEnum `db:"status" json:"status"`
	EstimatedArrivalTime   pgtype.Timestamp          `db:"estimated_arrival_time" json:"estimated_arrival_time"`
	ActualArrivalTime      pgtype.Timestamp          `db:"actual_arrival_time" json:"actual_arrival_time"`
	EstimatedDepartureTime pgtype.Timestamp          `db:"estimated_departure_time" json:"estimated_departure_time"`
	ActualDepartureTime    pgtype.Timestamp          `db:"actual_departure_time" json:"actual_departure_time"`
	CreatedAt              pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	ProofOfDeliveries      []TmsProofOfDelivery      `db:"proof_of_deliveries" json:"proof_of_deliveries"`
	TmsTrip                TmsTrip                   `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsFindTripStop(ctx context.Context, id pgtype.UUID) (TmsFindTripStopRow, error) {
	row := q.db.QueryRow(ctx, tmsFindTripStop, id)
	var i TmsFindTripStopRow
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.ShipmentID,
		&i.Sequence,
		&i.Address,
		&i.Status,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProofOfDeliveries,
		&i.TmsTrip.ID,
		&i.TmsTrip.DriverID,
		&i.TmsTrip.VehicleID,
		&i.TmsTrip.Status,
		&i.TmsTrip.CreatedAt,
		&i.TmsTrip.UpdatedAt,
		&i.TmsTrip.EndLocation,
		&i.TmsTrip.EndTime,
		&i.TmsTrip.StartLocation,
		&i.TmsTrip.StartTime,
	)
	return i, err
}

const tmsInsertTripStop = `-- name: TmsInsertTripStop :one
insert into "tms"."trip_stops"(trip_id, shipment_id, sequence,
  address,
  status,
  estimated_arrival_time,
  actual_arrival_time,
  estimated_departure_time,
  actual_departure_time)
values ($1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9)
returning
  id, trip_id, shipment_id, sequence, address, status, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created_at, updated_at
`

type TmsInsertTripStopParams struct {
	TripID                 pgtype.UUID               `db:"trip_id" json:"trip_id"`
	ShipmentID             pgtype.UUID               `db:"shipment_id" json:"shipment_id"`
	Sequence               int32                     `db:"sequence" fake:"{number:1,10}" json:"sequence"`
	Address                pgtype.Text               `db:"address" fake:"{streetaddress}" json:"address"`
	Status                 NullTmsTripStopStatusEnum `db:"status" json:"status"`
	EstimatedArrivalTime   pgtype.Timestamp          `db:"estimated_arrival_time" fake:"{date}" json:"estimated_arrival_time"`
	ActualArrivalTime      pgtype.Timestamp          `db:"actual_arrival_time" fake:"{date}" json:"actual_arrival_time"`
	EstimatedDepartureTime pgtype.Timestamp          `db:"estimated_departure_time" fake:"{date}" json:"estimated_departure_time"`
	ActualDepartureTime    pgtype.Timestamp          `db:"actual_departure_time" fake:"{date}" json:"actual_departure_time"`
}

func (q *Queries) TmsInsertTripStop(ctx context.Context, arg TmsInsertTripStopParams) (TmsTripStop, error) {
	row := q.db.QueryRow(ctx, tmsInsertTripStop,
		arg.TripID,
		arg.ShipmentID,
		arg.Sequence,
		arg.Address,
		arg.Status,
		arg.EstimatedArrivalTime,
		arg.ActualArrivalTime,
		arg.EstimatedDepartureTime,
		arg.ActualDepartureTime,
	)
	var i TmsTripStop
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.ShipmentID,
		&i.Sequence,
		&i.Address,
		&i.Status,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateTripStop = `-- name: TmsPaginateTripStop :many
select
  trip_stops.id, trip_stops.trip_id, trip_stops.shipment_id, trip_stops.sequence, trip_stops.address, trip_stops.status, trip_stops.estimated_arrival_time, trip_stops.actual_arrival_time, trip_stops.estimated_departure_time, trip_stops.actual_departure_time, trip_stops.created_at, trip_stops.updated_at, trip_stops.proof_of_deliveries,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time
from
  "tms"."trip_stops_view" as trip_stops
  inner join "tms"."trips" as trip on trip_stops.trip_id = trip.id
where (trip.status::text ilike $1::text
  or trip_stops.address ilike $1::text
  or trip_stops.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateTripStopParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type TmsPaginateTripStopRow struct {
	ID                     pgtype.UUID               `db:"id" json:"id"`
	TripID                 pgtype.UUID               `db:"trip_id" json:"trip_id"`
	ShipmentID             pgtype.UUID               `db:"shipment_id" json:"shipment_id"`
	Sequence               int32                     `db:"sequence" json:"sequence"`
	Address                pgtype.Text               `db:"address" json:"address"`
	Status                 NullTmsTripStopStatusEnum `db:"status" json:"status"`
	EstimatedArrivalTime   pgtype.Timestamp          `db:"estimated_arrival_time" json:"estimated_arrival_time"`
	ActualArrivalTime      pgtype.Timestamp          `db:"actual_arrival_time" json:"actual_arrival_time"`
	EstimatedDepartureTime pgtype.Timestamp          `db:"estimated_departure_time" json:"estimated_departure_time"`
	ActualDepartureTime    pgtype.Timestamp          `db:"actual_departure_time" json:"actual_departure_time"`
	CreatedAt              pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	ProofOfDeliveries      []TmsProofOfDelivery      `db:"proof_of_deliveries" json:"proof_of_deliveries"`
	TmsTrip                TmsTrip                   `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsPaginateTripStop(ctx context.Context, arg TmsPaginateTripStopParams) ([]TmsPaginateTripStopRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateTripStop, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateTripStopRow
	for rows.Next() {
		var i TmsPaginateTripStopRow
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.ShipmentID,
			&i.Sequence,
			&i.Address,
			&i.Status,
			&i.EstimatedArrivalTime,
			&i.ActualArrivalTime,
			&i.EstimatedDepartureTime,
			&i.ActualDepartureTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProofOfDeliveries,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsPaginateTripStopMetadata = `-- name: TmsPaginateTripStopMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "tms"."trip_stops_view" as trip_stops
`

type TmsPaginateTripStopMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type TmsPaginateTripStopMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) TmsPaginateTripStopMetadata(ctx context.Context, arg TmsPaginateTripStopMetadataParams) (TmsPaginateTripStopMetadataRow, error) {
	row := q.db.QueryRow(ctx, tmsPaginateTripStopMetadata, arg.PerPage, arg.Page)
	var i TmsPaginateTripStopMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const tmsRangeTripStop = `-- name: TmsRangeTripStop :many
select
  trip_stops.id, trip_stops.trip_id, trip_stops.shipment_id, trip_stops.sequence, trip_stops.address, trip_stops.status, trip_stops.estimated_arrival_time, trip_stops.actual_arrival_time, trip_stops.estimated_departure_time, trip_stops.actual_departure_time, trip_stops.created_at, trip_stops.updated_at, trip_stops.proof_of_deliveries,
  trip.id, trip.driver_id, trip.vehicle_id, trip.status, trip.created_at, trip.updated_at, trip.end_location, trip.end_time, trip.start_location, trip.start_time
from
  "tms"."trip_stops_view" as trip_stops
  inner join "tms"."trips" as trip on trip_stops.trip_id = trip.id
where
  trip_stops.created_at >= $1::date
  and trip_stops.created_at <= $2::date
  and (trip.status::text ilike $3::text
    or trip_stops.address ilike $3::text
    or trip_stops.status::text ilike $3::text
    or $3::text is null)
`

type TmsRangeTripStopParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeTripStopRow struct {
	ID                     pgtype.UUID               `db:"id" json:"id"`
	TripID                 pgtype.UUID               `db:"trip_id" json:"trip_id"`
	ShipmentID             pgtype.UUID               `db:"shipment_id" json:"shipment_id"`
	Sequence               int32                     `db:"sequence" json:"sequence"`
	Address                pgtype.Text               `db:"address" json:"address"`
	Status                 NullTmsTripStopStatusEnum `db:"status" json:"status"`
	EstimatedArrivalTime   pgtype.Timestamp          `db:"estimated_arrival_time" json:"estimated_arrival_time"`
	ActualArrivalTime      pgtype.Timestamp          `db:"actual_arrival_time" json:"actual_arrival_time"`
	EstimatedDepartureTime pgtype.Timestamp          `db:"estimated_departure_time" json:"estimated_departure_time"`
	ActualDepartureTime    pgtype.Timestamp          `db:"actual_departure_time" json:"actual_departure_time"`
	CreatedAt              pgtype.Timestamp          `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp          `db:"updated_at" json:"updated_at"`
	ProofOfDeliveries      []TmsProofOfDelivery      `db:"proof_of_deliveries" json:"proof_of_deliveries"`
	TmsTrip                TmsTrip                   `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsRangeTripStop(ctx context.Context, arg TmsRangeTripStopParams) ([]TmsRangeTripStopRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeTripStop, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeTripStopRow
	for rows.Next() {
		var i TmsRangeTripStopRow
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.ShipmentID,
			&i.Sequence,
			&i.Address,
			&i.Status,
			&i.EstimatedArrivalTime,
			&i.ActualArrivalTime,
			&i.EstimatedDepartureTime,
			&i.ActualDepartureTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProofOfDeliveries,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveTripStop = `-- name: TmsRemoveTripStop :exec
delete from "tms"."trip_stops"
where id = $1::uuid
`

func (q *Queries) TmsRemoveTripStop(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveTripStop, id)
	return err
}

const tmsUpdateTripStop = `-- name: TmsUpdateTripStop :one
update
  "tms"."trip_stops"
set
  updated_at = now(),
  trip_id = case when $1 is not null then
    $1::uuid
  else
    trip_id
  end,
  shipment_id = case when $2 is not null then
    $2::uuid
  else
    shipment_id
  end,
  sequence =
    case when $3 is not null then
      $3::integer
    else
      sequence
    end,
    address = case when $4 is not null then
      $4::varchar
    else
      address
    end,
    status = case when $5 is not null then
      $5::tms.trip_stop_status_enum
    else
      status
    end,
    estimated_arrival_time = case when $6 is not null then
      $6::timestamp
    else
      estimated_arrival_time
    end,
    actual_arrival_time = case when $7 is not null then
      $7::timestamp
    else
      actual_arrival_time
    end,
    estimated_departure_time = case when $8 is not null then
      $8::timestamp
    else
      estimated_departure_time
    end,
    actual_departure_time = case when $9 is not null then
      $9::timestamp
    else
      actual_departure_time
    end
  where
    id = $10::uuid
  returning
    id, trip_id, shipment_id, sequence, address, status, estimated_arrival_time, actual_arrival_time, estimated_departure_time, actual_departure_time, created_at, updated_at
`

type TmsUpdateTripStopParams struct {
	TripID                 pgtype.UUID               `db:"trip_id" json:"trip_id"`
	ShipmentID             pgtype.UUID               `db:"shipment_id" json:"shipment_id"`
	Sequence               int32                     `db:"sequence" fake:"{number:1,10}" json:"sequence"`
	Address                pgtype.Text               `db:"address" fake:"{streetaddress}" json:"address"`
	Status                 NullTmsTripStopStatusEnum `db:"status" json:"status"`
	EstimatedArrivalTime   pgtype.Timestamp          `db:"estimated_arrival_time" fake:"{date}" json:"estimated_arrival_time"`
	ActualArrivalTime      pgtype.Timestamp          `db:"actual_arrival_time" fake:"{date}" json:"actual_arrival_time"`
	EstimatedDepartureTime pgtype.Timestamp          `db:"estimated_departure_time" fake:"{date}" json:"estimated_departure_time"`
	ActualDepartureTime    pgtype.Timestamp          `db:"actual_departure_time" fake:"{date}" json:"actual_departure_time"`
	ID                     pgtype.UUID               `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateTripStop(ctx context.Context, arg TmsUpdateTripStopParams) (TmsTripStop, error) {
	row := q.db.QueryRow(ctx, tmsUpdateTripStop,
		arg.TripID,
		arg.ShipmentID,
		arg.Sequence,
		arg.Address,
		arg.Status,
		arg.EstimatedArrivalTime,
		arg.ActualArrivalTime,
		arg.EstimatedDepartureTime,
		arg.ActualDepartureTime,
		arg.ID,
	)
	var i TmsTripStop
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.ShipmentID,
		&i.Sequence,
		&i.Address,
		&i.Status,
		&i.EstimatedArrivalTime,
		&i.ActualArrivalTime,
		&i.EstimatedDepartureTime,
		&i.ActualDepartureTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
