// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_disputes.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyDispute = `-- name: BillingAnyDispute :many
select
  disputes.id, disputes.line_item_id, disputes.client_id, disputes.reason, disputes.status, disputes.disputed_amount, disputes.resolution_notes, disputes.submitted_at, disputes.resolved_at, disputes.resolved_by_user_id, disputes.created_at, disputes.updated_at,
  line_item.id, line_item.invoice_id, line_item.source_record_id, line_item.source_record_type, line_item.description, line_item.quantity, line_item.unit_price, line_item.total_price, line_item.tax_rate, line_item.tax_amount, line_item.discount_rate, line_item.discount_amount, line_item.line_total, line_item.created_at, line_item.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  resolved_by_user.id, resolved_by_user.name, resolved_by_user.email, resolved_by_user.email_verified, resolved_by_user.image, resolved_by_user.created_at, resolved_by_user.updated_at, resolved_by_user.role, resolved_by_user.banned, resolved_by_user.ban_reason, resolved_by_user.ban_expires
from
  "billing"."disputes" as disputes
  inner join "billing"."invoice_line_items" as line_item on disputes.line_item_id = line_item.id
  inner join "crm"."companies" as client on disputes.client_id = client.id
  left join "public"."user" as resolved_by_user on disputes.resolved_by_user_id = resolved_by_user.id
where
  disputes.id = any ($1::uuid[])
`

type BillingAnyDisputeRow struct {
	ID                     pgtype.UUID                  `db:"id" json:"id"`
	LineItemID             pgtype.UUID                  `db:"line_item_id" json:"line_item_id"`
	ClientID               pgtype.UUID                  `db:"client_id" json:"client_id"`
	Reason                 string                       `db:"reason" fake:"{sentence}" json:"reason"`
	Status                 NullBillingDisputeStatusEnum `db:"status" json:"status"`
	DisputedAmount         pgtype.Numeric               `db:"disputed_amount" fake:"{price:10,1000}" json:"disputed_amount"`
	ResolutionNotes        pgtype.Text                  `db:"resolution_notes" fake:"{sentence}" json:"resolution_notes"`
	SubmittedAt            pgtype.Timestamp             `db:"submitted_at" fake:"{date}" json:"submitted_at"`
	ResolvedAt             pgtype.Timestamp             `db:"resolved_at" fake:"{date}" json:"resolved_at"`
	ResolvedByUserID       pgtype.Text                  `db:"resolved_by_user_id" json:"resolved_by_user_id"`
	CreatedAt              pgtype.Timestamp             `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp             `db:"updated_at" json:"updated_at"`
	BillingInvoiceLineItem BillingInvoiceLineItem       `db:"billing_invoice_line_item" json:"billing_invoice_line_item"`
	CrmCompany             CrmCompany                   `db:"crm_company" json:"crm_company"`
	User                   User                         `db:"user" json:"user"`
}

func (q *Queries) BillingAnyDispute(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyDisputeRow, error) {
	rows, err := q.db.Query(ctx, billingAnyDispute, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyDisputeRow
	for rows.Next() {
		var i BillingAnyDisputeRow
		if err := rows.Scan(
			&i.ID,
			&i.LineItemID,
			&i.ClientID,
			&i.Reason,
			&i.Status,
			&i.DisputedAmount,
			&i.ResolutionNotes,
			&i.SubmittedAt,
			&i.ResolvedAt,
			&i.ResolvedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BillingInvoiceLineItem.ID,
			&i.BillingInvoiceLineItem.InvoiceID,
			&i.BillingInvoiceLineItem.SourceRecordID,
			&i.BillingInvoiceLineItem.SourceRecordType,
			&i.BillingInvoiceLineItem.Description,
			&i.BillingInvoiceLineItem.Quantity,
			&i.BillingInvoiceLineItem.UnitPrice,
			&i.BillingInvoiceLineItem.TotalPrice,
			&i.BillingInvoiceLineItem.TaxRate,
			&i.BillingInvoiceLineItem.TaxAmount,
			&i.BillingInvoiceLineItem.DiscountRate,
			&i.BillingInvoiceLineItem.DiscountAmount,
			&i.BillingInvoiceLineItem.LineTotal,
			&i.BillingInvoiceLineItem.CreatedAt,
			&i.BillingInvoiceLineItem.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindDispute = `-- name: BillingFindDispute :one
select
  disputes.id, disputes.line_item_id, disputes.client_id, disputes.reason, disputes.status, disputes.disputed_amount, disputes.resolution_notes, disputes.submitted_at, disputes.resolved_at, disputes.resolved_by_user_id, disputes.created_at, disputes.updated_at,
  line_item.id, line_item.invoice_id, line_item.source_record_id, line_item.source_record_type, line_item.description, line_item.quantity, line_item.unit_price, line_item.total_price, line_item.tax_rate, line_item.tax_amount, line_item.discount_rate, line_item.discount_amount, line_item.line_total, line_item.created_at, line_item.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  resolved_by_user.id, resolved_by_user.name, resolved_by_user.email, resolved_by_user.email_verified, resolved_by_user.image, resolved_by_user.created_at, resolved_by_user.updated_at, resolved_by_user.role, resolved_by_user.banned, resolved_by_user.ban_reason, resolved_by_user.ban_expires
from
  "billing"."disputes" as disputes
  inner join "billing"."invoice_line_items" as line_item on disputes.line_item_id = line_item.id
  inner join "crm"."companies" as client on disputes.client_id = client.id
  left join "public"."user" as resolved_by_user on disputes.resolved_by_user_id = resolved_by_user.id
where
  disputes.id = $1::uuid
`

type BillingFindDisputeRow struct {
	ID                     pgtype.UUID                  `db:"id" json:"id"`
	LineItemID             pgtype.UUID                  `db:"line_item_id" json:"line_item_id"`
	ClientID               pgtype.UUID                  `db:"client_id" json:"client_id"`
	Reason                 string                       `db:"reason" fake:"{sentence}" json:"reason"`
	Status                 NullBillingDisputeStatusEnum `db:"status" json:"status"`
	DisputedAmount         pgtype.Numeric               `db:"disputed_amount" fake:"{price:10,1000}" json:"disputed_amount"`
	ResolutionNotes        pgtype.Text                  `db:"resolution_notes" fake:"{sentence}" json:"resolution_notes"`
	SubmittedAt            pgtype.Timestamp             `db:"submitted_at" fake:"{date}" json:"submitted_at"`
	ResolvedAt             pgtype.Timestamp             `db:"resolved_at" fake:"{date}" json:"resolved_at"`
	ResolvedByUserID       pgtype.Text                  `db:"resolved_by_user_id" json:"resolved_by_user_id"`
	CreatedAt              pgtype.Timestamp             `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp             `db:"updated_at" json:"updated_at"`
	BillingInvoiceLineItem BillingInvoiceLineItem       `db:"billing_invoice_line_item" json:"billing_invoice_line_item"`
	CrmCompany             CrmCompany                   `db:"crm_company" json:"crm_company"`
	User                   User                         `db:"user" json:"user"`
}

func (q *Queries) BillingFindDispute(ctx context.Context, id pgtype.UUID) (BillingFindDisputeRow, error) {
	row := q.db.QueryRow(ctx, billingFindDispute, id)
	var i BillingFindDisputeRow
	err := row.Scan(
		&i.ID,
		&i.LineItemID,
		&i.ClientID,
		&i.Reason,
		&i.Status,
		&i.DisputedAmount,
		&i.ResolutionNotes,
		&i.SubmittedAt,
		&i.ResolvedAt,
		&i.ResolvedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BillingInvoiceLineItem.ID,
		&i.BillingInvoiceLineItem.InvoiceID,
		&i.BillingInvoiceLineItem.SourceRecordID,
		&i.BillingInvoiceLineItem.SourceRecordType,
		&i.BillingInvoiceLineItem.Description,
		&i.BillingInvoiceLineItem.Quantity,
		&i.BillingInvoiceLineItem.UnitPrice,
		&i.BillingInvoiceLineItem.TotalPrice,
		&i.BillingInvoiceLineItem.TaxRate,
		&i.BillingInvoiceLineItem.TaxAmount,
		&i.BillingInvoiceLineItem.DiscountRate,
		&i.BillingInvoiceLineItem.DiscountAmount,
		&i.BillingInvoiceLineItem.LineTotal,
		&i.BillingInvoiceLineItem.CreatedAt,
		&i.BillingInvoiceLineItem.UpdatedAt,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertDispute = `-- name: BillingInsertDispute :one
insert into "billing"."disputes"(line_item_id, client_id, reason, status, disputed_amount, resolution_notes, submitted_at, resolved_at, resolved_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning
  id, line_item_id, client_id, reason, status, disputed_amount, resolution_notes, submitted_at, resolved_at, resolved_by_user_id, created_at, updated_at
`

type BillingInsertDisputeParams struct {
	LineItemID       pgtype.UUID                  `db:"line_item_id" json:"line_item_id"`
	ClientID         pgtype.UUID                  `db:"client_id" json:"client_id"`
	Reason           string                       `db:"reason" fake:"{sentence}" json:"reason"`
	Status           NullBillingDisputeStatusEnum `db:"status" json:"status"`
	DisputedAmount   pgtype.Numeric               `db:"disputed_amount" fake:"{price:10,1000}" json:"disputed_amount"`
	ResolutionNotes  pgtype.Text                  `db:"resolution_notes" fake:"{sentence}" json:"resolution_notes"`
	SubmittedAt      pgtype.Timestamp             `db:"submitted_at" fake:"{date}" json:"submitted_at"`
	ResolvedAt       pgtype.Timestamp             `db:"resolved_at" fake:"{date}" json:"resolved_at"`
	ResolvedByUserID pgtype.Text                  `db:"resolved_by_user_id" json:"resolved_by_user_id"`
}

func (q *Queries) BillingInsertDispute(ctx context.Context, arg BillingInsertDisputeParams) (BillingDispute, error) {
	row := q.db.QueryRow(ctx, billingInsertDispute,
		arg.LineItemID,
		arg.ClientID,
		arg.Reason,
		arg.Status,
		arg.DisputedAmount,
		arg.ResolutionNotes,
		arg.SubmittedAt,
		arg.ResolvedAt,
		arg.ResolvedByUserID,
	)
	var i BillingDispute
	err := row.Scan(
		&i.ID,
		&i.LineItemID,
		&i.ClientID,
		&i.Reason,
		&i.Status,
		&i.DisputedAmount,
		&i.ResolutionNotes,
		&i.SubmittedAt,
		&i.ResolvedAt,
		&i.ResolvedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateDispute = `-- name: BillingPaginateDispute :many
select
  disputes.id, disputes.line_item_id, disputes.client_id, disputes.reason, disputes.status, disputes.disputed_amount, disputes.resolution_notes, disputes.submitted_at, disputes.resolved_at, disputes.resolved_by_user_id, disputes.created_at, disputes.updated_at,
  line_item.id, line_item.invoice_id, line_item.source_record_id, line_item.source_record_type, line_item.description, line_item.quantity, line_item.unit_price, line_item.total_price, line_item.tax_rate, line_item.tax_amount, line_item.discount_rate, line_item.discount_amount, line_item.line_total, line_item.created_at, line_item.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  resolved_by_user.id, resolved_by_user.name, resolved_by_user.email, resolved_by_user.email_verified, resolved_by_user.image, resolved_by_user.created_at, resolved_by_user.updated_at, resolved_by_user.role, resolved_by_user.banned, resolved_by_user.ban_reason, resolved_by_user.ban_expires
from
  "billing"."disputes" as disputes
  inner join "billing"."invoice_line_items" as line_item on disputes.line_item_id = line_item.id
  inner join "crm"."companies" as client on disputes.client_id = client.id
  left join "public"."user" as resolved_by_user on disputes.resolved_by_user_id = resolved_by_user.id
where (line_item.description ilike $1::text
  or client.name ilike $1::text
  or resolved_by_user.name ilike $1::text
  or disputes.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateDisputeParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type BillingPaginateDisputeRow struct {
	ID                     pgtype.UUID                  `db:"id" json:"id"`
	LineItemID             pgtype.UUID                  `db:"line_item_id" json:"line_item_id"`
	ClientID               pgtype.UUID                  `db:"client_id" json:"client_id"`
	Reason                 string                       `db:"reason" fake:"{sentence}" json:"reason"`
	Status                 NullBillingDisputeStatusEnum `db:"status" json:"status"`
	DisputedAmount         pgtype.Numeric               `db:"disputed_amount" fake:"{price:10,1000}" json:"disputed_amount"`
	ResolutionNotes        pgtype.Text                  `db:"resolution_notes" fake:"{sentence}" json:"resolution_notes"`
	SubmittedAt            pgtype.Timestamp             `db:"submitted_at" fake:"{date}" json:"submitted_at"`
	ResolvedAt             pgtype.Timestamp             `db:"resolved_at" fake:"{date}" json:"resolved_at"`
	ResolvedByUserID       pgtype.Text                  `db:"resolved_by_user_id" json:"resolved_by_user_id"`
	CreatedAt              pgtype.Timestamp             `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp             `db:"updated_at" json:"updated_at"`
	BillingInvoiceLineItem BillingInvoiceLineItem       `db:"billing_invoice_line_item" json:"billing_invoice_line_item"`
	CrmCompany             CrmCompany                   `db:"crm_company" json:"crm_company"`
	User                   User                         `db:"user" json:"user"`
}

func (q *Queries) BillingPaginateDispute(ctx context.Context, arg BillingPaginateDisputeParams) ([]BillingPaginateDisputeRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateDispute, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateDisputeRow
	for rows.Next() {
		var i BillingPaginateDisputeRow
		if err := rows.Scan(
			&i.ID,
			&i.LineItemID,
			&i.ClientID,
			&i.Reason,
			&i.Status,
			&i.DisputedAmount,
			&i.ResolutionNotes,
			&i.SubmittedAt,
			&i.ResolvedAt,
			&i.ResolvedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BillingInvoiceLineItem.ID,
			&i.BillingInvoiceLineItem.InvoiceID,
			&i.BillingInvoiceLineItem.SourceRecordID,
			&i.BillingInvoiceLineItem.SourceRecordType,
			&i.BillingInvoiceLineItem.Description,
			&i.BillingInvoiceLineItem.Quantity,
			&i.BillingInvoiceLineItem.UnitPrice,
			&i.BillingInvoiceLineItem.TotalPrice,
			&i.BillingInvoiceLineItem.TaxRate,
			&i.BillingInvoiceLineItem.TaxAmount,
			&i.BillingInvoiceLineItem.DiscountRate,
			&i.BillingInvoiceLineItem.DiscountAmount,
			&i.BillingInvoiceLineItem.LineTotal,
			&i.BillingInvoiceLineItem.CreatedAt,
			&i.BillingInvoiceLineItem.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingPaginateDisputeMetadata = `-- name: BillingPaginateDisputeMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "billing"."disputes" as disputes
`

type BillingPaginateDisputeMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type BillingPaginateDisputeMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) BillingPaginateDisputeMetadata(ctx context.Context, arg BillingPaginateDisputeMetadataParams) (BillingPaginateDisputeMetadataRow, error) {
	row := q.db.QueryRow(ctx, billingPaginateDisputeMetadata, arg.PerPage, arg.Page)
	var i BillingPaginateDisputeMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const billingRangeDispute = `-- name: BillingRangeDispute :many
select
  disputes.id, disputes.line_item_id, disputes.client_id, disputes.reason, disputes.status, disputes.disputed_amount, disputes.resolution_notes, disputes.submitted_at, disputes.resolved_at, disputes.resolved_by_user_id, disputes.created_at, disputes.updated_at,
  line_item.id, line_item.invoice_id, line_item.source_record_id, line_item.source_record_type, line_item.description, line_item.quantity, line_item.unit_price, line_item.total_price, line_item.tax_rate, line_item.tax_amount, line_item.discount_rate, line_item.discount_amount, line_item.line_total, line_item.created_at, line_item.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  resolved_by_user.id, resolved_by_user.name, resolved_by_user.email, resolved_by_user.email_verified, resolved_by_user.image, resolved_by_user.created_at, resolved_by_user.updated_at, resolved_by_user.role, resolved_by_user.banned, resolved_by_user.ban_reason, resolved_by_user.ban_expires
from
  "billing"."disputes" as disputes
  inner join "billing"."invoice_line_items" as line_item on disputes.line_item_id = line_item.id
  inner join "crm"."companies" as client on disputes.client_id = client.id
  left join "public"."user" as resolved_by_user on disputes.resolved_by_user_id = resolved_by_user.id
where
  disputes.created_at >= $1::date
  and disputes.created_at <= $2::date
  and (line_item.description ilike $3::text
    or client.name ilike $3::text
    or resolved_by_user.name ilike $3::text
    or disputes.status::text ilike $3::text
    or $3::text is null)
`

type BillingRangeDisputeParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type BillingRangeDisputeRow struct {
	ID                     pgtype.UUID                  `db:"id" json:"id"`
	LineItemID             pgtype.UUID                  `db:"line_item_id" json:"line_item_id"`
	ClientID               pgtype.UUID                  `db:"client_id" json:"client_id"`
	Reason                 string                       `db:"reason" fake:"{sentence}" json:"reason"`
	Status                 NullBillingDisputeStatusEnum `db:"status" json:"status"`
	DisputedAmount         pgtype.Numeric               `db:"disputed_amount" fake:"{price:10,1000}" json:"disputed_amount"`
	ResolutionNotes        pgtype.Text                  `db:"resolution_notes" fake:"{sentence}" json:"resolution_notes"`
	SubmittedAt            pgtype.Timestamp             `db:"submitted_at" fake:"{date}" json:"submitted_at"`
	ResolvedAt             pgtype.Timestamp             `db:"resolved_at" fake:"{date}" json:"resolved_at"`
	ResolvedByUserID       pgtype.Text                  `db:"resolved_by_user_id" json:"resolved_by_user_id"`
	CreatedAt              pgtype.Timestamp             `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp             `db:"updated_at" json:"updated_at"`
	BillingInvoiceLineItem BillingInvoiceLineItem       `db:"billing_invoice_line_item" json:"billing_invoice_line_item"`
	CrmCompany             CrmCompany                   `db:"crm_company" json:"crm_company"`
	User                   User                         `db:"user" json:"user"`
}

func (q *Queries) BillingRangeDispute(ctx context.Context, arg BillingRangeDisputeParams) ([]BillingRangeDisputeRow, error) {
	rows, err := q.db.Query(ctx, billingRangeDispute, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeDisputeRow
	for rows.Next() {
		var i BillingRangeDisputeRow
		if err := rows.Scan(
			&i.ID,
			&i.LineItemID,
			&i.ClientID,
			&i.Reason,
			&i.Status,
			&i.DisputedAmount,
			&i.ResolutionNotes,
			&i.SubmittedAt,
			&i.ResolvedAt,
			&i.ResolvedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BillingInvoiceLineItem.ID,
			&i.BillingInvoiceLineItem.InvoiceID,
			&i.BillingInvoiceLineItem.SourceRecordID,
			&i.BillingInvoiceLineItem.SourceRecordType,
			&i.BillingInvoiceLineItem.Description,
			&i.BillingInvoiceLineItem.Quantity,
			&i.BillingInvoiceLineItem.UnitPrice,
			&i.BillingInvoiceLineItem.TotalPrice,
			&i.BillingInvoiceLineItem.TaxRate,
			&i.BillingInvoiceLineItem.TaxAmount,
			&i.BillingInvoiceLineItem.DiscountRate,
			&i.BillingInvoiceLineItem.DiscountAmount,
			&i.BillingInvoiceLineItem.LineTotal,
			&i.BillingInvoiceLineItem.CreatedAt,
			&i.BillingInvoiceLineItem.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveDispute = `-- name: BillingRemoveDispute :exec
delete from "billing"."disputes"
where id = $1::uuid
`

func (q *Queries) BillingRemoveDispute(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveDispute, id)
	return err
}

const billingUpdateDispute = `-- name: BillingUpdateDispute :one
update
  "billing"."disputes"
set
  updated_at = now(),
  line_item_id = case when $1 is not null then
    $1::uuid
  else
    line_item_id
  end,
  client_id = case when $2 is not null then
    $2::uuid
  else
    client_id
  end,
  reason = case when $3 is not null then
    $3::text
  else
    reason
  end,
  status = case when $4 is not null then
    $4::billing.dispute_status_enum
  else
    status
  end,
  disputed_amount = case when $5 is not null then
    $5::numeric
  else
    disputed_amount
  end,
  resolution_notes = case when $6 is not null then
    $6::text
  else
    resolution_notes
  end,
  submitted_at = case when $7 is not null then
    $7::timestamp
  else
    submitted_at
  end,
  resolved_at = case when $8 is not null then
    $8::timestamp
  else
    resolved_at
  end,
  resolved_by_user_id = case when $9 is not null then
    $9::text
  else
    resolved_by_user_id
  end
where
  id = $10::uuid
returning
  id, line_item_id, client_id, reason, status, disputed_amount, resolution_notes, submitted_at, resolved_at, resolved_by_user_id, created_at, updated_at
`

type BillingUpdateDisputeParams struct {
	LineItemID       pgtype.UUID                  `db:"line_item_id" json:"line_item_id"`
	ClientID         pgtype.UUID                  `db:"client_id" json:"client_id"`
	Reason           string                       `db:"reason" fake:"{sentence}" json:"reason"`
	Status           NullBillingDisputeStatusEnum `db:"status" json:"status"`
	DisputedAmount   pgtype.Numeric               `db:"disputed_amount" fake:"{price:10,1000}" json:"disputed_amount"`
	ResolutionNotes  pgtype.Text                  `db:"resolution_notes" fake:"{sentence}" json:"resolution_notes"`
	SubmittedAt      pgtype.Timestamp             `db:"submitted_at" fake:"{date}" json:"submitted_at"`
	ResolvedAt       pgtype.Timestamp             `db:"resolved_at" fake:"{date}" json:"resolved_at"`
	ResolvedByUserID pgtype.Text                  `db:"resolved_by_user_id" json:"resolved_by_user_id"`
	ID               pgtype.UUID                  `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateDispute(ctx context.Context, arg BillingUpdateDisputeParams) (BillingDispute, error) {
	row := q.db.QueryRow(ctx, billingUpdateDispute,
		arg.LineItemID,
		arg.ClientID,
		arg.Reason,
		arg.Status,
		arg.DisputedAmount,
		arg.ResolutionNotes,
		arg.SubmittedAt,
		arg.ResolvedAt,
		arg.ResolvedByUserID,
		arg.ID,
	)
	var i BillingDispute
	err := row.Scan(
		&i.ID,
		&i.LineItemID,
		&i.ClientID,
		&i.Reason,
		&i.Status,
		&i.DisputedAmount,
		&i.ResolutionNotes,
		&i.SubmittedAt,
		&i.ResolvedAt,
		&i.ResolvedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
