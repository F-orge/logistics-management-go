// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_disputes.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyDispute = `-- name: BillingAnyDispute :many
select
  disputes.id, disputes.line_item_id, disputes.client_id, disputes.reason, disputes.status, disputes.disputed_amount, disputes.resolution_notes, disputes.submitted_at, disputes.resolved_at, disputes.resolved_by_user_id, disputes.created_at, disputes.updated_at,
  line_item.id, line_item.invoice_id, line_item.source_record_id, line_item.source_record_type, line_item.description, line_item.quantity, line_item.unit_price, line_item.total_price, line_item.tax_rate, line_item.tax_amount, line_item.discount_rate, line_item.discount_amount, line_item.line_total, line_item.created_at, line_item.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  resolved_by_user.id, resolved_by_user.name, resolved_by_user.email, resolved_by_user.email_verified, resolved_by_user.image, resolved_by_user.created_at, resolved_by_user.updated_at, resolved_by_user.role, resolved_by_user.banned, resolved_by_user.ban_reason, resolved_by_user.ban_expires
from
  "billing"."disputes" as disputes
  inner join "billing"."invoice_line_items" as line_item on disputes.line_item_id = line_item.id
  inner join "crm"."companies" as client on disputes.client_id = client.id
  left join "public"."user" as resolved_by_user on disputes.resolved_by_user_id = resolved_by_user.id
where
  disputes.id = any ($1::uuid[])
`

type BillingAnyDisputeRow struct {
	BillingDispute         BillingDispute
	BillingInvoiceLineItem BillingInvoiceLineItem
	CrmCompany             CrmCompany
	User                   User
}

func (q *Queries) BillingAnyDispute(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyDisputeRow, error) {
	rows, err := q.db.Query(ctx, billingAnyDispute, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyDisputeRow
	for rows.Next() {
		var i BillingAnyDisputeRow
		if err := rows.Scan(
			&i.BillingDispute.ID,
			&i.BillingDispute.LineItemID,
			&i.BillingDispute.ClientID,
			&i.BillingDispute.Reason,
			&i.BillingDispute.Status,
			&i.BillingDispute.DisputedAmount,
			&i.BillingDispute.ResolutionNotes,
			&i.BillingDispute.SubmittedAt,
			&i.BillingDispute.ResolvedAt,
			&i.BillingDispute.ResolvedByUserID,
			&i.BillingDispute.CreatedAt,
			&i.BillingDispute.UpdatedAt,
			&i.BillingInvoiceLineItem.ID,
			&i.BillingInvoiceLineItem.InvoiceID,
			&i.BillingInvoiceLineItem.SourceRecordID,
			&i.BillingInvoiceLineItem.SourceRecordType,
			&i.BillingInvoiceLineItem.Description,
			&i.BillingInvoiceLineItem.Quantity,
			&i.BillingInvoiceLineItem.UnitPrice,
			&i.BillingInvoiceLineItem.TotalPrice,
			&i.BillingInvoiceLineItem.TaxRate,
			&i.BillingInvoiceLineItem.TaxAmount,
			&i.BillingInvoiceLineItem.DiscountRate,
			&i.BillingInvoiceLineItem.DiscountAmount,
			&i.BillingInvoiceLineItem.LineTotal,
			&i.BillingInvoiceLineItem.CreatedAt,
			&i.BillingInvoiceLineItem.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindDispute = `-- name: BillingFindDispute :one
select
  disputes.id, disputes.line_item_id, disputes.client_id, disputes.reason, disputes.status, disputes.disputed_amount, disputes.resolution_notes, disputes.submitted_at, disputes.resolved_at, disputes.resolved_by_user_id, disputes.created_at, disputes.updated_at,
  line_item.id, line_item.invoice_id, line_item.source_record_id, line_item.source_record_type, line_item.description, line_item.quantity, line_item.unit_price, line_item.total_price, line_item.tax_rate, line_item.tax_amount, line_item.discount_rate, line_item.discount_amount, line_item.line_total, line_item.created_at, line_item.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  resolved_by_user.id, resolved_by_user.name, resolved_by_user.email, resolved_by_user.email_verified, resolved_by_user.image, resolved_by_user.created_at, resolved_by_user.updated_at, resolved_by_user.role, resolved_by_user.banned, resolved_by_user.ban_reason, resolved_by_user.ban_expires
from
  "billing"."disputes" as disputes
  inner join "billing"."invoice_line_items" as line_item on disputes.line_item_id = line_item.id
  inner join "crm"."companies" as client on disputes.client_id = client.id
  left join "public"."user" as resolved_by_user on disputes.resolved_by_user_id = resolved_by_user.id
where
  disputes.id = $1::uuid
`

type BillingFindDisputeRow struct {
	BillingDispute         BillingDispute
	BillingInvoiceLineItem BillingInvoiceLineItem
	CrmCompany             CrmCompany
	User                   User
}

func (q *Queries) BillingFindDispute(ctx context.Context, id pgtype.UUID) (BillingFindDisputeRow, error) {
	row := q.db.QueryRow(ctx, billingFindDispute, id)
	var i BillingFindDisputeRow
	err := row.Scan(
		&i.BillingDispute.ID,
		&i.BillingDispute.LineItemID,
		&i.BillingDispute.ClientID,
		&i.BillingDispute.Reason,
		&i.BillingDispute.Status,
		&i.BillingDispute.DisputedAmount,
		&i.BillingDispute.ResolutionNotes,
		&i.BillingDispute.SubmittedAt,
		&i.BillingDispute.ResolvedAt,
		&i.BillingDispute.ResolvedByUserID,
		&i.BillingDispute.CreatedAt,
		&i.BillingDispute.UpdatedAt,
		&i.BillingInvoiceLineItem.ID,
		&i.BillingInvoiceLineItem.InvoiceID,
		&i.BillingInvoiceLineItem.SourceRecordID,
		&i.BillingInvoiceLineItem.SourceRecordType,
		&i.BillingInvoiceLineItem.Description,
		&i.BillingInvoiceLineItem.Quantity,
		&i.BillingInvoiceLineItem.UnitPrice,
		&i.BillingInvoiceLineItem.TotalPrice,
		&i.BillingInvoiceLineItem.TaxRate,
		&i.BillingInvoiceLineItem.TaxAmount,
		&i.BillingInvoiceLineItem.DiscountRate,
		&i.BillingInvoiceLineItem.DiscountAmount,
		&i.BillingInvoiceLineItem.LineTotal,
		&i.BillingInvoiceLineItem.CreatedAt,
		&i.BillingInvoiceLineItem.UpdatedAt,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertDispute = `-- name: BillingInsertDispute :one
insert into "billing"."disputes"(line_item_id, client_id, reason, status, disputed_amount, resolution_notes, submitted_at, resolved_at, resolved_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning
  id, line_item_id, client_id, reason, status, disputed_amount, resolution_notes, submitted_at, resolved_at, resolved_by_user_id, created_at, updated_at
`

type BillingInsertDisputeParams struct {
	LineItemID       pgtype.UUID
	ClientID         pgtype.UUID
	Reason           string
	Status           NullBillingDisputeStatusEnum
	DisputedAmount   pgtype.Numeric
	ResolutionNotes  pgtype.Text
	SubmittedAt      pgtype.Timestamp
	ResolvedAt       pgtype.Timestamp
	ResolvedByUserID pgtype.Text
}

func (q *Queries) BillingInsertDispute(ctx context.Context, arg BillingInsertDisputeParams) (BillingDispute, error) {
	row := q.db.QueryRow(ctx, billingInsertDispute,
		arg.LineItemID,
		arg.ClientID,
		arg.Reason,
		arg.Status,
		arg.DisputedAmount,
		arg.ResolutionNotes,
		arg.SubmittedAt,
		arg.ResolvedAt,
		arg.ResolvedByUserID,
	)
	var i BillingDispute
	err := row.Scan(
		&i.ID,
		&i.LineItemID,
		&i.ClientID,
		&i.Reason,
		&i.Status,
		&i.DisputedAmount,
		&i.ResolutionNotes,
		&i.SubmittedAt,
		&i.ResolvedAt,
		&i.ResolvedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateDispute = `-- name: BillingPaginateDispute :many
select
  disputes.id, disputes.line_item_id, disputes.client_id, disputes.reason, disputes.status, disputes.disputed_amount, disputes.resolution_notes, disputes.submitted_at, disputes.resolved_at, disputes.resolved_by_user_id, disputes.created_at, disputes.updated_at,
  line_item.id, line_item.invoice_id, line_item.source_record_id, line_item.source_record_type, line_item.description, line_item.quantity, line_item.unit_price, line_item.total_price, line_item.tax_rate, line_item.tax_amount, line_item.discount_rate, line_item.discount_amount, line_item.line_total, line_item.created_at, line_item.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  resolved_by_user.id, resolved_by_user.name, resolved_by_user.email, resolved_by_user.email_verified, resolved_by_user.image, resolved_by_user.created_at, resolved_by_user.updated_at, resolved_by_user.role, resolved_by_user.banned, resolved_by_user.ban_reason, resolved_by_user.ban_expires
from
  "billing"."disputes" as disputes
  inner join "billing"."invoice_line_items" as line_item on disputes.line_item_id = line_item.id
  inner join "crm"."companies" as client on disputes.client_id = client.id
  left join "public"."user" as resolved_by_user on disputes.resolved_by_user_id = resolved_by_user.id
limit $2::int offset ($1::int - 1) * $2::int
`

type BillingPaginateDisputeParams struct {
	Page    int32
	Perpage int32
}

type BillingPaginateDisputeRow struct {
	BillingDispute         BillingDispute
	BillingInvoiceLineItem BillingInvoiceLineItem
	CrmCompany             CrmCompany
	User                   User
}

func (q *Queries) BillingPaginateDispute(ctx context.Context, arg BillingPaginateDisputeParams) ([]BillingPaginateDisputeRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateDispute, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateDisputeRow
	for rows.Next() {
		var i BillingPaginateDisputeRow
		if err := rows.Scan(
			&i.BillingDispute.ID,
			&i.BillingDispute.LineItemID,
			&i.BillingDispute.ClientID,
			&i.BillingDispute.Reason,
			&i.BillingDispute.Status,
			&i.BillingDispute.DisputedAmount,
			&i.BillingDispute.ResolutionNotes,
			&i.BillingDispute.SubmittedAt,
			&i.BillingDispute.ResolvedAt,
			&i.BillingDispute.ResolvedByUserID,
			&i.BillingDispute.CreatedAt,
			&i.BillingDispute.UpdatedAt,
			&i.BillingInvoiceLineItem.ID,
			&i.BillingInvoiceLineItem.InvoiceID,
			&i.BillingInvoiceLineItem.SourceRecordID,
			&i.BillingInvoiceLineItem.SourceRecordType,
			&i.BillingInvoiceLineItem.Description,
			&i.BillingInvoiceLineItem.Quantity,
			&i.BillingInvoiceLineItem.UnitPrice,
			&i.BillingInvoiceLineItem.TotalPrice,
			&i.BillingInvoiceLineItem.TaxRate,
			&i.BillingInvoiceLineItem.TaxAmount,
			&i.BillingInvoiceLineItem.DiscountRate,
			&i.BillingInvoiceLineItem.DiscountAmount,
			&i.BillingInvoiceLineItem.LineTotal,
			&i.BillingInvoiceLineItem.CreatedAt,
			&i.BillingInvoiceLineItem.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeDispute = `-- name: BillingRangeDispute :many
select
  disputes.id, disputes.line_item_id, disputes.client_id, disputes.reason, disputes.status, disputes.disputed_amount, disputes.resolution_notes, disputes.submitted_at, disputes.resolved_at, disputes.resolved_by_user_id, disputes.created_at, disputes.updated_at,
  line_item.id, line_item.invoice_id, line_item.source_record_id, line_item.source_record_type, line_item.description, line_item.quantity, line_item.unit_price, line_item.total_price, line_item.tax_rate, line_item.tax_amount, line_item.discount_rate, line_item.discount_amount, line_item.line_total, line_item.created_at, line_item.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  resolved_by_user.id, resolved_by_user.name, resolved_by_user.email, resolved_by_user.email_verified, resolved_by_user.image, resolved_by_user.created_at, resolved_by_user.updated_at, resolved_by_user.role, resolved_by_user.banned, resolved_by_user.ban_reason, resolved_by_user.ban_expires
from
  "billing"."disputes" as disputes
  inner join "billing"."invoice_line_items" as line_item on disputes.line_item_id = line_item.id
  inner join "crm"."companies" as client on disputes.client_id = client.id
  left join "public"."user" as resolved_by_user on disputes.resolved_by_user_id = resolved_by_user.id
where
  disputes.created_at >= $1::date
  and disputes.created_at <= $2::date
`

type BillingRangeDisputeParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type BillingRangeDisputeRow struct {
	BillingDispute         BillingDispute
	BillingInvoiceLineItem BillingInvoiceLineItem
	CrmCompany             CrmCompany
	User                   User
}

func (q *Queries) BillingRangeDispute(ctx context.Context, arg BillingRangeDisputeParams) ([]BillingRangeDisputeRow, error) {
	rows, err := q.db.Query(ctx, billingRangeDispute, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeDisputeRow
	for rows.Next() {
		var i BillingRangeDisputeRow
		if err := rows.Scan(
			&i.BillingDispute.ID,
			&i.BillingDispute.LineItemID,
			&i.BillingDispute.ClientID,
			&i.BillingDispute.Reason,
			&i.BillingDispute.Status,
			&i.BillingDispute.DisputedAmount,
			&i.BillingDispute.ResolutionNotes,
			&i.BillingDispute.SubmittedAt,
			&i.BillingDispute.ResolvedAt,
			&i.BillingDispute.ResolvedByUserID,
			&i.BillingDispute.CreatedAt,
			&i.BillingDispute.UpdatedAt,
			&i.BillingInvoiceLineItem.ID,
			&i.BillingInvoiceLineItem.InvoiceID,
			&i.BillingInvoiceLineItem.SourceRecordID,
			&i.BillingInvoiceLineItem.SourceRecordType,
			&i.BillingInvoiceLineItem.Description,
			&i.BillingInvoiceLineItem.Quantity,
			&i.BillingInvoiceLineItem.UnitPrice,
			&i.BillingInvoiceLineItem.TotalPrice,
			&i.BillingInvoiceLineItem.TaxRate,
			&i.BillingInvoiceLineItem.TaxAmount,
			&i.BillingInvoiceLineItem.DiscountRate,
			&i.BillingInvoiceLineItem.DiscountAmount,
			&i.BillingInvoiceLineItem.LineTotal,
			&i.BillingInvoiceLineItem.CreatedAt,
			&i.BillingInvoiceLineItem.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveDispute = `-- name: BillingRemoveDispute :exec
delete from "billing"."disputes"
where id = $1::uuid
`

func (q *Queries) BillingRemoveDispute(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveDispute, id)
	return err
}

const billingUpdateDispute = `-- name: BillingUpdateDispute :one
update
  "billing"."disputes"
set
  line_item_id = case when $1::boolean then
    $2::uuid
  else
    line_item_id
  end,
  client_id = case when $3::boolean then
    $4::uuid
  else
    client_id
  end,
  reason = case when $5::boolean then
    $6::text
  else
    reason
  end,
  status = case when $7::boolean then
    $8::billing.dispute_status_enum
  else
    status
  end,
  disputed_amount = case when $9::boolean then
    $10::numeric
  else
    disputed_amount
  end,
  resolution_notes = case when $11::boolean then
    $12::text
  else
    resolution_notes
  end,
  submitted_at = case when $13::boolean then
    $14::timestamp
  else
    submitted_at
  end,
  resolved_at = case when $15::boolean then
    $16::timestamp
  else
    resolved_at
  end,
  resolved_by_user_id = case when $17::boolean then
    $18::text
  else
    resolved_by_user_id
  end
where
  id = $19::uuid
returning
  id, line_item_id, client_id, reason, status, disputed_amount, resolution_notes, submitted_at, resolved_at, resolved_by_user_id, created_at, updated_at
`

type BillingUpdateDisputeParams struct {
	SetLineItemID       bool
	LineItemID          pgtype.UUID
	SetClientID         bool
	ClientID            pgtype.UUID
	SetReason           bool
	Reason              string
	SetStatus           bool
	Status              BillingDisputeStatusEnum
	SetDisputedAmount   bool
	DisputedAmount      pgtype.Numeric
	SetResolutionNotes  bool
	ResolutionNotes     string
	SetSubmittedAt      bool
	SubmittedAt         pgtype.Timestamp
	SetResolvedAt       bool
	ResolvedAt          pgtype.Timestamp
	SetResolvedByUserID bool
	ResolvedByUserID    string
	ID                  pgtype.UUID
}

func (q *Queries) BillingUpdateDispute(ctx context.Context, arg BillingUpdateDisputeParams) (BillingDispute, error) {
	row := q.db.QueryRow(ctx, billingUpdateDispute,
		arg.SetLineItemID,
		arg.LineItemID,
		arg.SetClientID,
		arg.ClientID,
		arg.SetReason,
		arg.Reason,
		arg.SetStatus,
		arg.Status,
		arg.SetDisputedAmount,
		arg.DisputedAmount,
		arg.SetResolutionNotes,
		arg.ResolutionNotes,
		arg.SetSubmittedAt,
		arg.SubmittedAt,
		arg.SetResolvedAt,
		arg.ResolvedAt,
		arg.SetResolvedByUserID,
		arg.ResolvedByUserID,
		arg.ID,
	)
	var i BillingDispute
	err := row.Scan(
		&i.ID,
		&i.LineItemID,
		&i.ClientID,
		&i.Reason,
		&i.Status,
		&i.DisputedAmount,
		&i.ResolutionNotes,
		&i.SubmittedAt,
		&i.ResolvedAt,
		&i.ResolvedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
