// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dms_driver_locations.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dmsAnyDriverLocation = `-- name: DmsAnyDriverLocation :many
select
  driver_locations.id, driver_locations.driver_id, driver_locations.latitude, driver_locations.longitude, driver_locations.altitude, driver_locations.accuracy, driver_locations.speed_kmh, driver_locations.heading, driver_locations.timestamp, driver_locations.created_at, driver_locations.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."driver_locations" as driver_locations
  inner join "tms"."drivers" as driver on driver_locations.driver_id = driver.id
where
  driver_locations.id = any ($1::uuid[])
`

type DmsAnyDriverLocationRow struct {
	DmsDriverLocation DmsDriverLocation
	TmsDriver         TmsDriver
}

func (q *Queries) DmsAnyDriverLocation(ctx context.Context, ids []pgtype.UUID) ([]DmsAnyDriverLocationRow, error) {
	rows, err := q.db.Query(ctx, dmsAnyDriverLocation, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsAnyDriverLocationRow
	for rows.Next() {
		var i DmsAnyDriverLocationRow
		if err := rows.Scan(
			&i.DmsDriverLocation.ID,
			&i.DmsDriverLocation.DriverID,
			&i.DmsDriverLocation.Latitude,
			&i.DmsDriverLocation.Longitude,
			&i.DmsDriverLocation.Altitude,
			&i.DmsDriverLocation.Accuracy,
			&i.DmsDriverLocation.SpeedKmh,
			&i.DmsDriverLocation.Heading,
			&i.DmsDriverLocation.Timestamp,
			&i.DmsDriverLocation.CreatedAt,
			&i.DmsDriverLocation.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsFindDriverLocation = `-- name: DmsFindDriverLocation :one
select
  driver_locations.id, driver_locations.driver_id, driver_locations.latitude, driver_locations.longitude, driver_locations.altitude, driver_locations.accuracy, driver_locations.speed_kmh, driver_locations.heading, driver_locations.timestamp, driver_locations.created_at, driver_locations.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."driver_locations" as driver_locations
  inner join "tms"."drivers" as driver on driver_locations.driver_id = driver.id
where
  driver_locations.id = $1::uuid
`

type DmsFindDriverLocationRow struct {
	DmsDriverLocation DmsDriverLocation
	TmsDriver         TmsDriver
}

func (q *Queries) DmsFindDriverLocation(ctx context.Context, id pgtype.UUID) (DmsFindDriverLocationRow, error) {
	row := q.db.QueryRow(ctx, dmsFindDriverLocation, id)
	var i DmsFindDriverLocationRow
	err := row.Scan(
		&i.DmsDriverLocation.ID,
		&i.DmsDriverLocation.DriverID,
		&i.DmsDriverLocation.Latitude,
		&i.DmsDriverLocation.Longitude,
		&i.DmsDriverLocation.Altitude,
		&i.DmsDriverLocation.Accuracy,
		&i.DmsDriverLocation.SpeedKmh,
		&i.DmsDriverLocation.Heading,
		&i.DmsDriverLocation.Timestamp,
		&i.DmsDriverLocation.CreatedAt,
		&i.DmsDriverLocation.UpdatedAt,
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
	)
	return i, err
}

const dmsInsertDriverLocation = `-- name: DmsInsertDriverLocation :one
insert into "dms"."driver_locations"(driver_id, latitude, longitude, altitude, accuracy, speed_kmh, heading, timestamp)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, driver_id, latitude, longitude, altitude, accuracy, speed_kmh, heading, timestamp, created_at, updated_at
`

type DmsInsertDriverLocationParams struct {
	DriverID  pgtype.UUID
	Latitude  float32
	Longitude float32
	Altitude  pgtype.Float4
	Accuracy  pgtype.Float4
	SpeedKmh  pgtype.Float4
	Heading   pgtype.Float4
	Timestamp pgtype.Timestamp
}

func (q *Queries) DmsInsertDriverLocation(ctx context.Context, arg DmsInsertDriverLocationParams) (DmsDriverLocation, error) {
	row := q.db.QueryRow(ctx, dmsInsertDriverLocation,
		arg.DriverID,
		arg.Latitude,
		arg.Longitude,
		arg.Altitude,
		arg.Accuracy,
		arg.SpeedKmh,
		arg.Heading,
		arg.Timestamp,
	)
	var i DmsDriverLocation
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Latitude,
		&i.Longitude,
		&i.Altitude,
		&i.Accuracy,
		&i.SpeedKmh,
		&i.Heading,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dmsPaginateDriverLocation = `-- name: DmsPaginateDriverLocation :many
select
  driver_locations.id, driver_locations.driver_id, driver_locations.latitude, driver_locations.longitude, driver_locations.altitude, driver_locations.accuracy, driver_locations.speed_kmh, driver_locations.heading, driver_locations.timestamp, driver_locations.created_at, driver_locations.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."driver_locations" as driver_locations
  inner join "tms"."drivers" as driver on driver_locations.driver_id = driver.id
where
  (driver.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type DmsPaginateDriverLocationParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type DmsPaginateDriverLocationRow struct {
	DmsDriverLocation DmsDriverLocation
	TmsDriver         TmsDriver
}

func (q *Queries) DmsPaginateDriverLocation(ctx context.Context, arg DmsPaginateDriverLocationParams) ([]DmsPaginateDriverLocationRow, error) {
	rows, err := q.db.Query(ctx, dmsPaginateDriverLocation, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsPaginateDriverLocationRow
	for rows.Next() {
		var i DmsPaginateDriverLocationRow
		if err := rows.Scan(
			&i.DmsDriverLocation.ID,
			&i.DmsDriverLocation.DriverID,
			&i.DmsDriverLocation.Latitude,
			&i.DmsDriverLocation.Longitude,
			&i.DmsDriverLocation.Altitude,
			&i.DmsDriverLocation.Accuracy,
			&i.DmsDriverLocation.SpeedKmh,
			&i.DmsDriverLocation.Heading,
			&i.DmsDriverLocation.Timestamp,
			&i.DmsDriverLocation.CreatedAt,
			&i.DmsDriverLocation.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRangeDriverLocation = `-- name: DmsRangeDriverLocation :many
select
  driver_locations.id, driver_locations.driver_id, driver_locations.latitude, driver_locations.longitude, driver_locations.altitude, driver_locations.accuracy, driver_locations.speed_kmh, driver_locations.heading, driver_locations.timestamp, driver_locations.created_at, driver_locations.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."driver_locations" as driver_locations
  inner join "tms"."drivers" as driver on driver_locations.driver_id = driver.id
where
  driver_locations.created_at >= $1::date
  and driver_locations.created_at <= $2::date
  and (driver.name ilike $3::text
  or $3::text is null)
`

type DmsRangeDriverLocationParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type DmsRangeDriverLocationRow struct {
	DmsDriverLocation DmsDriverLocation
	TmsDriver         TmsDriver
}

func (q *Queries) DmsRangeDriverLocation(ctx context.Context, arg DmsRangeDriverLocationParams) ([]DmsRangeDriverLocationRow, error) {
	rows, err := q.db.Query(ctx, dmsRangeDriverLocation, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsRangeDriverLocationRow
	for rows.Next() {
		var i DmsRangeDriverLocationRow
		if err := rows.Scan(
			&i.DmsDriverLocation.ID,
			&i.DmsDriverLocation.DriverID,
			&i.DmsDriverLocation.Latitude,
			&i.DmsDriverLocation.Longitude,
			&i.DmsDriverLocation.Altitude,
			&i.DmsDriverLocation.Accuracy,
			&i.DmsDriverLocation.SpeedKmh,
			&i.DmsDriverLocation.Heading,
			&i.DmsDriverLocation.Timestamp,
			&i.DmsDriverLocation.CreatedAt,
			&i.DmsDriverLocation.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRemoveDriverLocation = `-- name: DmsRemoveDriverLocation :exec
delete from "dms"."driver_locations"
where id = $1::uuid
`

func (q *Queries) DmsRemoveDriverLocation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, dmsRemoveDriverLocation, id)
	return err
}

const dmsUpdateDriverLocation = `-- name: DmsUpdateDriverLocation :one
update
  "dms"."driver_locations"
set
  driver_id = case when $1::boolean then
    $2::uuid
  else
    driver_id
  end,
  latitude = case when $3::boolean then
    $4::real
  else
    latitude
  end,
  longitude = case when $5::boolean then
    $6::real
  else
    longitude
  end,
  altitude = case when $7::boolean then
    $8::real
  else
    altitude
  end,
  accuracy = case when $9::boolean then
    $10::real
  else
    accuracy
  end,
  speed_kmh = case when $11::boolean then
    $12::real
  else
    speed_kmh
  end,
  heading = case when $13::boolean then
    $14::real
  else
    heading
  end,
  timestamp = case when $15::boolean then
    $16::timestamp
  else
    timestamp
  end
where
  id = $17::uuid
returning
  id, driver_id, latitude, longitude, altitude, accuracy, speed_kmh, heading, timestamp, created_at, updated_at
`

type DmsUpdateDriverLocationParams struct {
	SetDriverID  bool
	DriverID     pgtype.UUID
	SetLatitude  bool
	Latitude     float32
	SetLongitude bool
	Longitude    float32
	SetAltitude  bool
	Altitude     float32
	SetAccuracy  bool
	Accuracy     float32
	SetSpeedKmh  bool
	SpeedKmh     float32
	SetHeading   bool
	Heading      float32
	SetTimestamp bool
	Timestamp    pgtype.Timestamp
	ID           pgtype.UUID
}

func (q *Queries) DmsUpdateDriverLocation(ctx context.Context, arg DmsUpdateDriverLocationParams) (DmsDriverLocation, error) {
	row := q.db.QueryRow(ctx, dmsUpdateDriverLocation,
		arg.SetDriverID,
		arg.DriverID,
		arg.SetLatitude,
		arg.Latitude,
		arg.SetLongitude,
		arg.Longitude,
		arg.SetAltitude,
		arg.Altitude,
		arg.SetAccuracy,
		arg.Accuracy,
		arg.SetSpeedKmh,
		arg.SpeedKmh,
		arg.SetHeading,
		arg.Heading,
		arg.SetTimestamp,
		arg.Timestamp,
		arg.ID,
	)
	var i DmsDriverLocation
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Latitude,
		&i.Longitude,
		&i.Altitude,
		&i.Accuracy,
		&i.SpeedKmh,
		&i.Heading,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
