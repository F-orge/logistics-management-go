// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dms_driver_locations.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dmsAnyDriverLocation = `-- name: DmsAnyDriverLocation :many
select
  driver_locations.id, driver_locations.driver_id, driver_locations.latitude, driver_locations.longitude, driver_locations.altitude, driver_locations.accuracy, driver_locations.speed_kmh, driver_locations.heading, driver_locations.timestamp, driver_locations.created_at, driver_locations.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."driver_locations" as driver_locations
  inner join "tms"."drivers" as driver on driver_locations.driver_id = driver.id
where
  driver_locations.id = any ($1::uuid[])
`

type DmsAnyDriverLocationRow struct {
	ID        pgtype.UUID      `db:"id" json:"id"`
	DriverID  pgtype.UUID      `db:"driver_id" json:"driver_id"`
	Latitude  float32          `db:"latitude" fake:"{latitude}" json:"latitude"`
	Longitude float32          `db:"longitude" fake:"{longitude}" json:"longitude"`
	Altitude  pgtype.Float4    `db:"altitude" fake:"{float64range:0,1000}" json:"altitude"`
	Accuracy  pgtype.Float4    `db:"accuracy" fake:"{float64range:0,100}" json:"accuracy"`
	SpeedKmh  pgtype.Float4    `db:"speed_kmh" fake:"{float64range:0,120}" json:"speed_kmh"`
	Heading   pgtype.Float4    `db:"heading" fake:"{float64range:0,360}" json:"heading"`
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	TmsDriver TmsDriver        `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) DmsAnyDriverLocation(ctx context.Context, ids []pgtype.UUID) ([]DmsAnyDriverLocationRow, error) {
	rows, err := q.db.Query(ctx, dmsAnyDriverLocation, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsAnyDriverLocationRow
	for rows.Next() {
		var i DmsAnyDriverLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.Latitude,
			&i.Longitude,
			&i.Altitude,
			&i.Accuracy,
			&i.SpeedKmh,
			&i.Heading,
			&i.Timestamp,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsFindDriverLocation = `-- name: DmsFindDriverLocation :one
select
  driver_locations.id, driver_locations.driver_id, driver_locations.latitude, driver_locations.longitude, driver_locations.altitude, driver_locations.accuracy, driver_locations.speed_kmh, driver_locations.heading, driver_locations.timestamp, driver_locations.created_at, driver_locations.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."driver_locations" as driver_locations
  inner join "tms"."drivers" as driver on driver_locations.driver_id = driver.id
where
  driver_locations.id = $1::uuid
`

type DmsFindDriverLocationRow struct {
	ID        pgtype.UUID      `db:"id" json:"id"`
	DriverID  pgtype.UUID      `db:"driver_id" json:"driver_id"`
	Latitude  float32          `db:"latitude" fake:"{latitude}" json:"latitude"`
	Longitude float32          `db:"longitude" fake:"{longitude}" json:"longitude"`
	Altitude  pgtype.Float4    `db:"altitude" fake:"{float64range:0,1000}" json:"altitude"`
	Accuracy  pgtype.Float4    `db:"accuracy" fake:"{float64range:0,100}" json:"accuracy"`
	SpeedKmh  pgtype.Float4    `db:"speed_kmh" fake:"{float64range:0,120}" json:"speed_kmh"`
	Heading   pgtype.Float4    `db:"heading" fake:"{float64range:0,360}" json:"heading"`
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	TmsDriver TmsDriver        `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) DmsFindDriverLocation(ctx context.Context, id pgtype.UUID) (DmsFindDriverLocationRow, error) {
	row := q.db.QueryRow(ctx, dmsFindDriverLocation, id)
	var i DmsFindDriverLocationRow
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Latitude,
		&i.Longitude,
		&i.Altitude,
		&i.Accuracy,
		&i.SpeedKmh,
		&i.Heading,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
	)
	return i, err
}

const dmsInsertDriverLocation = `-- name: DmsInsertDriverLocation :one
insert into "dms"."driver_locations"(driver_id, latitude, longitude, altitude, accuracy, speed_kmh, heading, timestamp)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, driver_id, latitude, longitude, altitude, accuracy, speed_kmh, heading, timestamp, created_at, updated_at
`

type DmsInsertDriverLocationParams struct {
	DriverID  pgtype.UUID      `db:"driver_id" json:"driver_id"`
	Latitude  float32          `db:"latitude" fake:"{latitude}" json:"latitude"`
	Longitude float32          `db:"longitude" fake:"{longitude}" json:"longitude"`
	Altitude  pgtype.Float4    `db:"altitude" fake:"{float64range:0,1000}" json:"altitude"`
	Accuracy  pgtype.Float4    `db:"accuracy" fake:"{float64range:0,100}" json:"accuracy"`
	SpeedKmh  pgtype.Float4    `db:"speed_kmh" fake:"{float64range:0,120}" json:"speed_kmh"`
	Heading   pgtype.Float4    `db:"heading" fake:"{float64range:0,360}" json:"heading"`
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
}

func (q *Queries) DmsInsertDriverLocation(ctx context.Context, arg DmsInsertDriverLocationParams) (DmsDriverLocation, error) {
	row := q.db.QueryRow(ctx, dmsInsertDriverLocation,
		arg.DriverID,
		arg.Latitude,
		arg.Longitude,
		arg.Altitude,
		arg.Accuracy,
		arg.SpeedKmh,
		arg.Heading,
		arg.Timestamp,
	)
	var i DmsDriverLocation
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Latitude,
		&i.Longitude,
		&i.Altitude,
		&i.Accuracy,
		&i.SpeedKmh,
		&i.Heading,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dmsPaginateDriverLocation = `-- name: DmsPaginateDriverLocation :many
select
  driver_locations.id, driver_locations.driver_id, driver_locations.latitude, driver_locations.longitude, driver_locations.altitude, driver_locations.accuracy, driver_locations.speed_kmh, driver_locations.heading, driver_locations.timestamp, driver_locations.created_at, driver_locations.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."driver_locations" as driver_locations
  inner join "tms"."drivers" as driver on driver_locations.driver_id = driver.id
where (driver.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type DmsPaginateDriverLocationParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type DmsPaginateDriverLocationRow struct {
	ID        pgtype.UUID      `db:"id" json:"id"`
	DriverID  pgtype.UUID      `db:"driver_id" json:"driver_id"`
	Latitude  float32          `db:"latitude" fake:"{latitude}" json:"latitude"`
	Longitude float32          `db:"longitude" fake:"{longitude}" json:"longitude"`
	Altitude  pgtype.Float4    `db:"altitude" fake:"{float64range:0,1000}" json:"altitude"`
	Accuracy  pgtype.Float4    `db:"accuracy" fake:"{float64range:0,100}" json:"accuracy"`
	SpeedKmh  pgtype.Float4    `db:"speed_kmh" fake:"{float64range:0,120}" json:"speed_kmh"`
	Heading   pgtype.Float4    `db:"heading" fake:"{float64range:0,360}" json:"heading"`
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	TmsDriver TmsDriver        `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) DmsPaginateDriverLocation(ctx context.Context, arg DmsPaginateDriverLocationParams) ([]DmsPaginateDriverLocationRow, error) {
	rows, err := q.db.Query(ctx, dmsPaginateDriverLocation, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsPaginateDriverLocationRow
	for rows.Next() {
		var i DmsPaginateDriverLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.Latitude,
			&i.Longitude,
			&i.Altitude,
			&i.Accuracy,
			&i.SpeedKmh,
			&i.Heading,
			&i.Timestamp,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsPaginateDriverLocationMetadata = `-- name: DmsPaginateDriverLocationMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "dms"."driver_locations" as driver_locations
`

type DmsPaginateDriverLocationMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type DmsPaginateDriverLocationMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) DmsPaginateDriverLocationMetadata(ctx context.Context, arg DmsPaginateDriverLocationMetadataParams) (DmsPaginateDriverLocationMetadataRow, error) {
	row := q.db.QueryRow(ctx, dmsPaginateDriverLocationMetadata, arg.PerPage, arg.Page)
	var i DmsPaginateDriverLocationMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const dmsRangeDriverLocation = `-- name: DmsRangeDriverLocation :many
select
  driver_locations.id, driver_locations.driver_id, driver_locations.latitude, driver_locations.longitude, driver_locations.altitude, driver_locations.accuracy, driver_locations.speed_kmh, driver_locations.heading, driver_locations.timestamp, driver_locations.created_at, driver_locations.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "dms"."driver_locations" as driver_locations
  inner join "tms"."drivers" as driver on driver_locations.driver_id = driver.id
where
  driver_locations.created_at >= $1::date
  and driver_locations.created_at <= $2::date
  and (driver.name ilike $3::text
    or $3::text is null)
`

type DmsRangeDriverLocationParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type DmsRangeDriverLocationRow struct {
	ID        pgtype.UUID      `db:"id" json:"id"`
	DriverID  pgtype.UUID      `db:"driver_id" json:"driver_id"`
	Latitude  float32          `db:"latitude" fake:"{latitude}" json:"latitude"`
	Longitude float32          `db:"longitude" fake:"{longitude}" json:"longitude"`
	Altitude  pgtype.Float4    `db:"altitude" fake:"{float64range:0,1000}" json:"altitude"`
	Accuracy  pgtype.Float4    `db:"accuracy" fake:"{float64range:0,100}" json:"accuracy"`
	SpeedKmh  pgtype.Float4    `db:"speed_kmh" fake:"{float64range:0,120}" json:"speed_kmh"`
	Heading   pgtype.Float4    `db:"heading" fake:"{float64range:0,360}" json:"heading"`
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	TmsDriver TmsDriver        `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) DmsRangeDriverLocation(ctx context.Context, arg DmsRangeDriverLocationParams) ([]DmsRangeDriverLocationRow, error) {
	rows, err := q.db.Query(ctx, dmsRangeDriverLocation, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsRangeDriverLocationRow
	for rows.Next() {
		var i DmsRangeDriverLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.Latitude,
			&i.Longitude,
			&i.Altitude,
			&i.Accuracy,
			&i.SpeedKmh,
			&i.Heading,
			&i.Timestamp,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRemoveDriverLocation = `-- name: DmsRemoveDriverLocation :exec
delete from "dms"."driver_locations"
where id = $1::uuid
`

func (q *Queries) DmsRemoveDriverLocation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, dmsRemoveDriverLocation, id)
	return err
}

const dmsUpdateDriverLocation = `-- name: DmsUpdateDriverLocation :one
update
  "dms"."driver_locations"
set
  updated_at = now(),
  driver_id = case when $1 is not null then
    $1::uuid
  else
    driver_id
  end,
  latitude = case when $2 is not null then
    $2::real
  else
    latitude
  end,
  longitude = case when $3 is not null then
    $3::real
  else
    longitude
  end,
  altitude = case when $4 is not null then
    $4::real
  else
    altitude
  end,
  accuracy = case when $5 is not null then
    $5::real
  else
    accuracy
  end,
  speed_kmh = case when $6 is not null then
    $6::real
  else
    speed_kmh
  end,
  heading = case when $7 is not null then
    $7::real
  else
    heading
  end,
  timestamp = case when $8 is not null then
    $8::timestamp
  else
    timestamp
  end
where
  id = $9::uuid
returning
  id, driver_id, latitude, longitude, altitude, accuracy, speed_kmh, heading, timestamp, created_at, updated_at
`

type DmsUpdateDriverLocationParams struct {
	DriverID  pgtype.UUID      `db:"driver_id" json:"driver_id"`
	Latitude  float32          `db:"latitude" fake:"{latitude}" json:"latitude"`
	Longitude float32          `db:"longitude" fake:"{longitude}" json:"longitude"`
	Altitude  pgtype.Float4    `db:"altitude" fake:"{float64range:0,1000}" json:"altitude"`
	Accuracy  pgtype.Float4    `db:"accuracy" fake:"{float64range:0,100}" json:"accuracy"`
	SpeedKmh  pgtype.Float4    `db:"speed_kmh" fake:"{float64range:0,120}" json:"speed_kmh"`
	Heading   pgtype.Float4    `db:"heading" fake:"{float64range:0,360}" json:"heading"`
	Timestamp pgtype.Timestamp `db:"timestamp" fake:"{date}" json:"timestamp"`
	ID        pgtype.UUID      `db:"id" json:"id"`
}

func (q *Queries) DmsUpdateDriverLocation(ctx context.Context, arg DmsUpdateDriverLocationParams) (DmsDriverLocation, error) {
	row := q.db.QueryRow(ctx, dmsUpdateDriverLocation,
		arg.DriverID,
		arg.Latitude,
		arg.Longitude,
		arg.Altitude,
		arg.Accuracy,
		arg.SpeedKmh,
		arg.Heading,
		arg.Timestamp,
		arg.ID,
	)
	var i DmsDriverLocation
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Latitude,
		&i.Longitude,
		&i.Altitude,
		&i.Accuracy,
		&i.SpeedKmh,
		&i.Heading,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
