// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_invoices.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyInvoice = `-- name: BillingAnyInvoice :many
select
  invoices.id, invoices.client_id, invoices.quote_id, invoices.invoice_number, invoices.status, invoices.issue_date, invoices.due_date, invoices.total_amount, invoices.amount_paid, invoices.amount_outstanding, invoices.currency, invoices.tax_amount, invoices.discount_amount, invoices.subtotal, invoices.payment_terms, invoices.notes, invoices.sent_at, invoices.paid_at, invoices.created_by_user_id, invoices.created_at, invoices.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  quote.id, quote.client_id, quote.origin_details, quote.destination_details, quote.weight, quote.length, quote.width, quote.height, quote.volume, quote.quoted_price, quote.service_level, quote.expires_at, quote.status, quote.quote_number, quote.notes, quote.created_by_user_id, quote.created_at, quote.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."invoices" as invoices
  inner join "crm"."companies" as client on invoices.client_id = client.id
  left join "billing"."quotes" as quote on invoices.quote_id = quote.id
  left join "public"."user" as created_by_user on invoices.created_by_user_id = created_by_user.id
where
  invoices.id = any ($1::uuid[])
`

type BillingAnyInvoiceRow struct {
	BillingInvoice BillingInvoice
	CrmCompany     CrmCompany
	BillingQuote   BillingQuote
	User           User
}

func (q *Queries) BillingAnyInvoice(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyInvoiceRow, error) {
	rows, err := q.db.Query(ctx, billingAnyInvoice, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyInvoiceRow
	for rows.Next() {
		var i BillingAnyInvoiceRow
		if err := rows.Scan(
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.BillingQuote.ID,
			&i.BillingQuote.ClientID,
			&i.BillingQuote.OriginDetails,
			&i.BillingQuote.DestinationDetails,
			&i.BillingQuote.Weight,
			&i.BillingQuote.Length,
			&i.BillingQuote.Width,
			&i.BillingQuote.Height,
			&i.BillingQuote.Volume,
			&i.BillingQuote.QuotedPrice,
			&i.BillingQuote.ServiceLevel,
			&i.BillingQuote.ExpiresAt,
			&i.BillingQuote.Status,
			&i.BillingQuote.QuoteNumber,
			&i.BillingQuote.Notes,
			&i.BillingQuote.CreatedByUserID,
			&i.BillingQuote.CreatedAt,
			&i.BillingQuote.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindInvoice = `-- name: BillingFindInvoice :one
select
  invoices.id, invoices.client_id, invoices.quote_id, invoices.invoice_number, invoices.status, invoices.issue_date, invoices.due_date, invoices.total_amount, invoices.amount_paid, invoices.amount_outstanding, invoices.currency, invoices.tax_amount, invoices.discount_amount, invoices.subtotal, invoices.payment_terms, invoices.notes, invoices.sent_at, invoices.paid_at, invoices.created_by_user_id, invoices.created_at, invoices.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  quote.id, quote.client_id, quote.origin_details, quote.destination_details, quote.weight, quote.length, quote.width, quote.height, quote.volume, quote.quoted_price, quote.service_level, quote.expires_at, quote.status, quote.quote_number, quote.notes, quote.created_by_user_id, quote.created_at, quote.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."invoices" as invoices
  inner join "crm"."companies" as client on invoices.client_id = client.id
  left join "billing"."quotes" as quote on invoices.quote_id = quote.id
  left join "public"."user" as created_by_user on invoices.created_by_user_id = created_by_user.id
where
  invoices.id = $1::uuid
`

type BillingFindInvoiceRow struct {
	BillingInvoice BillingInvoice
	CrmCompany     CrmCompany
	BillingQuote   BillingQuote
	User           User
}

func (q *Queries) BillingFindInvoice(ctx context.Context, id pgtype.UUID) (BillingFindInvoiceRow, error) {
	row := q.db.QueryRow(ctx, billingFindInvoice, id)
	var i BillingFindInvoiceRow
	err := row.Scan(
		&i.BillingInvoice.ID,
		&i.BillingInvoice.ClientID,
		&i.BillingInvoice.QuoteID,
		&i.BillingInvoice.InvoiceNumber,
		&i.BillingInvoice.Status,
		&i.BillingInvoice.IssueDate,
		&i.BillingInvoice.DueDate,
		&i.BillingInvoice.TotalAmount,
		&i.BillingInvoice.AmountPaid,
		&i.BillingInvoice.AmountOutstanding,
		&i.BillingInvoice.Currency,
		&i.BillingInvoice.TaxAmount,
		&i.BillingInvoice.DiscountAmount,
		&i.BillingInvoice.Subtotal,
		&i.BillingInvoice.PaymentTerms,
		&i.BillingInvoice.Notes,
		&i.BillingInvoice.SentAt,
		&i.BillingInvoice.PaidAt,
		&i.BillingInvoice.CreatedByUserID,
		&i.BillingInvoice.CreatedAt,
		&i.BillingInvoice.UpdatedAt,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
		&i.BillingQuote.ID,
		&i.BillingQuote.ClientID,
		&i.BillingQuote.OriginDetails,
		&i.BillingQuote.DestinationDetails,
		&i.BillingQuote.Weight,
		&i.BillingQuote.Length,
		&i.BillingQuote.Width,
		&i.BillingQuote.Height,
		&i.BillingQuote.Volume,
		&i.BillingQuote.QuotedPrice,
		&i.BillingQuote.ServiceLevel,
		&i.BillingQuote.ExpiresAt,
		&i.BillingQuote.Status,
		&i.BillingQuote.QuoteNumber,
		&i.BillingQuote.Notes,
		&i.BillingQuote.CreatedByUserID,
		&i.BillingQuote.CreatedAt,
		&i.BillingQuote.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertInvoice = `-- name: BillingInsertInvoice :one
insert into "billing"."invoices"(client_id, quote_id, invoice_number, status, issue_date, due_date, total_amount, amount_paid, currency, tax_amount, discount_amount, subtotal, payment_terms, notes, sent_at, paid_at, created_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
returning
  id, client_id, quote_id, invoice_number, status, issue_date, due_date, total_amount, amount_paid, amount_outstanding, currency, tax_amount, discount_amount, subtotal, payment_terms, notes, sent_at, paid_at, created_by_user_id, created_at, updated_at
`

type BillingInsertInvoiceParams struct {
	ClientID        pgtype.UUID
	QuoteID         pgtype.UUID
	InvoiceNumber   string
	Status          NullBillingInvoiceStatusEnum
	IssueDate       pgtype.Date
	DueDate         pgtype.Date
	TotalAmount     pgtype.Numeric
	AmountPaid      pgtype.Numeric
	Currency        pgtype.Text
	TaxAmount       pgtype.Numeric
	DiscountAmount  pgtype.Numeric
	Subtotal        pgtype.Numeric
	PaymentTerms    pgtype.Text
	Notes           pgtype.Text
	SentAt          pgtype.Timestamp
	PaidAt          pgtype.Timestamp
	CreatedByUserID pgtype.Text
}

func (q *Queries) BillingInsertInvoice(ctx context.Context, arg BillingInsertInvoiceParams) (BillingInvoice, error) {
	row := q.db.QueryRow(ctx, billingInsertInvoice,
		arg.ClientID,
		arg.QuoteID,
		arg.InvoiceNumber,
		arg.Status,
		arg.IssueDate,
		arg.DueDate,
		arg.TotalAmount,
		arg.AmountPaid,
		arg.Currency,
		arg.TaxAmount,
		arg.DiscountAmount,
		arg.Subtotal,
		arg.PaymentTerms,
		arg.Notes,
		arg.SentAt,
		arg.PaidAt,
		arg.CreatedByUserID,
	)
	var i BillingInvoice
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.QuoteID,
		&i.InvoiceNumber,
		&i.Status,
		&i.IssueDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.AmountPaid,
		&i.AmountOutstanding,
		&i.Currency,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.Subtotal,
		&i.PaymentTerms,
		&i.Notes,
		&i.SentAt,
		&i.PaidAt,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateInvoice = `-- name: BillingPaginateInvoice :many
select
  invoices.id, invoices.client_id, invoices.quote_id, invoices.invoice_number, invoices.status, invoices.issue_date, invoices.due_date, invoices.total_amount, invoices.amount_paid, invoices.amount_outstanding, invoices.currency, invoices.tax_amount, invoices.discount_amount, invoices.subtotal, invoices.payment_terms, invoices.notes, invoices.sent_at, invoices.paid_at, invoices.created_by_user_id, invoices.created_at, invoices.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  quote.id, quote.client_id, quote.origin_details, quote.destination_details, quote.weight, quote.length, quote.width, quote.height, quote.volume, quote.quoted_price, quote.service_level, quote.expires_at, quote.status, quote.quote_number, quote.notes, quote.created_by_user_id, quote.created_at, quote.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."invoices" as invoices
  inner join "crm"."companies" as client on invoices.client_id = client.id
  left join "billing"."quotes" as quote on invoices.quote_id = quote.id
  left join "public"."user" as created_by_user on invoices.created_by_user_id = created_by_user.id
where (client.name ilike $1::text
  or quote.quote_number ilike $1::text
  or invoices.invoice_number ilike $1::text
  or invoices.status::text ilike $1::text
  or created_by_user.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateInvoiceParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type BillingPaginateInvoiceRow struct {
	BillingInvoice BillingInvoice
	CrmCompany     CrmCompany
	BillingQuote   BillingQuote
	User           User
}

func (q *Queries) BillingPaginateInvoice(ctx context.Context, arg BillingPaginateInvoiceParams) ([]BillingPaginateInvoiceRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateInvoice, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateInvoiceRow
	for rows.Next() {
		var i BillingPaginateInvoiceRow
		if err := rows.Scan(
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.BillingQuote.ID,
			&i.BillingQuote.ClientID,
			&i.BillingQuote.OriginDetails,
			&i.BillingQuote.DestinationDetails,
			&i.BillingQuote.Weight,
			&i.BillingQuote.Length,
			&i.BillingQuote.Width,
			&i.BillingQuote.Height,
			&i.BillingQuote.Volume,
			&i.BillingQuote.QuotedPrice,
			&i.BillingQuote.ServiceLevel,
			&i.BillingQuote.ExpiresAt,
			&i.BillingQuote.Status,
			&i.BillingQuote.QuoteNumber,
			&i.BillingQuote.Notes,
			&i.BillingQuote.CreatedByUserID,
			&i.BillingQuote.CreatedAt,
			&i.BillingQuote.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeInvoice = `-- name: BillingRangeInvoice :many
select
  invoices.id, invoices.client_id, invoices.quote_id, invoices.invoice_number, invoices.status, invoices.issue_date, invoices.due_date, invoices.total_amount, invoices.amount_paid, invoices.amount_outstanding, invoices.currency, invoices.tax_amount, invoices.discount_amount, invoices.subtotal, invoices.payment_terms, invoices.notes, invoices.sent_at, invoices.paid_at, invoices.created_by_user_id, invoices.created_at, invoices.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at,
  quote.id, quote.client_id, quote.origin_details, quote.destination_details, quote.weight, quote.length, quote.width, quote.height, quote.volume, quote.quoted_price, quote.service_level, quote.expires_at, quote.status, quote.quote_number, quote.notes, quote.created_by_user_id, quote.created_at, quote.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."invoices" as invoices
  inner join "crm"."companies" as client on invoices.client_id = client.id
  left join "billing"."quotes" as quote on invoices.quote_id = quote.id
  left join "public"."user" as created_by_user on invoices.created_by_user_id = created_by_user.id
where
  invoices.created_at >= $1::date
  and invoices.created_at <= $2::date
  and (client.name ilike $3::text
    or quote.quote_number ilike $3::text
    or invoices.invoice_number ilike $3::text
    or invoices.status::text ilike $3::text
    or created_by_user.name ilike $3::text
    or $3::text is null)
`

type BillingRangeInvoiceParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type BillingRangeInvoiceRow struct {
	BillingInvoice BillingInvoice
	CrmCompany     CrmCompany
	BillingQuote   BillingQuote
	User           User
}

func (q *Queries) BillingRangeInvoice(ctx context.Context, arg BillingRangeInvoiceParams) ([]BillingRangeInvoiceRow, error) {
	rows, err := q.db.Query(ctx, billingRangeInvoice, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeInvoiceRow
	for rows.Next() {
		var i BillingRangeInvoiceRow
		if err := rows.Scan(
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.BillingQuote.ID,
			&i.BillingQuote.ClientID,
			&i.BillingQuote.OriginDetails,
			&i.BillingQuote.DestinationDetails,
			&i.BillingQuote.Weight,
			&i.BillingQuote.Length,
			&i.BillingQuote.Width,
			&i.BillingQuote.Height,
			&i.BillingQuote.Volume,
			&i.BillingQuote.QuotedPrice,
			&i.BillingQuote.ServiceLevel,
			&i.BillingQuote.ExpiresAt,
			&i.BillingQuote.Status,
			&i.BillingQuote.QuoteNumber,
			&i.BillingQuote.Notes,
			&i.BillingQuote.CreatedByUserID,
			&i.BillingQuote.CreatedAt,
			&i.BillingQuote.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveInvoice = `-- name: BillingRemoveInvoice :exec
delete from "billing"."invoices"
where id = $1::uuid
`

func (q *Queries) BillingRemoveInvoice(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveInvoice, id)
	return err
}

const billingUpdateInvoice = `-- name: BillingUpdateInvoice :one
update
  "billing"."invoices"
set
  updated_at = now(),
  client_id = case when $1 is not null then
    $1::uuid
  else
    client_id
  end,
  quote_id = case when $2 is not null then
    $2::uuid
  else
    quote_id
  end,
  invoice_number = case when $3 is not null then
    $3::varchar
  else
    invoice_number
  end,
  status = case when $4 is not null then
    $4::billing.invoice_status_enum
  else
    status
  end,
  issue_date = case when $5 is not null then
    $5::date
  else
    issue_date
  end,
  due_date = case when $6 is not null then
    $6::date
  else
    due_date
  end,
  total_amount = case when $7 is not null then
    $7::numeric
  else
    total_amount
  end,
  amount_paid = case when $8 is not null then
    $8::numeric
  else
    amount_paid
  end,
  currency = case when $9 is not null then
    $9::varchar
  else
    currency
  end,
  tax_amount = case when $10 is not null then
    $10::numeric
  else
    tax_amount
  end,
  discount_amount = case when $11 is not null then
    $11::numeric
  else
    discount_amount
  end,
  subtotal = case when $12 is not null then
    $12::numeric
  else
    subtotal
  end,
  payment_terms = case when $13 is not null then
    $13::text
  else
    payment_terms
  end,
  notes = case when $14 is not null then
    $14::text
  else
    notes
  end,
  sent_at = case when $15 is not null then
    $15::timestamp
  else
    sent_at
  end,
  paid_at = case when $16 is not null then
    $16::timestamp
  else
    paid_at
  end,
  created_by_user_id = case when $17 is not null then
    $17::text
  else
    created_by_user_id
  end
where
  id = $18::uuid
returning
  id, client_id, quote_id, invoice_number, status, issue_date, due_date, total_amount, amount_paid, amount_outstanding, currency, tax_amount, discount_amount, subtotal, payment_terms, notes, sent_at, paid_at, created_by_user_id, created_at, updated_at
`

type BillingUpdateInvoiceParams struct {
	ClientID        pgtype.UUID
	QuoteID         pgtype.UUID
	InvoiceNumber   string
	Status          NullBillingInvoiceStatusEnum
	IssueDate       pgtype.Date
	DueDate         pgtype.Date
	TotalAmount     pgtype.Numeric
	AmountPaid      pgtype.Numeric
	Currency        pgtype.Text
	TaxAmount       pgtype.Numeric
	DiscountAmount  pgtype.Numeric
	Subtotal        pgtype.Numeric
	PaymentTerms    pgtype.Text
	Notes           pgtype.Text
	SentAt          pgtype.Timestamp
	PaidAt          pgtype.Timestamp
	CreatedByUserID pgtype.Text
	ID              pgtype.UUID
}

func (q *Queries) BillingUpdateInvoice(ctx context.Context, arg BillingUpdateInvoiceParams) (BillingInvoice, error) {
	row := q.db.QueryRow(ctx, billingUpdateInvoice,
		arg.ClientID,
		arg.QuoteID,
		arg.InvoiceNumber,
		arg.Status,
		arg.IssueDate,
		arg.DueDate,
		arg.TotalAmount,
		arg.AmountPaid,
		arg.Currency,
		arg.TaxAmount,
		arg.DiscountAmount,
		arg.Subtotal,
		arg.PaymentTerms,
		arg.Notes,
		arg.SentAt,
		arg.PaidAt,
		arg.CreatedByUserID,
		arg.ID,
	)
	var i BillingInvoice
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.QuoteID,
		&i.InvoiceNumber,
		&i.Status,
		&i.IssueDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.AmountPaid,
		&i.AmountOutstanding,
		&i.Currency,
		&i.TaxAmount,
		&i.DiscountAmount,
		&i.Subtotal,
		&i.PaymentTerms,
		&i.Notes,
		&i.SentAt,
		&i.PaidAt,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
