// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_reorder_points.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyReorderPoint = `-- name: WmsAnyReorderPoint :many
select
  reorder_points.id, reorder_points.product_id, reorder_points.warehouse_id, reorder_points.threshold, reorder_points.created_at, reorder_points.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."reorder_points" as reorder_points
  inner join "wms"."products" as product on reorder_points.product_id = product.id
where
  reorder_points.id = any ($1::uuid[])
`

type WmsAnyReorderPointRow struct {
	ID          pgtype.UUID      `db:"id" json:"id"`
	ProductID   pgtype.UUID      `db:"product_id" json:"product_id"`
	WarehouseID pgtype.UUID      `db:"warehouse_id" json:"warehouse_id"`
	Threshold   int32            `db:"threshold" json:"threshold"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	WmsProduct  WmsProduct       `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsAnyReorderPoint(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyReorderPointRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyReorderPoint, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyReorderPointRow
	for rows.Next() {
		var i WmsAnyReorderPointRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.WarehouseID,
			&i.Threshold,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindReorderPoint = `-- name: WmsFindReorderPoint :one
select
  reorder_points.id, reorder_points.product_id, reorder_points.warehouse_id, reorder_points.threshold, reorder_points.created_at, reorder_points.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."reorder_points" as reorder_points
  inner join "wms"."products" as product on reorder_points.product_id = product.id
where
  reorder_points.id = $1::uuid
`

type WmsFindReorderPointRow struct {
	ID          pgtype.UUID      `db:"id" json:"id"`
	ProductID   pgtype.UUID      `db:"product_id" json:"product_id"`
	WarehouseID pgtype.UUID      `db:"warehouse_id" json:"warehouse_id"`
	Threshold   int32            `db:"threshold" json:"threshold"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	WmsProduct  WmsProduct       `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsFindReorderPoint(ctx context.Context, id pgtype.UUID) (WmsFindReorderPointRow, error) {
	row := q.db.QueryRow(ctx, wmsFindReorderPoint, id)
	var i WmsFindReorderPointRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Threshold,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
	)
	return i, err
}

const wmsInsertReorderPoint = `-- name: WmsInsertReorderPoint :one
insert into "wms"."reorder_points"(product_id, warehouse_id, threshold)
  values ($1, $2, $3)
returning
  id, product_id, warehouse_id, threshold, created_at, updated_at
`

type WmsInsertReorderPointParams struct {
	ProductID   pgtype.UUID `db:"product_id" json:"product_id"`
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	Threshold   int32       `db:"threshold" json:"threshold"`
}

func (q *Queries) WmsInsertReorderPoint(ctx context.Context, arg WmsInsertReorderPointParams) (WmsReorderPoint, error) {
	row := q.db.QueryRow(ctx, wmsInsertReorderPoint, arg.ProductID, arg.WarehouseID, arg.Threshold)
	var i WmsReorderPoint
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Threshold,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateReorderPoint = `-- name: WmsPaginateReorderPoint :many
select
  reorder_points.id, reorder_points.product_id, reorder_points.warehouse_id, reorder_points.threshold, reorder_points.created_at, reorder_points.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."reorder_points" as reorder_points
  inner join "wms"."products" as product on reorder_points.product_id = product.id
where (product.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateReorderPointParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type WmsPaginateReorderPointRow struct {
	ID          pgtype.UUID      `db:"id" json:"id"`
	ProductID   pgtype.UUID      `db:"product_id" json:"product_id"`
	WarehouseID pgtype.UUID      `db:"warehouse_id" json:"warehouse_id"`
	Threshold   int32            `db:"threshold" json:"threshold"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	WmsProduct  WmsProduct       `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsPaginateReorderPoint(ctx context.Context, arg WmsPaginateReorderPointParams) ([]WmsPaginateReorderPointRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateReorderPoint, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateReorderPointRow
	for rows.Next() {
		var i WmsPaginateReorderPointRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.WarehouseID,
			&i.Threshold,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsPaginateReorderPointMetadata = `-- name: WmsPaginateReorderPointMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "wms"."reorder_points" as reorder_points
`

type WmsPaginateReorderPointMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type WmsPaginateReorderPointMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) WmsPaginateReorderPointMetadata(ctx context.Context, arg WmsPaginateReorderPointMetadataParams) (WmsPaginateReorderPointMetadataRow, error) {
	row := q.db.QueryRow(ctx, wmsPaginateReorderPointMetadata, arg.PerPage, arg.Page)
	var i WmsPaginateReorderPointMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const wmsRangeReorderPoint = `-- name: WmsRangeReorderPoint :many
select
  reorder_points.id, reorder_points.product_id, reorder_points.warehouse_id, reorder_points.threshold, reorder_points.created_at, reorder_points.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."reorder_points" as reorder_points
  inner join "wms"."products" as product on reorder_points.product_id = product.id
where
  reorder_points.created_at >= $1::date
  and reorder_points.created_at <= $2::date
  and (product.name ilike $3::text
    or $3::text is null)
`

type WmsRangeReorderPointParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangeReorderPointRow struct {
	ID          pgtype.UUID      `db:"id" json:"id"`
	ProductID   pgtype.UUID      `db:"product_id" json:"product_id"`
	WarehouseID pgtype.UUID      `db:"warehouse_id" json:"warehouse_id"`
	Threshold   int32            `db:"threshold" json:"threshold"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	WmsProduct  WmsProduct       `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsRangeReorderPoint(ctx context.Context, arg WmsRangeReorderPointParams) ([]WmsRangeReorderPointRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeReorderPoint, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeReorderPointRow
	for rows.Next() {
		var i WmsRangeReorderPointRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.WarehouseID,
			&i.Threshold,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveReorderPoint = `-- name: WmsRemoveReorderPoint :exec
delete from "wms"."reorder_points"
where id = $1::uuid
`

func (q *Queries) WmsRemoveReorderPoint(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveReorderPoint, id)
	return err
}

const wmsUpdateReorderPoint = `-- name: WmsUpdateReorderPoint :one
update
  "wms"."reorder_points"
set
  updated_at = now(),
  product_id = case when $1 is not null then
    $1::uuid
  else
    product_id
  end,
  warehouse_id = case when $2 is not null then
    $2::uuid
  else
    warehouse_id
  end,
  threshold = case when $3 is not null then
    $3::integer
  else
    threshold
  end
where
  id = $4::uuid
returning
  id, product_id, warehouse_id, threshold, created_at, updated_at
`

type WmsUpdateReorderPointParams struct {
	ProductID   pgtype.UUID `db:"product_id" json:"product_id"`
	WarehouseID pgtype.UUID `db:"warehouse_id" json:"warehouse_id"`
	Threshold   int32       `db:"threshold" json:"threshold"`
	ID          pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) WmsUpdateReorderPoint(ctx context.Context, arg WmsUpdateReorderPointParams) (WmsReorderPoint, error) {
	row := q.db.QueryRow(ctx, wmsUpdateReorderPoint,
		arg.ProductID,
		arg.WarehouseID,
		arg.Threshold,
		arg.ID,
	)
	var i WmsReorderPoint
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Threshold,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
