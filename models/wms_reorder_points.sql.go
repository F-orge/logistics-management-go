// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_reorder_points.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyReorderPoint = `-- name: WmsAnyReorderPoint :many
select
  reorder_points.id, reorder_points.product_id, reorder_points.warehouse_id, reorder_points.threshold, reorder_points.created_at, reorder_points.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."reorder_points" as reorder_points
  inner join "wms"."products" as product on reorder_points.product_id = product.id
where
  reorder_points.id = any ($1::uuid[])
`

type WmsAnyReorderPointRow struct {
	WmsReorderPoint WmsReorderPoint
	WmsProduct      WmsProduct
}

func (q *Queries) WmsAnyReorderPoint(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyReorderPointRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyReorderPoint, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyReorderPointRow
	for rows.Next() {
		var i WmsAnyReorderPointRow
		if err := rows.Scan(
			&i.WmsReorderPoint.ID,
			&i.WmsReorderPoint.ProductID,
			&i.WmsReorderPoint.WarehouseID,
			&i.WmsReorderPoint.Threshold,
			&i.WmsReorderPoint.CreatedAt,
			&i.WmsReorderPoint.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindReorderPoint = `-- name: WmsFindReorderPoint :one
select
  reorder_points.id, reorder_points.product_id, reorder_points.warehouse_id, reorder_points.threshold, reorder_points.created_at, reorder_points.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."reorder_points" as reorder_points
  inner join "wms"."products" as product on reorder_points.product_id = product.id
where
  reorder_points.id = $1::uuid
`

type WmsFindReorderPointRow struct {
	WmsReorderPoint WmsReorderPoint
	WmsProduct      WmsProduct
}

func (q *Queries) WmsFindReorderPoint(ctx context.Context, id pgtype.UUID) (WmsFindReorderPointRow, error) {
	row := q.db.QueryRow(ctx, wmsFindReorderPoint, id)
	var i WmsFindReorderPointRow
	err := row.Scan(
		&i.WmsReorderPoint.ID,
		&i.WmsReorderPoint.ProductID,
		&i.WmsReorderPoint.WarehouseID,
		&i.WmsReorderPoint.Threshold,
		&i.WmsReorderPoint.CreatedAt,
		&i.WmsReorderPoint.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
	)
	return i, err
}

const wmsInsertReorderPoint = `-- name: WmsInsertReorderPoint :one
insert into "wms"."reorder_points"(product_id, warehouse_id, threshold)
  values ($1, $2, $3)
returning
  id, product_id, warehouse_id, threshold, created_at, updated_at
`

type WmsInsertReorderPointParams struct {
	ProductID   pgtype.UUID
	WarehouseID pgtype.UUID
	Threshold   int32
}

func (q *Queries) WmsInsertReorderPoint(ctx context.Context, arg WmsInsertReorderPointParams) (WmsReorderPoint, error) {
	row := q.db.QueryRow(ctx, wmsInsertReorderPoint, arg.ProductID, arg.WarehouseID, arg.Threshold)
	var i WmsReorderPoint
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Threshold,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateReorderPoint = `-- name: WmsPaginateReorderPoint :many
select
  reorder_points.id, reorder_points.product_id, reorder_points.warehouse_id, reorder_points.threshold, reorder_points.created_at, reorder_points.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."reorder_points" as reorder_points
  inner join "wms"."products" as product on reorder_points.product_id = product.id
where
  (product.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateReorderPointParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginateReorderPointRow struct {
	WmsReorderPoint WmsReorderPoint
	WmsProduct      WmsProduct
}

func (q *Queries) WmsPaginateReorderPoint(ctx context.Context, arg WmsPaginateReorderPointParams) ([]WmsPaginateReorderPointRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateReorderPoint, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateReorderPointRow
	for rows.Next() {
		var i WmsPaginateReorderPointRow
		if err := rows.Scan(
			&i.WmsReorderPoint.ID,
			&i.WmsReorderPoint.ProductID,
			&i.WmsReorderPoint.WarehouseID,
			&i.WmsReorderPoint.Threshold,
			&i.WmsReorderPoint.CreatedAt,
			&i.WmsReorderPoint.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeReorderPoint = `-- name: WmsRangeReorderPoint :many
select
  reorder_points.id, reorder_points.product_id, reorder_points.warehouse_id, reorder_points.threshold, reorder_points.created_at, reorder_points.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."reorder_points" as reorder_points
  inner join "wms"."products" as product on reorder_points.product_id = product.id
where
  reorder_points.created_at >= $1::date
  and reorder_points.created_at <= $2::date
  and (product.name ilike $3::text
  or $3::text is null)
`

type WmsRangeReorderPointParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangeReorderPointRow struct {
	WmsReorderPoint WmsReorderPoint
	WmsProduct      WmsProduct
}

func (q *Queries) WmsRangeReorderPoint(ctx context.Context, arg WmsRangeReorderPointParams) ([]WmsRangeReorderPointRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeReorderPoint, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeReorderPointRow
	for rows.Next() {
		var i WmsRangeReorderPointRow
		if err := rows.Scan(
			&i.WmsReorderPoint.ID,
			&i.WmsReorderPoint.ProductID,
			&i.WmsReorderPoint.WarehouseID,
			&i.WmsReorderPoint.Threshold,
			&i.WmsReorderPoint.CreatedAt,
			&i.WmsReorderPoint.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveReorderPoint = `-- name: WmsRemoveReorderPoint :exec
delete from "wms"."reorder_points"
where id = $1::uuid
`

func (q *Queries) WmsRemoveReorderPoint(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveReorderPoint, id)
	return err
}

const wmsUpdateReorderPoint = `-- name: WmsUpdateReorderPoint :one
update
  "wms"."reorder_points"
set
  product_id = case when $1::boolean then
    $2::uuid
  else
    product_id
  end,
  warehouse_id = case when $3::boolean then
    $4::uuid
  else
    warehouse_id
  end,
  threshold = case when $5::boolean then
    $6::integer
  else
    threshold
  end
where
  id = $7::uuid
returning
  id, product_id, warehouse_id, threshold, created_at, updated_at
`

type WmsUpdateReorderPointParams struct {
	SetProductID   bool
	ProductID      pgtype.UUID
	SetWarehouseID bool
	WarehouseID    pgtype.UUID
	SetThreshold   bool
	Threshold      int32
	ID             pgtype.UUID
}

func (q *Queries) WmsUpdateReorderPoint(ctx context.Context, arg WmsUpdateReorderPointParams) (WmsReorderPoint, error) {
	row := q.db.QueryRow(ctx, wmsUpdateReorderPoint,
		arg.SetProductID,
		arg.ProductID,
		arg.SetWarehouseID,
		arg.WarehouseID,
		arg.SetThreshold,
		arg.Threshold,
		arg.ID,
	)
	var i WmsReorderPoint
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Threshold,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
