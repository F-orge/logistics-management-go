// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInventoryItem = `-- name: CreateInventoryItem :one
insert into inventory_items (product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type CreateInventoryItemParams struct {
	Product             pgtype.UUID
	Warehouse           pgtype.UUID
	QuantityOnHand      int32
	LotNumber           string
	SerialNumber        string
	Status              string
	ExpiryDate          pgtype.Timestamptz
	StorageLocationCode string
	LastCountedDate     pgtype.Timestamptz
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, createInventoryItem,
		arg.Product,
		arg.Warehouse,
		arg.QuantityOnHand,
		arg.LotNumber,
		arg.SerialNumber,
		arg.Status,
		arg.ExpiryDate,
		arg.StorageLocationCode,
		arg.LastCountedDate,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteInventoryItem = `-- name: DeleteInventoryItem :one
delete from inventory_items where id = $1 returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

func (q *Queries) DeleteInventoryItem(ctx context.Context, id pgtype.UUID) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, deleteInventoryItem, id)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getInventoryItemByID = `-- name: GetInventoryItemByID :one
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items where id = $1
`

func (q *Queries) GetInventoryItemByID(ctx context.Context, id pgtype.UUID) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, getInventoryItemByID, id)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getInventoryItems = `-- name: GetInventoryItems :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items order by created desc offset $1 limit $2
`

type GetInventoryItemsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetInventoryItems(ctx context.Context, arg GetInventoryItemsParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, getInventoryItems, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryItemsByProduct = `-- name: GetInventoryItemsByProduct :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items where product = $1 order by created desc offset $2 limit $3
`

type GetInventoryItemsByProductParams struct {
	Product pgtype.UUID
	Offset  int32
	Limit   int32
}

func (q *Queries) GetInventoryItemsByProduct(ctx context.Context, arg GetInventoryItemsByProductParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, getInventoryItemsByProduct, arg.Product, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryItemsByStatus = `-- name: GetInventoryItemsByStatus :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items where status = $1 order by created desc offset $2 limit $3
`

type GetInventoryItemsByStatusParams struct {
	Status string
	Offset int32
	Limit  int32
}

func (q *Queries) GetInventoryItemsByStatus(ctx context.Context, arg GetInventoryItemsByStatusParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, getInventoryItemsByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryItemsByWarehouse = `-- name: GetInventoryItemsByWarehouse :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items where warehouse = $1 order by created desc offset $2 limit $3
`

type GetInventoryItemsByWarehouseParams struct {
	Warehouse pgtype.UUID
	Offset    int32
	Limit     int32
}

func (q *Queries) GetInventoryItemsByWarehouse(ctx context.Context, arg GetInventoryItemsByWarehouseParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, getInventoryItemsByWarehouse, arg.Warehouse, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInventoryItems = `-- name: SearchInventoryItems :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items where lot_number ilike '%' || $1::text || '%' or serial_number ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchInventoryItemsParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchInventoryItems(ctx context.Context, arg SearchInventoryItemsParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, searchInventoryItems, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryItemExpiryDate = `-- name: UpdateInventoryItemExpiryDate :one
update inventory_items set expiry_date = $1 where id = $2 returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type UpdateInventoryItemExpiryDateParams struct {
	ExpiryDate pgtype.Timestamptz
	ID         pgtype.UUID
}

func (q *Queries) UpdateInventoryItemExpiryDate(ctx context.Context, arg UpdateInventoryItemExpiryDateParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemExpiryDate, arg.ExpiryDate, arg.ID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInventoryItemLastCountedDate = `-- name: UpdateInventoryItemLastCountedDate :one
update inventory_items set last_counted_date = $1 where id = $2 returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type UpdateInventoryItemLastCountedDateParams struct {
	LastCountedDate pgtype.Timestamptz
	ID              pgtype.UUID
}

func (q *Queries) UpdateInventoryItemLastCountedDate(ctx context.Context, arg UpdateInventoryItemLastCountedDateParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemLastCountedDate, arg.LastCountedDate, arg.ID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInventoryItemQuantity = `-- name: UpdateInventoryItemQuantity :one
update inventory_items set quantity_on_hand = $1 where id = $2 returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type UpdateInventoryItemQuantityParams struct {
	QuantityOnHand int32
	ID             pgtype.UUID
}

func (q *Queries) UpdateInventoryItemQuantity(ctx context.Context, arg UpdateInventoryItemQuantityParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemQuantity, arg.QuantityOnHand, arg.ID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInventoryItemStatus = `-- name: UpdateInventoryItemStatus :one
update inventory_items set status = $1 where id = $2 returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type UpdateInventoryItemStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateInventoryItemStatus(ctx context.Context, arg UpdateInventoryItemStatusParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemStatus, arg.Status, arg.ID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInventoryItemStorageLocationCode = `-- name: UpdateInventoryItemStorageLocationCode :one
update inventory_items set storage_location_code = $1 where id = $2 returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type UpdateInventoryItemStorageLocationCodeParams struct {
	StorageLocationCode string
	ID                  pgtype.UUID
}

func (q *Queries) UpdateInventoryItemStorageLocationCode(ctx context.Context, arg UpdateInventoryItemStorageLocationCodeParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemStorageLocationCode, arg.StorageLocationCode, arg.ID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
