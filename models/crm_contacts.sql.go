// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_contacts.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyContact = `-- name: CrmAnyContact :many
select
  contacts.id, contacts.name, contacts.email, contacts.phone_number, contacts.job_title, contacts.company_id, contacts.owner_id, contacts.created_at, contacts.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  company.id, company.name, company.street, company.city, company.state, company.postal_code, company.country, company.phone_number, company.industry, company.website, company.annual_revenue, company.owner_id, company.created_at, company.updated_at
from
  "crm"."contacts" as contacts
  inner join "public"."user" as owner on contacts.owner_id = owner.id
  left join "crm"."companies" as company on contacts.company_id = company.id
where
  contacts.id = any ($1::uuid[])
`

type CrmAnyContactRow struct {
	CrmContact CrmContact `db:"crm_contact" json:"crm_contact"`
	User       User       `db:"user" json:"user"`
	CrmCompany CrmCompany `db:"crm_company" json:"crm_company"`
}

func (q *Queries) CrmAnyContact(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyContactRow, error) {
	rows, err := q.db.Query(ctx, crmAnyContact, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyContactRow
	for rows.Next() {
		var i CrmAnyContactRow
		if err := rows.Scan(
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindContact = `-- name: CrmFindContact :one
select
  contacts.id, contacts.name, contacts.email, contacts.phone_number, contacts.job_title, contacts.company_id, contacts.owner_id, contacts.created_at, contacts.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  company.id, company.name, company.street, company.city, company.state, company.postal_code, company.country, company.phone_number, company.industry, company.website, company.annual_revenue, company.owner_id, company.created_at, company.updated_at
from
  "crm"."contacts" as contacts
  inner join "public"."user" as owner on contacts.owner_id = owner.id
  left join "crm"."companies" as company on contacts.company_id = company.id
where
  contacts.id = $1::uuid
`

type CrmFindContactRow struct {
	CrmContact CrmContact `db:"crm_contact" json:"crm_contact"`
	User       User       `db:"user" json:"user"`
	CrmCompany CrmCompany `db:"crm_company" json:"crm_company"`
}

func (q *Queries) CrmFindContact(ctx context.Context, id pgtype.UUID) (CrmFindContactRow, error) {
	row := q.db.QueryRow(ctx, crmFindContact, id)
	var i CrmFindContactRow
	err := row.Scan(
		&i.CrmContact.ID,
		&i.CrmContact.Name,
		&i.CrmContact.Email,
		&i.CrmContact.PhoneNumber,
		&i.CrmContact.JobTitle,
		&i.CrmContact.CompanyID,
		&i.CrmContact.OwnerID,
		&i.CrmContact.CreatedAt,
		&i.CrmContact.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
	)
	return i, err
}

const crmInsertContact = `-- name: CrmInsertContact :one
insert into "crm"."contacts"(name, email, phone_number, job_title, company_id, owner_id)
  values ($1, $2, $3, $4, $5, $6)
returning
  id, name, email, phone_number, job_title, company_id, owner_id, created_at, updated_at
`

type CrmInsertContactParams struct {
	Name        string      `db:"name" json:"name"`
	Email       string      `db:"email" json:"email"`
	PhoneNumber pgtype.Text `db:"phone_number" json:"phone_number"`
	JobTitle    pgtype.Text `db:"job_title" json:"job_title"`
	CompanyID   pgtype.UUID `db:"company_id" json:"company_id"`
	OwnerID     string      `db:"owner_id" json:"owner_id"`
}

func (q *Queries) CrmInsertContact(ctx context.Context, arg CrmInsertContactParams) (CrmContact, error) {
	row := q.db.QueryRow(ctx, crmInsertContact,
		arg.Name,
		arg.Email,
		arg.PhoneNumber,
		arg.JobTitle,
		arg.CompanyID,
		arg.OwnerID,
	)
	var i CrmContact
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PhoneNumber,
		&i.JobTitle,
		&i.CompanyID,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateContact = `-- name: CrmPaginateContact :many
select
  contacts.id, contacts.name, contacts.email, contacts.phone_number, contacts.job_title, contacts.company_id, contacts.owner_id, contacts.created_at, contacts.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  company.id, company.name, company.street, company.city, company.state, company.postal_code, company.country, company.phone_number, company.industry, company.website, company.annual_revenue, company.owner_id, company.created_at, company.updated_at
from
  "crm"."contacts" as contacts
  inner join "public"."user" as owner on contacts.owner_id = owner.id
  left join "crm"."companies" as company on contacts.company_id = company.id
where (contacts.name ilike $1::text
  or contacts.email ilike $1::text
  or company.name ilike $1::text
  or owner.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateContactParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	Perpage int32       `db:"perpage" json:"perpage"`
}

type CrmPaginateContactRow struct {
	CrmContact CrmContact `db:"crm_contact" json:"crm_contact"`
	User       User       `db:"user" json:"user"`
	CrmCompany CrmCompany `db:"crm_company" json:"crm_company"`
}

func (q *Queries) CrmPaginateContact(ctx context.Context, arg CrmPaginateContactParams) ([]CrmPaginateContactRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateContact, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateContactRow
	for rows.Next() {
		var i CrmPaginateContactRow
		if err := rows.Scan(
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeContact = `-- name: CrmRangeContact :many
select
  contacts.id, contacts.name, contacts.email, contacts.phone_number, contacts.job_title, contacts.company_id, contacts.owner_id, contacts.created_at, contacts.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  company.id, company.name, company.street, company.city, company.state, company.postal_code, company.country, company.phone_number, company.industry, company.website, company.annual_revenue, company.owner_id, company.created_at, company.updated_at
from
  "crm"."contacts" as contacts
  inner join "public"."user" as owner on contacts.owner_id = owner.id
  left join "crm"."companies" as company on contacts.company_id = company.id
where
  contacts.created_at >= $1::date
  and contacts.created_at <= $2::date
  and (contacts.name ilike $3::text
    or contacts.email ilike $3::text
    or company.name ilike $3::text
    or owner.name ilike $3::text
    or $3::text is null)
`

type CrmRangeContactParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type CrmRangeContactRow struct {
	CrmContact CrmContact `db:"crm_contact" json:"crm_contact"`
	User       User       `db:"user" json:"user"`
	CrmCompany CrmCompany `db:"crm_company" json:"crm_company"`
}

func (q *Queries) CrmRangeContact(ctx context.Context, arg CrmRangeContactParams) ([]CrmRangeContactRow, error) {
	rows, err := q.db.Query(ctx, crmRangeContact, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeContactRow
	for rows.Next() {
		var i CrmRangeContactRow
		if err := rows.Scan(
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveContact = `-- name: CrmRemoveContact :exec
delete from "crm"."contacts"
where id = $1::uuid
`

func (q *Queries) CrmRemoveContact(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveContact, id)
	return err
}

const crmUpdateContact = `-- name: CrmUpdateContact :one
update
  "crm"."contacts"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::text
  else
    name
  end,
  email = case when $2 is not null then
    $2::text
  else
    email
  end,
  phone_number = case when $3 is not null then
    $3::text
  else
    phone_number
  end,
  job_title = case when $4 is not null then
    $4::text
  else
    job_title
  end,
  company_id = case when $5 is not null then
    $5::uuid
  else
    company_id
  end,
  owner_id = case when $6 is not null then
    $6::text
  else
    owner_id
  end
where
  id = $7::uuid
returning
  id, name, email, phone_number, job_title, company_id, owner_id, created_at, updated_at
`

type CrmUpdateContactParams struct {
	Name        string      `db:"name" json:"name"`
	Email       string      `db:"email" json:"email"`
	PhoneNumber pgtype.Text `db:"phone_number" json:"phone_number"`
	JobTitle    pgtype.Text `db:"job_title" json:"job_title"`
	CompanyID   pgtype.UUID `db:"company_id" json:"company_id"`
	OwnerID     string      `db:"owner_id" json:"owner_id"`
	ID          pgtype.UUID `db:"id" json:"id"`
}

func (q *Queries) CrmUpdateContact(ctx context.Context, arg CrmUpdateContactParams) (CrmContact, error) {
	row := q.db.QueryRow(ctx, crmUpdateContact,
		arg.Name,
		arg.Email,
		arg.PhoneNumber,
		arg.JobTitle,
		arg.CompanyID,
		arg.OwnerID,
		arg.ID,
	)
	var i CrmContact
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PhoneNumber,
		&i.JobTitle,
		&i.CompanyID,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
