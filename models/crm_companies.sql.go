// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_companies.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyCompany = `-- name: CrmAnyCompany :many
select
  companies.id, companies.name, companies.street, companies.city, companies.state, companies.postal_code, companies.country, companies.phone_number, companies.industry, companies.website, companies.annual_revenue, companies.owner_id, companies.created_at, companies.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires
from
  "crm"."companies" as companies
  inner join "public"."user" as owner on companies.owner_id = owner.id
where
  companies.id = any ($1::uuid[])
`

type CrmAnyCompanyRow struct {
	CrmCompany CrmCompany
	User       User
}

func (q *Queries) CrmAnyCompany(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyCompanyRow, error) {
	rows, err := q.db.Query(ctx, crmAnyCompany, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyCompanyRow
	for rows.Next() {
		var i CrmAnyCompanyRow
		if err := rows.Scan(
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindCompany = `-- name: CrmFindCompany :one
select
  companies.id, companies.name, companies.street, companies.city, companies.state, companies.postal_code, companies.country, companies.phone_number, companies.industry, companies.website, companies.annual_revenue, companies.owner_id, companies.created_at, companies.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires
from
  "crm"."companies" as companies
  inner join "public"."user" as owner on companies.owner_id = owner.id
where
  companies.id = $1::uuid
`

type CrmFindCompanyRow struct {
	CrmCompany CrmCompany
	User       User
}

func (q *Queries) CrmFindCompany(ctx context.Context, id pgtype.UUID) (CrmFindCompanyRow, error) {
	row := q.db.QueryRow(ctx, crmFindCompany, id)
	var i CrmFindCompanyRow
	err := row.Scan(
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const crmInsertCompany = `-- name: CrmInsertCompany :one
insert into "crm"."companies"(name, street, city, state, postal_code, country, phone_number, industry, website, annual_revenue, owner_id)
  values ($1, $2, $3, $4, $4, $5, $6, $7, $8, $9, $10)
returning
  id, name, street, city, state, postal_code, country, phone_number, industry, website, annual_revenue, owner_id, created_at, updated_at
`

type CrmInsertCompanyParams struct {
	Name          string
	Street        pgtype.Text
	City          pgtype.Text
	State         pgtype.Text
	Country       pgtype.Text
	PhoneNumber   pgtype.Text
	Industry      pgtype.Text
	Website       pgtype.Text
	AnnualRevenue pgtype.Numeric
	OwnerID       pgtype.Text
}

func (q *Queries) CrmInsertCompany(ctx context.Context, arg CrmInsertCompanyParams) (CrmCompany, error) {
	row := q.db.QueryRow(ctx, crmInsertCompany,
		arg.Name,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.PhoneNumber,
		arg.Industry,
		arg.Website,
		arg.AnnualRevenue,
		arg.OwnerID,
	)
	var i CrmCompany
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Street,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.PhoneNumber,
		&i.Industry,
		&i.Website,
		&i.AnnualRevenue,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateCompany = `-- name: CrmPaginateCompany :many
select
  companies.id, companies.name, companies.street, companies.city, companies.state, companies.postal_code, companies.country, companies.phone_number, companies.industry, companies.website, companies.annual_revenue, companies.owner_id, companies.created_at, companies.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires
from
  "crm"."companies" as companies
  inner join "public"."user" as owner on companies.owner_id = owner.id
where
  (companies.name ilike $1::text
  or companies.industry ilike $1::text
  or owner.name ilike $1::text
  or companies.country ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateCompanyParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type CrmPaginateCompanyRow struct {
	CrmCompany CrmCompany
	User       User
}

func (q *Queries) CrmPaginateCompany(ctx context.Context, arg CrmPaginateCompanyParams) ([]CrmPaginateCompanyRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateCompany, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateCompanyRow
	for rows.Next() {
		var i CrmPaginateCompanyRow
		if err := rows.Scan(
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeCompany = `-- name: CrmRangeCompany :many
select
  companies.id, companies.name, companies.street, companies.city, companies.state, companies.postal_code, companies.country, companies.phone_number, companies.industry, companies.website, companies.annual_revenue, companies.owner_id, companies.created_at, companies.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires
from
  "crm"."companies" as companies
  inner join "public"."user" as owner on companies.owner_id = owner.id
where
  companies.created_at >= $1::date
  and companies.created_at <= $2::date
  and (companies.name ilike $3::text
    or companies.industry ilike $3::text
    or owner.name ilike $3::text
    or companies.country ilike $3::text
    or $3::text is null)
`

type CrmRangeCompanyParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type CrmRangeCompanyRow struct {
	CrmCompany CrmCompany
	User       User
}

func (q *Queries) CrmRangeCompany(ctx context.Context, arg CrmRangeCompanyParams) ([]CrmRangeCompanyRow, error) {
	rows, err := q.db.Query(ctx, crmRangeCompany, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeCompanyRow
	for rows.Next() {
		var i CrmRangeCompanyRow
		if err := rows.Scan(
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveCompany = `-- name: CrmRemoveCompany :exec
delete from "crm"."companies"
where id = $1::uuid
`

func (q *Queries) CrmRemoveCompany(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveCompany, id)
	return err
}

const crmUpdateCompany = `-- name: CrmUpdateCompany :one
update
  "crm"."companies"
set
  name = case when $1::boolean then
    $2::text
  else
    name
  end,
  street = case when $3::boolean then
    $4::text
  else
    street
  end,
  city = case when $5::boolean then
    $6::text
  else
    city
  end,
  state = case when $7::boolean then
    $8::text
  else
    state
  end,
  postal_code = case when $9::boolean then
    $10::text
  else
    postal_code
  end,
  country = case when $11::boolean then
    $12::text
  else
    country
  end,
  phone_number = case when $13::boolean then
    $14::text
  else
    phone_number
  end,
  industry = case when $15::boolean then
    $16::text
  else
    industry
  end,
  website = case when $17::boolean then
    $18::text
  else
    website
  end,
  annual_revenue = case when $19::boolean then
    $20::numeric
  else
    annual_revenue
  end,
  owner_id = case when $21::boolean then
    $22::text
  else
    owner_id
  end
where
  id = $23::uuid
returning
  id, name, street, city, state, postal_code, country, phone_number, industry, website, annual_revenue, owner_id, created_at, updated_at
`

type CrmUpdateCompanyParams struct {
	SetName          bool
	Name             string
	SetStreet        bool
	Street           string
	SetCity          bool
	City             string
	SetState         bool
	State            string
	SetPostalCode    bool
	PostalCode       string
	SetCountry       bool
	Country          string
	SetPhoneNumber   bool
	PhoneNumber      string
	SetIndustry      bool
	Industry         string
	SetWebsite       bool
	Website          string
	SetAnnualRevenue bool
	AnnualRevenue    pgtype.Numeric
	SetOwnerID       bool
	OwnerID          string
	ID               pgtype.UUID
}

func (q *Queries) CrmUpdateCompany(ctx context.Context, arg CrmUpdateCompanyParams) (CrmCompany, error) {
	row := q.db.QueryRow(ctx, crmUpdateCompany,
		arg.SetName,
		arg.Name,
		arg.SetStreet,
		arg.Street,
		arg.SetCity,
		arg.City,
		arg.SetState,
		arg.State,
		arg.SetPostalCode,
		arg.PostalCode,
		arg.SetCountry,
		arg.Country,
		arg.SetPhoneNumber,
		arg.PhoneNumber,
		arg.SetIndustry,
		arg.Industry,
		arg.SetWebsite,
		arg.Website,
		arg.SetAnnualRevenue,
		arg.AnnualRevenue,
		arg.SetOwnerID,
		arg.OwnerID,
		arg.ID,
	)
	var i CrmCompany
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Street,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.PhoneNumber,
		&i.Industry,
		&i.Website,
		&i.AnnualRevenue,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
