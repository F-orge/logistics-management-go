// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_companies.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyCompany = `-- name: CrmAnyCompany :many
select
  companies.id, companies.name, companies.street, companies.city, companies.state, companies.postal_code, companies.country, companies.phone_number, companies.industry, companies.website, companies.annual_revenue, companies.owner_id, companies.created_at, companies.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires
from
  "crm"."companies" as companies
  inner join "public"."user" as owner on companies.owner_id = owner.id
where
  companies.id = any ($1::uuid[])
`

type CrmAnyCompanyRow struct {
	CrmCompany CrmCompany `db:"crm_company" json:"crm_company"`
	User       User       `db:"user" json:"user"`
}

func (q *Queries) CrmAnyCompany(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyCompanyRow, error) {
	rows, err := q.db.Query(ctx, crmAnyCompany, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyCompanyRow
	for rows.Next() {
		var i CrmAnyCompanyRow
		if err := rows.Scan(
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindCompany = `-- name: CrmFindCompany :one
select
  companies.id, companies.name, companies.street, companies.city, companies.state, companies.postal_code, companies.country, companies.phone_number, companies.industry, companies.website, companies.annual_revenue, companies.owner_id, companies.created_at, companies.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires
from
  "crm"."companies" as companies
  inner join "public"."user" as owner on companies.owner_id = owner.id
where
  companies.id = $1::uuid
`

type CrmFindCompanyRow struct {
	CrmCompany CrmCompany `db:"crm_company" json:"crm_company"`
	User       User       `db:"user" json:"user"`
}

func (q *Queries) CrmFindCompany(ctx context.Context, id pgtype.UUID) (CrmFindCompanyRow, error) {
	row := q.db.QueryRow(ctx, crmFindCompany, id)
	var i CrmFindCompanyRow
	err := row.Scan(
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const crmInsertCompany = `-- name: CrmInsertCompany :one
insert into "crm"."companies"(name, street, city, state, postal_code, country, phone_number, industry, website, annual_revenue, owner_id)
  values ($1, $2, $3, $4, $4, $5, $6, $7, $8, $9, $10)
returning
  id, name, street, city, state, postal_code, country, phone_number, industry, website, annual_revenue, owner_id, created_at, updated_at
`

type CrmInsertCompanyParams struct {
	Name          string         `db:"name" json:"name"`
	Street        pgtype.Text    `db:"street" json:"street"`
	City          pgtype.Text    `db:"city" json:"city"`
	State         pgtype.Text    `db:"state" json:"state"`
	Country       pgtype.Text    `db:"country" json:"country"`
	PhoneNumber   pgtype.Text    `db:"phone_number" json:"phone_number"`
	Industry      pgtype.Text    `db:"industry" json:"industry"`
	Website       pgtype.Text    `db:"website" json:"website"`
	AnnualRevenue pgtype.Numeric `db:"annual_revenue" json:"annual_revenue"`
	OwnerID       pgtype.Text    `db:"owner_id" json:"owner_id"`
}

func (q *Queries) CrmInsertCompany(ctx context.Context, arg CrmInsertCompanyParams) (CrmCompany, error) {
	row := q.db.QueryRow(ctx, crmInsertCompany,
		arg.Name,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.PhoneNumber,
		arg.Industry,
		arg.Website,
		arg.AnnualRevenue,
		arg.OwnerID,
	)
	var i CrmCompany
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Street,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.PhoneNumber,
		&i.Industry,
		&i.Website,
		&i.AnnualRevenue,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateCompany = `-- name: CrmPaginateCompany :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int - 1 as page,
  $1::int as per_page,
  companies.id, companies.name, companies.street, companies.city, companies.state, companies.postal_code, companies.country, companies.phone_number, companies.industry, companies.website, companies.annual_revenue, companies.owner_id, companies.created_at, companies.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires
from
  "crm"."companies" as companies
  inner join "public"."user" as owner on companies.owner_id = owner.id
where (companies.name ilike $3::text
  or companies.industry ilike $3::text
  or owner.name ilike $3::text
  or companies.country ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type CrmPaginateCompanyParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type CrmPaginateCompanyRow struct {
	TotalItems int64      `db:"total_items" json:"total_items"`
	TotalPages float64    `db:"total_pages" json:"total_pages"`
	Page       int32      `db:"page" json:"page"`
	PerPage    int32      `db:"per_page" json:"per_page"`
	CrmCompany CrmCompany `db:"crm_company" json:"crm_company"`
	User       User       `db:"user" json:"user"`
}

func (q *Queries) CrmPaginateCompany(ctx context.Context, arg CrmPaginateCompanyParams) ([]CrmPaginateCompanyRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateCompany, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateCompanyRow
	for rows.Next() {
		var i CrmPaginateCompanyRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeCompany = `-- name: CrmRangeCompany :many
select
  companies.id, companies.name, companies.street, companies.city, companies.state, companies.postal_code, companies.country, companies.phone_number, companies.industry, companies.website, companies.annual_revenue, companies.owner_id, companies.created_at, companies.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires
from
  "crm"."companies" as companies
  inner join "public"."user" as owner on companies.owner_id = owner.id
where
  companies.created_at >= $1::date
  and companies.created_at <= $2::date
  and (companies.name ilike $3::text
    or companies.industry ilike $3::text
    or owner.name ilike $3::text
    or companies.country ilike $3::text
    or $3::text is null)
`

type CrmRangeCompanyParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type CrmRangeCompanyRow struct {
	CrmCompany CrmCompany `db:"crm_company" json:"crm_company"`
	User       User       `db:"user" json:"user"`
}

func (q *Queries) CrmRangeCompany(ctx context.Context, arg CrmRangeCompanyParams) ([]CrmRangeCompanyRow, error) {
	rows, err := q.db.Query(ctx, crmRangeCompany, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeCompanyRow
	for rows.Next() {
		var i CrmRangeCompanyRow
		if err := rows.Scan(
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveCompany = `-- name: CrmRemoveCompany :exec
delete from "crm"."companies"
where id = $1::uuid
`

func (q *Queries) CrmRemoveCompany(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveCompany, id)
	return err
}

const crmUpdateCompany = `-- name: CrmUpdateCompany :one
update
  "crm"."companies"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::text
  else
    name
  end,
  street = case when $2 is not null then
    $2::text
  else
    street
  end,
  city = case when $3 is not null then
    $3::text
  else
    city
  end,
  state = case when $4 is not null then
    $4::text
  else
    state
  end,
  postal_code = case when $5 is not null then
    $5::text
  else
    postal_code
  end,
  country = case when $6 is not null then
    $6::text
  else
    country
  end,
  phone_number = case when $7 is not null then
    $7::text
  else
    phone_number
  end,
  industry = case when $8 is not null then
    $8::text
  else
    industry
  end,
  website = case when $9 is not null then
    $9::text
  else
    website
  end,
  annual_revenue = case when $10 is not null then
    $10::numeric
  else
    annual_revenue
  end,
  owner_id = case when $11 is not null then
    $11::text
  else
    owner_id
  end
where
  id = $12::uuid
returning
  id, name, street, city, state, postal_code, country, phone_number, industry, website, annual_revenue, owner_id, created_at, updated_at
`

type CrmUpdateCompanyParams struct {
	Name          string         `db:"name" json:"name"`
	Street        pgtype.Text    `db:"street" json:"street"`
	City          pgtype.Text    `db:"city" json:"city"`
	State         pgtype.Text    `db:"state" json:"state"`
	PostalCode    pgtype.Text    `db:"postal_code" json:"postal_code"`
	Country       pgtype.Text    `db:"country" json:"country"`
	PhoneNumber   pgtype.Text    `db:"phone_number" json:"phone_number"`
	Industry      pgtype.Text    `db:"industry" json:"industry"`
	Website       pgtype.Text    `db:"website" json:"website"`
	AnnualRevenue pgtype.Numeric `db:"annual_revenue" json:"annual_revenue"`
	OwnerID       pgtype.Text    `db:"owner_id" json:"owner_id"`
	ID            pgtype.UUID    `db:"id" json:"id"`
}

func (q *Queries) CrmUpdateCompany(ctx context.Context, arg CrmUpdateCompanyParams) (CrmCompany, error) {
	row := q.db.QueryRow(ctx, crmUpdateCompany,
		arg.Name,
		arg.Street,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.PhoneNumber,
		arg.Industry,
		arg.Website,
		arg.AnnualRevenue,
		arg.OwnerID,
		arg.ID,
	)
	var i CrmCompany
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Street,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.PhoneNumber,
		&i.Industry,
		&i.Website,
		&i.AnnualRevenue,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
