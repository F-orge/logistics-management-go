// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: auth.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :one
insert into "account"(id, account_id, provider_id, user_id, access_token, refresh_token, id_token, access_token_expires_at, refresh_token_expires_at, scope, password)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning
  id, account_id, provider_id, user_id, access_token, refresh_token, id_token, access_token_expires_at, refresh_token_expires_at, scope, password, created_at, updated_at
`

type CreateAccountParams struct {
	ID                    string             `db:"id" json:"id"`
	AccountID             string             `db:"account_id" json:"account_id"`
	ProviderID            string             `db:"provider_id" json:"provider_id"`
	UserID                string             `db:"user_id" json:"user_id"`
	AccessToken           pgtype.Text        `db:"access_token" json:"access_token"`
	RefreshToken          pgtype.Text        `db:"refresh_token" json:"refresh_token"`
	IDToken               pgtype.Text        `db:"id_token" json:"id_token"`
	AccessTokenExpiresAt  pgtype.Timestamptz `db:"access_token_expires_at" json:"access_token_expires_at"`
	RefreshTokenExpiresAt pgtype.Timestamptz `db:"refresh_token_expires_at" json:"refresh_token_expires_at"`
	Scope                 pgtype.Text        `db:"scope" json:"scope"`
	Password              pgtype.Text        `db:"password" json:"password"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.ID,
		arg.AccountID,
		arg.ProviderID,
		arg.UserID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.IDToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.ProviderID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IDToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
insert into "session"(id, expires_at, token, user_id, ip_address, user_agent, impersonated_by)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, expires_at, token, created_at, updated_at, ip_address, user_agent, user_id, impersonated_by
`

type CreateSessionParams struct {
	ID             string             `db:"id" json:"id"`
	ExpiresAt      pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	Token          string             `db:"token" json:"token"`
	UserID         string             `db:"user_id" json:"user_id"`
	IpAddress      pgtype.Text        `db:"ip_address" json:"ip_address"`
	UserAgent      pgtype.Text        `db:"user_agent" json:"user_agent"`
	ImpersonatedBy pgtype.Text        `db:"impersonated_by" json:"impersonated_by"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.ExpiresAt,
		arg.Token,
		arg.UserID,
		arg.IpAddress,
		arg.UserAgent,
		arg.ImpersonatedBy,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.UserID,
		&i.ImpersonatedBy,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
insert into "user"(id, name, email, email_verified, image, role, banned, ban_reason, ban_expires)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning
  id, name, email, email_verified, image, created_at, updated_at, role, banned, ban_reason, ban_expires
`

type CreateUserParams struct {
	ID            string             `db:"id" json:"id"`
	Name          string             `db:"name" json:"name"`
	Email         string             `db:"email" json:"email"`
	EmailVerified bool               `db:"email_verified" json:"email_verified"`
	Image         pgtype.Text        `db:"image" json:"image"`
	Role          NullUserRole       `db:"role" json:"role"`
	Banned        pgtype.Bool        `db:"banned" json:"banned"`
	BanReason     pgtype.Text        `db:"ban_reason" json:"ban_reason"`
	BanExpires    pgtype.Timestamptz `db:"ban_expires" json:"ban_expires"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.EmailVerified,
		arg.Image,
		arg.Role,
		arg.Banned,
		arg.BanReason,
		arg.BanExpires,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Role,
		&i.Banned,
		&i.BanReason,
		&i.BanExpires,
	)
	return i, err
}

const createVerification = `-- name: CreateVerification :one
insert into "verification"(id, identifier, value, expires_at)
  values ($1, $2, $3, $4)
returning
  id, identifier, value, expires_at, created_at, updated_at
`

type CreateVerificationParams struct {
	ID         string             `db:"id" json:"id"`
	Identifier string             `db:"identifier" json:"identifier"`
	Value      string             `db:"value" json:"value"`
	ExpiresAt  pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
}

func (q *Queries) CreateVerification(ctx context.Context, arg CreateVerificationParams) (Verification, error) {
	row := q.db.QueryRow(ctx, createVerification,
		arg.ID,
		arg.Identifier,
		arg.Value,
		arg.ExpiresAt,
	)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
delete from "account"
where id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const deleteAllSessionsForUser = `-- name: DeleteAllSessionsForUser :exec
delete from "session"
where user_id = $1
`

func (q *Queries) DeleteAllSessionsForUser(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deleteAllSessionsForUser, userID)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
delete from "session"
where id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
delete from "user"
where id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteVerification = `-- name: DeleteVerification :exec
delete from "verification"
where id = $1
`

func (q *Queries) DeleteVerification(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteVerification, id)
	return err
}

const getAccount = `-- name: GetAccount :one
select
  id, account_id, provider_id, user_id, access_token, refresh_token, id_token, access_token_expires_at, refresh_token_expires_at, scope, password, created_at, updated_at
from
  "account"
where
  id = $1
limit 1
`

func (q *Queries) GetAccount(ctx context.Context, id string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.ProviderID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IDToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByProvider = `-- name: GetAccountByProvider :one
select
  id, account_id, provider_id, user_id, access_token, refresh_token, id_token, access_token_expires_at, refresh_token_expires_at, scope, password, created_at, updated_at
from
  "account"
where
  provider_id = $1
  and account_id = $2
limit 1
`

type GetAccountByProviderParams struct {
	ProviderID string `db:"provider_id" json:"provider_id"`
	AccountID  string `db:"account_id" json:"account_id"`
}

func (q *Queries) GetAccountByProvider(ctx context.Context, arg GetAccountByProviderParams) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByProvider, arg.ProviderID, arg.AccountID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.ProviderID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IDToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
select
  id, expires_at, token, created_at, updated_at, ip_address, user_agent, user_id, impersonated_by
from
  "session"
where
  id = $1
limit 1
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRow(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.UserID,
		&i.ImpersonatedBy,
	)
	return i, err
}

const getSessionByToken = `-- name: GetSessionByToken :one
select
  id, expires_at, token, created_at, updated_at, ip_address, user_agent, user_id, impersonated_by
from
  "session"
where
  token = $1
limit 1
`

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ExpiresAt,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.UserID,
		&i.ImpersonatedBy,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
select
  id, name, email, email_verified, image, created_at, updated_at, role, banned, ban_reason, ban_expires
from
  "user"
where
  id = $1
limit 1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Role,
		&i.Banned,
		&i.BanReason,
		&i.BanExpires,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
select
  id, name, email, email_verified, image, created_at, updated_at, role, banned, ban_reason, ban_expires
from
  "user"
where
  email = $1
limit 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Role,
		&i.Banned,
		&i.BanReason,
		&i.BanExpires,
	)
	return i, err
}

const getVerification = `-- name: GetVerification :one
select
  id, identifier, value, expires_at, created_at, updated_at
from
  "verification"
where
  identifier = $1
  and value = $2
limit 1
`

type GetVerificationParams struct {
	Identifier string `db:"identifier" json:"identifier"`
	Value      string `db:"value" json:"value"`
}

func (q *Queries) GetVerification(ctx context.Context, arg GetVerificationParams) (Verification, error) {
	row := q.db.QueryRow(ctx, getVerification, arg.Identifier, arg.Value)
	var i Verification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
select
  id, account_id, provider_id, user_id, access_token, refresh_token, id_token, access_token_expires_at, refresh_token_expires_at, scope, password, created_at, updated_at
from
  "account"
where
  user_id = $1
order by
  created_at
`

func (q *Queries) ListAccounts(ctx context.Context, userID string) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.ProviderID,
			&i.UserID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.IDToken,
			&i.AccessTokenExpiresAt,
			&i.RefreshTokenExpiresAt,
			&i.Scope,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
select
  id, expires_at, token, created_at, updated_at, ip_address, user_agent, user_id, impersonated_by
from
  "session"
where
  user_id = $1
order by
  created_at
`

func (q *Queries) ListSessions(ctx context.Context, userID string) ([]Session, error) {
	rows, err := q.db.Query(ctx, listSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ExpiresAt,
			&i.Token,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IpAddress,
			&i.UserAgent,
			&i.UserID,
			&i.ImpersonatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
select
  id, name, email, email_verified, image, created_at, updated_at, role, banned, ban_reason, ban_expires
from
  "user"
order by
  name
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.EmailVerified,
			&i.Image,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
			&i.Banned,
			&i.BanReason,
			&i.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
update
  "account"
set
  access_token = case when $1 is not null then
    $1::text
  else
    access_token
  end,
  refresh_token = case when $2 is not null then
    $2::text
  else
    refresh_token
  end,
  id_token = case when $3 is not null then
    $3::text
  else
    id_token
  end,
  access_token_expires_at = case when $4 is not null then
    $4::timestamptz
  else
    access_token_expires_at
  end,
  refresh_token_expires_at = case when $5 is not null then
    $5::timestamptz
  else
    refresh_token_expires_at
  end,
  scope = case when $6 is not null then
    $6::text
  else
    scope
  end,
  password = case when $7 is not null then
    $7::text
  else
    password
  end,
  updated_at = now()
where
  id = $8::text
returning
  id, account_id, provider_id, user_id, access_token, refresh_token, id_token, access_token_expires_at, refresh_token_expires_at, scope, password, created_at, updated_at
`

type UpdateAccountParams struct {
	AccessToken           pgtype.Text        `db:"access_token" json:"access_token"`
	RefreshToken          pgtype.Text        `db:"refresh_token" json:"refresh_token"`
	IDToken               pgtype.Text        `db:"id_token" json:"id_token"`
	AccessTokenExpiresAt  pgtype.Timestamptz `db:"access_token_expires_at" json:"access_token_expires_at"`
	RefreshTokenExpiresAt pgtype.Timestamptz `db:"refresh_token_expires_at" json:"refresh_token_expires_at"`
	Scope                 pgtype.Text        `db:"scope" json:"scope"`
	Password              pgtype.Text        `db:"password" json:"password"`
	ID                    string             `db:"id" json:"id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.AccessToken,
		arg.RefreshToken,
		arg.IDToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.Password,
		arg.ID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.ProviderID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IDToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :one
update
  "account"
set
  password = $2,
  updated_at = now()
where
  user_id = $1
  and provider_id = 'email'
returning
  id, account_id, provider_id, user_id, access_token, refresh_token, id_token, access_token_expires_at, refresh_token_expires_at, scope, password, created_at, updated_at
`

type UpdatePasswordParams struct {
	UserID   string      `db:"user_id" json:"user_id"`
	Password pgtype.Text `db:"password" json:"password"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) (Account, error) {
	row := q.db.QueryRow(ctx, updatePassword, arg.UserID, arg.Password)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.ProviderID,
		&i.UserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IDToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
update
  "user"
set
  name = case when $1 is not null then
    $1::text
  else
    name
  end,
  email = case when $2 is not null then
    $2::text
  else
    email
  end,
  email_verified = case when $3 is not null then
    $3::boolean
  else
    email_verified
  end,
  image = case when $4 is not null then
    $4::text
  else
    image
  end,
  role = case when $5 is not null then
    $5::text
  else
    role
  end,
  banned = case when $6 is not null then
    $6::boolean
  else
    banned
  end,
  ban_reason = case when $7 is not null then
    $7::text
  else
    ban_reason
  end,
  ban_expires = case when $8 is not null then
    $8::timestamptz
  else
    ban_expires
  end,
  updated_at = now()
where
  id = $9::text
returning
  id, name, email, email_verified, image, created_at, updated_at, role, banned, ban_reason, ban_expires
`

type UpdateUserParams struct {
	Name          pgtype.Text        `db:"name" json:"name"`
	Email         pgtype.Text        `db:"email" json:"email"`
	EmailVerified pgtype.Bool        `db:"email_verified" json:"email_verified"`
	Image         pgtype.Text        `db:"image" json:"image"`
	Role          NullUserRole       `db:"role" json:"role"`
	Banned        pgtype.Bool        `db:"banned" json:"banned"`
	BanReason     pgtype.Text        `db:"ban_reason" json:"ban_reason"`
	BanExpires    pgtype.Timestamptz `db:"ban_expires" json:"ban_expires"`
	ID            string             `db:"id" json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Name,
		arg.Email,
		arg.EmailVerified,
		arg.Image,
		arg.Role,
		arg.Banned,
		arg.BanReason,
		arg.BanExpires,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Role,
		&i.Banned,
		&i.BanReason,
		&i.BanExpires,
	)
	return i, err
}

const verifyEmail = `-- name: VerifyEmail :one
update
  "user"
set
  email_verified = true,
  updated_at = now()
where
  id = $1
returning
  id, name, email, email_verified, image, created_at, updated_at, role, banned, ban_reason, ban_expires
`

func (q *Queries) VerifyEmail(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, verifyEmail, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Role,
		&i.Banned,
		&i.BanReason,
		&i.BanExpires,
	)
	return i, err
}
