// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_stock_transfers.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyStockTransfer = `-- name: WmsAnyStockTransfer :many
select
  stock_transfers.id, stock_transfers.product_id, stock_transfers.source_warehouse_id, stock_transfers.destination_warehouse_id, stock_transfers.quantity, stock_transfers.status, stock_transfers.created_at, stock_transfers.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."stock_transfers" as stock_transfers
  inner join "wms"."products" as product on stock_transfers.product_id = product.id
where
  stock_transfers.id = any ($1::uuid[])
`

type WmsAnyStockTransferRow struct {
	ID                     pgtype.UUID                    `db:"id" json:"id"`
	ProductID              pgtype.UUID                    `db:"product_id" json:"product_id"`
	SourceWarehouseID      pgtype.UUID                    `db:"source_warehouse_id" json:"source_warehouse_id"`
	DestinationWarehouseID pgtype.UUID                    `db:"destination_warehouse_id" json:"destination_warehouse_id"`
	Quantity               int32                          `db:"quantity" json:"quantity"`
	Status                 NullWmsStockTransferStatusEnum `db:"status" json:"status"`
	CreatedAt              pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	WmsProduct             WmsProduct                     `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsAnyStockTransfer(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyStockTransferRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyStockTransfer, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyStockTransferRow
	for rows.Next() {
		var i WmsAnyStockTransferRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.SourceWarehouseID,
			&i.DestinationWarehouseID,
			&i.Quantity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindStockTransfer = `-- name: WmsFindStockTransfer :one
select
  stock_transfers.id, stock_transfers.product_id, stock_transfers.source_warehouse_id, stock_transfers.destination_warehouse_id, stock_transfers.quantity, stock_transfers.status, stock_transfers.created_at, stock_transfers.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."stock_transfers" as stock_transfers
  inner join "wms"."products" as product on stock_transfers.product_id = product.id
where
  stock_transfers.id = $1::uuid
`

type WmsFindStockTransferRow struct {
	ID                     pgtype.UUID                    `db:"id" json:"id"`
	ProductID              pgtype.UUID                    `db:"product_id" json:"product_id"`
	SourceWarehouseID      pgtype.UUID                    `db:"source_warehouse_id" json:"source_warehouse_id"`
	DestinationWarehouseID pgtype.UUID                    `db:"destination_warehouse_id" json:"destination_warehouse_id"`
	Quantity               int32                          `db:"quantity" json:"quantity"`
	Status                 NullWmsStockTransferStatusEnum `db:"status" json:"status"`
	CreatedAt              pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	WmsProduct             WmsProduct                     `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsFindStockTransfer(ctx context.Context, id pgtype.UUID) (WmsFindStockTransferRow, error) {
	row := q.db.QueryRow(ctx, wmsFindStockTransfer, id)
	var i WmsFindStockTransferRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.SourceWarehouseID,
		&i.DestinationWarehouseID,
		&i.Quantity,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
	)
	return i, err
}

const wmsInsertStockTransfer = `-- name: WmsInsertStockTransfer :one
insert into "wms"."stock_transfers"(product_id, source_warehouse_id, destination_warehouse_id, quantity, status)
  values ($1, $2, $3, $4, $5)
returning
  id, product_id, source_warehouse_id, destination_warehouse_id, quantity, status, created_at, updated_at
`

type WmsInsertStockTransferParams struct {
	ProductID              pgtype.UUID                    `db:"product_id" json:"product_id"`
	SourceWarehouseID      pgtype.UUID                    `db:"source_warehouse_id" json:"source_warehouse_id"`
	DestinationWarehouseID pgtype.UUID                    `db:"destination_warehouse_id" json:"destination_warehouse_id"`
	Quantity               int32                          `db:"quantity" json:"quantity"`
	Status                 NullWmsStockTransferStatusEnum `db:"status" json:"status"`
}

func (q *Queries) WmsInsertStockTransfer(ctx context.Context, arg WmsInsertStockTransferParams) (WmsStockTransfer, error) {
	row := q.db.QueryRow(ctx, wmsInsertStockTransfer,
		arg.ProductID,
		arg.SourceWarehouseID,
		arg.DestinationWarehouseID,
		arg.Quantity,
		arg.Status,
	)
	var i WmsStockTransfer
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.SourceWarehouseID,
		&i.DestinationWarehouseID,
		&i.Quantity,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateStockTransfer = `-- name: WmsPaginateStockTransfer :many
select
  stock_transfers.id, stock_transfers.product_id, stock_transfers.source_warehouse_id, stock_transfers.destination_warehouse_id, stock_transfers.quantity, stock_transfers.status, stock_transfers.created_at, stock_transfers.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."stock_transfers" as stock_transfers
  inner join "wms"."products" as product on stock_transfers.product_id = product.id
where (product.name ilike $1::text
  or stock_transfers.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateStockTransferParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type WmsPaginateStockTransferRow struct {
	ID                     pgtype.UUID                    `db:"id" json:"id"`
	ProductID              pgtype.UUID                    `db:"product_id" json:"product_id"`
	SourceWarehouseID      pgtype.UUID                    `db:"source_warehouse_id" json:"source_warehouse_id"`
	DestinationWarehouseID pgtype.UUID                    `db:"destination_warehouse_id" json:"destination_warehouse_id"`
	Quantity               int32                          `db:"quantity" json:"quantity"`
	Status                 NullWmsStockTransferStatusEnum `db:"status" json:"status"`
	CreatedAt              pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	WmsProduct             WmsProduct                     `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsPaginateStockTransfer(ctx context.Context, arg WmsPaginateStockTransferParams) ([]WmsPaginateStockTransferRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateStockTransfer, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateStockTransferRow
	for rows.Next() {
		var i WmsPaginateStockTransferRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.SourceWarehouseID,
			&i.DestinationWarehouseID,
			&i.Quantity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsPaginateStockTransferMetadata = `-- name: WmsPaginateStockTransferMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "wms"."stock_transfers" as stock_transfers
`

type WmsPaginateStockTransferMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type WmsPaginateStockTransferMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) WmsPaginateStockTransferMetadata(ctx context.Context, arg WmsPaginateStockTransferMetadataParams) (WmsPaginateStockTransferMetadataRow, error) {
	row := q.db.QueryRow(ctx, wmsPaginateStockTransferMetadata, arg.PerPage, arg.Page)
	var i WmsPaginateStockTransferMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const wmsRangeStockTransfer = `-- name: WmsRangeStockTransfer :many
select
  stock_transfers.id, stock_transfers.product_id, stock_transfers.source_warehouse_id, stock_transfers.destination_warehouse_id, stock_transfers.quantity, stock_transfers.status, stock_transfers.created_at, stock_transfers.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."stock_transfers" as stock_transfers
  inner join "wms"."products" as product on stock_transfers.product_id = product.id
where
  stock_transfers.created_at >= $1::date
  and stock_transfers.created_at <= $2::date
  and (product.name ilike $3::text
    or stock_transfers.status::text ilike $3::text
    or $3::text is null)
`

type WmsRangeStockTransferParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangeStockTransferRow struct {
	ID                     pgtype.UUID                    `db:"id" json:"id"`
	ProductID              pgtype.UUID                    `db:"product_id" json:"product_id"`
	SourceWarehouseID      pgtype.UUID                    `db:"source_warehouse_id" json:"source_warehouse_id"`
	DestinationWarehouseID pgtype.UUID                    `db:"destination_warehouse_id" json:"destination_warehouse_id"`
	Quantity               int32                          `db:"quantity" json:"quantity"`
	Status                 NullWmsStockTransferStatusEnum `db:"status" json:"status"`
	CreatedAt              pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	WmsProduct             WmsProduct                     `db:"wms_product" json:"wms_product"`
}

func (q *Queries) WmsRangeStockTransfer(ctx context.Context, arg WmsRangeStockTransferParams) ([]WmsRangeStockTransferRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeStockTransfer, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeStockTransferRow
	for rows.Next() {
		var i WmsRangeStockTransferRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.SourceWarehouseID,
			&i.DestinationWarehouseID,
			&i.Quantity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveStockTransfer = `-- name: WmsRemoveStockTransfer :exec
delete from "wms"."stock_transfers"
where id = $1::uuid
`

func (q *Queries) WmsRemoveStockTransfer(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveStockTransfer, id)
	return err
}

const wmsUpdateStockTransfer = `-- name: WmsUpdateStockTransfer :one
update
  "wms"."stock_transfers"
set
  updated_at = now(),
  product_id = case when $1 is not null then
    $1::uuid
  else
    product_id
  end,
  source_warehouse_id = case when $2 is not null then
    $2::uuid
  else
    source_warehouse_id
  end,
  destination_warehouse_id = case when $3 is not null then
    $3::uuid
  else
    destination_warehouse_id
  end,
  quantity = case when $4 is not null then
    $4::integer
  else
    quantity
  end,
  status = case when $5 is not null then
    $5::wms.stock_transfer_status_enum
  else
    status
  end
where
  id = $6::uuid
returning
  id, product_id, source_warehouse_id, destination_warehouse_id, quantity, status, created_at, updated_at
`

type WmsUpdateStockTransferParams struct {
	ProductID              pgtype.UUID                    `db:"product_id" json:"product_id"`
	SourceWarehouseID      pgtype.UUID                    `db:"source_warehouse_id" json:"source_warehouse_id"`
	DestinationWarehouseID pgtype.UUID                    `db:"destination_warehouse_id" json:"destination_warehouse_id"`
	Quantity               int32                          `db:"quantity" json:"quantity"`
	Status                 NullWmsStockTransferStatusEnum `db:"status" json:"status"`
	ID                     pgtype.UUID                    `db:"id" json:"id"`
}

func (q *Queries) WmsUpdateStockTransfer(ctx context.Context, arg WmsUpdateStockTransferParams) (WmsStockTransfer, error) {
	row := q.db.QueryRow(ctx, wmsUpdateStockTransfer,
		arg.ProductID,
		arg.SourceWarehouseID,
		arg.DestinationWarehouseID,
		arg.Quantity,
		arg.Status,
		arg.ID,
	)
	var i WmsStockTransfer
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.SourceWarehouseID,
		&i.DestinationWarehouseID,
		&i.Quantity,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
