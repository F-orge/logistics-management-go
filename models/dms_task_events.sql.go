// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dms_task_events.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dmsAnyTaskEvent = `-- name: DmsAnyTaskEvent :many
select
  task_events.id, task_events.delivery_task_id, task_events.status, task_events.reason, task_events.notes, task_events.latitude, task_events.longitude, task_events.timestamp, task_events.created_at, task_events.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."task_events" as task_events
  inner join "dms"."delivery_tasks" as delivery_task on task_events.delivery_task_id = delivery_task.id
where
  task_events.id = any ($1::uuid[])
`

type DmsAnyTaskEventRow struct {
	DmsTaskEvent    DmsTaskEvent    `db:"dms_task_event" json:"dms_task_event"`
	DmsDeliveryTask DmsDeliveryTask `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsAnyTaskEvent(ctx context.Context, ids []pgtype.UUID) ([]DmsAnyTaskEventRow, error) {
	rows, err := q.db.Query(ctx, dmsAnyTaskEvent, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsAnyTaskEventRow
	for rows.Next() {
		var i DmsAnyTaskEventRow
		if err := rows.Scan(
			&i.DmsTaskEvent.ID,
			&i.DmsTaskEvent.DeliveryTaskID,
			&i.DmsTaskEvent.Status,
			&i.DmsTaskEvent.Reason,
			&i.DmsTaskEvent.Notes,
			&i.DmsTaskEvent.Latitude,
			&i.DmsTaskEvent.Longitude,
			&i.DmsTaskEvent.Timestamp,
			&i.DmsTaskEvent.CreatedAt,
			&i.DmsTaskEvent.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsFindTaskEvent = `-- name: DmsFindTaskEvent :one
select
  task_events.id, task_events.delivery_task_id, task_events.status, task_events.reason, task_events.notes, task_events.latitude, task_events.longitude, task_events.timestamp, task_events.created_at, task_events.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."task_events" as task_events
  inner join "dms"."delivery_tasks" as delivery_task on task_events.delivery_task_id = delivery_task.id
where
  task_events.id = $1::uuid
`

type DmsFindTaskEventRow struct {
	DmsTaskEvent    DmsTaskEvent    `db:"dms_task_event" json:"dms_task_event"`
	DmsDeliveryTask DmsDeliveryTask `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsFindTaskEvent(ctx context.Context, id pgtype.UUID) (DmsFindTaskEventRow, error) {
	row := q.db.QueryRow(ctx, dmsFindTaskEvent, id)
	var i DmsFindTaskEventRow
	err := row.Scan(
		&i.DmsTaskEvent.ID,
		&i.DmsTaskEvent.DeliveryTaskID,
		&i.DmsTaskEvent.Status,
		&i.DmsTaskEvent.Reason,
		&i.DmsTaskEvent.Notes,
		&i.DmsTaskEvent.Latitude,
		&i.DmsTaskEvent.Longitude,
		&i.DmsTaskEvent.Timestamp,
		&i.DmsTaskEvent.CreatedAt,
		&i.DmsTaskEvent.UpdatedAt,
		&i.DmsDeliveryTask.ID,
		&i.DmsDeliveryTask.PackageID,
		&i.DmsDeliveryTask.DeliveryRouteID,
		&i.DmsDeliveryTask.RouteSequence,
		&i.DmsDeliveryTask.DeliveryAddress,
		&i.DmsDeliveryTask.RecipientName,
		&i.DmsDeliveryTask.RecipientPhone,
		&i.DmsDeliveryTask.DeliveryInstructions,
		&i.DmsDeliveryTask.EstimatedArrivalTime,
		&i.DmsDeliveryTask.ActualArrivalTime,
		&i.DmsDeliveryTask.DeliveryTime,
		&i.DmsDeliveryTask.Status,
		&i.DmsDeliveryTask.FailureReason,
		&i.DmsDeliveryTask.AttemptCount,
		&i.DmsDeliveryTask.CreatedAt,
		&i.DmsDeliveryTask.UpdatedAt,
	)
	return i, err
}

const dmsInsertTaskEvent = `-- name: DmsInsertTaskEvent :one
insert into "dms"."task_events"(delivery_task_id, status, reason, notes, latitude, longitude, timestamp)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, delivery_task_id, status, reason, notes, latitude, longitude, timestamp, created_at, updated_at
`

type DmsInsertTaskEventParams struct {
	DeliveryTaskID pgtype.UUID            `db:"delivery_task_id" json:"delivery_task_id"`
	Status         DmsTaskEventStatusEnum `db:"status" json:"status"`
	Reason         pgtype.Text            `db:"reason" json:"reason"`
	Notes          pgtype.Text            `db:"notes" json:"notes"`
	Latitude       pgtype.Float4          `db:"latitude" json:"latitude"`
	Longitude      pgtype.Float4          `db:"longitude" json:"longitude"`
	Timestamp      pgtype.Timestamp       `db:"timestamp" json:"timestamp"`
}

func (q *Queries) DmsInsertTaskEvent(ctx context.Context, arg DmsInsertTaskEventParams) (DmsTaskEvent, error) {
	row := q.db.QueryRow(ctx, dmsInsertTaskEvent,
		arg.DeliveryTaskID,
		arg.Status,
		arg.Reason,
		arg.Notes,
		arg.Latitude,
		arg.Longitude,
		arg.Timestamp,
	)
	var i DmsTaskEvent
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.Status,
		&i.Reason,
		&i.Notes,
		&i.Latitude,
		&i.Longitude,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dmsPaginateTaskEvent = `-- name: DmsPaginateTaskEvent :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page,
  task_events.id, task_events.delivery_task_id, task_events.status, task_events.reason, task_events.notes, task_events.latitude, task_events.longitude, task_events.timestamp, task_events.created_at, task_events.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."task_events" as task_events
  inner join "dms"."delivery_tasks" as delivery_task on task_events.delivery_task_id = delivery_task.id
where (task_events.status::text ilike $3::text
  or delivery_task.recipient_name ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type DmsPaginateTaskEventParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type DmsPaginateTaskEventRow struct {
	TotalItems      int64           `db:"total_items" json:"total_items"`
	TotalPages      float64         `db:"total_pages" json:"total_pages"`
	Page            int32           `db:"page" json:"page"`
	PerPage         int32           `db:"per_page" json:"per_page"`
	DmsTaskEvent    DmsTaskEvent    `db:"dms_task_event" json:"dms_task_event"`
	DmsDeliveryTask DmsDeliveryTask `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsPaginateTaskEvent(ctx context.Context, arg DmsPaginateTaskEventParams) ([]DmsPaginateTaskEventRow, error) {
	rows, err := q.db.Query(ctx, dmsPaginateTaskEvent, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsPaginateTaskEventRow
	for rows.Next() {
		var i DmsPaginateTaskEventRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.DmsTaskEvent.ID,
			&i.DmsTaskEvent.DeliveryTaskID,
			&i.DmsTaskEvent.Status,
			&i.DmsTaskEvent.Reason,
			&i.DmsTaskEvent.Notes,
			&i.DmsTaskEvent.Latitude,
			&i.DmsTaskEvent.Longitude,
			&i.DmsTaskEvent.Timestamp,
			&i.DmsTaskEvent.CreatedAt,
			&i.DmsTaskEvent.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRangeTaskEvent = `-- name: DmsRangeTaskEvent :many
select
  task_events.id, task_events.delivery_task_id, task_events.status, task_events.reason, task_events.notes, task_events.latitude, task_events.longitude, task_events.timestamp, task_events.created_at, task_events.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."task_events" as task_events
  inner join "dms"."delivery_tasks" as delivery_task on task_events.delivery_task_id = delivery_task.id
where
  task_events.created_at >= $1::date
  and task_events.created_at <= $2::date
  and (task_events.status::text ilike $3::text
    or delivery_task.recipient_name ilike $3::text
    or $3::text is null)
`

type DmsRangeTaskEventParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type DmsRangeTaskEventRow struct {
	DmsTaskEvent    DmsTaskEvent    `db:"dms_task_event" json:"dms_task_event"`
	DmsDeliveryTask DmsDeliveryTask `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsRangeTaskEvent(ctx context.Context, arg DmsRangeTaskEventParams) ([]DmsRangeTaskEventRow, error) {
	rows, err := q.db.Query(ctx, dmsRangeTaskEvent, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsRangeTaskEventRow
	for rows.Next() {
		var i DmsRangeTaskEventRow
		if err := rows.Scan(
			&i.DmsTaskEvent.ID,
			&i.DmsTaskEvent.DeliveryTaskID,
			&i.DmsTaskEvent.Status,
			&i.DmsTaskEvent.Reason,
			&i.DmsTaskEvent.Notes,
			&i.DmsTaskEvent.Latitude,
			&i.DmsTaskEvent.Longitude,
			&i.DmsTaskEvent.Timestamp,
			&i.DmsTaskEvent.CreatedAt,
			&i.DmsTaskEvent.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRemoveTaskEvent = `-- name: DmsRemoveTaskEvent :exec
delete from "dms"."task_events"
where id = $1::uuid
`

func (q *Queries) DmsRemoveTaskEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, dmsRemoveTaskEvent, id)
	return err
}

const dmsUpdateTaskEvent = `-- name: DmsUpdateTaskEvent :one
update
  "dms"."task_events"
set
  updated_at = now(),
  delivery_task_id = case when $1 is not null then
    $1::uuid
  else
    delivery_task_id
  end,
  status = case when $2 is not null then
    $2::dms.task_event_status_enum
  else
    status
  end,
  reason = case when $3 is not null then
    $3::text
  else
    reason
  end,
  notes = case when $4 is not null then
    $4::text
  else
    notes
  end,
  latitude = case when $5 is not null then
    $5::real
  else
    latitude
  end,
  longitude = case when $6 is not null then
    $6::real
  else
    longitude
  end,
  timestamp = case when $7 is not null then
    $7::timestamp
  else
    timestamp
  end
where
  id = $8::uuid
returning
  id, delivery_task_id, status, reason, notes, latitude, longitude, timestamp, created_at, updated_at
`

type DmsUpdateTaskEventParams struct {
	DeliveryTaskID pgtype.UUID            `db:"delivery_task_id" json:"delivery_task_id"`
	Status         DmsTaskEventStatusEnum `db:"status" json:"status"`
	Reason         pgtype.Text            `db:"reason" json:"reason"`
	Notes          pgtype.Text            `db:"notes" json:"notes"`
	Latitude       pgtype.Float4          `db:"latitude" json:"latitude"`
	Longitude      pgtype.Float4          `db:"longitude" json:"longitude"`
	Timestamp      pgtype.Timestamp       `db:"timestamp" json:"timestamp"`
	ID             pgtype.UUID            `db:"id" json:"id"`
}

func (q *Queries) DmsUpdateTaskEvent(ctx context.Context, arg DmsUpdateTaskEventParams) (DmsTaskEvent, error) {
	row := q.db.QueryRow(ctx, dmsUpdateTaskEvent,
		arg.DeliveryTaskID,
		arg.Status,
		arg.Reason,
		arg.Notes,
		arg.Latitude,
		arg.Longitude,
		arg.Timestamp,
		arg.ID,
	)
	var i DmsTaskEvent
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.Status,
		&i.Reason,
		&i.Notes,
		&i.Latitude,
		&i.Longitude,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
