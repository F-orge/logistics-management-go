// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dms_task_events.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dmsAnyTaskEvent = `-- name: DmsAnyTaskEvent :many
select
  task_events.id, task_events.delivery_task_id, task_events.status, task_events.reason, task_events.notes, task_events.latitude, task_events.longitude, task_events.timestamp, task_events.created_at, task_events.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."task_events" as task_events
  inner join "dms"."delivery_tasks" as delivery_task on task_events.delivery_task_id = delivery_task.id
where
  task_events.id = any ($1::uuid[])
`

type DmsAnyTaskEventRow struct {
	DmsTaskEvent    DmsTaskEvent
	DmsDeliveryTask DmsDeliveryTask
}

func (q *Queries) DmsAnyTaskEvent(ctx context.Context, ids []pgtype.UUID) ([]DmsAnyTaskEventRow, error) {
	rows, err := q.db.Query(ctx, dmsAnyTaskEvent, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsAnyTaskEventRow
	for rows.Next() {
		var i DmsAnyTaskEventRow
		if err := rows.Scan(
			&i.DmsTaskEvent.ID,
			&i.DmsTaskEvent.DeliveryTaskID,
			&i.DmsTaskEvent.Status,
			&i.DmsTaskEvent.Reason,
			&i.DmsTaskEvent.Notes,
			&i.DmsTaskEvent.Latitude,
			&i.DmsTaskEvent.Longitude,
			&i.DmsTaskEvent.Timestamp,
			&i.DmsTaskEvent.CreatedAt,
			&i.DmsTaskEvent.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsFindTaskEvent = `-- name: DmsFindTaskEvent :one
select
  task_events.id, task_events.delivery_task_id, task_events.status, task_events.reason, task_events.notes, task_events.latitude, task_events.longitude, task_events.timestamp, task_events.created_at, task_events.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."task_events" as task_events
  inner join "dms"."delivery_tasks" as delivery_task on task_events.delivery_task_id = delivery_task.id
where
  task_events.id = $1::uuid
`

type DmsFindTaskEventRow struct {
	DmsTaskEvent    DmsTaskEvent
	DmsDeliveryTask DmsDeliveryTask
}

func (q *Queries) DmsFindTaskEvent(ctx context.Context, id pgtype.UUID) (DmsFindTaskEventRow, error) {
	row := q.db.QueryRow(ctx, dmsFindTaskEvent, id)
	var i DmsFindTaskEventRow
	err := row.Scan(
		&i.DmsTaskEvent.ID,
		&i.DmsTaskEvent.DeliveryTaskID,
		&i.DmsTaskEvent.Status,
		&i.DmsTaskEvent.Reason,
		&i.DmsTaskEvent.Notes,
		&i.DmsTaskEvent.Latitude,
		&i.DmsTaskEvent.Longitude,
		&i.DmsTaskEvent.Timestamp,
		&i.DmsTaskEvent.CreatedAt,
		&i.DmsTaskEvent.UpdatedAt,
		&i.DmsDeliveryTask.ID,
		&i.DmsDeliveryTask.PackageID,
		&i.DmsDeliveryTask.DeliveryRouteID,
		&i.DmsDeliveryTask.RouteSequence,
		&i.DmsDeliveryTask.DeliveryAddress,
		&i.DmsDeliveryTask.RecipientName,
		&i.DmsDeliveryTask.RecipientPhone,
		&i.DmsDeliveryTask.DeliveryInstructions,
		&i.DmsDeliveryTask.EstimatedArrivalTime,
		&i.DmsDeliveryTask.ActualArrivalTime,
		&i.DmsDeliveryTask.DeliveryTime,
		&i.DmsDeliveryTask.Status,
		&i.DmsDeliveryTask.FailureReason,
		&i.DmsDeliveryTask.AttemptCount,
		&i.DmsDeliveryTask.CreatedAt,
		&i.DmsDeliveryTask.UpdatedAt,
	)
	return i, err
}

const dmsInsertTaskEvent = `-- name: DmsInsertTaskEvent :one
insert into "dms"."task_events"(delivery_task_id, status, reason, notes, latitude, longitude, timestamp)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, delivery_task_id, status, reason, notes, latitude, longitude, timestamp, created_at, updated_at
`

type DmsInsertTaskEventParams struct {
	DeliveryTaskID pgtype.UUID
	Status         DmsTaskEventStatusEnum
	Reason         pgtype.Text
	Notes          pgtype.Text
	Latitude       pgtype.Float4
	Longitude      pgtype.Float4
	Timestamp      pgtype.Timestamp
}

func (q *Queries) DmsInsertTaskEvent(ctx context.Context, arg DmsInsertTaskEventParams) (DmsTaskEvent, error) {
	row := q.db.QueryRow(ctx, dmsInsertTaskEvent,
		arg.DeliveryTaskID,
		arg.Status,
		arg.Reason,
		arg.Notes,
		arg.Latitude,
		arg.Longitude,
		arg.Timestamp,
	)
	var i DmsTaskEvent
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.Status,
		&i.Reason,
		&i.Notes,
		&i.Latitude,
		&i.Longitude,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dmsPaginateTaskEvent = `-- name: DmsPaginateTaskEvent :many
select
  task_events.id, task_events.delivery_task_id, task_events.status, task_events.reason, task_events.notes, task_events.latitude, task_events.longitude, task_events.timestamp, task_events.created_at, task_events.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."task_events" as task_events
  inner join "dms"."delivery_tasks" as delivery_task on task_events.delivery_task_id = delivery_task.id
limit $2::int offset ($1::int - 1) * $2::int
`

type DmsPaginateTaskEventParams struct {
	Page    int32
	Perpage int32
}

type DmsPaginateTaskEventRow struct {
	DmsTaskEvent    DmsTaskEvent
	DmsDeliveryTask DmsDeliveryTask
}

func (q *Queries) DmsPaginateTaskEvent(ctx context.Context, arg DmsPaginateTaskEventParams) ([]DmsPaginateTaskEventRow, error) {
	rows, err := q.db.Query(ctx, dmsPaginateTaskEvent, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsPaginateTaskEventRow
	for rows.Next() {
		var i DmsPaginateTaskEventRow
		if err := rows.Scan(
			&i.DmsTaskEvent.ID,
			&i.DmsTaskEvent.DeliveryTaskID,
			&i.DmsTaskEvent.Status,
			&i.DmsTaskEvent.Reason,
			&i.DmsTaskEvent.Notes,
			&i.DmsTaskEvent.Latitude,
			&i.DmsTaskEvent.Longitude,
			&i.DmsTaskEvent.Timestamp,
			&i.DmsTaskEvent.CreatedAt,
			&i.DmsTaskEvent.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRangeTaskEvent = `-- name: DmsRangeTaskEvent :many
select
  task_events.id, task_events.delivery_task_id, task_events.status, task_events.reason, task_events.notes, task_events.latitude, task_events.longitude, task_events.timestamp, task_events.created_at, task_events.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."task_events" as task_events
  inner join "dms"."delivery_tasks" as delivery_task on task_events.delivery_task_id = delivery_task.id
where
  task_events.created_at >= $1::date
  and task_events.created_at <= $2::date
`

type DmsRangeTaskEventParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type DmsRangeTaskEventRow struct {
	DmsTaskEvent    DmsTaskEvent
	DmsDeliveryTask DmsDeliveryTask
}

func (q *Queries) DmsRangeTaskEvent(ctx context.Context, arg DmsRangeTaskEventParams) ([]DmsRangeTaskEventRow, error) {
	rows, err := q.db.Query(ctx, dmsRangeTaskEvent, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsRangeTaskEventRow
	for rows.Next() {
		var i DmsRangeTaskEventRow
		if err := rows.Scan(
			&i.DmsTaskEvent.ID,
			&i.DmsTaskEvent.DeliveryTaskID,
			&i.DmsTaskEvent.Status,
			&i.DmsTaskEvent.Reason,
			&i.DmsTaskEvent.Notes,
			&i.DmsTaskEvent.Latitude,
			&i.DmsTaskEvent.Longitude,
			&i.DmsTaskEvent.Timestamp,
			&i.DmsTaskEvent.CreatedAt,
			&i.DmsTaskEvent.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRemoveTaskEvent = `-- name: DmsRemoveTaskEvent :exec
delete from "dms"."task_events"
where id = $1::uuid
`

func (q *Queries) DmsRemoveTaskEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, dmsRemoveTaskEvent, id)
	return err
}

const dmsUpdateTaskEvent = `-- name: DmsUpdateTaskEvent :one
update
  "dms"."task_events"
set
  delivery_task_id = case when $1::boolean then
    $2::uuid
  else
    delivery_task_id
  end,
  status = case when $3::boolean then
    $4::dms.task_event_status_enum
  else
    status
  end,
  reason = case when $5::boolean then
    $6::text
  else
    reason
  end,
  notes = case when $7::boolean then
    $8::text
  else
    notes
  end,
  latitude = case when $9::boolean then
    $10::real
  else
    latitude
  end,
  longitude = case when $11::boolean then
    $12::real
  else
    longitude
  end,
  timestamp = case when $13::boolean then
    $14::timestamp
  else
    timestamp
  end
where
  id = $15::uuid
returning
  id, delivery_task_id, status, reason, notes, latitude, longitude, timestamp, created_at, updated_at
`

type DmsUpdateTaskEventParams struct {
	SetDeliveryTaskID bool
	DeliveryTaskID    pgtype.UUID
	SetStatus         bool
	Status            DmsTaskEventStatusEnum
	SetReason         bool
	Reason            string
	SetNotes          bool
	Notes             string
	SetLatitude       bool
	Latitude          float32
	SetLongitude      bool
	Longitude         float32
	SetTimestamp      bool
	Timestamp         pgtype.Timestamp
	ID                pgtype.UUID
}

func (q *Queries) DmsUpdateTaskEvent(ctx context.Context, arg DmsUpdateTaskEventParams) (DmsTaskEvent, error) {
	row := q.db.QueryRow(ctx, dmsUpdateTaskEvent,
		arg.SetDeliveryTaskID,
		arg.DeliveryTaskID,
		arg.SetStatus,
		arg.Status,
		arg.SetReason,
		arg.Reason,
		arg.SetNotes,
		arg.Notes,
		arg.SetLatitude,
		arg.Latitude,
		arg.SetLongitude,
		arg.Longitude,
		arg.SetTimestamp,
		arg.Timestamp,
		arg.ID,
	)
	var i DmsTaskEvent
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.Status,
		&i.Reason,
		&i.Notes,
		&i.Latitude,
		&i.Longitude,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
