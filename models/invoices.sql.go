// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invoices.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInvoice = `-- name: CreateInvoice :one
insert into invoices (invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url)
values ($1, $2, $3, $4, $5, $6,
  $7, $8)
returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

type CreateInvoiceParams struct {
	InvoiceNumber string
	Order         pgtype.UUID
	Customer      pgtype.UUID
	InvoiceDate   pgtype.Timestamptz
	DueDate       pgtype.Timestamptz
	TotalAmount   pgtype.Numeric
	Status        string
	InvoicePdfUrl pgtype.Text
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.InvoiceNumber,
		arg.Order,
		arg.Customer,
		arg.InvoiceDate,
		arg.DueDate,
		arg.TotalAmount,
		arg.Status,
		arg.InvoicePdfUrl,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :one
delete from invoices where id = $1 returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

func (q *Queries) DeleteInvoice(ctx context.Context, id pgtype.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, deleteInvoice, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getInvoiceByID = `-- name: GetInvoiceByID :one
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where id = $1
`

func (q *Queries) GetInvoiceByID(ctx context.Context, id pgtype.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByID, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getInvoices = `-- name: GetInvoices :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices order by created desc offset $1 limit $2
`

type GetInvoicesParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetInvoices(ctx context.Context, arg GetInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoices, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomer = `-- name: GetInvoicesByCustomer :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1 order by created desc offset $2 limit $3
`

type GetInvoicesByCustomerParams struct {
	Customer pgtype.UUID
	Offset   int32
	Limit    int32
}

func (q *Queries) GetInvoicesByCustomer(ctx context.Context, arg GetInvoicesByCustomerParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomer, arg.Customer, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomerAndDateRange = `-- name: GetInvoicesByCustomerAndDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1 and invoice_date >= $2 and invoice_date <= $3
order by created desc offset $4 limit $5
`

type GetInvoicesByCustomerAndDateRangeParams struct {
	Customer      pgtype.UUID
	InvoiceDate   pgtype.Timestamptz
	InvoiceDate_2 pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) GetInvoicesByCustomerAndDateRange(ctx context.Context, arg GetInvoicesByCustomerAndDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomerAndDateRange,
		arg.Customer,
		arg.InvoiceDate,
		arg.InvoiceDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomerAndDueDateRange = `-- name: GetInvoicesByCustomerAndDueDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1 and due_date >= $2 and due_date <= $3
order by created desc offset $4 limit $5
`

type GetInvoicesByCustomerAndDueDateRangeParams struct {
	Customer  pgtype.UUID
	DueDate   pgtype.Timestamptz
	DueDate_2 pgtype.Timestamptz
	Offset    int32
	Limit     int32
}

func (q *Queries) GetInvoicesByCustomerAndDueDateRange(ctx context.Context, arg GetInvoicesByCustomerAndDueDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomerAndDueDateRange,
		arg.Customer,
		arg.DueDate,
		arg.DueDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomerAndStatus = `-- name: GetInvoicesByCustomerAndStatus :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1 and status = $2
order by created desc offset $3 limit $4
`

type GetInvoicesByCustomerAndStatusParams struct {
	Customer pgtype.UUID
	Status   string
	Offset   int32
	Limit    int32
}

func (q *Queries) GetInvoicesByCustomerAndStatus(ctx context.Context, arg GetInvoicesByCustomerAndStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomerAndStatus,
		arg.Customer,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomerAndStatusAndDateRange = `-- name: GetInvoicesByCustomerAndStatusAndDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1 and status = $2 and invoice_date >= $3 and invoice_date <= $4
order by created desc offset $5 limit $6
`

type GetInvoicesByCustomerAndStatusAndDateRangeParams struct {
	Customer      pgtype.UUID
	Status        string
	InvoiceDate   pgtype.Timestamptz
	InvoiceDate_2 pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) GetInvoicesByCustomerAndStatusAndDateRange(ctx context.Context, arg GetInvoicesByCustomerAndStatusAndDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomerAndStatusAndDateRange,
		arg.Customer,
		arg.Status,
		arg.InvoiceDate,
		arg.InvoiceDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByDateRange = `-- name: GetInvoicesByDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where invoice_date >= $1 and invoice_date <= $2
order by created desc offset $3 limit $4
`

type GetInvoicesByDateRangeParams struct {
	InvoiceDate   pgtype.Timestamptz
	InvoiceDate_2 pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) GetInvoicesByDateRange(ctx context.Context, arg GetInvoicesByDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByDateRange,
		arg.InvoiceDate,
		arg.InvoiceDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByDueDateRange = `-- name: GetInvoicesByDueDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where due_date >= $1 and due_date <= $2
order by created desc offset $3 limit $4
`

type GetInvoicesByDueDateRangeParams struct {
	DueDate   pgtype.Timestamptz
	DueDate_2 pgtype.Timestamptz
	Offset    int32
	Limit     int32
}

func (q *Queries) GetInvoicesByDueDateRange(ctx context.Context, arg GetInvoicesByDueDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByDueDateRange,
		arg.DueDate,
		arg.DueDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrder = `-- name: GetInvoicesByOrder :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1 order by created desc offset $2 limit $3
`

type GetInvoicesByOrderParams struct {
	Order  pgtype.UUID
	Offset int32
	Limit  int32
}

func (q *Queries) GetInvoicesByOrder(ctx context.Context, arg GetInvoicesByOrderParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrder, arg.Order, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrderAndDateRange = `-- name: GetInvoicesByOrderAndDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1 and invoice_date >= $2 and invoice_date <= $3
order by created desc offset $4 limit $5
`

type GetInvoicesByOrderAndDateRangeParams struct {
	Order         pgtype.UUID
	InvoiceDate   pgtype.Timestamptz
	InvoiceDate_2 pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) GetInvoicesByOrderAndDateRange(ctx context.Context, arg GetInvoicesByOrderAndDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrderAndDateRange,
		arg.Order,
		arg.InvoiceDate,
		arg.InvoiceDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrderAndDueDateRange = `-- name: GetInvoicesByOrderAndDueDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1 and due_date >= $2 and due_date <= $3
order by created desc offset $4 limit $5
`

type GetInvoicesByOrderAndDueDateRangeParams struct {
	Order     pgtype.UUID
	DueDate   pgtype.Timestamptz
	DueDate_2 pgtype.Timestamptz
	Offset    int32
	Limit     int32
}

func (q *Queries) GetInvoicesByOrderAndDueDateRange(ctx context.Context, arg GetInvoicesByOrderAndDueDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrderAndDueDateRange,
		arg.Order,
		arg.DueDate,
		arg.DueDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrderAndStatus = `-- name: GetInvoicesByOrderAndStatus :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1 and status = $2
order by created desc offset $3 limit $4
`

type GetInvoicesByOrderAndStatusParams struct {
	Order  pgtype.UUID
	Status string
	Offset int32
	Limit  int32
}

func (q *Queries) GetInvoicesByOrderAndStatus(ctx context.Context, arg GetInvoicesByOrderAndStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrderAndStatus,
		arg.Order,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrderAndStatusAndDateRange = `-- name: GetInvoicesByOrderAndStatusAndDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1 and status = $2 and invoice_date >= $3 and invoice_date <= $4
order by created desc offset $5 limit $6
`

type GetInvoicesByOrderAndStatusAndDateRangeParams struct {
	Order         pgtype.UUID
	Status        string
	InvoiceDate   pgtype.Timestamptz
	InvoiceDate_2 pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) GetInvoicesByOrderAndStatusAndDateRange(ctx context.Context, arg GetInvoicesByOrderAndStatusAndDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrderAndStatusAndDateRange,
		arg.Order,
		arg.Status,
		arg.InvoiceDate,
		arg.InvoiceDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByStatus = `-- name: GetInvoicesByStatus :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where status = $1 order by created desc offset $2 limit $3
`

type GetInvoicesByStatusParams struct {
	Status string
	Offset int32
	Limit  int32
}

func (q *Queries) GetInvoicesByStatus(ctx context.Context, arg GetInvoicesByStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInvoices = `-- name: SearchInvoices :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where invoice_number ilike '%' || $1::text || '%' or
  status ilike '%' || $1::text || '%' or
  customer ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchInvoicesParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchInvoices(ctx context.Context, arg SearchInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, searchInvoices, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoiceDueDate = `-- name: UpdateInvoiceDueDate :one
update invoices set due_date = $1 where id = $2 returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

type UpdateInvoiceDueDateParams struct {
	DueDate pgtype.Timestamptz
	ID      pgtype.UUID
}

func (q *Queries) UpdateInvoiceDueDate(ctx context.Context, arg UpdateInvoiceDueDateParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceDueDate, arg.DueDate, arg.ID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInvoiceStatus = `-- name: UpdateInvoiceStatus :one
update invoices set status = $1 where id = $2 returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

type UpdateInvoiceStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateInvoiceStatus(ctx context.Context, arg UpdateInvoiceStatusParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceStatus, arg.Status, arg.ID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInvoiceTotalAmount = `-- name: UpdateInvoiceTotalAmount :one
update invoices set total_amount = $1 where id = $2 returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

type UpdateInvoiceTotalAmountParams struct {
	TotalAmount pgtype.Numeric
	ID          pgtype.UUID
}

func (q *Queries) UpdateInvoiceTotalAmount(ctx context.Context, arg UpdateInvoiceTotalAmountParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceTotalAmount, arg.TotalAmount, arg.ID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
