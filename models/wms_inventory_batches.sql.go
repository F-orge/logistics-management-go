// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_inventory_batches.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyInventoryBatch = `-- name: WmsAnyInventoryBatch :many
select
  inventory_batches.id, inventory_batches.product_id, inventory_batches.batch_number, inventory_batches.expiration_date, inventory_batches.created_at, inventory_batches.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."inventory_batches" as inventory_batches
  inner join "wms"."products" as product on inventory_batches.product_id = product.id
where
  inventory_batches.id = any ($1::uuid[])
`

type WmsAnyInventoryBatchRow struct {
	WmsInventoryBatch WmsInventoryBatch
	WmsProduct        WmsProduct
}

func (q *Queries) WmsAnyInventoryBatch(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyInventoryBatchRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyInventoryBatch, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyInventoryBatchRow
	for rows.Next() {
		var i WmsAnyInventoryBatchRow
		if err := rows.Scan(
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindInventoryBatch = `-- name: WmsFindInventoryBatch :one
select
  inventory_batches.id, inventory_batches.product_id, inventory_batches.batch_number, inventory_batches.expiration_date, inventory_batches.created_at, inventory_batches.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."inventory_batches" as inventory_batches
  inner join "wms"."products" as product on inventory_batches.product_id = product.id
where
  inventory_batches.id = $1::uuid
`

type WmsFindInventoryBatchRow struct {
	WmsInventoryBatch WmsInventoryBatch
	WmsProduct        WmsProduct
}

func (q *Queries) WmsFindInventoryBatch(ctx context.Context, id pgtype.UUID) (WmsFindInventoryBatchRow, error) {
	row := q.db.QueryRow(ctx, wmsFindInventoryBatch, id)
	var i WmsFindInventoryBatchRow
	err := row.Scan(
		&i.WmsInventoryBatch.ID,
		&i.WmsInventoryBatch.ProductID,
		&i.WmsInventoryBatch.BatchNumber,
		&i.WmsInventoryBatch.ExpirationDate,
		&i.WmsInventoryBatch.CreatedAt,
		&i.WmsInventoryBatch.UpdatedAt,
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
	)
	return i, err
}

const wmsInsertInventoryBatch = `-- name: WmsInsertInventoryBatch :one
insert into "wms"."inventory_batches"(product_id, batch_number, expiration_date)
  values ($1, $2, $3)
returning
  id, product_id, batch_number, expiration_date, created_at, updated_at
`

type WmsInsertInventoryBatchParams struct {
	ProductID      pgtype.UUID
	BatchNumber    string
	ExpirationDate pgtype.Date
}

func (q *Queries) WmsInsertInventoryBatch(ctx context.Context, arg WmsInsertInventoryBatchParams) (WmsInventoryBatch, error) {
	row := q.db.QueryRow(ctx, wmsInsertInventoryBatch, arg.ProductID, arg.BatchNumber, arg.ExpirationDate)
	var i WmsInventoryBatch
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.BatchNumber,
		&i.ExpirationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateInventoryBatch = `-- name: WmsPaginateInventoryBatch :many
select
  inventory_batches.id, inventory_batches.product_id, inventory_batches.batch_number, inventory_batches.expiration_date, inventory_batches.created_at, inventory_batches.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."inventory_batches" as inventory_batches
  inner join "wms"."products" as product on inventory_batches.product_id = product.id
where
  (product.name ilike $1::text
  or inventory_batches.batch_number ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateInventoryBatchParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type WmsPaginateInventoryBatchRow struct {
	WmsInventoryBatch WmsInventoryBatch
	WmsProduct        WmsProduct
}

func (q *Queries) WmsPaginateInventoryBatch(ctx context.Context, arg WmsPaginateInventoryBatchParams) ([]WmsPaginateInventoryBatchRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateInventoryBatch, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateInventoryBatchRow
	for rows.Next() {
		var i WmsPaginateInventoryBatchRow
		if err := rows.Scan(
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeInventoryBatch = `-- name: WmsRangeInventoryBatch :many
select
  inventory_batches.id, inventory_batches.product_id, inventory_batches.batch_number, inventory_batches.expiration_date, inventory_batches.created_at, inventory_batches.updated_at,
  product.id, product.name, product.sku, product.barcode, product.description, product.cost_price, product.length, product.width, product.height, product.volume, product.weight, product.status, product.supplier_id, product.client_id, product.created_at, product.updated_at
from
  "wms"."inventory_batches" as inventory_batches
  inner join "wms"."products" as product on inventory_batches.product_id = product.id
where
  inventory_batches.created_at >= $1::date
  and inventory_batches.created_at <= $2::date
  and (product.name ilike $3::text
  or inventory_batches.batch_number ilike $3::text
  or $3::text is null)
`

type WmsRangeInventoryBatchParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type WmsRangeInventoryBatchRow struct {
	WmsInventoryBatch WmsInventoryBatch
	WmsProduct        WmsProduct
}

func (q *Queries) WmsRangeInventoryBatch(ctx context.Context, arg WmsRangeInventoryBatchParams) ([]WmsRangeInventoryBatchRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeInventoryBatch, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeInventoryBatchRow
	for rows.Next() {
		var i WmsRangeInventoryBatchRow
		if err := rows.Scan(
			&i.WmsInventoryBatch.ID,
			&i.WmsInventoryBatch.ProductID,
			&i.WmsInventoryBatch.BatchNumber,
			&i.WmsInventoryBatch.ExpirationDate,
			&i.WmsInventoryBatch.CreatedAt,
			&i.WmsInventoryBatch.UpdatedAt,
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveInventoryBatch = `-- name: WmsRemoveInventoryBatch :exec
delete from "wms"."inventory_batches"
where id = $1::uuid
`

func (q *Queries) WmsRemoveInventoryBatch(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveInventoryBatch, id)
	return err
}

const wmsUpdateInventoryBatch = `-- name: WmsUpdateInventoryBatch :one
update
  "wms"."inventory_batches"
set
  updated_at = now(),
  product_id = case when $1::boolean then
    $2::uuid
  else
    product_id
  end,
  batch_number = case when $3::boolean then
    $4::varchar
  else
    batch_number
  end,
  expiration_date = case when $5::boolean then
    $6::date
  else
    expiration_date
  end
where
  id = $7::uuid
returning
  id, product_id, batch_number, expiration_date, created_at, updated_at
`

type WmsUpdateInventoryBatchParams struct {
	SetProductID      bool
	ProductID         pgtype.UUID
	SetBatchNumber    bool
	BatchNumber       string
	SetExpirationDate bool
	ExpirationDate    pgtype.Date
	ID                pgtype.UUID
}

func (q *Queries) WmsUpdateInventoryBatch(ctx context.Context, arg WmsUpdateInventoryBatchParams) (WmsInventoryBatch, error) {
	row := q.db.QueryRow(ctx, wmsUpdateInventoryBatch,
		arg.SetProductID,
		arg.ProductID,
		arg.SetBatchNumber,
		arg.BatchNumber,
		arg.SetExpirationDate,
		arg.ExpirationDate,
		arg.ID,
	)
	var i WmsInventoryBatch
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.BatchNumber,
		&i.ExpirationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
