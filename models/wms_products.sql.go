// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_products.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyProduct = `-- name: WmsAnyProduct :many
select
  products.id, products.name, products.sku, products.barcode, products.description, products.cost_price, products.length, products.width, products.height, products.volume, products.weight, products.status, products.supplier_id, products.client_id, products.created_at, products.updated_at,
  supplier.id, supplier.name, supplier.contact_person, supplier.email, supplier.phone_number, supplier.created_at, supplier.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."products" as products
  left join "wms"."suppliers" as supplier on products.supplier_id = supplier.id
  left join "crm"."companies" as client on products.client_id = client.id
where
  products.id = any ($1::uuid[])
`

type WmsAnyProductRow struct {
	WmsProduct  WmsProduct
	WmsSupplier WmsSupplier
	CrmCompany  CrmCompany
}

func (q *Queries) WmsAnyProduct(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyProductRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyProduct, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyProductRow
	for rows.Next() {
		var i WmsAnyProductRow
		if err := rows.Scan(
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsSupplier.ID,
			&i.WmsSupplier.Name,
			&i.WmsSupplier.ContactPerson,
			&i.WmsSupplier.Email,
			&i.WmsSupplier.PhoneNumber,
			&i.WmsSupplier.CreatedAt,
			&i.WmsSupplier.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindProduct = `-- name: WmsFindProduct :one
select
  products.id, products.name, products.sku, products.barcode, products.description, products.cost_price, products.length, products.width, products.height, products.volume, products.weight, products.status, products.supplier_id, products.client_id, products.created_at, products.updated_at,
  supplier.id, supplier.name, supplier.contact_person, supplier.email, supplier.phone_number, supplier.created_at, supplier.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."products" as products
  left join "wms"."suppliers" as supplier on products.supplier_id = supplier.id
  left join "crm"."companies" as client on products.client_id = client.id
where
  products.id = $1::uuid
`

type WmsFindProductRow struct {
	WmsProduct  WmsProduct
	WmsSupplier WmsSupplier
	CrmCompany  CrmCompany
}

func (q *Queries) WmsFindProduct(ctx context.Context, id pgtype.UUID) (WmsFindProductRow, error) {
	row := q.db.QueryRow(ctx, wmsFindProduct, id)
	var i WmsFindProductRow
	err := row.Scan(
		&i.WmsProduct.ID,
		&i.WmsProduct.Name,
		&i.WmsProduct.Sku,
		&i.WmsProduct.Barcode,
		&i.WmsProduct.Description,
		&i.WmsProduct.CostPrice,
		&i.WmsProduct.Length,
		&i.WmsProduct.Width,
		&i.WmsProduct.Height,
		&i.WmsProduct.Volume,
		&i.WmsProduct.Weight,
		&i.WmsProduct.Status,
		&i.WmsProduct.SupplierID,
		&i.WmsProduct.ClientID,
		&i.WmsProduct.CreatedAt,
		&i.WmsProduct.UpdatedAt,
		&i.WmsSupplier.ID,
		&i.WmsSupplier.Name,
		&i.WmsSupplier.ContactPerson,
		&i.WmsSupplier.Email,
		&i.WmsSupplier.PhoneNumber,
		&i.WmsSupplier.CreatedAt,
		&i.WmsSupplier.UpdatedAt,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
	)
	return i, err
}

const wmsInsertProduct = `-- name: WmsInsertProduct :one
insert into "wms"."products"(name, sku, barcode, description, cost_price, length, width, height, weight, status, supplier_id, client_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
returning
  id, name, sku, barcode, description, cost_price, length, width, height, volume, weight, status, supplier_id, client_id, created_at, updated_at
`

type WmsInsertProductParams struct {
	Name        string
	Sku         string
	Barcode     pgtype.Text
	Description pgtype.Text
	CostPrice   pgtype.Numeric
	Length      pgtype.Float4
	Width       pgtype.Float4
	Height      pgtype.Float4
	Weight      pgtype.Float4
	Status      NullWmsProductStatusEnum
	SupplierID  pgtype.UUID
	ClientID    pgtype.UUID
}

func (q *Queries) WmsInsertProduct(ctx context.Context, arg WmsInsertProductParams) (WmsProduct, error) {
	row := q.db.QueryRow(ctx, wmsInsertProduct,
		arg.Name,
		arg.Sku,
		arg.Barcode,
		arg.Description,
		arg.CostPrice,
		arg.Length,
		arg.Width,
		arg.Height,
		arg.Weight,
		arg.Status,
		arg.SupplierID,
		arg.ClientID,
	)
	var i WmsProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Barcode,
		&i.Description,
		&i.CostPrice,
		&i.Length,
		&i.Width,
		&i.Height,
		&i.Volume,
		&i.Weight,
		&i.Status,
		&i.SupplierID,
		&i.ClientID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateProduct = `-- name: WmsPaginateProduct :many
select
  products.id, products.name, products.sku, products.barcode, products.description, products.cost_price, products.length, products.width, products.height, products.volume, products.weight, products.status, products.supplier_id, products.client_id, products.created_at, products.updated_at,
  supplier.id, supplier.name, supplier.contact_person, supplier.email, supplier.phone_number, supplier.created_at, supplier.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."products" as products
  left join "wms"."suppliers" as supplier on products.supplier_id = supplier.id
  left join "crm"."companies" as client on products.client_id = client.id
limit $2::int offset ($1::int - 1) * $2::int
`

type WmsPaginateProductParams struct {
	Page    int32
	Perpage int32
}

type WmsPaginateProductRow struct {
	WmsProduct  WmsProduct
	WmsSupplier WmsSupplier
	CrmCompany  CrmCompany
}

func (q *Queries) WmsPaginateProduct(ctx context.Context, arg WmsPaginateProductParams) ([]WmsPaginateProductRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateProduct, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateProductRow
	for rows.Next() {
		var i WmsPaginateProductRow
		if err := rows.Scan(
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsSupplier.ID,
			&i.WmsSupplier.Name,
			&i.WmsSupplier.ContactPerson,
			&i.WmsSupplier.Email,
			&i.WmsSupplier.PhoneNumber,
			&i.WmsSupplier.CreatedAt,
			&i.WmsSupplier.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeProduct = `-- name: WmsRangeProduct :many
select
  products.id, products.name, products.sku, products.barcode, products.description, products.cost_price, products.length, products.width, products.height, products.volume, products.weight, products.status, products.supplier_id, products.client_id, products.created_at, products.updated_at,
  supplier.id, supplier.name, supplier.contact_person, supplier.email, supplier.phone_number, supplier.created_at, supplier.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."products" as products
  left join "wms"."suppliers" as supplier on products.supplier_id = supplier.id
  left join "crm"."companies" as client on products.client_id = client.id
where
  products.created_at >= $1::date
  and products.created_at <= $2::date
`

type WmsRangeProductParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type WmsRangeProductRow struct {
	WmsProduct  WmsProduct
	WmsSupplier WmsSupplier
	CrmCompany  CrmCompany
}

func (q *Queries) WmsRangeProduct(ctx context.Context, arg WmsRangeProductParams) ([]WmsRangeProductRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeProduct, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeProductRow
	for rows.Next() {
		var i WmsRangeProductRow
		if err := rows.Scan(
			&i.WmsProduct.ID,
			&i.WmsProduct.Name,
			&i.WmsProduct.Sku,
			&i.WmsProduct.Barcode,
			&i.WmsProduct.Description,
			&i.WmsProduct.CostPrice,
			&i.WmsProduct.Length,
			&i.WmsProduct.Width,
			&i.WmsProduct.Height,
			&i.WmsProduct.Volume,
			&i.WmsProduct.Weight,
			&i.WmsProduct.Status,
			&i.WmsProduct.SupplierID,
			&i.WmsProduct.ClientID,
			&i.WmsProduct.CreatedAt,
			&i.WmsProduct.UpdatedAt,
			&i.WmsSupplier.ID,
			&i.WmsSupplier.Name,
			&i.WmsSupplier.ContactPerson,
			&i.WmsSupplier.Email,
			&i.WmsSupplier.PhoneNumber,
			&i.WmsSupplier.CreatedAt,
			&i.WmsSupplier.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveProduct = `-- name: WmsRemoveProduct :exec
delete from "wms"."products"
where id = $1::uuid
`

func (q *Queries) WmsRemoveProduct(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveProduct, id)
	return err
}

const wmsUpdateProduct = `-- name: WmsUpdateProduct :one
update
  "wms"."products"
set
  name = case when $1::boolean then
    $2::varchar
  else
    name
  end,
  sku = case when $3::boolean then
    $4::varchar
  else
    sku
  end,
  barcode = case when $5::boolean then
    $6::varchar
  else
    barcode
  end,
  description = case when $7::boolean then
    $8::text
  else
    description
  end,
  cost_price = case when $9::boolean then
    $10::numeric
  else
    cost_price
  end,
  length = case when $11::boolean then
    $12::real
  else
    length
  end,
  width = case when $13::boolean then
    $14::real
  else
    width
  end,
  height = case when $15::boolean then
    $16::real
  else
    height
  end,
  weight = case when $17::boolean then
    $18::real
  else
    weight
  end,
  status = case when $19::boolean then
    $20::wms.product_status_enum
  else
    status
  end,
  supplier_id = case when $21::boolean then
    $22::uuid
  else
    supplier_id
  end,
  client_id = case when $23::boolean then
    $24::uuid
  else
    client_id
  end
where
  id = $25::uuid
returning
  id, name, sku, barcode, description, cost_price, length, width, height, volume, weight, status, supplier_id, client_id, created_at, updated_at
`

type WmsUpdateProductParams struct {
	SetName        bool
	Name           string
	SetSku         bool
	Sku            string
	SetBarcode     bool
	Barcode        string
	SetDescription bool
	Description    string
	SetCostPrice   bool
	CostPrice      pgtype.Numeric
	SetLength      bool
	Length         float32
	SetWidth       bool
	Width          float32
	SetHeight      bool
	Height         float32
	SetWeight      bool
	Weight         float32
	SetStatus      bool
	Status         WmsProductStatusEnum
	SetSupplierID  bool
	SupplierID     pgtype.UUID
	SetClientID    bool
	ClientID       pgtype.UUID
	ID             pgtype.UUID
}

func (q *Queries) WmsUpdateProduct(ctx context.Context, arg WmsUpdateProductParams) (WmsProduct, error) {
	row := q.db.QueryRow(ctx, wmsUpdateProduct,
		arg.SetName,
		arg.Name,
		arg.SetSku,
		arg.Sku,
		arg.SetBarcode,
		arg.Barcode,
		arg.SetDescription,
		arg.Description,
		arg.SetCostPrice,
		arg.CostPrice,
		arg.SetLength,
		arg.Length,
		arg.SetWidth,
		arg.Width,
		arg.SetHeight,
		arg.Height,
		arg.SetWeight,
		arg.Weight,
		arg.SetStatus,
		arg.Status,
		arg.SetSupplierID,
		arg.SupplierID,
		arg.SetClientID,
		arg.ClientID,
		arg.ID,
	)
	var i WmsProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Barcode,
		&i.Description,
		&i.CostPrice,
		&i.Length,
		&i.Width,
		&i.Height,
		&i.Volume,
		&i.Weight,
		&i.Status,
		&i.SupplierID,
		&i.ClientID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
