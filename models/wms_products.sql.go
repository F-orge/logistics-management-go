// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wms_products.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const wmsAnyProduct = `-- name: WmsAnyProduct :many
select
  products.id, products.name, products.sku, products.barcode, products.description, products.cost_price, products.length, products.width, products.height, products.volume, products.weight, products.status, products.supplier_id, products.client_id, products.created_at, products.updated_at, products.inventory_batches, products.inventory_adjustments, products.reorder_points, products.inbound_shipment_items, products.stock_transfers, products.sales_order_items, products.outbound_shipment_items, products.return_items, products.inventory_stock, products.putaway_rules, products.bin_thresholds, products.task_items, products.package_items,
  supplier.id, supplier.name, supplier.contact_person, supplier.email, supplier.phone_number, supplier.created_at, supplier.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."products_view" as products
  left join "wms"."suppliers" as supplier on products.supplier_id = supplier.id
  left join "crm"."companies" as client on products.client_id = client.id
where
  products.id = any ($1::uuid[])
`

type WmsAnyProductRow struct {
	WmsProductsView WmsProductsView `db:"wms_products_view" json:"wms_products_view"`
	WmsSupplier     WmsSupplier     `db:"wms_supplier" json:"wms_supplier"`
	CrmCompany      CrmCompany      `db:"crm_company" json:"crm_company"`
}

func (q *Queries) WmsAnyProduct(ctx context.Context, ids []pgtype.UUID) ([]WmsAnyProductRow, error) {
	rows, err := q.db.Query(ctx, wmsAnyProduct, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsAnyProductRow
	for rows.Next() {
		var i WmsAnyProductRow
		if err := rows.Scan(
			&i.WmsProductsView.ID,
			&i.WmsProductsView.Name,
			&i.WmsProductsView.Sku,
			&i.WmsProductsView.Barcode,
			&i.WmsProductsView.Description,
			&i.WmsProductsView.CostPrice,
			&i.WmsProductsView.Length,
			&i.WmsProductsView.Width,
			&i.WmsProductsView.Height,
			&i.WmsProductsView.Volume,
			&i.WmsProductsView.Weight,
			&i.WmsProductsView.Status,
			&i.WmsProductsView.SupplierID,
			&i.WmsProductsView.ClientID,
			&i.WmsProductsView.CreatedAt,
			&i.WmsProductsView.UpdatedAt,
			&i.WmsProductsView.InventoryBatches,
			&i.WmsProductsView.InventoryAdjustments,
			&i.WmsProductsView.ReorderPoints,
			&i.WmsProductsView.InboundShipmentItems,
			&i.WmsProductsView.StockTransfers,
			&i.WmsProductsView.SalesOrderItems,
			&i.WmsProductsView.OutboundShipmentItems,
			&i.WmsProductsView.ReturnItems,
			&i.WmsProductsView.InventoryStock,
			&i.WmsProductsView.PutawayRules,
			&i.WmsProductsView.BinThresholds,
			&i.WmsProductsView.TaskItems,
			&i.WmsProductsView.PackageItems,
			&i.WmsSupplier.ID,
			&i.WmsSupplier.Name,
			&i.WmsSupplier.ContactPerson,
			&i.WmsSupplier.Email,
			&i.WmsSupplier.PhoneNumber,
			&i.WmsSupplier.CreatedAt,
			&i.WmsSupplier.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsFindProduct = `-- name: WmsFindProduct :one
select
  products.id, products.name, products.sku, products.barcode, products.description, products.cost_price, products.length, products.width, products.height, products.volume, products.weight, products.status, products.supplier_id, products.client_id, products.created_at, products.updated_at, products.inventory_batches, products.inventory_adjustments, products.reorder_points, products.inbound_shipment_items, products.stock_transfers, products.sales_order_items, products.outbound_shipment_items, products.return_items, products.inventory_stock, products.putaway_rules, products.bin_thresholds, products.task_items, products.package_items,
  supplier.id, supplier.name, supplier.contact_person, supplier.email, supplier.phone_number, supplier.created_at, supplier.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."products_view" as products
  left join "wms"."suppliers" as supplier on products.supplier_id = supplier.id
  left join "crm"."companies" as client on products.client_id = client.id
where
  products.id = $1::uuid
`

type WmsFindProductRow struct {
	WmsProductsView WmsProductsView `db:"wms_products_view" json:"wms_products_view"`
	WmsSupplier     WmsSupplier     `db:"wms_supplier" json:"wms_supplier"`
	CrmCompany      CrmCompany      `db:"crm_company" json:"crm_company"`
}

func (q *Queries) WmsFindProduct(ctx context.Context, id pgtype.UUID) (WmsFindProductRow, error) {
	row := q.db.QueryRow(ctx, wmsFindProduct, id)
	var i WmsFindProductRow
	err := row.Scan(
		&i.WmsProductsView.ID,
		&i.WmsProductsView.Name,
		&i.WmsProductsView.Sku,
		&i.WmsProductsView.Barcode,
		&i.WmsProductsView.Description,
		&i.WmsProductsView.CostPrice,
		&i.WmsProductsView.Length,
		&i.WmsProductsView.Width,
		&i.WmsProductsView.Height,
		&i.WmsProductsView.Volume,
		&i.WmsProductsView.Weight,
		&i.WmsProductsView.Status,
		&i.WmsProductsView.SupplierID,
		&i.WmsProductsView.ClientID,
		&i.WmsProductsView.CreatedAt,
		&i.WmsProductsView.UpdatedAt,
		&i.WmsProductsView.InventoryBatches,
		&i.WmsProductsView.InventoryAdjustments,
		&i.WmsProductsView.ReorderPoints,
		&i.WmsProductsView.InboundShipmentItems,
		&i.WmsProductsView.StockTransfers,
		&i.WmsProductsView.SalesOrderItems,
		&i.WmsProductsView.OutboundShipmentItems,
		&i.WmsProductsView.ReturnItems,
		&i.WmsProductsView.InventoryStock,
		&i.WmsProductsView.PutawayRules,
		&i.WmsProductsView.BinThresholds,
		&i.WmsProductsView.TaskItems,
		&i.WmsProductsView.PackageItems,
		&i.WmsSupplier.ID,
		&i.WmsSupplier.Name,
		&i.WmsSupplier.ContactPerson,
		&i.WmsSupplier.Email,
		&i.WmsSupplier.PhoneNumber,
		&i.WmsSupplier.CreatedAt,
		&i.WmsSupplier.UpdatedAt,
		&i.CrmCompany.ID,
		&i.CrmCompany.Name,
		&i.CrmCompany.Street,
		&i.CrmCompany.City,
		&i.CrmCompany.State,
		&i.CrmCompany.PostalCode,
		&i.CrmCompany.Country,
		&i.CrmCompany.PhoneNumber,
		&i.CrmCompany.Industry,
		&i.CrmCompany.Website,
		&i.CrmCompany.AnnualRevenue,
		&i.CrmCompany.OwnerID,
		&i.CrmCompany.CreatedAt,
		&i.CrmCompany.UpdatedAt,
	)
	return i, err
}

const wmsInsertProduct = `-- name: WmsInsertProduct :one
insert into "wms"."products"(name, sku, barcode, description, cost_price, length, width, height, weight, status, supplier_id, client_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
returning
  id, name, sku, barcode, description, cost_price, length, width, height, volume, weight, status, supplier_id, client_id, created_at, updated_at
`

type WmsInsertProductParams struct {
	Name        string                   `db:"name" json:"name"`
	Sku         string                   `db:"sku" json:"sku"`
	Barcode     pgtype.Text              `db:"barcode" json:"barcode"`
	Description pgtype.Text              `db:"description" json:"description"`
	CostPrice   pgtype.Numeric           `db:"cost_price" json:"cost_price"`
	Length      pgtype.Float4            `db:"length" json:"length"`
	Width       pgtype.Float4            `db:"width" json:"width"`
	Height      pgtype.Float4            `db:"height" json:"height"`
	Weight      pgtype.Float4            `db:"weight" json:"weight"`
	Status      NullWmsProductStatusEnum `db:"status" json:"status"`
	SupplierID  pgtype.UUID              `db:"supplier_id" json:"supplier_id"`
	ClientID    pgtype.UUID              `db:"client_id" json:"client_id"`
}

func (q *Queries) WmsInsertProduct(ctx context.Context, arg WmsInsertProductParams) (WmsProduct, error) {
	row := q.db.QueryRow(ctx, wmsInsertProduct,
		arg.Name,
		arg.Sku,
		arg.Barcode,
		arg.Description,
		arg.CostPrice,
		arg.Length,
		arg.Width,
		arg.Height,
		arg.Weight,
		arg.Status,
		arg.SupplierID,
		arg.ClientID,
	)
	var i WmsProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Barcode,
		&i.Description,
		&i.CostPrice,
		&i.Length,
		&i.Width,
		&i.Height,
		&i.Volume,
		&i.Weight,
		&i.Status,
		&i.SupplierID,
		&i.ClientID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const wmsPaginateProduct = `-- name: WmsPaginateProduct :many
select
  products.id, products.name, products.sku, products.barcode, products.description, products.cost_price, products.length, products.width, products.height, products.volume, products.weight, products.status, products.supplier_id, products.client_id, products.created_at, products.updated_at, products.inventory_batches, products.inventory_adjustments, products.reorder_points, products.inbound_shipment_items, products.stock_transfers, products.sales_order_items, products.outbound_shipment_items, products.return_items, products.inventory_stock, products.putaway_rules, products.bin_thresholds, products.task_items, products.package_items,
  supplier.id, supplier.name, supplier.contact_person, supplier.email, supplier.phone_number, supplier.created_at, supplier.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."products_view" as products
  left join "wms"."suppliers" as supplier on products.supplier_id = supplier.id
  left join "crm"."companies" as client on products.client_id = client.id
where (products.name ilike $1::text
  or products.sku ilike $1::text
  or products.barcode ilike $1::text
  or products.status::text ilike $1::text
  or supplier.name ilike $1::text
  or client.name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type WmsPaginateProductParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type WmsPaginateProductRow struct {
	WmsProductsView WmsProductsView `db:"wms_products_view" json:"wms_products_view"`
	WmsSupplier     WmsSupplier     `db:"wms_supplier" json:"wms_supplier"`
	CrmCompany      CrmCompany      `db:"crm_company" json:"crm_company"`
}

func (q *Queries) WmsPaginateProduct(ctx context.Context, arg WmsPaginateProductParams) ([]WmsPaginateProductRow, error) {
	rows, err := q.db.Query(ctx, wmsPaginateProduct, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsPaginateProductRow
	for rows.Next() {
		var i WmsPaginateProductRow
		if err := rows.Scan(
			&i.WmsProductsView.ID,
			&i.WmsProductsView.Name,
			&i.WmsProductsView.Sku,
			&i.WmsProductsView.Barcode,
			&i.WmsProductsView.Description,
			&i.WmsProductsView.CostPrice,
			&i.WmsProductsView.Length,
			&i.WmsProductsView.Width,
			&i.WmsProductsView.Height,
			&i.WmsProductsView.Volume,
			&i.WmsProductsView.Weight,
			&i.WmsProductsView.Status,
			&i.WmsProductsView.SupplierID,
			&i.WmsProductsView.ClientID,
			&i.WmsProductsView.CreatedAt,
			&i.WmsProductsView.UpdatedAt,
			&i.WmsProductsView.InventoryBatches,
			&i.WmsProductsView.InventoryAdjustments,
			&i.WmsProductsView.ReorderPoints,
			&i.WmsProductsView.InboundShipmentItems,
			&i.WmsProductsView.StockTransfers,
			&i.WmsProductsView.SalesOrderItems,
			&i.WmsProductsView.OutboundShipmentItems,
			&i.WmsProductsView.ReturnItems,
			&i.WmsProductsView.InventoryStock,
			&i.WmsProductsView.PutawayRules,
			&i.WmsProductsView.BinThresholds,
			&i.WmsProductsView.TaskItems,
			&i.WmsProductsView.PackageItems,
			&i.WmsSupplier.ID,
			&i.WmsSupplier.Name,
			&i.WmsSupplier.ContactPerson,
			&i.WmsSupplier.Email,
			&i.WmsSupplier.PhoneNumber,
			&i.WmsSupplier.CreatedAt,
			&i.WmsSupplier.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRangeProduct = `-- name: WmsRangeProduct :many
select
  products.id, products.name, products.sku, products.barcode, products.description, products.cost_price, products.length, products.width, products.height, products.volume, products.weight, products.status, products.supplier_id, products.client_id, products.created_at, products.updated_at, products.inventory_batches, products.inventory_adjustments, products.reorder_points, products.inbound_shipment_items, products.stock_transfers, products.sales_order_items, products.outbound_shipment_items, products.return_items, products.inventory_stock, products.putaway_rules, products.bin_thresholds, products.task_items, products.package_items,
  supplier.id, supplier.name, supplier.contact_person, supplier.email, supplier.phone_number, supplier.created_at, supplier.updated_at,
  client.id, client.name, client.street, client.city, client.state, client.postal_code, client.country, client.phone_number, client.industry, client.website, client.annual_revenue, client.owner_id, client.created_at, client.updated_at
from
  "wms"."products_view" as products
  left join "wms"."suppliers" as supplier on products.supplier_id = supplier.id
  left join "crm"."companies" as client on products.client_id = client.id
where
  products.created_at >= $1::date
  and products.created_at <= $2::date
  and (products.name ilike $3::text
    or products.sku ilike $3::text
    or products.barcode ilike $3::text
    or products.status::text ilike $3::text
    or supplier.name ilike $3::text
    or client.name ilike $3::text
    or $3::text is null)
`

type WmsRangeProductParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type WmsRangeProductRow struct {
	WmsProductsView WmsProductsView `db:"wms_products_view" json:"wms_products_view"`
	WmsSupplier     WmsSupplier     `db:"wms_supplier" json:"wms_supplier"`
	CrmCompany      CrmCompany      `db:"crm_company" json:"crm_company"`
}

func (q *Queries) WmsRangeProduct(ctx context.Context, arg WmsRangeProductParams) ([]WmsRangeProductRow, error) {
	rows, err := q.db.Query(ctx, wmsRangeProduct, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WmsRangeProductRow
	for rows.Next() {
		var i WmsRangeProductRow
		if err := rows.Scan(
			&i.WmsProductsView.ID,
			&i.WmsProductsView.Name,
			&i.WmsProductsView.Sku,
			&i.WmsProductsView.Barcode,
			&i.WmsProductsView.Description,
			&i.WmsProductsView.CostPrice,
			&i.WmsProductsView.Length,
			&i.WmsProductsView.Width,
			&i.WmsProductsView.Height,
			&i.WmsProductsView.Volume,
			&i.WmsProductsView.Weight,
			&i.WmsProductsView.Status,
			&i.WmsProductsView.SupplierID,
			&i.WmsProductsView.ClientID,
			&i.WmsProductsView.CreatedAt,
			&i.WmsProductsView.UpdatedAt,
			&i.WmsProductsView.InventoryBatches,
			&i.WmsProductsView.InventoryAdjustments,
			&i.WmsProductsView.ReorderPoints,
			&i.WmsProductsView.InboundShipmentItems,
			&i.WmsProductsView.StockTransfers,
			&i.WmsProductsView.SalesOrderItems,
			&i.WmsProductsView.OutboundShipmentItems,
			&i.WmsProductsView.ReturnItems,
			&i.WmsProductsView.InventoryStock,
			&i.WmsProductsView.PutawayRules,
			&i.WmsProductsView.BinThresholds,
			&i.WmsProductsView.TaskItems,
			&i.WmsProductsView.PackageItems,
			&i.WmsSupplier.ID,
			&i.WmsSupplier.Name,
			&i.WmsSupplier.ContactPerson,
			&i.WmsSupplier.Email,
			&i.WmsSupplier.PhoneNumber,
			&i.WmsSupplier.CreatedAt,
			&i.WmsSupplier.UpdatedAt,
			&i.CrmCompany.ID,
			&i.CrmCompany.Name,
			&i.CrmCompany.Street,
			&i.CrmCompany.City,
			&i.CrmCompany.State,
			&i.CrmCompany.PostalCode,
			&i.CrmCompany.Country,
			&i.CrmCompany.PhoneNumber,
			&i.CrmCompany.Industry,
			&i.CrmCompany.Website,
			&i.CrmCompany.AnnualRevenue,
			&i.CrmCompany.OwnerID,
			&i.CrmCompany.CreatedAt,
			&i.CrmCompany.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const wmsRemoveProduct = `-- name: WmsRemoveProduct :exec
delete from "wms"."products"
where id = $1::uuid
`

func (q *Queries) WmsRemoveProduct(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, wmsRemoveProduct, id)
	return err
}

const wmsUpdateProduct = `-- name: WmsUpdateProduct :one
update
  "wms"."products"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::varchar
  else
    name
  end,
  sku = case when $2 is not null then
    $2::varchar
  else
    sku
  end,
  barcode = case when $3 is not null then
    $3::varchar
  else
    barcode
  end,
  description = case when $4 is not null then
    $4::text
  else
    description
  end,
  cost_price = case when $5 is not null then
    $5::numeric
  else
    cost_price
  end,
  length = case when $6 is not null then
    $6::real
  else
    length
  end,
  width = case when $7 is not null then
    $7::real
  else
    width
  end,
  height = case when $8 is not null then
    $8::real
  else
    height
  end,
  weight = case when $9 is not null then
    $9::real
  else
    weight
  end,
  status = case when $10 is not null then
    $10::wms.product_status_enum
  else
    status
  end,
  supplier_id = case when $11 is not null then
    $11::uuid
  else
    supplier_id
  end,
  client_id = case when $12 is not null then
    $12::uuid
  else
    client_id
  end
where
  id = $13::uuid
returning
  id, name, sku, barcode, description, cost_price, length, width, height, volume, weight, status, supplier_id, client_id, created_at, updated_at
`

type WmsUpdateProductParams struct {
	Name        string                   `db:"name" json:"name"`
	Sku         string                   `db:"sku" json:"sku"`
	Barcode     pgtype.Text              `db:"barcode" json:"barcode"`
	Description pgtype.Text              `db:"description" json:"description"`
	CostPrice   pgtype.Numeric           `db:"cost_price" json:"cost_price"`
	Length      pgtype.Float4            `db:"length" json:"length"`
	Width       pgtype.Float4            `db:"width" json:"width"`
	Height      pgtype.Float4            `db:"height" json:"height"`
	Weight      pgtype.Float4            `db:"weight" json:"weight"`
	Status      NullWmsProductStatusEnum `db:"status" json:"status"`
	SupplierID  pgtype.UUID              `db:"supplier_id" json:"supplier_id"`
	ClientID    pgtype.UUID              `db:"client_id" json:"client_id"`
	ID          pgtype.UUID              `db:"id" json:"id"`
}

func (q *Queries) WmsUpdateProduct(ctx context.Context, arg WmsUpdateProductParams) (WmsProduct, error) {
	row := q.db.QueryRow(ctx, wmsUpdateProduct,
		arg.Name,
		arg.Sku,
		arg.Barcode,
		arg.Description,
		arg.CostPrice,
		arg.Length,
		arg.Width,
		arg.Height,
		arg.Weight,
		arg.Status,
		arg.SupplierID,
		arg.ClientID,
		arg.ID,
	)
	var i WmsProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Barcode,
		&i.Description,
		&i.CostPrice,
		&i.Length,
		&i.Width,
		&i.Height,
		&i.Volume,
		&i.Weight,
		&i.Status,
		&i.SupplierID,
		&i.ClientID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
