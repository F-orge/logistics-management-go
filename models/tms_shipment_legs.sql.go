// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_shipment_legs.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyShipmentLeg = `-- name: TmsAnyShipmentLeg :many
select
  shipment_legs.id, shipment_legs.shipment_id, shipment_legs.leg_sequence, shipment_legs.start_location, shipment_legs.end_location, shipment_legs.carrier_id, shipment_legs.internal_trip_id, shipment_legs.status, shipment_legs.created_at, shipment_legs.updated_at, shipment_legs.shipment_leg_events,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone,
  internal_trip.id, internal_trip.driver_id, internal_trip.vehicle_id, internal_trip.status, internal_trip.created_at, internal_trip.updated_at, internal_trip.end_location, internal_trip.end_time, internal_trip.start_location, internal_trip.start_time
from
  "tms"."shipment_legs_view" as shipment_legs
  left join "tms"."carriers" as carrier on shipment_legs.carrier_id = carrier.id
  left join "tms"."trips" as internal_trip on shipment_legs.internal_trip_id = internal_trip.id
where
  shipment_legs.id = any ($1::uuid[])
`

type TmsAnyShipmentLegRow struct {
	TmsShipmentLegsView TmsShipmentLegsView `db:"tms_shipment_legs_view" json:"tms_shipment_legs_view"`
	TmsCarrier          TmsCarrier          `db:"tms_carrier" json:"tms_carrier"`
	TmsTrip             TmsTrip             `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsAnyShipmentLeg(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyShipmentLegRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyShipmentLeg, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyShipmentLegRow
	for rows.Next() {
		var i TmsAnyShipmentLegRow
		if err := rows.Scan(
			&i.TmsShipmentLegsView.ID,
			&i.TmsShipmentLegsView.ShipmentID,
			&i.TmsShipmentLegsView.LegSequence,
			&i.TmsShipmentLegsView.StartLocation,
			&i.TmsShipmentLegsView.EndLocation,
			&i.TmsShipmentLegsView.CarrierID,
			&i.TmsShipmentLegsView.InternalTripID,
			&i.TmsShipmentLegsView.Status,
			&i.TmsShipmentLegsView.CreatedAt,
			&i.TmsShipmentLegsView.UpdatedAt,
			&i.TmsShipmentLegsView.ShipmentLegEvents,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindShipmentLeg = `-- name: TmsFindShipmentLeg :one
select
  shipment_legs.id, shipment_legs.shipment_id, shipment_legs.leg_sequence, shipment_legs.start_location, shipment_legs.end_location, shipment_legs.carrier_id, shipment_legs.internal_trip_id, shipment_legs.status, shipment_legs.created_at, shipment_legs.updated_at, shipment_legs.shipment_leg_events,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone,
  internal_trip.id, internal_trip.driver_id, internal_trip.vehicle_id, internal_trip.status, internal_trip.created_at, internal_trip.updated_at, internal_trip.end_location, internal_trip.end_time, internal_trip.start_location, internal_trip.start_time
from
  "tms"."shipment_legs_view" as shipment_legs
  left join "tms"."carriers" as carrier on shipment_legs.carrier_id = carrier.id
  left join "tms"."trips" as internal_trip on shipment_legs.internal_trip_id = internal_trip.id
where
  shipment_legs.id = $1::uuid
`

type TmsFindShipmentLegRow struct {
	TmsShipmentLegsView TmsShipmentLegsView `db:"tms_shipment_legs_view" json:"tms_shipment_legs_view"`
	TmsCarrier          TmsCarrier          `db:"tms_carrier" json:"tms_carrier"`
	TmsTrip             TmsTrip             `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsFindShipmentLeg(ctx context.Context, id pgtype.UUID) (TmsFindShipmentLegRow, error) {
	row := q.db.QueryRow(ctx, tmsFindShipmentLeg, id)
	var i TmsFindShipmentLegRow
	err := row.Scan(
		&i.TmsShipmentLegsView.ID,
		&i.TmsShipmentLegsView.ShipmentID,
		&i.TmsShipmentLegsView.LegSequence,
		&i.TmsShipmentLegsView.StartLocation,
		&i.TmsShipmentLegsView.EndLocation,
		&i.TmsShipmentLegsView.CarrierID,
		&i.TmsShipmentLegsView.InternalTripID,
		&i.TmsShipmentLegsView.Status,
		&i.TmsShipmentLegsView.CreatedAt,
		&i.TmsShipmentLegsView.UpdatedAt,
		&i.TmsShipmentLegsView.ShipmentLegEvents,
		&i.TmsCarrier.ID,
		&i.TmsCarrier.Name,
		&i.TmsCarrier.ContactDetails,
		&i.TmsCarrier.ServicesOffered,
		&i.TmsCarrier.CreatedAt,
		&i.TmsCarrier.UpdatedAt,
		&i.TmsCarrier.ContactPerson,
		&i.TmsCarrier.ContactEmail,
		&i.TmsCarrier.ContactPhone,
		&i.TmsTrip.ID,
		&i.TmsTrip.DriverID,
		&i.TmsTrip.VehicleID,
		&i.TmsTrip.Status,
		&i.TmsTrip.CreatedAt,
		&i.TmsTrip.UpdatedAt,
		&i.TmsTrip.EndLocation,
		&i.TmsTrip.EndTime,
		&i.TmsTrip.StartLocation,
		&i.TmsTrip.StartTime,
	)
	return i, err
}

const tmsInsertShipmentLeg = `-- name: TmsInsertShipmentLeg :one
insert into "tms"."shipment_legs"(shipment_id, leg_sequence, start_location, end_location, carrier_id, internal_trip_id, status)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, shipment_id, leg_sequence, start_location, end_location, carrier_id, internal_trip_id, status, created_at, updated_at
`

type TmsInsertShipmentLegParams struct {
	ShipmentID     pgtype.UUID                  `db:"shipment_id" json:"shipment_id"`
	LegSequence    int32                        `db:"leg_sequence" json:"leg_sequence"`
	StartLocation  pgtype.Text                  `db:"start_location" json:"start_location"`
	EndLocation    pgtype.Text                  `db:"end_location" json:"end_location"`
	CarrierID      pgtype.UUID                  `db:"carrier_id" json:"carrier_id"`
	InternalTripID pgtype.UUID                  `db:"internal_trip_id" json:"internal_trip_id"`
	Status         NullTmsShipmentLegStatusEnum `db:"status" json:"status"`
}

func (q *Queries) TmsInsertShipmentLeg(ctx context.Context, arg TmsInsertShipmentLegParams) (TmsShipmentLeg, error) {
	row := q.db.QueryRow(ctx, tmsInsertShipmentLeg,
		arg.ShipmentID,
		arg.LegSequence,
		arg.StartLocation,
		arg.EndLocation,
		arg.CarrierID,
		arg.InternalTripID,
		arg.Status,
	)
	var i TmsShipmentLeg
	err := row.Scan(
		&i.ID,
		&i.ShipmentID,
		&i.LegSequence,
		&i.StartLocation,
		&i.EndLocation,
		&i.CarrierID,
		&i.InternalTripID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateShipmentLeg = `-- name: TmsPaginateShipmentLeg :many
select
  shipment_legs.id, shipment_legs.shipment_id, shipment_legs.leg_sequence, shipment_legs.start_location, shipment_legs.end_location, shipment_legs.carrier_id, shipment_legs.internal_trip_id, shipment_legs.status, shipment_legs.created_at, shipment_legs.updated_at, shipment_legs.shipment_leg_events,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone,
  internal_trip.id, internal_trip.driver_id, internal_trip.vehicle_id, internal_trip.status, internal_trip.created_at, internal_trip.updated_at, internal_trip.end_location, internal_trip.end_time, internal_trip.start_location, internal_trip.start_time
from
  "tms"."shipment_legs_view" as shipment_legs
  left join "tms"."carriers" as carrier on shipment_legs.carrier_id = carrier.id
  left join "tms"."trips" as internal_trip on shipment_legs.internal_trip_id = internal_trip.id
where (carrier.name ilike $1::text
  or internal_trip.status::text ilike $1::text
  or shipment_legs.start_location ilike $1::text
  or shipment_legs.end_location ilike $1::text
  or shipment_legs.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateShipmentLegParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	Perpage int32       `db:"perpage" json:"perpage"`
}

type TmsPaginateShipmentLegRow struct {
	TmsShipmentLegsView TmsShipmentLegsView `db:"tms_shipment_legs_view" json:"tms_shipment_legs_view"`
	TmsCarrier          TmsCarrier          `db:"tms_carrier" json:"tms_carrier"`
	TmsTrip             TmsTrip             `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsPaginateShipmentLeg(ctx context.Context, arg TmsPaginateShipmentLegParams) ([]TmsPaginateShipmentLegRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateShipmentLeg, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateShipmentLegRow
	for rows.Next() {
		var i TmsPaginateShipmentLegRow
		if err := rows.Scan(
			&i.TmsShipmentLegsView.ID,
			&i.TmsShipmentLegsView.ShipmentID,
			&i.TmsShipmentLegsView.LegSequence,
			&i.TmsShipmentLegsView.StartLocation,
			&i.TmsShipmentLegsView.EndLocation,
			&i.TmsShipmentLegsView.CarrierID,
			&i.TmsShipmentLegsView.InternalTripID,
			&i.TmsShipmentLegsView.Status,
			&i.TmsShipmentLegsView.CreatedAt,
			&i.TmsShipmentLegsView.UpdatedAt,
			&i.TmsShipmentLegsView.ShipmentLegEvents,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeShipmentLeg = `-- name: TmsRangeShipmentLeg :many
select
  shipment_legs.id, shipment_legs.shipment_id, shipment_legs.leg_sequence, shipment_legs.start_location, shipment_legs.end_location, shipment_legs.carrier_id, shipment_legs.internal_trip_id, shipment_legs.status, shipment_legs.created_at, shipment_legs.updated_at, shipment_legs.shipment_leg_events,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone,
  internal_trip.id, internal_trip.driver_id, internal_trip.vehicle_id, internal_trip.status, internal_trip.created_at, internal_trip.updated_at, internal_trip.end_location, internal_trip.end_time, internal_trip.start_location, internal_trip.start_time
from
  "tms"."shipment_legs_view" as shipment_legs
  left join "tms"."carriers" as carrier on shipment_legs.carrier_id = carrier.id
  left join "tms"."trips" as internal_trip on shipment_legs.internal_trip_id = internal_trip.id
where
  shipment_legs.created_at >= $1::date
  and shipment_legs.created_at <= $2::date
  and (carrier.name ilike $3::text
    or internal_trip.status::text ilike $3::text
    or shipment_legs.start_location ilike $3::text
    or shipment_legs.end_location ilike $3::text
    or shipment_legs.status::text ilike $3::text
    or $3::text is null)
`

type TmsRangeShipmentLegParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeShipmentLegRow struct {
	TmsShipmentLegsView TmsShipmentLegsView `db:"tms_shipment_legs_view" json:"tms_shipment_legs_view"`
	TmsCarrier          TmsCarrier          `db:"tms_carrier" json:"tms_carrier"`
	TmsTrip             TmsTrip             `db:"tms_trip" json:"tms_trip"`
}

func (q *Queries) TmsRangeShipmentLeg(ctx context.Context, arg TmsRangeShipmentLegParams) ([]TmsRangeShipmentLegRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeShipmentLeg, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeShipmentLegRow
	for rows.Next() {
		var i TmsRangeShipmentLegRow
		if err := rows.Scan(
			&i.TmsShipmentLegsView.ID,
			&i.TmsShipmentLegsView.ShipmentID,
			&i.TmsShipmentLegsView.LegSequence,
			&i.TmsShipmentLegsView.StartLocation,
			&i.TmsShipmentLegsView.EndLocation,
			&i.TmsShipmentLegsView.CarrierID,
			&i.TmsShipmentLegsView.InternalTripID,
			&i.TmsShipmentLegsView.Status,
			&i.TmsShipmentLegsView.CreatedAt,
			&i.TmsShipmentLegsView.UpdatedAt,
			&i.TmsShipmentLegsView.ShipmentLegEvents,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveShipmentLeg = `-- name: TmsRemoveShipmentLeg :exec
delete from "tms"."shipment_legs"
where id = $1::uuid
`

func (q *Queries) TmsRemoveShipmentLeg(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveShipmentLeg, id)
	return err
}

const tmsUpdateShipmentLeg = `-- name: TmsUpdateShipmentLeg :one
update
  "tms"."shipment_legs"
set
  updated_at = now(),
  shipment_id = case when $1 is not null then
    $1::uuid
  else
    shipment_id
  end,
  leg_sequence = case when $2 is not null then
    $2::integer
  else
    leg_sequence
  end,
  start_location = case when $3 is not null then
    $3::varchar
  else
    start_location
  end,
  end_location = case when $4 is not null then
    $4::varchar
  else
    end_location
  end,
  carrier_id = case when $5 is not null then
    $5::uuid
  else
    carrier_id
  end,
  internal_trip_id = case when $6 is not null then
    $6::uuid
  else
    internal_trip_id
  end,
  status = case when $7 is not null then
    $7::tms.shipment_leg_status_enum
  else
    status
  end
where
  id = $8::uuid
returning
  id, shipment_id, leg_sequence, start_location, end_location, carrier_id, internal_trip_id, status, created_at, updated_at
`

type TmsUpdateShipmentLegParams struct {
	ShipmentID     pgtype.UUID                  `db:"shipment_id" json:"shipment_id"`
	LegSequence    int32                        `db:"leg_sequence" json:"leg_sequence"`
	StartLocation  pgtype.Text                  `db:"start_location" json:"start_location"`
	EndLocation    pgtype.Text                  `db:"end_location" json:"end_location"`
	CarrierID      pgtype.UUID                  `db:"carrier_id" json:"carrier_id"`
	InternalTripID pgtype.UUID                  `db:"internal_trip_id" json:"internal_trip_id"`
	Status         NullTmsShipmentLegStatusEnum `db:"status" json:"status"`
	ID             pgtype.UUID                  `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateShipmentLeg(ctx context.Context, arg TmsUpdateShipmentLegParams) (TmsShipmentLeg, error) {
	row := q.db.QueryRow(ctx, tmsUpdateShipmentLeg,
		arg.ShipmentID,
		arg.LegSequence,
		arg.StartLocation,
		arg.EndLocation,
		arg.CarrierID,
		arg.InternalTripID,
		arg.Status,
		arg.ID,
	)
	var i TmsShipmentLeg
	err := row.Scan(
		&i.ID,
		&i.ShipmentID,
		&i.LegSequence,
		&i.StartLocation,
		&i.EndLocation,
		&i.CarrierID,
		&i.InternalTripID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
