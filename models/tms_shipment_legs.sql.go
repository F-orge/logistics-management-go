// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_shipment_legs.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyShipmentLeg = `-- name: TmsAnyShipmentLeg :many
select
  shipment_legs.id, shipment_legs.shipment_id, shipment_legs.leg_sequence, shipment_legs.start_location, shipment_legs.end_location, shipment_legs.carrier_id, shipment_legs.internal_trip_id, shipment_legs.status, shipment_legs.created_at, shipment_legs.updated_at,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone,
  internal_trip.id, internal_trip.driver_id, internal_trip.vehicle_id, internal_trip.status, internal_trip.created_at, internal_trip.updated_at, internal_trip.end_location, internal_trip.end_time, internal_trip.start_location, internal_trip.start_time
from
  "tms"."shipment_legs" as shipment_legs
  left join "tms"."carriers" as carrier on shipment_legs.carrier_id = carrier.id
  left join "tms"."trips" as internal_trip on shipment_legs.internal_trip_id = internal_trip.id
where
  shipment_legs.id = any ($1::uuid[])
`

type TmsAnyShipmentLegRow struct {
	TmsShipmentLeg TmsShipmentLeg
	TmsCarrier     TmsCarrier
	TmsTrip        TmsTrip
}

func (q *Queries) TmsAnyShipmentLeg(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyShipmentLegRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyShipmentLeg, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyShipmentLegRow
	for rows.Next() {
		var i TmsAnyShipmentLegRow
		if err := rows.Scan(
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindShipmentLeg = `-- name: TmsFindShipmentLeg :one
select
  shipment_legs.id, shipment_legs.shipment_id, shipment_legs.leg_sequence, shipment_legs.start_location, shipment_legs.end_location, shipment_legs.carrier_id, shipment_legs.internal_trip_id, shipment_legs.status, shipment_legs.created_at, shipment_legs.updated_at,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone,
  internal_trip.id, internal_trip.driver_id, internal_trip.vehicle_id, internal_trip.status, internal_trip.created_at, internal_trip.updated_at, internal_trip.end_location, internal_trip.end_time, internal_trip.start_location, internal_trip.start_time
from
  "tms"."shipment_legs" as shipment_legs
  left join "tms"."carriers" as carrier on shipment_legs.carrier_id = carrier.id
  left join "tms"."trips" as internal_trip on shipment_legs.internal_trip_id = internal_trip.id
where
  shipment_legs.id = $1::uuid
`

type TmsFindShipmentLegRow struct {
	TmsShipmentLeg TmsShipmentLeg
	TmsCarrier     TmsCarrier
	TmsTrip        TmsTrip
}

func (q *Queries) TmsFindShipmentLeg(ctx context.Context, id pgtype.UUID) (TmsFindShipmentLegRow, error) {
	row := q.db.QueryRow(ctx, tmsFindShipmentLeg, id)
	var i TmsFindShipmentLegRow
	err := row.Scan(
		&i.TmsShipmentLeg.ID,
		&i.TmsShipmentLeg.ShipmentID,
		&i.TmsShipmentLeg.LegSequence,
		&i.TmsShipmentLeg.StartLocation,
		&i.TmsShipmentLeg.EndLocation,
		&i.TmsShipmentLeg.CarrierID,
		&i.TmsShipmentLeg.InternalTripID,
		&i.TmsShipmentLeg.Status,
		&i.TmsShipmentLeg.CreatedAt,
		&i.TmsShipmentLeg.UpdatedAt,
		&i.TmsCarrier.ID,
		&i.TmsCarrier.Name,
		&i.TmsCarrier.ContactDetails,
		&i.TmsCarrier.ServicesOffered,
		&i.TmsCarrier.CreatedAt,
		&i.TmsCarrier.UpdatedAt,
		&i.TmsCarrier.ContactPerson,
		&i.TmsCarrier.ContactEmail,
		&i.TmsCarrier.ContactPhone,
		&i.TmsTrip.ID,
		&i.TmsTrip.DriverID,
		&i.TmsTrip.VehicleID,
		&i.TmsTrip.Status,
		&i.TmsTrip.CreatedAt,
		&i.TmsTrip.UpdatedAt,
		&i.TmsTrip.EndLocation,
		&i.TmsTrip.EndTime,
		&i.TmsTrip.StartLocation,
		&i.TmsTrip.StartTime,
	)
	return i, err
}

const tmsInsertShipmentLeg = `-- name: TmsInsertShipmentLeg :one
insert into "tms"."shipment_legs"(shipment_id, leg_sequence, start_location, end_location, carrier_id, internal_trip_id, status)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, shipment_id, leg_sequence, start_location, end_location, carrier_id, internal_trip_id, status, created_at, updated_at
`

type TmsInsertShipmentLegParams struct {
	ShipmentID     pgtype.UUID
	LegSequence    int32
	StartLocation  pgtype.Text
	EndLocation    pgtype.Text
	CarrierID      pgtype.UUID
	InternalTripID pgtype.UUID
	Status         NullTmsShipmentLegStatusEnum
}

func (q *Queries) TmsInsertShipmentLeg(ctx context.Context, arg TmsInsertShipmentLegParams) (TmsShipmentLeg, error) {
	row := q.db.QueryRow(ctx, tmsInsertShipmentLeg,
		arg.ShipmentID,
		arg.LegSequence,
		arg.StartLocation,
		arg.EndLocation,
		arg.CarrierID,
		arg.InternalTripID,
		arg.Status,
	)
	var i TmsShipmentLeg
	err := row.Scan(
		&i.ID,
		&i.ShipmentID,
		&i.LegSequence,
		&i.StartLocation,
		&i.EndLocation,
		&i.CarrierID,
		&i.InternalTripID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateShipmentLeg = `-- name: TmsPaginateShipmentLeg :many
select
  shipment_legs.id, shipment_legs.shipment_id, shipment_legs.leg_sequence, shipment_legs.start_location, shipment_legs.end_location, shipment_legs.carrier_id, shipment_legs.internal_trip_id, shipment_legs.status, shipment_legs.created_at, shipment_legs.updated_at,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone,
  internal_trip.id, internal_trip.driver_id, internal_trip.vehicle_id, internal_trip.status, internal_trip.created_at, internal_trip.updated_at, internal_trip.end_location, internal_trip.end_time, internal_trip.start_location, internal_trip.start_time
from
  "tms"."shipment_legs" as shipment_legs
  left join "tms"."carriers" as carrier on shipment_legs.carrier_id = carrier.id
  left join "tms"."trips" as internal_trip on shipment_legs.internal_trip_id = internal_trip.id
where
  (carrier.name ilike $1::text
  or internal_trip.status::text ilike $1::text
  or shipment_legs.start_location ilike $1::text
  or shipment_legs.end_location ilike $1::text
  or shipment_legs.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateShipmentLegParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type TmsPaginateShipmentLegRow struct {
	TmsShipmentLeg TmsShipmentLeg
	TmsCarrier     TmsCarrier
	TmsTrip        TmsTrip
}

func (q *Queries) TmsPaginateShipmentLeg(ctx context.Context, arg TmsPaginateShipmentLegParams) ([]TmsPaginateShipmentLegRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateShipmentLeg, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateShipmentLegRow
	for rows.Next() {
		var i TmsPaginateShipmentLegRow
		if err := rows.Scan(
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeShipmentLeg = `-- name: TmsRangeShipmentLeg :many
select
  shipment_legs.id, shipment_legs.shipment_id, shipment_legs.leg_sequence, shipment_legs.start_location, shipment_legs.end_location, shipment_legs.carrier_id, shipment_legs.internal_trip_id, shipment_legs.status, shipment_legs.created_at, shipment_legs.updated_at,
  carrier.id, carrier.name, carrier.contact_details, carrier.services_offered, carrier.created_at, carrier.updated_at, carrier.contact_person, carrier.contact_email, carrier.contact_phone,
  internal_trip.id, internal_trip.driver_id, internal_trip.vehicle_id, internal_trip.status, internal_trip.created_at, internal_trip.updated_at, internal_trip.end_location, internal_trip.end_time, internal_trip.start_location, internal_trip.start_time
from
  "tms"."shipment_legs" as shipment_legs
  left join "tms"."carriers" as carrier on shipment_legs.carrier_id = carrier.id
  left join "tms"."trips" as internal_trip on shipment_legs.internal_trip_id = internal_trip.id
where
  shipment_legs.created_at >= $1::date
  and shipment_legs.created_at <= $2::date
  and (carrier.name ilike $3::text
  or internal_trip.status::text ilike $3::text
  or shipment_legs.start_location ilike $3::text
  or shipment_legs.end_location ilike $3::text
  or shipment_legs.status::text ilike $3::text
  or $3::text is null)
`

type TmsRangeShipmentLegParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type TmsRangeShipmentLegRow struct {
	TmsShipmentLeg TmsShipmentLeg
	TmsCarrier     TmsCarrier
	TmsTrip        TmsTrip
}

func (q *Queries) TmsRangeShipmentLeg(ctx context.Context, arg TmsRangeShipmentLegParams) ([]TmsRangeShipmentLegRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeShipmentLeg, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeShipmentLegRow
	for rows.Next() {
		var i TmsRangeShipmentLegRow
		if err := rows.Scan(
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
			&i.TmsCarrier.ID,
			&i.TmsCarrier.Name,
			&i.TmsCarrier.ContactDetails,
			&i.TmsCarrier.ServicesOffered,
			&i.TmsCarrier.CreatedAt,
			&i.TmsCarrier.UpdatedAt,
			&i.TmsCarrier.ContactPerson,
			&i.TmsCarrier.ContactEmail,
			&i.TmsCarrier.ContactPhone,
			&i.TmsTrip.ID,
			&i.TmsTrip.DriverID,
			&i.TmsTrip.VehicleID,
			&i.TmsTrip.Status,
			&i.TmsTrip.CreatedAt,
			&i.TmsTrip.UpdatedAt,
			&i.TmsTrip.EndLocation,
			&i.TmsTrip.EndTime,
			&i.TmsTrip.StartLocation,
			&i.TmsTrip.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveShipmentLeg = `-- name: TmsRemoveShipmentLeg :exec
delete from "tms"."shipment_legs"
where id = $1::uuid
`

func (q *Queries) TmsRemoveShipmentLeg(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveShipmentLeg, id)
	return err
}

const tmsUpdateShipmentLeg = `-- name: TmsUpdateShipmentLeg :one
update
  "tms"."shipment_legs"
set
  updated_at = now(),
  shipment_id = case when $1::boolean then
    $2::uuid
  else
    shipment_id
  end,
  leg_sequence = case when $3::boolean then
    $4::integer
  else
    leg_sequence
  end,
  start_location = case when $5::boolean then
    $6::varchar
  else
    start_location
  end,
  end_location = case when $7::boolean then
    $8::varchar
  else
    end_location
  end,
  carrier_id = case when $9::boolean then
    $10::uuid
  else
    carrier_id
  end,
  internal_trip_id = case when $11::boolean then
    $12::uuid
  else
    internal_trip_id
  end,
  status = case when $13::boolean then
    $14::tms.shipment_leg_status_enum
  else
    status
  end
where
  id = $15::uuid
returning
  id, shipment_id, leg_sequence, start_location, end_location, carrier_id, internal_trip_id, status, created_at, updated_at
`

type TmsUpdateShipmentLegParams struct {
	SetShipmentID     bool
	ShipmentID        pgtype.UUID
	SetLegSequence    bool
	LegSequence       int32
	SetStartLocation  bool
	StartLocation     string
	SetEndLocation    bool
	EndLocation       string
	SetCarrierID      bool
	CarrierID         pgtype.UUID
	SetInternalTripID bool
	InternalTripID    pgtype.UUID
	SetStatus         bool
	Status            TmsShipmentLegStatusEnum
	ID                pgtype.UUID
}

func (q *Queries) TmsUpdateShipmentLeg(ctx context.Context, arg TmsUpdateShipmentLegParams) (TmsShipmentLeg, error) {
	row := q.db.QueryRow(ctx, tmsUpdateShipmentLeg,
		arg.SetShipmentID,
		arg.ShipmentID,
		arg.SetLegSequence,
		arg.LegSequence,
		arg.SetStartLocation,
		arg.StartLocation,
		arg.SetEndLocation,
		arg.EndLocation,
		arg.SetCarrierID,
		arg.CarrierID,
		arg.SetInternalTripID,
		arg.InternalTripID,
		arg.SetStatus,
		arg.Status,
		arg.ID,
	)
	var i TmsShipmentLeg
	err := row.Scan(
		&i.ID,
		&i.ShipmentID,
		&i.LegSequence,
		&i.StartLocation,
		&i.EndLocation,
		&i.CarrierID,
		&i.InternalTripID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
