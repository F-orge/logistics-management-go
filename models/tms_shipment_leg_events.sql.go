// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_shipment_leg_events.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyShipmentLegEvent = `-- name: TmsAnyShipmentLegEvent :many
select
  shipment_leg_events.id, shipment_leg_events.shipment_leg_id, shipment_leg_events.status_message, shipment_leg_events.location, shipment_leg_events.event_timestamp,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."shipment_leg_events" as shipment_leg_events
  inner join "tms"."shipment_legs" as shipment_leg on shipment_leg_events.shipment_leg_id = shipment_leg.id
where
  shipment_leg_events.id = any ($1::uuid[])
`

type TmsAnyShipmentLegEventRow struct {
	TmsShipmentLegEvent TmsShipmentLegEvent
	TmsShipmentLeg      TmsShipmentLeg
}

func (q *Queries) TmsAnyShipmentLegEvent(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyShipmentLegEventRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyShipmentLegEvent, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyShipmentLegEventRow
	for rows.Next() {
		var i TmsAnyShipmentLegEventRow
		if err := rows.Scan(
			&i.TmsShipmentLegEvent.ID,
			&i.TmsShipmentLegEvent.ShipmentLegID,
			&i.TmsShipmentLegEvent.StatusMessage,
			&i.TmsShipmentLegEvent.Location,
			&i.TmsShipmentLegEvent.EventTimestamp,
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindShipmentLegEvent = `-- name: TmsFindShipmentLegEvent :one
select
  shipment_leg_events.id, shipment_leg_events.shipment_leg_id, shipment_leg_events.status_message, shipment_leg_events.location, shipment_leg_events.event_timestamp,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."shipment_leg_events" as shipment_leg_events
  inner join "tms"."shipment_legs" as shipment_leg on shipment_leg_events.shipment_leg_id = shipment_leg.id
where
  shipment_leg_events.id = $1::uuid
`

type TmsFindShipmentLegEventRow struct {
	TmsShipmentLegEvent TmsShipmentLegEvent
	TmsShipmentLeg      TmsShipmentLeg
}

func (q *Queries) TmsFindShipmentLegEvent(ctx context.Context, id pgtype.UUID) (TmsFindShipmentLegEventRow, error) {
	row := q.db.QueryRow(ctx, tmsFindShipmentLegEvent, id)
	var i TmsFindShipmentLegEventRow
	err := row.Scan(
		&i.TmsShipmentLegEvent.ID,
		&i.TmsShipmentLegEvent.ShipmentLegID,
		&i.TmsShipmentLegEvent.StatusMessage,
		&i.TmsShipmentLegEvent.Location,
		&i.TmsShipmentLegEvent.EventTimestamp,
		&i.TmsShipmentLeg.ID,
		&i.TmsShipmentLeg.ShipmentID,
		&i.TmsShipmentLeg.LegSequence,
		&i.TmsShipmentLeg.StartLocation,
		&i.TmsShipmentLeg.EndLocation,
		&i.TmsShipmentLeg.CarrierID,
		&i.TmsShipmentLeg.InternalTripID,
		&i.TmsShipmentLeg.Status,
		&i.TmsShipmentLeg.CreatedAt,
		&i.TmsShipmentLeg.UpdatedAt,
	)
	return i, err
}

const tmsInsertShipmentLegEvent = `-- name: TmsInsertShipmentLegEvent :one
insert into "tms"."shipment_leg_events"(shipment_leg_id, status_message, location, event_timestamp)
  values ($1, $2, $3, $4)
returning
  id, shipment_leg_id, status_message, location, event_timestamp
`

type TmsInsertShipmentLegEventParams struct {
	ShipmentLegID  pgtype.UUID
	StatusMessage  pgtype.Text
	Location       pgtype.Text
	EventTimestamp pgtype.Timestamp
}

func (q *Queries) TmsInsertShipmentLegEvent(ctx context.Context, arg TmsInsertShipmentLegEventParams) (TmsShipmentLegEvent, error) {
	row := q.db.QueryRow(ctx, tmsInsertShipmentLegEvent,
		arg.ShipmentLegID,
		arg.StatusMessage,
		arg.Location,
		arg.EventTimestamp,
	)
	var i TmsShipmentLegEvent
	err := row.Scan(
		&i.ID,
		&i.ShipmentLegID,
		&i.StatusMessage,
		&i.Location,
		&i.EventTimestamp,
	)
	return i, err
}

const tmsPaginateShipmentLegEvent = `-- name: TmsPaginateShipmentLegEvent :many
select
  shipment_leg_events.id, shipment_leg_events.shipment_leg_id, shipment_leg_events.status_message, shipment_leg_events.location, shipment_leg_events.event_timestamp,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."shipment_leg_events" as shipment_leg_events
  inner join "tms"."shipment_legs" as shipment_leg on shipment_leg_events.shipment_leg_id = shipment_leg.id
limit $2::int offset ($1::int - 1) * $2::int
`

type TmsPaginateShipmentLegEventParams struct {
	Page    int32
	Perpage int32
}

type TmsPaginateShipmentLegEventRow struct {
	TmsShipmentLegEvent TmsShipmentLegEvent
	TmsShipmentLeg      TmsShipmentLeg
}

func (q *Queries) TmsPaginateShipmentLegEvent(ctx context.Context, arg TmsPaginateShipmentLegEventParams) ([]TmsPaginateShipmentLegEventRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateShipmentLegEvent, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateShipmentLegEventRow
	for rows.Next() {
		var i TmsPaginateShipmentLegEventRow
		if err := rows.Scan(
			&i.TmsShipmentLegEvent.ID,
			&i.TmsShipmentLegEvent.ShipmentLegID,
			&i.TmsShipmentLegEvent.StatusMessage,
			&i.TmsShipmentLegEvent.Location,
			&i.TmsShipmentLegEvent.EventTimestamp,
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeShipmentLegEvent = `-- name: TmsRangeShipmentLegEvent :many
select
  shipment_leg_events.id, shipment_leg_events.shipment_leg_id, shipment_leg_events.status_message, shipment_leg_events.location, shipment_leg_events.event_timestamp,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."shipment_leg_events" as shipment_leg_events
  inner join "tms"."shipment_legs" as shipment_leg on shipment_leg_events.shipment_leg_id = shipment_leg.id
where
  shipment_leg_events.event_timestamp >= $1::date
  and shipment_leg_events.event_timestamp <= $2::date
`

type TmsRangeShipmentLegEventParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type TmsRangeShipmentLegEventRow struct {
	TmsShipmentLegEvent TmsShipmentLegEvent
	TmsShipmentLeg      TmsShipmentLeg
}

func (q *Queries) TmsRangeShipmentLegEvent(ctx context.Context, arg TmsRangeShipmentLegEventParams) ([]TmsRangeShipmentLegEventRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeShipmentLegEvent, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeShipmentLegEventRow
	for rows.Next() {
		var i TmsRangeShipmentLegEventRow
		if err := rows.Scan(
			&i.TmsShipmentLegEvent.ID,
			&i.TmsShipmentLegEvent.ShipmentLegID,
			&i.TmsShipmentLegEvent.StatusMessage,
			&i.TmsShipmentLegEvent.Location,
			&i.TmsShipmentLegEvent.EventTimestamp,
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveShipmentLegEvent = `-- name: TmsRemoveShipmentLegEvent :exec
delete from "tms"."shipment_leg_events"
where id = $1::uuid
`

func (q *Queries) TmsRemoveShipmentLegEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveShipmentLegEvent, id)
	return err
}

const tmsUpdateShipmentLegEvent = `-- name: TmsUpdateShipmentLegEvent :one
update
  "tms"."shipment_leg_events"
set
  shipment_leg_id = case when $1::boolean then
    $2::uuid
  else
    shipment_leg_id
  end,
  status_message = case when $3::boolean then
    $4::varchar
  else
    status_message
  end,
  location = case when $5::boolean then
    $6::varchar
  else
    location
  end,
  event_timestamp = case when $7::boolean then
    $8::timestamp
  else
    event_timestamp
  end
where
  id = $9::uuid
returning
  id, shipment_leg_id, status_message, location, event_timestamp
`

type TmsUpdateShipmentLegEventParams struct {
	SetShipmentLegID  bool
	ShipmentLegID     pgtype.UUID
	SetStatusMessage  bool
	StatusMessage     string
	SetLocation       bool
	Location          string
	SetEventTimestamp bool
	EventTimestamp    pgtype.Timestamp
	ID                pgtype.UUID
}

func (q *Queries) TmsUpdateShipmentLegEvent(ctx context.Context, arg TmsUpdateShipmentLegEventParams) (TmsShipmentLegEvent, error) {
	row := q.db.QueryRow(ctx, tmsUpdateShipmentLegEvent,
		arg.SetShipmentLegID,
		arg.ShipmentLegID,
		arg.SetStatusMessage,
		arg.StatusMessage,
		arg.SetLocation,
		arg.Location,
		arg.SetEventTimestamp,
		arg.EventTimestamp,
		arg.ID,
	)
	var i TmsShipmentLegEvent
	err := row.Scan(
		&i.ID,
		&i.ShipmentLegID,
		&i.StatusMessage,
		&i.Location,
		&i.EventTimestamp,
	)
	return i, err
}
