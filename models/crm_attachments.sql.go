// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_attachments.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyAttachment = `-- name: CrmAnyAttachment :many
select
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
from
  "crm"."attachments"
where
  id = any ($1::uuid[])
`

func (q *Queries) CrmAnyAttachment(ctx context.Context, ids []pgtype.UUID) ([]CrmAttachment, error) {
	rows, err := q.db.Query(ctx, crmAnyAttachment, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAttachment
	for rows.Next() {
		var i CrmAttachment
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FilePath,
			&i.MimeType,
			&i.RecordID,
			&i.RecordType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindAttachment = `-- name: CrmFindAttachment :one
select
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
from
  "crm"."attachments"
where
  id = $1::uuid
`

func (q *Queries) CrmFindAttachment(ctx context.Context, id pgtype.UUID) (CrmAttachment, error) {
	row := q.db.QueryRow(ctx, crmFindAttachment, id)
	var i CrmAttachment
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.FilePath,
		&i.MimeType,
		&i.RecordID,
		&i.RecordType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmInsertAttachment = `-- name: CrmInsertAttachment :one
insert into "crm"."attachments"(file_name, file_path, mime_type, record_id, record_type)
  values ($1, $2, $3, $4, $5)
returning
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
`

type CrmInsertAttachmentParams struct {
	FileName   string
	FilePath   string
	MimeType   pgtype.Text
	RecordID   pgtype.UUID
	RecordType NullCrmRecordType
}

func (q *Queries) CrmInsertAttachment(ctx context.Context, arg CrmInsertAttachmentParams) (CrmAttachment, error) {
	row := q.db.QueryRow(ctx, crmInsertAttachment,
		arg.FileName,
		arg.FilePath,
		arg.MimeType,
		arg.RecordID,
		arg.RecordType,
	)
	var i CrmAttachment
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.FilePath,
		&i.MimeType,
		&i.RecordID,
		&i.RecordType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateAttachment = `-- name: CrmPaginateAttachment :many
select
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
from
  "crm"."attachments"
where
  (record_type::text ilike $1::text
  or mime_type ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateAttachmentParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

func (q *Queries) CrmPaginateAttachment(ctx context.Context, arg CrmPaginateAttachmentParams) ([]CrmAttachment, error) {
	rows, err := q.db.Query(ctx, crmPaginateAttachment, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAttachment
	for rows.Next() {
		var i CrmAttachment
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FilePath,
			&i.MimeType,
			&i.RecordID,
			&i.RecordType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeAttachment = `-- name: CrmRangeAttachment :many
select
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
from
  "crm"."attachments"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (record_type::text ilike $3::text
  or mime_type ilike $3::text
  or $3::text is null)
`

type CrmRangeAttachmentParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

func (q *Queries) CrmRangeAttachment(ctx context.Context, arg CrmRangeAttachmentParams) ([]CrmAttachment, error) {
	rows, err := q.db.Query(ctx, crmRangeAttachment, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAttachment
	for rows.Next() {
		var i CrmAttachment
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FilePath,
			&i.MimeType,
			&i.RecordID,
			&i.RecordType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveAttachment = `-- name: CrmRemoveAttachment :exec
delete from "crm"."attachments"
where id = $1::uuid
`

func (q *Queries) CrmRemoveAttachment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveAttachment, id)
	return err
}

const crmUpdateAttachment = `-- name: CrmUpdateAttachment :one
update
  "crm"."attachments"
set
  file_name = case when $1::boolean then
    $2::varchar
  else
    file_name
  end,
  file_path = case when $3::boolean then
    $4::varchar
  else
    file_path
  end,
  mime_type = case when $5::boolean then
    $6::varchar
  else
    mime_type
  end,
  record_id = case when $7::boolean then
    $8::uuid
  else
    record_id
  end,
  record_type = case when $9::boolean then
    $10::crm.record_type
  else
    record_type
  end
where
  id = $11::uuid
returning
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
`

type CrmUpdateAttachmentParams struct {
	SetFileName   bool
	FileName      string
	SetFilePath   bool
	FilePath      string
	SetMimeType   bool
	MimeType      string
	SetRecordID   bool
	RecordID      pgtype.UUID
	SetRecordType bool
	RecordType    CrmRecordType
	ID            pgtype.UUID
}

func (q *Queries) CrmUpdateAttachment(ctx context.Context, arg CrmUpdateAttachmentParams) (CrmAttachment, error) {
	row := q.db.QueryRow(ctx, crmUpdateAttachment,
		arg.SetFileName,
		arg.FileName,
		arg.SetFilePath,
		arg.FilePath,
		arg.SetMimeType,
		arg.MimeType,
		arg.SetRecordID,
		arg.RecordID,
		arg.SetRecordType,
		arg.RecordType,
		arg.ID,
	)
	var i CrmAttachment
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.FilePath,
		&i.MimeType,
		&i.RecordID,
		&i.RecordType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
