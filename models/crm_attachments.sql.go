// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_attachments.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyAttachment = `-- name: CrmAnyAttachment :many
select
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
from
  "crm"."attachments"
where
  id = any ($1::uuid[])
`

func (q *Queries) CrmAnyAttachment(ctx context.Context, ids []pgtype.UUID) ([]CrmAttachment, error) {
	rows, err := q.db.Query(ctx, crmAnyAttachment, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAttachment
	for rows.Next() {
		var i CrmAttachment
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FilePath,
			&i.MimeType,
			&i.RecordID,
			&i.RecordType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindAttachment = `-- name: CrmFindAttachment :one
select
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
from
  "crm"."attachments"
where
  id = $1::uuid
`

func (q *Queries) CrmFindAttachment(ctx context.Context, id pgtype.UUID) (CrmAttachment, error) {
	row := q.db.QueryRow(ctx, crmFindAttachment, id)
	var i CrmAttachment
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.FilePath,
		&i.MimeType,
		&i.RecordID,
		&i.RecordType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmInsertAttachment = `-- name: CrmInsertAttachment :one
insert into "crm"."attachments"(file_name, file_path, mime_type, record_id, record_type)
  values ($1, $2, $3, $4, $5)
returning
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
`

type CrmInsertAttachmentParams struct {
	FileName   string            `db:"file_name" json:"file_name"`
	FilePath   string            `db:"file_path" json:"file_path"`
	MimeType   pgtype.Text       `db:"mime_type" json:"mime_type"`
	RecordID   pgtype.UUID       `db:"record_id" json:"record_id"`
	RecordType NullCrmRecordType `db:"record_type" json:"record_type"`
}

func (q *Queries) CrmInsertAttachment(ctx context.Context, arg CrmInsertAttachmentParams) (CrmAttachment, error) {
	row := q.db.QueryRow(ctx, crmInsertAttachment,
		arg.FileName,
		arg.FilePath,
		arg.MimeType,
		arg.RecordID,
		arg.RecordType,
	)
	var i CrmAttachment
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.FilePath,
		&i.MimeType,
		&i.RecordID,
		&i.RecordType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateAttachment = `-- name: CrmPaginateAttachment :many
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page,
  attachments.id, attachments.file_name, attachments.file_path, attachments.mime_type, attachments.record_id, attachments.record_type, attachments.created_at, attachments.updated_at
from
  "crm"."attachments" as attachments
where (record_type::text ilike $3::text
  or mime_type ilike $3::text
  or $3::text is null)
limit $1::int offset ($2::int - 1) * $1::int
`

type CrmPaginateAttachmentParams struct {
	PerPage int32       `db:"per_page" json:"per_page"`
	Page    int32       `db:"page" json:"page"`
	Search  pgtype.Text `db:"search" json:"search"`
}

type CrmPaginateAttachmentRow struct {
	TotalItems    int64         `db:"total_items" json:"total_items"`
	TotalPages    float64       `db:"total_pages" json:"total_pages"`
	Page          int32         `db:"page" json:"page"`
	PerPage       int32         `db:"per_page" json:"per_page"`
	CrmAttachment CrmAttachment `db:"crm_attachment" json:"crm_attachment"`
}

func (q *Queries) CrmPaginateAttachment(ctx context.Context, arg CrmPaginateAttachmentParams) ([]CrmPaginateAttachmentRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateAttachment, arg.PerPage, arg.Page, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateAttachmentRow
	for rows.Next() {
		var i CrmPaginateAttachmentRow
		if err := rows.Scan(
			&i.TotalItems,
			&i.TotalPages,
			&i.Page,
			&i.PerPage,
			&i.CrmAttachment.ID,
			&i.CrmAttachment.FileName,
			&i.CrmAttachment.FilePath,
			&i.CrmAttachment.MimeType,
			&i.CrmAttachment.RecordID,
			&i.CrmAttachment.RecordType,
			&i.CrmAttachment.CreatedAt,
			&i.CrmAttachment.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeAttachment = `-- name: CrmRangeAttachment :many
select
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
from
  "crm"."attachments"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (record_type::text ilike $3::text
    or mime_type ilike $3::text
    or $3::text is null)
`

type CrmRangeAttachmentParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) CrmRangeAttachment(ctx context.Context, arg CrmRangeAttachmentParams) ([]CrmAttachment, error) {
	rows, err := q.db.Query(ctx, crmRangeAttachment, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAttachment
	for rows.Next() {
		var i CrmAttachment
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FilePath,
			&i.MimeType,
			&i.RecordID,
			&i.RecordType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveAttachment = `-- name: CrmRemoveAttachment :exec
delete from "crm"."attachments"
where id = $1::uuid
`

func (q *Queries) CrmRemoveAttachment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveAttachment, id)
	return err
}

const crmUpdateAttachment = `-- name: CrmUpdateAttachment :one
update
  "crm"."attachments"
set
  updated_at = now(),
  file_name = case when $1 is not null then
    $1::varchar
  else
    file_name
  end,
  file_path = case when $2 is not null then
    $2::varchar
  else
    file_path
  end,
  mime_type = case when $3 is not null then
    $3::varchar
  else
    mime_type
  end,
  record_id = case when $4 is not null then
    $4::uuid
  else
    record_id
  end,
  record_type = case when $5 is not null then
    $5::crm.record_type
  else
    record_type
  end
where
  id = $6::uuid
returning
  id, file_name, file_path, mime_type, record_id, record_type, created_at, updated_at
`

type CrmUpdateAttachmentParams struct {
	FileName   string            `db:"file_name" json:"file_name"`
	FilePath   string            `db:"file_path" json:"file_path"`
	MimeType   pgtype.Text       `db:"mime_type" json:"mime_type"`
	RecordID   pgtype.UUID       `db:"record_id" json:"record_id"`
	RecordType NullCrmRecordType `db:"record_type" json:"record_type"`
	ID         pgtype.UUID       `db:"id" json:"id"`
}

func (q *Queries) CrmUpdateAttachment(ctx context.Context, arg CrmUpdateAttachmentParams) (CrmAttachment, error) {
	row := q.db.QueryRow(ctx, crmUpdateAttachment,
		arg.FileName,
		arg.FilePath,
		arg.MimeType,
		arg.RecordID,
		arg.RecordType,
		arg.ID,
	)
	var i CrmAttachment
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.FilePath,
		&i.MimeType,
		&i.RecordID,
		&i.RecordType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
