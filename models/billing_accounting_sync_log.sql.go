// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_accounting_sync_log.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyAccountingSyncLog = `-- name: BillingAnyAccountingSyncLog :many
select
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
from
  "billing"."accounting_sync_log"
where
  id = any ($1::uuid[])
`

func (q *Queries) BillingAnyAccountingSyncLog(ctx context.Context, ids []pgtype.UUID) ([]BillingAccountingSyncLog, error) {
	rows, err := q.db.Query(ctx, billingAnyAccountingSyncLog, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAccountingSyncLog
	for rows.Next() {
		var i BillingAccountingSyncLog
		if err := rows.Scan(
			&i.ID,
			&i.RecordID,
			&i.RecordType,
			&i.ExternalSystem,
			&i.ExternalID,
			&i.Status,
			&i.ErrorMessage,
			&i.RequestPayload,
			&i.ResponsePayload,
			&i.LastSyncAt,
			&i.RetryCount,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindAccountingSyncLog = `-- name: BillingFindAccountingSyncLog :one
select
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
from
  "billing"."accounting_sync_log"
where
  id = $1::uuid
`

func (q *Queries) BillingFindAccountingSyncLog(ctx context.Context, id pgtype.UUID) (BillingAccountingSyncLog, error) {
	row := q.db.QueryRow(ctx, billingFindAccountingSyncLog, id)
	var i BillingAccountingSyncLog
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.ExternalSystem,
		&i.ExternalID,
		&i.Status,
		&i.ErrorMessage,
		&i.RequestPayload,
		&i.ResponsePayload,
		&i.LastSyncAt,
		&i.RetryCount,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingInsertAccountingSyncLog = `-- name: BillingInsertAccountingSyncLog :one
insert into "billing"."accounting_sync_log"(record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
`

type BillingInsertAccountingSyncLogParams struct {
	RecordID        pgtype.UUID
	RecordType      string
	ExternalSystem  string
	ExternalID      pgtype.Text
	Status          NullBillingSyncStatusEnum
	ErrorMessage    pgtype.Text
	RequestPayload  pgtype.Text
	ResponsePayload pgtype.Text
	LastSyncAt      pgtype.Timestamp
	RetryCount      pgtype.Int4
	NextRetryAt     pgtype.Timestamp
}

func (q *Queries) BillingInsertAccountingSyncLog(ctx context.Context, arg BillingInsertAccountingSyncLogParams) (BillingAccountingSyncLog, error) {
	row := q.db.QueryRow(ctx, billingInsertAccountingSyncLog,
		arg.RecordID,
		arg.RecordType,
		arg.ExternalSystem,
		arg.ExternalID,
		arg.Status,
		arg.ErrorMessage,
		arg.RequestPayload,
		arg.ResponsePayload,
		arg.LastSyncAt,
		arg.RetryCount,
		arg.NextRetryAt,
	)
	var i BillingAccountingSyncLog
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.ExternalSystem,
		&i.ExternalID,
		&i.Status,
		&i.ErrorMessage,
		&i.RequestPayload,
		&i.ResponsePayload,
		&i.LastSyncAt,
		&i.RetryCount,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateAccountingSyncLog = `-- name: BillingPaginateAccountingSyncLog :many
select
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
from
  "billing"."accounting_sync_log"
where
  (record_type ilike $1::text
  or external_system ilike $1::text
  or status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateAccountingSyncLogParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

func (q *Queries) BillingPaginateAccountingSyncLog(ctx context.Context, arg BillingPaginateAccountingSyncLogParams) ([]BillingAccountingSyncLog, error) {
	rows, err := q.db.Query(ctx, billingPaginateAccountingSyncLog, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAccountingSyncLog
	for rows.Next() {
		var i BillingAccountingSyncLog
		if err := rows.Scan(
			&i.ID,
			&i.RecordID,
			&i.RecordType,
			&i.ExternalSystem,
			&i.ExternalID,
			&i.Status,
			&i.ErrorMessage,
			&i.RequestPayload,
			&i.ResponsePayload,
			&i.LastSyncAt,
			&i.RetryCount,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeAccountingSyncLog = `-- name: BillingRangeAccountingSyncLog :many
select
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
from
  "billing"."accounting_sync_log"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (record_type ilike $3::text
  or external_system ilike $3::text
  or status::text ilike $3::text
  or $3::text is null)
`

type BillingRangeAccountingSyncLogParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

func (q *Queries) BillingRangeAccountingSyncLog(ctx context.Context, arg BillingRangeAccountingSyncLogParams) ([]BillingAccountingSyncLog, error) {
	rows, err := q.db.Query(ctx, billingRangeAccountingSyncLog, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAccountingSyncLog
	for rows.Next() {
		var i BillingAccountingSyncLog
		if err := rows.Scan(
			&i.ID,
			&i.RecordID,
			&i.RecordType,
			&i.ExternalSystem,
			&i.ExternalID,
			&i.Status,
			&i.ErrorMessage,
			&i.RequestPayload,
			&i.ResponsePayload,
			&i.LastSyncAt,
			&i.RetryCount,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveAccountingSyncLog = `-- name: BillingRemoveAccountingSyncLog :exec
delete from "billing"."accounting_sync_log"
where id = $1::uuid
`

func (q *Queries) BillingRemoveAccountingSyncLog(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveAccountingSyncLog, id)
	return err
}

const billingUpdateAccountingSyncLog = `-- name: BillingUpdateAccountingSyncLog :one
update
  "billing"."accounting_sync_log"
set
  updated_at = now(),
  record_id = case when $1::boolean then
    $2::uuid
  else
    record_id
  end,
  record_type = case when $3::boolean then
    $4::varchar
  else
    record_type
  end,
  external_system = case when $5::boolean then
    $6::varchar
  else
    external_system
  end,
  external_id = case when $7::boolean then
    $8::varchar
  else
    external_id
  end,
  status = case when $9::boolean then
    $10::billing.sync_status_enum
  else
    status
  end,
  error_message = case when $11::boolean then
    $12::text
  else
    error_message
  end,
  request_payload = case when $13::boolean then
    $14::text
  else
    request_payload
  end,
  response_payload = case when $15::boolean then
    $16::text
  else
    response_payload
  end,
  last_sync_at = case when $17::boolean then
    $18::timestamp
  else
    last_sync_at
  end,
  retry_count = case when $19::boolean then
    $20::integer
  else
    retry_count
  end,
  next_retry_at = case when $21::boolean then
    $22::timestamp
  else
    next_retry_at
  end
where
  id = $23::uuid
returning
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
`

type BillingUpdateAccountingSyncLogParams struct {
	SetRecordID        bool
	RecordID           pgtype.UUID
	SetRecordType      bool
	RecordType         string
	SetExternalSystem  bool
	ExternalSystem     string
	SetExternalID      bool
	ExternalID         string
	SetStatus          bool
	Status             BillingSyncStatusEnum
	SetErrorMessage    bool
	ErrorMessage       string
	SetRequestPayload  bool
	RequestPayload     string
	SetResponsePayload bool
	ResponsePayload    string
	SetLastSyncAt      bool
	LastSyncAt         pgtype.Timestamp
	SetRetryCount      bool
	RetryCount         int32
	SetNextRetryAt     bool
	NextRetryAt        pgtype.Timestamp
	ID                 pgtype.UUID
}

func (q *Queries) BillingUpdateAccountingSyncLog(ctx context.Context, arg BillingUpdateAccountingSyncLogParams) (BillingAccountingSyncLog, error) {
	row := q.db.QueryRow(ctx, billingUpdateAccountingSyncLog,
		arg.SetRecordID,
		arg.RecordID,
		arg.SetRecordType,
		arg.RecordType,
		arg.SetExternalSystem,
		arg.ExternalSystem,
		arg.SetExternalID,
		arg.ExternalID,
		arg.SetStatus,
		arg.Status,
		arg.SetErrorMessage,
		arg.ErrorMessage,
		arg.SetRequestPayload,
		arg.RequestPayload,
		arg.SetResponsePayload,
		arg.ResponsePayload,
		arg.SetLastSyncAt,
		arg.LastSyncAt,
		arg.SetRetryCount,
		arg.RetryCount,
		arg.SetNextRetryAt,
		arg.NextRetryAt,
		arg.ID,
	)
	var i BillingAccountingSyncLog
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.ExternalSystem,
		&i.ExternalID,
		&i.Status,
		&i.ErrorMessage,
		&i.RequestPayload,
		&i.ResponsePayload,
		&i.LastSyncAt,
		&i.RetryCount,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
