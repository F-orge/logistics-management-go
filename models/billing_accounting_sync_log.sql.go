// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_accounting_sync_log.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyAccountingSyncLog = `-- name: BillingAnyAccountingSyncLog :many
select
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
from
  "billing"."accounting_sync_log"
where
  id = any ($1::uuid[])
`

func (q *Queries) BillingAnyAccountingSyncLog(ctx context.Context, ids []pgtype.UUID) ([]BillingAccountingSyncLog, error) {
	rows, err := q.db.Query(ctx, billingAnyAccountingSyncLog, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAccountingSyncLog
	for rows.Next() {
		var i BillingAccountingSyncLog
		if err := rows.Scan(
			&i.ID,
			&i.RecordID,
			&i.RecordType,
			&i.ExternalSystem,
			&i.ExternalID,
			&i.Status,
			&i.ErrorMessage,
			&i.RequestPayload,
			&i.ResponsePayload,
			&i.LastSyncAt,
			&i.RetryCount,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindAccountingSyncLog = `-- name: BillingFindAccountingSyncLog :one
select
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
from
  "billing"."accounting_sync_log"
where
  id = $1::uuid
`

func (q *Queries) BillingFindAccountingSyncLog(ctx context.Context, id pgtype.UUID) (BillingAccountingSyncLog, error) {
	row := q.db.QueryRow(ctx, billingFindAccountingSyncLog, id)
	var i BillingAccountingSyncLog
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.ExternalSystem,
		&i.ExternalID,
		&i.Status,
		&i.ErrorMessage,
		&i.RequestPayload,
		&i.ResponsePayload,
		&i.LastSyncAt,
		&i.RetryCount,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingInsertAccountingSyncLog = `-- name: BillingInsertAccountingSyncLog :one
insert into "billing"."accounting_sync_log"(record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
`

type BillingInsertAccountingSyncLogParams struct {
	RecordID        pgtype.UUID               `db:"record_id" json:"record_id"`
	RecordType      string                    `db:"record_type" json:"record_type"`
	ExternalSystem  string                    `db:"external_system" json:"external_system"`
	ExternalID      pgtype.Text               `db:"external_id" json:"external_id"`
	Status          NullBillingSyncStatusEnum `db:"status" json:"status"`
	ErrorMessage    pgtype.Text               `db:"error_message" json:"error_message"`
	RequestPayload  pgtype.Text               `db:"request_payload" json:"request_payload"`
	ResponsePayload pgtype.Text               `db:"response_payload" json:"response_payload"`
	LastSyncAt      pgtype.Timestamp          `db:"last_sync_at" json:"last_sync_at"`
	RetryCount      pgtype.Int4               `db:"retry_count" json:"retry_count"`
	NextRetryAt     pgtype.Timestamp          `db:"next_retry_at" json:"next_retry_at"`
}

func (q *Queries) BillingInsertAccountingSyncLog(ctx context.Context, arg BillingInsertAccountingSyncLogParams) (BillingAccountingSyncLog, error) {
	row := q.db.QueryRow(ctx, billingInsertAccountingSyncLog,
		arg.RecordID,
		arg.RecordType,
		arg.ExternalSystem,
		arg.ExternalID,
		arg.Status,
		arg.ErrorMessage,
		arg.RequestPayload,
		arg.ResponsePayload,
		arg.LastSyncAt,
		arg.RetryCount,
		arg.NextRetryAt,
	)
	var i BillingAccountingSyncLog
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.ExternalSystem,
		&i.ExternalID,
		&i.Status,
		&i.ErrorMessage,
		&i.RequestPayload,
		&i.ResponsePayload,
		&i.LastSyncAt,
		&i.RetryCount,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateAccountingSyncLog = `-- name: BillingPaginateAccountingSyncLog :many
select
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
from
  "billing"."accounting_sync_log"
where (record_type ilike $1::text
  or external_system ilike $1::text
  or status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateAccountingSyncLogParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

func (q *Queries) BillingPaginateAccountingSyncLog(ctx context.Context, arg BillingPaginateAccountingSyncLogParams) ([]BillingAccountingSyncLog, error) {
	rows, err := q.db.Query(ctx, billingPaginateAccountingSyncLog, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAccountingSyncLog
	for rows.Next() {
		var i BillingAccountingSyncLog
		if err := rows.Scan(
			&i.ID,
			&i.RecordID,
			&i.RecordType,
			&i.ExternalSystem,
			&i.ExternalID,
			&i.Status,
			&i.ErrorMessage,
			&i.RequestPayload,
			&i.ResponsePayload,
			&i.LastSyncAt,
			&i.RetryCount,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeAccountingSyncLog = `-- name: BillingRangeAccountingSyncLog :many
select
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
from
  "billing"."accounting_sync_log"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (record_type ilike $3::text
    or external_system ilike $3::text
    or status::text ilike $3::text
    or $3::text is null)
`

type BillingRangeAccountingSyncLogParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) BillingRangeAccountingSyncLog(ctx context.Context, arg BillingRangeAccountingSyncLogParams) ([]BillingAccountingSyncLog, error) {
	rows, err := q.db.Query(ctx, billingRangeAccountingSyncLog, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAccountingSyncLog
	for rows.Next() {
		var i BillingAccountingSyncLog
		if err := rows.Scan(
			&i.ID,
			&i.RecordID,
			&i.RecordType,
			&i.ExternalSystem,
			&i.ExternalID,
			&i.Status,
			&i.ErrorMessage,
			&i.RequestPayload,
			&i.ResponsePayload,
			&i.LastSyncAt,
			&i.RetryCount,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveAccountingSyncLog = `-- name: BillingRemoveAccountingSyncLog :exec
delete from "billing"."accounting_sync_log"
where id = $1::uuid
`

func (q *Queries) BillingRemoveAccountingSyncLog(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveAccountingSyncLog, id)
	return err
}

const billingUpdateAccountingSyncLog = `-- name: BillingUpdateAccountingSyncLog :one
update
  "billing"."accounting_sync_log"
set
  updated_at = now(),
  record_id = case when $1 is not null then
    $1::uuid
  else
    record_id
  end,
  record_type = case when $2 is not null then
    $2::varchar
  else
    record_type
  end,
  external_system = case when $3 is not null then
    $3::varchar
  else
    external_system
  end,
  external_id = case when $4 is not null then
    $4::varchar
  else
    external_id
  end,
  status = case when $5 is not null then
    $5::billing.sync_status_enum
  else
    status
  end,
  error_message = case when $6 is not null then
    $6::text
  else
    error_message
  end,
  request_payload = case when $7 is not null then
    $7::text
  else
    request_payload
  end,
  response_payload = case when $8 is not null then
    $8::text
  else
    response_payload
  end,
  last_sync_at = case when $9 is not null then
    $9::timestamp
  else
    last_sync_at
  end,
  retry_count = case when $10 is not null then
    $10::integer
  else
    retry_count
  end,
  next_retry_at = case when $11 is not null then
    $11::timestamp
  else
    next_retry_at
  end
where
  id = $12::uuid
returning
  id, record_id, record_type, external_system, external_id, status, error_message, request_payload, response_payload, last_sync_at, retry_count, next_retry_at, created_at, updated_at
`

type BillingUpdateAccountingSyncLogParams struct {
	RecordID        pgtype.UUID               `db:"record_id" json:"record_id"`
	RecordType      string                    `db:"record_type" json:"record_type"`
	ExternalSystem  string                    `db:"external_system" json:"external_system"`
	ExternalID      pgtype.Text               `db:"external_id" json:"external_id"`
	Status          NullBillingSyncStatusEnum `db:"status" json:"status"`
	ErrorMessage    pgtype.Text               `db:"error_message" json:"error_message"`
	RequestPayload  pgtype.Text               `db:"request_payload" json:"request_payload"`
	ResponsePayload pgtype.Text               `db:"response_payload" json:"response_payload"`
	LastSyncAt      pgtype.Timestamp          `db:"last_sync_at" json:"last_sync_at"`
	RetryCount      pgtype.Int4               `db:"retry_count" json:"retry_count"`
	NextRetryAt     pgtype.Timestamp          `db:"next_retry_at" json:"next_retry_at"`
	ID              pgtype.UUID               `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateAccountingSyncLog(ctx context.Context, arg BillingUpdateAccountingSyncLogParams) (BillingAccountingSyncLog, error) {
	row := q.db.QueryRow(ctx, billingUpdateAccountingSyncLog,
		arg.RecordID,
		arg.RecordType,
		arg.ExternalSystem,
		arg.ExternalID,
		arg.Status,
		arg.ErrorMessage,
		arg.RequestPayload,
		arg.ResponsePayload,
		arg.LastSyncAt,
		arg.RetryCount,
		arg.NextRetryAt,
		arg.ID,
	)
	var i BillingAccountingSyncLog
	err := row.Scan(
		&i.ID,
		&i.RecordID,
		&i.RecordType,
		&i.ExternalSystem,
		&i.ExternalID,
		&i.Status,
		&i.ErrorMessage,
		&i.RequestPayload,
		&i.ResponsePayload,
		&i.LastSyncAt,
		&i.RetryCount,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
