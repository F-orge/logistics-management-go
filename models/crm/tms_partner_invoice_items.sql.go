// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_partner_invoice_items.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyPartnerInvoiceItem = `-- name: TmsAnyPartnerInvoiceItem :many
select
  partner_invoice_items.id, partner_invoice_items.partner_invoice_id, partner_invoice_items.shipment_leg_id, partner_invoice_items.amount,
  partner_invoice.id, partner_invoice.carrier_id, partner_invoice.invoice_number, partner_invoice.invoice_date, partner_invoice.total_amount, partner_invoice.status, partner_invoice.created_at, partner_invoice.updated_at,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."partner_invoice_items" as partner_invoice_items
  inner join "tms"."partner_invoices" as partner_invoice on partner_invoice_items.partner_invoice_id = partner_invoice.id
  inner join "tms"."shipment_legs" as shipment_leg on partner_invoice_items.shipment_leg_id = shipment_leg.id
where
  partner_invoice_items.id = any ($1::uuid[])
`

type TmsAnyPartnerInvoiceItemRow struct {
	TmsPartnerInvoiceItem TmsPartnerInvoiceItem
	TmsPartnerInvoice     TmsPartnerInvoice
	TmsShipmentLeg        TmsShipmentLeg
}

func (q *Queries) TmsAnyPartnerInvoiceItem(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyPartnerInvoiceItemRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyPartnerInvoiceItem, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyPartnerInvoiceItemRow
	for rows.Next() {
		var i TmsAnyPartnerInvoiceItemRow
		if err := rows.Scan(
			&i.TmsPartnerInvoiceItem.ID,
			&i.TmsPartnerInvoiceItem.PartnerInvoiceID,
			&i.TmsPartnerInvoiceItem.ShipmentLegID,
			&i.TmsPartnerInvoiceItem.Amount,
			&i.TmsPartnerInvoice.ID,
			&i.TmsPartnerInvoice.CarrierID,
			&i.TmsPartnerInvoice.InvoiceNumber,
			&i.TmsPartnerInvoice.InvoiceDate,
			&i.TmsPartnerInvoice.TotalAmount,
			&i.TmsPartnerInvoice.Status,
			&i.TmsPartnerInvoice.CreatedAt,
			&i.TmsPartnerInvoice.UpdatedAt,
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindPartnerInvoiceItem = `-- name: TmsFindPartnerInvoiceItem :one
select
  partner_invoice_items.id, partner_invoice_items.partner_invoice_id, partner_invoice_items.shipment_leg_id, partner_invoice_items.amount,
  partner_invoice.id, partner_invoice.carrier_id, partner_invoice.invoice_number, partner_invoice.invoice_date, partner_invoice.total_amount, partner_invoice.status, partner_invoice.created_at, partner_invoice.updated_at,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."partner_invoice_items" as partner_invoice_items
  inner join "tms"."partner_invoices" as partner_invoice on partner_invoice_items.partner_invoice_id = partner_invoice.id
  inner join "tms"."shipment_legs" as shipment_leg on partner_invoice_items.shipment_leg_id = shipment_leg.id
where
  partner_invoice_items.id = $1::uuid
`

type TmsFindPartnerInvoiceItemRow struct {
	TmsPartnerInvoiceItem TmsPartnerInvoiceItem
	TmsPartnerInvoice     TmsPartnerInvoice
	TmsShipmentLeg        TmsShipmentLeg
}

func (q *Queries) TmsFindPartnerInvoiceItem(ctx context.Context, id pgtype.UUID) (TmsFindPartnerInvoiceItemRow, error) {
	row := q.db.QueryRow(ctx, tmsFindPartnerInvoiceItem, id)
	var i TmsFindPartnerInvoiceItemRow
	err := row.Scan(
		&i.TmsPartnerInvoiceItem.ID,
		&i.TmsPartnerInvoiceItem.PartnerInvoiceID,
		&i.TmsPartnerInvoiceItem.ShipmentLegID,
		&i.TmsPartnerInvoiceItem.Amount,
		&i.TmsPartnerInvoice.ID,
		&i.TmsPartnerInvoice.CarrierID,
		&i.TmsPartnerInvoice.InvoiceNumber,
		&i.TmsPartnerInvoice.InvoiceDate,
		&i.TmsPartnerInvoice.TotalAmount,
		&i.TmsPartnerInvoice.Status,
		&i.TmsPartnerInvoice.CreatedAt,
		&i.TmsPartnerInvoice.UpdatedAt,
		&i.TmsShipmentLeg.ID,
		&i.TmsShipmentLeg.ShipmentID,
		&i.TmsShipmentLeg.LegSequence,
		&i.TmsShipmentLeg.StartLocation,
		&i.TmsShipmentLeg.EndLocation,
		&i.TmsShipmentLeg.CarrierID,
		&i.TmsShipmentLeg.InternalTripID,
		&i.TmsShipmentLeg.Status,
		&i.TmsShipmentLeg.CreatedAt,
		&i.TmsShipmentLeg.UpdatedAt,
	)
	return i, err
}

const tmsInsertPartnerInvoiceItem = `-- name: TmsInsertPartnerInvoiceItem :one
insert into "tms"."partner_invoice_items"(partner_invoice_id, shipment_leg_id, amount)
  values ($1, $2, $3)
returning
  id, partner_invoice_id, shipment_leg_id, amount
`

type TmsInsertPartnerInvoiceItemParams struct {
	PartnerInvoiceID pgtype.UUID
	ShipmentLegID    pgtype.UUID
	Amount           pgtype.Numeric
}

func (q *Queries) TmsInsertPartnerInvoiceItem(ctx context.Context, arg TmsInsertPartnerInvoiceItemParams) (TmsPartnerInvoiceItem, error) {
	row := q.db.QueryRow(ctx, tmsInsertPartnerInvoiceItem, arg.PartnerInvoiceID, arg.ShipmentLegID, arg.Amount)
	var i TmsPartnerInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.PartnerInvoiceID,
		&i.ShipmentLegID,
		&i.Amount,
	)
	return i, err
}

const tmsPaginatePartnerInvoiceItem = `-- name: TmsPaginatePartnerInvoiceItem :many
select
  partner_invoice_items.id, partner_invoice_items.partner_invoice_id, partner_invoice_items.shipment_leg_id, partner_invoice_items.amount,
  partner_invoice.id, partner_invoice.carrier_id, partner_invoice.invoice_number, partner_invoice.invoice_date, partner_invoice.total_amount, partner_invoice.status, partner_invoice.created_at, partner_invoice.updated_at,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."partner_invoice_items" as partner_invoice_items
  inner join "tms"."partner_invoices" as partner_invoice on partner_invoice_items.partner_invoice_id = partner_invoice.id
  inner join "tms"."shipment_legs" as shipment_leg on partner_invoice_items.shipment_leg_id = shipment_leg.id
limit $2::int offset ($1::int - 1) * $2::int
`

type TmsPaginatePartnerInvoiceItemParams struct {
	Page    int32
	Perpage int32
}

type TmsPaginatePartnerInvoiceItemRow struct {
	TmsPartnerInvoiceItem TmsPartnerInvoiceItem
	TmsPartnerInvoice     TmsPartnerInvoice
	TmsShipmentLeg        TmsShipmentLeg
}

func (q *Queries) TmsPaginatePartnerInvoiceItem(ctx context.Context, arg TmsPaginatePartnerInvoiceItemParams) ([]TmsPaginatePartnerInvoiceItemRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginatePartnerInvoiceItem, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginatePartnerInvoiceItemRow
	for rows.Next() {
		var i TmsPaginatePartnerInvoiceItemRow
		if err := rows.Scan(
			&i.TmsPartnerInvoiceItem.ID,
			&i.TmsPartnerInvoiceItem.PartnerInvoiceID,
			&i.TmsPartnerInvoiceItem.ShipmentLegID,
			&i.TmsPartnerInvoiceItem.Amount,
			&i.TmsPartnerInvoice.ID,
			&i.TmsPartnerInvoice.CarrierID,
			&i.TmsPartnerInvoice.InvoiceNumber,
			&i.TmsPartnerInvoice.InvoiceDate,
			&i.TmsPartnerInvoice.TotalAmount,
			&i.TmsPartnerInvoice.Status,
			&i.TmsPartnerInvoice.CreatedAt,
			&i.TmsPartnerInvoice.UpdatedAt,
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangePartnerInvoiceItem = `-- name: TmsRangePartnerInvoiceItem :many
select
  partner_invoice_items.id, partner_invoice_items.partner_invoice_id, partner_invoice_items.shipment_leg_id, partner_invoice_items.amount,
  partner_invoice.id, partner_invoice.carrier_id, partner_invoice.invoice_number, partner_invoice.invoice_date, partner_invoice.total_amount, partner_invoice.status, partner_invoice.created_at, partner_invoice.updated_at,
  shipment_leg.id, shipment_leg.shipment_id, shipment_leg.leg_sequence, shipment_leg.start_location, shipment_leg.end_location, shipment_leg.carrier_id, shipment_leg.internal_trip_id, shipment_leg.status, shipment_leg.created_at, shipment_leg.updated_at
from
  "tms"."partner_invoice_items" as partner_invoice_items
  inner join "tms"."partner_invoices" as partner_invoice on partner_invoice_items.partner_invoice_id = partner_invoice.id
  inner join "tms"."shipment_legs" as shipment_leg on partner_invoice_items.shipment_leg_id = shipment_leg.id
where
  partner_invoice_items.created_at >= $1::date
  and partner_invoice_items.created_at <= $2::date
`

type TmsRangePartnerInvoiceItemParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type TmsRangePartnerInvoiceItemRow struct {
	TmsPartnerInvoiceItem TmsPartnerInvoiceItem
	TmsPartnerInvoice     TmsPartnerInvoice
	TmsShipmentLeg        TmsShipmentLeg
}

func (q *Queries) TmsRangePartnerInvoiceItem(ctx context.Context, arg TmsRangePartnerInvoiceItemParams) ([]TmsRangePartnerInvoiceItemRow, error) {
	rows, err := q.db.Query(ctx, tmsRangePartnerInvoiceItem, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangePartnerInvoiceItemRow
	for rows.Next() {
		var i TmsRangePartnerInvoiceItemRow
		if err := rows.Scan(
			&i.TmsPartnerInvoiceItem.ID,
			&i.TmsPartnerInvoiceItem.PartnerInvoiceID,
			&i.TmsPartnerInvoiceItem.ShipmentLegID,
			&i.TmsPartnerInvoiceItem.Amount,
			&i.TmsPartnerInvoice.ID,
			&i.TmsPartnerInvoice.CarrierID,
			&i.TmsPartnerInvoice.InvoiceNumber,
			&i.TmsPartnerInvoice.InvoiceDate,
			&i.TmsPartnerInvoice.TotalAmount,
			&i.TmsPartnerInvoice.Status,
			&i.TmsPartnerInvoice.CreatedAt,
			&i.TmsPartnerInvoice.UpdatedAt,
			&i.TmsShipmentLeg.ID,
			&i.TmsShipmentLeg.ShipmentID,
			&i.TmsShipmentLeg.LegSequence,
			&i.TmsShipmentLeg.StartLocation,
			&i.TmsShipmentLeg.EndLocation,
			&i.TmsShipmentLeg.CarrierID,
			&i.TmsShipmentLeg.InternalTripID,
			&i.TmsShipmentLeg.Status,
			&i.TmsShipmentLeg.CreatedAt,
			&i.TmsShipmentLeg.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemovePartnerInvoiceItem = `-- name: TmsRemovePartnerInvoiceItem :exec
delete from "tms"."partner_invoice_items"
where id = $1::uuid
`

func (q *Queries) TmsRemovePartnerInvoiceItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemovePartnerInvoiceItem, id)
	return err
}

const tmsUpdatePartnerInvoiceItem = `-- name: TmsUpdatePartnerInvoiceItem :one
update
  "tms"."partner_invoice_items"
set
  partner_invoice_id = case when $1::boolean then
    $2::uuid
  else
    partner_invoice_id
  end,
  shipment_leg_id = case when $3::boolean then
    $4::uuid
  else
    shipment_leg_id
  end,
  amount = case when $5::boolean then
    $6::numeric
  else
    amount
  end
where
  id = $7::uuid
returning
  id, partner_invoice_id, shipment_leg_id, amount
`

type TmsUpdatePartnerInvoiceItemParams struct {
	SetPartnerInvoiceID bool
	PartnerInvoiceID    pgtype.UUID
	SetShipmentLegID    bool
	ShipmentLegID       pgtype.UUID
	SetAmount           bool
	Amount              pgtype.Numeric
	ID                  pgtype.UUID
}

func (q *Queries) TmsUpdatePartnerInvoiceItem(ctx context.Context, arg TmsUpdatePartnerInvoiceItemParams) (TmsPartnerInvoiceItem, error) {
	row := q.db.QueryRow(ctx, tmsUpdatePartnerInvoiceItem,
		arg.SetPartnerInvoiceID,
		arg.PartnerInvoiceID,
		arg.SetShipmentLegID,
		arg.ShipmentLegID,
		arg.SetAmount,
		arg.Amount,
		arg.ID,
	)
	var i TmsPartnerInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.PartnerInvoiceID,
		&i.ShipmentLegID,
		&i.Amount,
	)
	return i, err
}
