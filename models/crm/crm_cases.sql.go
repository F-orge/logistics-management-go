// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_cases.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyCase = `-- name: CrmAnyCase :many
select
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at
from
  "crm"."cases" as cases
  inner join "public"."user" as owner on cases.owner_id = owner.id
  left join "crm"."contacts" as contact on cases.contact_id = contact.id
where
  cases.id = any ($1::uuid[])
`

type CrmAnyCaseRow struct {
	CrmCase    CrmCase
	User       User
	CrmContact CrmContact
}

func (q *Queries) CrmAnyCase(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyCaseRow, error) {
	rows, err := q.db.Query(ctx, crmAnyCase, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyCaseRow
	for rows.Next() {
		var i CrmAnyCaseRow
		if err := rows.Scan(
			&i.CrmCase.ID,
			&i.CrmCase.CaseNumber,
			&i.CrmCase.Status,
			&i.CrmCase.Priority,
			&i.CrmCase.Type,
			&i.CrmCase.OwnerID,
			&i.CrmCase.ContactID,
			&i.CrmCase.Description,
			&i.CrmCase.CreatedAt,
			&i.CrmCase.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindCase = `-- name: CrmFindCase :one
select
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at
from
  "crm"."cases" as cases
  inner join "public"."user" as owner on cases.owner_id = owner.id
  left join "crm"."contacts" as contact on cases.contact_id = contact.id
where
  cases.id = $1::uuid
`

type CrmFindCaseRow struct {
	CrmCase    CrmCase
	User       User
	CrmContact CrmContact
}

func (q *Queries) CrmFindCase(ctx context.Context, id pgtype.UUID) (CrmFindCaseRow, error) {
	row := q.db.QueryRow(ctx, crmFindCase, id)
	var i CrmFindCaseRow
	err := row.Scan(
		&i.CrmCase.ID,
		&i.CrmCase.CaseNumber,
		&i.CrmCase.Status,
		&i.CrmCase.Priority,
		&i.CrmCase.Type,
		&i.CrmCase.OwnerID,
		&i.CrmCase.ContactID,
		&i.CrmCase.Description,
		&i.CrmCase.CreatedAt,
		&i.CrmCase.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
		&i.CrmContact.ID,
		&i.CrmContact.Name,
		&i.CrmContact.Email,
		&i.CrmContact.PhoneNumber,
		&i.CrmContact.JobTitle,
		&i.CrmContact.CompanyID,
		&i.CrmContact.OwnerID,
		&i.CrmContact.CreatedAt,
		&i.CrmContact.UpdatedAt,
	)
	return i, err
}

const crmInsertCase = `-- name: CrmInsertCase :one
insert into "crm"."cases"(case_number, status, priority, type, owner_id, contact_id, description)
  values ($1, $2, $3, $4, $5, $6, $7)
returning
  id, case_number, status, priority, type, owner_id, contact_id, description, created_at, updated_at
`

type CrmInsertCaseParams struct {
	CaseNumber  string
	Status      NullCrmCaseStatus
	Priority    NullCrmCasePriority
	Type        NullCrmCaseType
	OwnerID     string
	ContactID   pgtype.UUID
	Description pgtype.Text
}

func (q *Queries) CrmInsertCase(ctx context.Context, arg CrmInsertCaseParams) (CrmCase, error) {
	row := q.db.QueryRow(ctx, crmInsertCase,
		arg.CaseNumber,
		arg.Status,
		arg.Priority,
		arg.Type,
		arg.OwnerID,
		arg.ContactID,
		arg.Description,
	)
	var i CrmCase
	err := row.Scan(
		&i.ID,
		&i.CaseNumber,
		&i.Status,
		&i.Priority,
		&i.Type,
		&i.OwnerID,
		&i.ContactID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateCase = `-- name: CrmPaginateCase :many
select
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at
from
  "crm"."cases" as cases
  inner join "public"."user" as owner on cases.owner_id = owner.id
  left join "crm"."contacts" as contact on cases.contact_id = contact.id
limit $2::int offset ($1::int - 1) * $2::int
`

type CrmPaginateCaseParams struct {
	Page    int32
	Perpage int32
}

type CrmPaginateCaseRow struct {
	CrmCase    CrmCase
	User       User
	CrmContact CrmContact
}

func (q *Queries) CrmPaginateCase(ctx context.Context, arg CrmPaginateCaseParams) ([]CrmPaginateCaseRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateCase, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateCaseRow
	for rows.Next() {
		var i CrmPaginateCaseRow
		if err := rows.Scan(
			&i.CrmCase.ID,
			&i.CrmCase.CaseNumber,
			&i.CrmCase.Status,
			&i.CrmCase.Priority,
			&i.CrmCase.Type,
			&i.CrmCase.OwnerID,
			&i.CrmCase.ContactID,
			&i.CrmCase.Description,
			&i.CrmCase.CreatedAt,
			&i.CrmCase.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeCase = `-- name: CrmRangeCase :many
select
  cases.id, cases.case_number, cases.status, cases.priority, cases.type, cases.owner_id, cases.contact_id, cases.description, cases.created_at, cases.updated_at,
  owner.id, owner.name, owner.email, owner.email_verified, owner.image, owner.created_at, owner.updated_at, owner.role, owner.banned, owner.ban_reason, owner.ban_expires,
  contact.id, contact.name, contact.email, contact.phone_number, contact.job_title, contact.company_id, contact.owner_id, contact.created_at, contact.updated_at
from
  "crm"."cases" as cases
  inner join "public"."user" as owner on cases.owner_id = owner.id
  left join "crm"."contacts" as contact on cases.contact_id = contact.id
where
  cases.created_at >= $1::date
  and cases.created_at <= $2::date
`

type CrmRangeCaseParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type CrmRangeCaseRow struct {
	CrmCase    CrmCase
	User       User
	CrmContact CrmContact
}

func (q *Queries) CrmRangeCase(ctx context.Context, arg CrmRangeCaseParams) ([]CrmRangeCaseRow, error) {
	rows, err := q.db.Query(ctx, crmRangeCase, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeCaseRow
	for rows.Next() {
		var i CrmRangeCaseRow
		if err := rows.Scan(
			&i.CrmCase.ID,
			&i.CrmCase.CaseNumber,
			&i.CrmCase.Status,
			&i.CrmCase.Priority,
			&i.CrmCase.Type,
			&i.CrmCase.OwnerID,
			&i.CrmCase.ContactID,
			&i.CrmCase.Description,
			&i.CrmCase.CreatedAt,
			&i.CrmCase.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
			&i.CrmContact.ID,
			&i.CrmContact.Name,
			&i.CrmContact.Email,
			&i.CrmContact.PhoneNumber,
			&i.CrmContact.JobTitle,
			&i.CrmContact.CompanyID,
			&i.CrmContact.OwnerID,
			&i.CrmContact.CreatedAt,
			&i.CrmContact.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveCase = `-- name: CrmRemoveCase :exec
delete from "crm"."cases"
where id = $1::uuid
`

func (q *Queries) CrmRemoveCase(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveCase, id)
	return err
}

const crmUpdateCase = `-- name: CrmUpdateCase :one
update
  "crm"."cases"
set
  case_number = case when $1::boolean then
    $2::text
  else
    case_number
  end,
  status = case when $3::boolean then
    $4::crm.case_status
  else
    status
  end,
  priority = case when $5::boolean then
    $6::crm.case_priority
  else
    priority
  end,
  type = case when $7::boolean then
    $8::crm.case_type
  else
    type
  end,
  owner_id = case when $9::boolean then
    $10::text
  else
    owner_id
  end,
  contact_id = case when $11::boolean then
    $12::uuid
  else
    contact_id
  end,
  description = case when $13::boolean then
    $14::text
  else
    description
  end
where
  id = $15::uuid
returning
  id, case_number, status, priority, type, owner_id, contact_id, description, created_at, updated_at
`

type CrmUpdateCaseParams struct {
	SetCaseNumber  bool
	CaseNumber     string
	SetStatus      bool
	Status         CrmCaseStatus
	SetPriority    bool
	Priority       CrmCasePriority
	SetType        bool
	Type           CrmCaseType
	SetOwnerID     bool
	OwnerID        string
	SetContactID   bool
	ContactID      pgtype.UUID
	SetDescription bool
	Description    string
	ID             pgtype.UUID
}

func (q *Queries) CrmUpdateCase(ctx context.Context, arg CrmUpdateCaseParams) (CrmCase, error) {
	row := q.db.QueryRow(ctx, crmUpdateCase,
		arg.SetCaseNumber,
		arg.CaseNumber,
		arg.SetStatus,
		arg.Status,
		arg.SetPriority,
		arg.Priority,
		arg.SetType,
		arg.Type,
		arg.SetOwnerID,
		arg.OwnerID,
		arg.SetContactID,
		arg.ContactID,
		arg.SetDescription,
		arg.Description,
		arg.ID,
	)
	var i CrmCase
	err := row.Scan(
		&i.ID,
		&i.CaseNumber,
		&i.Status,
		&i.Priority,
		&i.Type,
		&i.OwnerID,
		&i.ContactID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
