// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_products.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyProduct = `-- name: CrmAnyProduct :many
select
  id, name, sku, price, type, description, created_at, updated_at
from
  "crm"."products"
where
  id = any ($1::uuid[])
`

func (q *Queries) CrmAnyProduct(ctx context.Context, ids []pgtype.UUID) ([]CrmProduct, error) {
	rows, err := q.db.Query(ctx, crmAnyProduct, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmProduct
	for rows.Next() {
		var i CrmProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.Price,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindProduct = `-- name: CrmFindProduct :one
select
  id, name, sku, price, type, description, created_at, updated_at
from
  "crm"."products"
where
  id = $1::uuid
`

func (q *Queries) CrmFindProduct(ctx context.Context, id pgtype.UUID) (CrmProduct, error) {
	row := q.db.QueryRow(ctx, crmFindProduct, id)
	var i CrmProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Price,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmInsertProduct = `-- name: CrmInsertProduct :one
insert into "crm"."products"(name, sku, price, type, description)
  values ($1, $2, $3, $4, $5)
returning
  id, name, sku, price, type, description, created_at, updated_at
`

type CrmInsertProductParams struct {
	Name        string
	Sku         pgtype.Text
	Price       pgtype.Numeric
	Type        NullCrmProductType
	Description pgtype.Text
}

func (q *Queries) CrmInsertProduct(ctx context.Context, arg CrmInsertProductParams) (CrmProduct, error) {
	row := q.db.QueryRow(ctx, crmInsertProduct,
		arg.Name,
		arg.Sku,
		arg.Price,
		arg.Type,
		arg.Description,
	)
	var i CrmProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Price,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateProduct = `-- name: CrmPaginateProduct :many
select
  id, name, sku, price, type, description, created_at, updated_at
from
  "crm"."products"
limit $2::int offset ($1::int - 1) * $2::int
`

type CrmPaginateProductParams struct {
	Page    int32
	Perpage int32
}

func (q *Queries) CrmPaginateProduct(ctx context.Context, arg CrmPaginateProductParams) ([]CrmProduct, error) {
	rows, err := q.db.Query(ctx, crmPaginateProduct, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmProduct
	for rows.Next() {
		var i CrmProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.Price,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeProduct = `-- name: CrmRangeProduct :many
select
  id, name, sku, price, type, description, created_at, updated_at
from
  "crm"."products"
where
  created_at >= $1::date
  and created_at <= $2::date
`

type CrmRangeProductParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

func (q *Queries) CrmRangeProduct(ctx context.Context, arg CrmRangeProductParams) ([]CrmProduct, error) {
	rows, err := q.db.Query(ctx, crmRangeProduct, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmProduct
	for rows.Next() {
		var i CrmProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.Price,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveProduct = `-- name: CrmRemoveProduct :exec
delete from "crm"."products"
where id = $1::uuid
`

func (q *Queries) CrmRemoveProduct(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveProduct, id)
	return err
}

const crmUpdateProduct = `-- name: CrmUpdateProduct :one
update
  "crm"."products"
set
  name = case when $1::boolean then
    $2::text
  else
    name
  end,
  sku = case when $3::boolean then
    $4::text
  else
    sku
  end,
  price = case when $5::boolean then
    $6::numeric
  else
    price
  end,
  type = case when $7::boolean then
    $8::crm.product_type
  else
    type
  end,
  description = case when $9::boolean then
    $10::text
  else
    description
  end
where
  id = $11::uuid
returning
  id, name, sku, price, type, description, created_at, updated_at
`

type CrmUpdateProductParams struct {
	SetName        bool
	Name           string
	SetSku         bool
	Sku            string
	SetPrice       bool
	Price          pgtype.Numeric
	SetType        bool
	Type           CrmProductType
	SetDescription bool
	Description    string
	ID             pgtype.UUID
}

func (q *Queries) CrmUpdateProduct(ctx context.Context, arg CrmUpdateProductParams) (CrmProduct, error) {
	row := q.db.QueryRow(ctx, crmUpdateProduct,
		arg.SetName,
		arg.Name,
		arg.SetSku,
		arg.Sku,
		arg.SetPrice,
		arg.Price,
		arg.SetType,
		arg.Type,
		arg.SetDescription,
		arg.Description,
		arg.ID,
	)
	var i CrmProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Price,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
