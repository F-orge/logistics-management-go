// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_driver_schedules.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyDriverSchedule = `-- name: TmsAnyDriverSchedule :many
select
  driver_schedules.id, driver_schedules.driver_id, driver_schedules.start_date, driver_schedules.end_date, driver_schedules.reason, driver_schedules.created_at, driver_schedules.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."driver_schedules" as driver_schedules
  inner join "tms"."drivers" as driver on driver_schedules.driver_id = driver.id
where
  driver_schedules.id = any ($1::uuid[])
`

type TmsAnyDriverScheduleRow struct {
	TmsDriverSchedule TmsDriverSchedule
	TmsDriver         TmsDriver
}

func (q *Queries) TmsAnyDriverSchedule(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyDriverScheduleRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyDriverSchedule, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyDriverScheduleRow
	for rows.Next() {
		var i TmsAnyDriverScheduleRow
		if err := rows.Scan(
			&i.TmsDriverSchedule.ID,
			&i.TmsDriverSchedule.DriverID,
			&i.TmsDriverSchedule.StartDate,
			&i.TmsDriverSchedule.EndDate,
			&i.TmsDriverSchedule.Reason,
			&i.TmsDriverSchedule.CreatedAt,
			&i.TmsDriverSchedule.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindDriverSchedule = `-- name: TmsFindDriverSchedule :one
select
  driver_schedules.id, driver_schedules.driver_id, driver_schedules.start_date, driver_schedules.end_date, driver_schedules.reason, driver_schedules.created_at, driver_schedules.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."driver_schedules" as driver_schedules
  inner join "tms"."drivers" as driver on driver_schedules.driver_id = driver.id
where
  driver_schedules.id = $1::uuid
`

type TmsFindDriverScheduleRow struct {
	TmsDriverSchedule TmsDriverSchedule
	TmsDriver         TmsDriver
}

func (q *Queries) TmsFindDriverSchedule(ctx context.Context, id pgtype.UUID) (TmsFindDriverScheduleRow, error) {
	row := q.db.QueryRow(ctx, tmsFindDriverSchedule, id)
	var i TmsFindDriverScheduleRow
	err := row.Scan(
		&i.TmsDriverSchedule.ID,
		&i.TmsDriverSchedule.DriverID,
		&i.TmsDriverSchedule.StartDate,
		&i.TmsDriverSchedule.EndDate,
		&i.TmsDriverSchedule.Reason,
		&i.TmsDriverSchedule.CreatedAt,
		&i.TmsDriverSchedule.UpdatedAt,
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
	)
	return i, err
}

const tmsInsertDriverSchedule = `-- name: TmsInsertDriverSchedule :one
insert into "tms"."driver_schedules"(driver_id, start_date, end_date, reason)
  values ($1, $2, $3, $4)
returning
  id, driver_id, start_date, end_date, reason, created_at, updated_at
`

type TmsInsertDriverScheduleParams struct {
	DriverID  pgtype.UUID
	StartDate pgtype.Date
	EndDate   pgtype.Date
	Reason    NullTmsDriverScheduleReasonEnum
}

func (q *Queries) TmsInsertDriverSchedule(ctx context.Context, arg TmsInsertDriverScheduleParams) (TmsDriverSchedule, error) {
	row := q.db.QueryRow(ctx, tmsInsertDriverSchedule,
		arg.DriverID,
		arg.StartDate,
		arg.EndDate,
		arg.Reason,
	)
	var i TmsDriverSchedule
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.StartDate,
		&i.EndDate,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateDriverSchedule = `-- name: TmsPaginateDriverSchedule :many
select
  driver_schedules.id, driver_schedules.driver_id, driver_schedules.start_date, driver_schedules.end_date, driver_schedules.reason, driver_schedules.created_at, driver_schedules.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."driver_schedules" as driver_schedules
  inner join "tms"."drivers" as driver on driver_schedules.driver_id = driver.id
where (driver.name ilike $1::text
  or driver_schedules.reason::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateDriverScheduleParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type TmsPaginateDriverScheduleRow struct {
	TmsDriverSchedule TmsDriverSchedule
	TmsDriver         TmsDriver
}

func (q *Queries) TmsPaginateDriverSchedule(ctx context.Context, arg TmsPaginateDriverScheduleParams) ([]TmsPaginateDriverScheduleRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateDriverSchedule, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateDriverScheduleRow
	for rows.Next() {
		var i TmsPaginateDriverScheduleRow
		if err := rows.Scan(
			&i.TmsDriverSchedule.ID,
			&i.TmsDriverSchedule.DriverID,
			&i.TmsDriverSchedule.StartDate,
			&i.TmsDriverSchedule.EndDate,
			&i.TmsDriverSchedule.Reason,
			&i.TmsDriverSchedule.CreatedAt,
			&i.TmsDriverSchedule.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRangeDriverSchedule = `-- name: TmsRangeDriverSchedule :many
select
  driver_schedules.id, driver_schedules.driver_id, driver_schedules.start_date, driver_schedules.end_date, driver_schedules.reason, driver_schedules.created_at, driver_schedules.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."driver_schedules" as driver_schedules
  inner join "tms"."drivers" as driver on driver_schedules.driver_id = driver.id
where
  driver_schedules.created_at >= $1::date
  and driver_schedules.created_at <= $2::date
  and (driver.name ilike $3::text
    or driver_schedules.reason::text ilike $3::text
    or $3::text is null)
`

type TmsRangeDriverScheduleParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type TmsRangeDriverScheduleRow struct {
	TmsDriverSchedule TmsDriverSchedule
	TmsDriver         TmsDriver
}

func (q *Queries) TmsRangeDriverSchedule(ctx context.Context, arg TmsRangeDriverScheduleParams) ([]TmsRangeDriverScheduleRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeDriverSchedule, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeDriverScheduleRow
	for rows.Next() {
		var i TmsRangeDriverScheduleRow
		if err := rows.Scan(
			&i.TmsDriverSchedule.ID,
			&i.TmsDriverSchedule.DriverID,
			&i.TmsDriverSchedule.StartDate,
			&i.TmsDriverSchedule.EndDate,
			&i.TmsDriverSchedule.Reason,
			&i.TmsDriverSchedule.CreatedAt,
			&i.TmsDriverSchedule.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveDriverSchedule = `-- name: TmsRemoveDriverSchedule :exec
delete from "tms"."driver_schedules"
where id = $1::uuid
`

func (q *Queries) TmsRemoveDriverSchedule(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveDriverSchedule, id)
	return err
}

const tmsUpdateDriverSchedule = `-- name: TmsUpdateDriverSchedule :one
update
  "tms"."driver_schedules"
set
  updated_at = now(),
  driver_id = case when $1 is not null then
    $1::uuid
  else
    driver_id
  end,
  start_date = case when $2 is not null then
    $2::date
  else
    start_date
  end,
  end_date = case when $3 is not null then
    $3::date
  else
    end_date
  end,
  reason = case when $4 is not null then
    $4::tms.driver_schedule_reason_enum
  else
    reason
  end
where
  id = $5::uuid
returning
  id, driver_id, start_date, end_date, reason, created_at, updated_at
`

type TmsUpdateDriverScheduleParams struct {
	DriverID  pgtype.UUID
	StartDate pgtype.Date
	EndDate   pgtype.Date
	Reason    NullTmsDriverScheduleReasonEnum
	ID        pgtype.UUID
}

func (q *Queries) TmsUpdateDriverSchedule(ctx context.Context, arg TmsUpdateDriverScheduleParams) (TmsDriverSchedule, error) {
	row := q.db.QueryRow(ctx, tmsUpdateDriverSchedule,
		arg.DriverID,
		arg.StartDate,
		arg.EndDate,
		arg.Reason,
		arg.ID,
	)
	var i TmsDriverSchedule
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.StartDate,
		&i.EndDate,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
