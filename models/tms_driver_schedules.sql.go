// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_driver_schedules.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyDriverSchedule = `-- name: TmsAnyDriverSchedule :many
select
  driver_schedules.id, driver_schedules.driver_id, driver_schedules.start_date, driver_schedules.end_date, driver_schedules.reason, driver_schedules.created_at, driver_schedules.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."driver_schedules" as driver_schedules
  inner join "tms"."drivers" as driver on driver_schedules.driver_id = driver.id
where
  driver_schedules.id = any ($1::uuid[])
`

type TmsAnyDriverScheduleRow struct {
	ID        pgtype.UUID                     `db:"id" json:"id"`
	DriverID  pgtype.UUID                     `db:"driver_id" json:"driver_id"`
	StartDate pgtype.Date                     `db:"start_date" fake:"{date}" json:"start_date"`
	EndDate   pgtype.Date                     `db:"end_date" fake:"{date}" json:"end_date"`
	Reason    NullTmsDriverScheduleReasonEnum `db:"reason" json:"reason"`
	CreatedAt pgtype.Timestamp                `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp                `db:"updated_at" json:"updated_at"`
	TmsDriver TmsDriver                       `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) TmsAnyDriverSchedule(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyDriverScheduleRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyDriverSchedule, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyDriverScheduleRow
	for rows.Next() {
		var i TmsAnyDriverScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.StartDate,
			&i.EndDate,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindDriverSchedule = `-- name: TmsFindDriverSchedule :one
select
  driver_schedules.id, driver_schedules.driver_id, driver_schedules.start_date, driver_schedules.end_date, driver_schedules.reason, driver_schedules.created_at, driver_schedules.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."driver_schedules" as driver_schedules
  inner join "tms"."drivers" as driver on driver_schedules.driver_id = driver.id
where
  driver_schedules.id = $1::uuid
`

type TmsFindDriverScheduleRow struct {
	ID        pgtype.UUID                     `db:"id" json:"id"`
	DriverID  pgtype.UUID                     `db:"driver_id" json:"driver_id"`
	StartDate pgtype.Date                     `db:"start_date" fake:"{date}" json:"start_date"`
	EndDate   pgtype.Date                     `db:"end_date" fake:"{date}" json:"end_date"`
	Reason    NullTmsDriverScheduleReasonEnum `db:"reason" json:"reason"`
	CreatedAt pgtype.Timestamp                `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp                `db:"updated_at" json:"updated_at"`
	TmsDriver TmsDriver                       `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) TmsFindDriverSchedule(ctx context.Context, id pgtype.UUID) (TmsFindDriverScheduleRow, error) {
	row := q.db.QueryRow(ctx, tmsFindDriverSchedule, id)
	var i TmsFindDriverScheduleRow
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.StartDate,
		&i.EndDate,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TmsDriver.ID,
		&i.TmsDriver.UserID,
		&i.TmsDriver.LicenseNumber,
		&i.TmsDriver.LicenseExpiryDate,
		&i.TmsDriver.Status,
		&i.TmsDriver.CreatedAt,
		&i.TmsDriver.UpdatedAt,
		&i.TmsDriver.ContactPhone,
	)
	return i, err
}

const tmsInsertDriverSchedule = `-- name: TmsInsertDriverSchedule :one
insert into "tms"."driver_schedules"(driver_id, start_date, end_date, reason)
  values ($1, $2, $3, $4)
returning
  id, driver_id, start_date, end_date, reason, created_at, updated_at
`

type TmsInsertDriverScheduleParams struct {
	DriverID  pgtype.UUID                     `db:"driver_id" json:"driver_id"`
	StartDate pgtype.Date                     `db:"start_date" fake:"{date}" json:"start_date"`
	EndDate   pgtype.Date                     `db:"end_date" fake:"{date}" json:"end_date"`
	Reason    NullTmsDriverScheduleReasonEnum `db:"reason" json:"reason"`
}

func (q *Queries) TmsInsertDriverSchedule(ctx context.Context, arg TmsInsertDriverScheduleParams) (TmsDriverSchedule, error) {
	row := q.db.QueryRow(ctx, tmsInsertDriverSchedule,
		arg.DriverID,
		arg.StartDate,
		arg.EndDate,
		arg.Reason,
	)
	var i TmsDriverSchedule
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.StartDate,
		&i.EndDate,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateDriverSchedule = `-- name: TmsPaginateDriverSchedule :many
select
  driver_schedules.id, driver_schedules.driver_id, driver_schedules.start_date, driver_schedules.end_date, driver_schedules.reason, driver_schedules.created_at, driver_schedules.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."driver_schedules" as driver_schedules
  inner join "tms"."drivers" as driver on driver_schedules.driver_id = driver.id
where (driver.name ilike $1::text
  or driver_schedules.reason::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateDriverScheduleParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type TmsPaginateDriverScheduleRow struct {
	ID        pgtype.UUID                     `db:"id" json:"id"`
	DriverID  pgtype.UUID                     `db:"driver_id" json:"driver_id"`
	StartDate pgtype.Date                     `db:"start_date" fake:"{date}" json:"start_date"`
	EndDate   pgtype.Date                     `db:"end_date" fake:"{date}" json:"end_date"`
	Reason    NullTmsDriverScheduleReasonEnum `db:"reason" json:"reason"`
	CreatedAt pgtype.Timestamp                `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp                `db:"updated_at" json:"updated_at"`
	TmsDriver TmsDriver                       `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) TmsPaginateDriverSchedule(ctx context.Context, arg TmsPaginateDriverScheduleParams) ([]TmsPaginateDriverScheduleRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateDriverSchedule, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateDriverScheduleRow
	for rows.Next() {
		var i TmsPaginateDriverScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.StartDate,
			&i.EndDate,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsPaginateDriverScheduleMetadata = `-- name: TmsPaginateDriverScheduleMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "tms"."driver_schedules" as driver_schedules
`

type TmsPaginateDriverScheduleMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type TmsPaginateDriverScheduleMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) TmsPaginateDriverScheduleMetadata(ctx context.Context, arg TmsPaginateDriverScheduleMetadataParams) (TmsPaginateDriverScheduleMetadataRow, error) {
	row := q.db.QueryRow(ctx, tmsPaginateDriverScheduleMetadata, arg.PerPage, arg.Page)
	var i TmsPaginateDriverScheduleMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const tmsRangeDriverSchedule = `-- name: TmsRangeDriverSchedule :many
select
  driver_schedules.id, driver_schedules.driver_id, driver_schedules.start_date, driver_schedules.end_date, driver_schedules.reason, driver_schedules.created_at, driver_schedules.updated_at,
  driver.id, driver.user_id, driver.license_number, driver.license_expiry_date, driver.status, driver.created_at, driver.updated_at, driver.contact_phone
from
  "tms"."driver_schedules" as driver_schedules
  inner join "tms"."drivers" as driver on driver_schedules.driver_id = driver.id
where
  driver_schedules.created_at >= $1::date
  and driver_schedules.created_at <= $2::date
  and (driver.name ilike $3::text
    or driver_schedules.reason::text ilike $3::text
    or $3::text is null)
`

type TmsRangeDriverScheduleParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeDriverScheduleRow struct {
	ID        pgtype.UUID                     `db:"id" json:"id"`
	DriverID  pgtype.UUID                     `db:"driver_id" json:"driver_id"`
	StartDate pgtype.Date                     `db:"start_date" fake:"{date}" json:"start_date"`
	EndDate   pgtype.Date                     `db:"end_date" fake:"{date}" json:"end_date"`
	Reason    NullTmsDriverScheduleReasonEnum `db:"reason" json:"reason"`
	CreatedAt pgtype.Timestamp                `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp                `db:"updated_at" json:"updated_at"`
	TmsDriver TmsDriver                       `db:"tms_driver" json:"tms_driver"`
}

func (q *Queries) TmsRangeDriverSchedule(ctx context.Context, arg TmsRangeDriverScheduleParams) ([]TmsRangeDriverScheduleRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeDriverSchedule, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeDriverScheduleRow
	for rows.Next() {
		var i TmsRangeDriverScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.StartDate,
			&i.EndDate,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsDriver.ID,
			&i.TmsDriver.UserID,
			&i.TmsDriver.LicenseNumber,
			&i.TmsDriver.LicenseExpiryDate,
			&i.TmsDriver.Status,
			&i.TmsDriver.CreatedAt,
			&i.TmsDriver.UpdatedAt,
			&i.TmsDriver.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveDriverSchedule = `-- name: TmsRemoveDriverSchedule :exec
delete from "tms"."driver_schedules"
where id = $1::uuid
`

func (q *Queries) TmsRemoveDriverSchedule(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveDriverSchedule, id)
	return err
}

const tmsUpdateDriverSchedule = `-- name: TmsUpdateDriverSchedule :one
update
  "tms"."driver_schedules"
set
  updated_at = now(),
  driver_id = case when $1 is not null then
    $1::uuid
  else
    driver_id
  end,
  start_date = case when $2 is not null then
    $2::date
  else
    start_date
  end,
  end_date = case when $3 is not null then
    $3::date
  else
    end_date
  end,
  reason = case when $4 is not null then
    $4::tms.driver_schedule_reason_enum
  else
    reason
  end
where
  id = $5::uuid
returning
  id, driver_id, start_date, end_date, reason, created_at, updated_at
`

type TmsUpdateDriverScheduleParams struct {
	DriverID  pgtype.UUID                     `db:"driver_id" json:"driver_id"`
	StartDate pgtype.Date                     `db:"start_date" fake:"{date}" json:"start_date"`
	EndDate   pgtype.Date                     `db:"end_date" fake:"{date}" json:"end_date"`
	Reason    NullTmsDriverScheduleReasonEnum `db:"reason" json:"reason"`
	ID        pgtype.UUID                     `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateDriverSchedule(ctx context.Context, arg TmsUpdateDriverScheduleParams) (TmsDriverSchedule, error) {
	row := q.db.QueryRow(ctx, tmsUpdateDriverSchedule,
		arg.DriverID,
		arg.StartDate,
		arg.EndDate,
		arg.Reason,
		arg.ID,
	)
	var i TmsDriverSchedule
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.StartDate,
		&i.EndDate,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
