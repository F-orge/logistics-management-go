// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dms_customer_tracking_links.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dmsAnyCustomerTrackingLink = `-- name: DmsAnyCustomerTrackingLink :many
select
  customer_tracking_links.id, customer_tracking_links.delivery_task_id, customer_tracking_links.tracking_token, customer_tracking_links.is_active, customer_tracking_links.access_count, customer_tracking_links.last_accessed_at, customer_tracking_links.expires_at, customer_tracking_links.created_at, customer_tracking_links.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."customer_tracking_links" as customer_tracking_links
  inner join "dms"."delivery_tasks" as delivery_task on customer_tracking_links.delivery_task_id = delivery_task.id
where
  customer_tracking_links.id = any ($1::uuid[])
`

type DmsAnyCustomerTrackingLinkRow struct {
	DmsCustomerTrackingLink DmsCustomerTrackingLink `db:"dms_customer_tracking_link" json:"dms_customer_tracking_link"`
	DmsDeliveryTask         DmsDeliveryTask         `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsAnyCustomerTrackingLink(ctx context.Context, ids []pgtype.UUID) ([]DmsAnyCustomerTrackingLinkRow, error) {
	rows, err := q.db.Query(ctx, dmsAnyCustomerTrackingLink, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsAnyCustomerTrackingLinkRow
	for rows.Next() {
		var i DmsAnyCustomerTrackingLinkRow
		if err := rows.Scan(
			&i.DmsCustomerTrackingLink.ID,
			&i.DmsCustomerTrackingLink.DeliveryTaskID,
			&i.DmsCustomerTrackingLink.TrackingToken,
			&i.DmsCustomerTrackingLink.IsActive,
			&i.DmsCustomerTrackingLink.AccessCount,
			&i.DmsCustomerTrackingLink.LastAccessedAt,
			&i.DmsCustomerTrackingLink.ExpiresAt,
			&i.DmsCustomerTrackingLink.CreatedAt,
			&i.DmsCustomerTrackingLink.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsFindCustomerTrackingLink = `-- name: DmsFindCustomerTrackingLink :one
select
  customer_tracking_links.id, customer_tracking_links.delivery_task_id, customer_tracking_links.tracking_token, customer_tracking_links.is_active, customer_tracking_links.access_count, customer_tracking_links.last_accessed_at, customer_tracking_links.expires_at, customer_tracking_links.created_at, customer_tracking_links.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."customer_tracking_links" as customer_tracking_links
  inner join "dms"."delivery_tasks" as delivery_task on customer_tracking_links.delivery_task_id = delivery_task.id
where
  customer_tracking_links.id = $1::uuid
`

type DmsFindCustomerTrackingLinkRow struct {
	DmsCustomerTrackingLink DmsCustomerTrackingLink `db:"dms_customer_tracking_link" json:"dms_customer_tracking_link"`
	DmsDeliveryTask         DmsDeliveryTask         `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsFindCustomerTrackingLink(ctx context.Context, id pgtype.UUID) (DmsFindCustomerTrackingLinkRow, error) {
	row := q.db.QueryRow(ctx, dmsFindCustomerTrackingLink, id)
	var i DmsFindCustomerTrackingLinkRow
	err := row.Scan(
		&i.DmsCustomerTrackingLink.ID,
		&i.DmsCustomerTrackingLink.DeliveryTaskID,
		&i.DmsCustomerTrackingLink.TrackingToken,
		&i.DmsCustomerTrackingLink.IsActive,
		&i.DmsCustomerTrackingLink.AccessCount,
		&i.DmsCustomerTrackingLink.LastAccessedAt,
		&i.DmsCustomerTrackingLink.ExpiresAt,
		&i.DmsCustomerTrackingLink.CreatedAt,
		&i.DmsCustomerTrackingLink.UpdatedAt,
		&i.DmsDeliveryTask.ID,
		&i.DmsDeliveryTask.PackageID,
		&i.DmsDeliveryTask.DeliveryRouteID,
		&i.DmsDeliveryTask.RouteSequence,
		&i.DmsDeliveryTask.DeliveryAddress,
		&i.DmsDeliveryTask.RecipientName,
		&i.DmsDeliveryTask.RecipientPhone,
		&i.DmsDeliveryTask.DeliveryInstructions,
		&i.DmsDeliveryTask.EstimatedArrivalTime,
		&i.DmsDeliveryTask.ActualArrivalTime,
		&i.DmsDeliveryTask.DeliveryTime,
		&i.DmsDeliveryTask.Status,
		&i.DmsDeliveryTask.FailureReason,
		&i.DmsDeliveryTask.AttemptCount,
		&i.DmsDeliveryTask.CreatedAt,
		&i.DmsDeliveryTask.UpdatedAt,
	)
	return i, err
}

const dmsInsertCustomerTrackingLink = `-- name: DmsInsertCustomerTrackingLink :one
insert into "dms"."customer_tracking_links"(delivery_task_id, tracking_token, is_active, access_count, last_accessed_at, expires_at)
  values ($1, $2, $3, $4, $5, $6)
returning
  id, delivery_task_id, tracking_token, is_active, access_count, last_accessed_at, expires_at, created_at, updated_at
`

type DmsInsertCustomerTrackingLinkParams struct {
	DeliveryTaskID pgtype.UUID      `db:"delivery_task_id" json:"delivery_task_id"`
	TrackingToken  string           `db:"tracking_token" json:"tracking_token"`
	IsActive       pgtype.Bool      `db:"is_active" json:"is_active"`
	AccessCount    pgtype.Int4      `db:"access_count" json:"access_count"`
	LastAccessedAt pgtype.Timestamp `db:"last_accessed_at" json:"last_accessed_at"`
	ExpiresAt      pgtype.Timestamp `db:"expires_at" json:"expires_at"`
}

func (q *Queries) DmsInsertCustomerTrackingLink(ctx context.Context, arg DmsInsertCustomerTrackingLinkParams) (DmsCustomerTrackingLink, error) {
	row := q.db.QueryRow(ctx, dmsInsertCustomerTrackingLink,
		arg.DeliveryTaskID,
		arg.TrackingToken,
		arg.IsActive,
		arg.AccessCount,
		arg.LastAccessedAt,
		arg.ExpiresAt,
	)
	var i DmsCustomerTrackingLink
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.TrackingToken,
		&i.IsActive,
		&i.AccessCount,
		&i.LastAccessedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dmsPaginateCustomerTrackingLink = `-- name: DmsPaginateCustomerTrackingLink :many
select
  customer_tracking_links.id, customer_tracking_links.delivery_task_id, customer_tracking_links.tracking_token, customer_tracking_links.is_active, customer_tracking_links.access_count, customer_tracking_links.last_accessed_at, customer_tracking_links.expires_at, customer_tracking_links.created_at, customer_tracking_links.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."customer_tracking_links" as customer_tracking_links
  inner join "dms"."delivery_tasks" as delivery_task on customer_tracking_links.delivery_task_id = delivery_task.id
where (customer_tracking_links.tracking_token ilike $1::text
  or delivery_task.recipient_name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type DmsPaginateCustomerTrackingLinkParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type DmsPaginateCustomerTrackingLinkRow struct {
	DmsCustomerTrackingLink DmsCustomerTrackingLink `db:"dms_customer_tracking_link" json:"dms_customer_tracking_link"`
	DmsDeliveryTask         DmsDeliveryTask         `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsPaginateCustomerTrackingLink(ctx context.Context, arg DmsPaginateCustomerTrackingLinkParams) ([]DmsPaginateCustomerTrackingLinkRow, error) {
	rows, err := q.db.Query(ctx, dmsPaginateCustomerTrackingLink, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsPaginateCustomerTrackingLinkRow
	for rows.Next() {
		var i DmsPaginateCustomerTrackingLinkRow
		if err := rows.Scan(
			&i.DmsCustomerTrackingLink.ID,
			&i.DmsCustomerTrackingLink.DeliveryTaskID,
			&i.DmsCustomerTrackingLink.TrackingToken,
			&i.DmsCustomerTrackingLink.IsActive,
			&i.DmsCustomerTrackingLink.AccessCount,
			&i.DmsCustomerTrackingLink.LastAccessedAt,
			&i.DmsCustomerTrackingLink.ExpiresAt,
			&i.DmsCustomerTrackingLink.CreatedAt,
			&i.DmsCustomerTrackingLink.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRangeCustomerTrackingLink = `-- name: DmsRangeCustomerTrackingLink :many
select
  customer_tracking_links.id, customer_tracking_links.delivery_task_id, customer_tracking_links.tracking_token, customer_tracking_links.is_active, customer_tracking_links.access_count, customer_tracking_links.last_accessed_at, customer_tracking_links.expires_at, customer_tracking_links.created_at, customer_tracking_links.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."customer_tracking_links" as customer_tracking_links
  inner join "dms"."delivery_tasks" as delivery_task on customer_tracking_links.delivery_task_id = delivery_task.id
where
  customer_tracking_links.created_at >= $1::date
  and customer_tracking_links.created_at <= $2::date
  and (customer_tracking_links.tracking_token ilike $3::text
    or delivery_task.recipient_name ilike $3::text
    or $3::text is null)
`

type DmsRangeCustomerTrackingLinkParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type DmsRangeCustomerTrackingLinkRow struct {
	DmsCustomerTrackingLink DmsCustomerTrackingLink `db:"dms_customer_tracking_link" json:"dms_customer_tracking_link"`
	DmsDeliveryTask         DmsDeliveryTask         `db:"dms_delivery_task" json:"dms_delivery_task"`
}

func (q *Queries) DmsRangeCustomerTrackingLink(ctx context.Context, arg DmsRangeCustomerTrackingLinkParams) ([]DmsRangeCustomerTrackingLinkRow, error) {
	rows, err := q.db.Query(ctx, dmsRangeCustomerTrackingLink, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsRangeCustomerTrackingLinkRow
	for rows.Next() {
		var i DmsRangeCustomerTrackingLinkRow
		if err := rows.Scan(
			&i.DmsCustomerTrackingLink.ID,
			&i.DmsCustomerTrackingLink.DeliveryTaskID,
			&i.DmsCustomerTrackingLink.TrackingToken,
			&i.DmsCustomerTrackingLink.IsActive,
			&i.DmsCustomerTrackingLink.AccessCount,
			&i.DmsCustomerTrackingLink.LastAccessedAt,
			&i.DmsCustomerTrackingLink.ExpiresAt,
			&i.DmsCustomerTrackingLink.CreatedAt,
			&i.DmsCustomerTrackingLink.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRemoveCustomerTrackingLink = `-- name: DmsRemoveCustomerTrackingLink :exec
delete from "dms"."customer_tracking_links"
where id = $1::uuid
`

func (q *Queries) DmsRemoveCustomerTrackingLink(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, dmsRemoveCustomerTrackingLink, id)
	return err
}

const dmsUpdateCustomerTrackingLink = `-- name: DmsUpdateCustomerTrackingLink :one
update
  "dms"."customer_tracking_links"
set
  updated_at = now(),
  delivery_task_id = case when $1 is not null then
    $1::uuid
  else
    delivery_task_id
  end,
  tracking_token = case when $2 is not null then
    $2::varchar
  else
    tracking_token
  end,
  is_active = case when $3 is not null then
    $3::boolean
  else
    is_active
  end,
  access_count = case when $4 is not null then
    $4::integer
  else
    access_count
  end,
  last_accessed_at = case when $5 is not null then
    $5::timestamp
  else
    last_accessed_at
  end,
  expires_at = case when $6 is not null then
    $6::timestamp
  else
    expires_at
  end
where
  id = $7::uuid
returning
  id, delivery_task_id, tracking_token, is_active, access_count, last_accessed_at, expires_at, created_at, updated_at
`

type DmsUpdateCustomerTrackingLinkParams struct {
	DeliveryTaskID pgtype.UUID      `db:"delivery_task_id" json:"delivery_task_id"`
	TrackingToken  string           `db:"tracking_token" json:"tracking_token"`
	IsActive       pgtype.Bool      `db:"is_active" json:"is_active"`
	AccessCount    pgtype.Int4      `db:"access_count" json:"access_count"`
	LastAccessedAt pgtype.Timestamp `db:"last_accessed_at" json:"last_accessed_at"`
	ExpiresAt      pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	ID             pgtype.UUID      `db:"id" json:"id"`
}

func (q *Queries) DmsUpdateCustomerTrackingLink(ctx context.Context, arg DmsUpdateCustomerTrackingLinkParams) (DmsCustomerTrackingLink, error) {
	row := q.db.QueryRow(ctx, dmsUpdateCustomerTrackingLink,
		arg.DeliveryTaskID,
		arg.TrackingToken,
		arg.IsActive,
		arg.AccessCount,
		arg.LastAccessedAt,
		arg.ExpiresAt,
		arg.ID,
	)
	var i DmsCustomerTrackingLink
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.TrackingToken,
		&i.IsActive,
		&i.AccessCount,
		&i.LastAccessedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
