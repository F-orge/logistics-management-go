// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dms_customer_tracking_links.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const dmsAnyCustomerTrackingLink = `-- name: DmsAnyCustomerTrackingLink :many
select
  customer_tracking_links.id, customer_tracking_links.delivery_task_id, customer_tracking_links.tracking_token, customer_tracking_links.is_active, customer_tracking_links.access_count, customer_tracking_links.last_accessed_at, customer_tracking_links.expires_at, customer_tracking_links.created_at, customer_tracking_links.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."customer_tracking_links" as customer_tracking_links
  inner join "dms"."delivery_tasks" as delivery_task on customer_tracking_links.delivery_task_id = delivery_task.id
where
  customer_tracking_links.id = any ($1::uuid[])
`

type DmsAnyCustomerTrackingLinkRow struct {
	DmsCustomerTrackingLink DmsCustomerTrackingLink
	DmsDeliveryTask         DmsDeliveryTask
}

func (q *Queries) DmsAnyCustomerTrackingLink(ctx context.Context, ids []pgtype.UUID) ([]DmsAnyCustomerTrackingLinkRow, error) {
	rows, err := q.db.Query(ctx, dmsAnyCustomerTrackingLink, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsAnyCustomerTrackingLinkRow
	for rows.Next() {
		var i DmsAnyCustomerTrackingLinkRow
		if err := rows.Scan(
			&i.DmsCustomerTrackingLink.ID,
			&i.DmsCustomerTrackingLink.DeliveryTaskID,
			&i.DmsCustomerTrackingLink.TrackingToken,
			&i.DmsCustomerTrackingLink.IsActive,
			&i.DmsCustomerTrackingLink.AccessCount,
			&i.DmsCustomerTrackingLink.LastAccessedAt,
			&i.DmsCustomerTrackingLink.ExpiresAt,
			&i.DmsCustomerTrackingLink.CreatedAt,
			&i.DmsCustomerTrackingLink.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsFindCustomerTrackingLink = `-- name: DmsFindCustomerTrackingLink :one
select
  customer_tracking_links.id, customer_tracking_links.delivery_task_id, customer_tracking_links.tracking_token, customer_tracking_links.is_active, customer_tracking_links.access_count, customer_tracking_links.last_accessed_at, customer_tracking_links.expires_at, customer_tracking_links.created_at, customer_tracking_links.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."customer_tracking_links" as customer_tracking_links
  inner join "dms"."delivery_tasks" as delivery_task on customer_tracking_links.delivery_task_id = delivery_task.id
where
  customer_tracking_links.id = $1::uuid
`

type DmsFindCustomerTrackingLinkRow struct {
	DmsCustomerTrackingLink DmsCustomerTrackingLink
	DmsDeliveryTask         DmsDeliveryTask
}

func (q *Queries) DmsFindCustomerTrackingLink(ctx context.Context, id pgtype.UUID) (DmsFindCustomerTrackingLinkRow, error) {
	row := q.db.QueryRow(ctx, dmsFindCustomerTrackingLink, id)
	var i DmsFindCustomerTrackingLinkRow
	err := row.Scan(
		&i.DmsCustomerTrackingLink.ID,
		&i.DmsCustomerTrackingLink.DeliveryTaskID,
		&i.DmsCustomerTrackingLink.TrackingToken,
		&i.DmsCustomerTrackingLink.IsActive,
		&i.DmsCustomerTrackingLink.AccessCount,
		&i.DmsCustomerTrackingLink.LastAccessedAt,
		&i.DmsCustomerTrackingLink.ExpiresAt,
		&i.DmsCustomerTrackingLink.CreatedAt,
		&i.DmsCustomerTrackingLink.UpdatedAt,
		&i.DmsDeliveryTask.ID,
		&i.DmsDeliveryTask.PackageID,
		&i.DmsDeliveryTask.DeliveryRouteID,
		&i.DmsDeliveryTask.RouteSequence,
		&i.DmsDeliveryTask.DeliveryAddress,
		&i.DmsDeliveryTask.RecipientName,
		&i.DmsDeliveryTask.RecipientPhone,
		&i.DmsDeliveryTask.DeliveryInstructions,
		&i.DmsDeliveryTask.EstimatedArrivalTime,
		&i.DmsDeliveryTask.ActualArrivalTime,
		&i.DmsDeliveryTask.DeliveryTime,
		&i.DmsDeliveryTask.Status,
		&i.DmsDeliveryTask.FailureReason,
		&i.DmsDeliveryTask.AttemptCount,
		&i.DmsDeliveryTask.CreatedAt,
		&i.DmsDeliveryTask.UpdatedAt,
	)
	return i, err
}

const dmsInsertCustomerTrackingLink = `-- name: DmsInsertCustomerTrackingLink :one
insert into "dms"."customer_tracking_links"(delivery_task_id, tracking_token, is_active, access_count, last_accessed_at, expires_at)
  values ($1, $2, $3, $4, $5, $6)
returning
  id, delivery_task_id, tracking_token, is_active, access_count, last_accessed_at, expires_at, created_at, updated_at
`

type DmsInsertCustomerTrackingLinkParams struct {
	DeliveryTaskID pgtype.UUID
	TrackingToken  string
	IsActive       pgtype.Bool
	AccessCount    pgtype.Int4
	LastAccessedAt pgtype.Timestamp
	ExpiresAt      pgtype.Timestamp
}

func (q *Queries) DmsInsertCustomerTrackingLink(ctx context.Context, arg DmsInsertCustomerTrackingLinkParams) (DmsCustomerTrackingLink, error) {
	row := q.db.QueryRow(ctx, dmsInsertCustomerTrackingLink,
		arg.DeliveryTaskID,
		arg.TrackingToken,
		arg.IsActive,
		arg.AccessCount,
		arg.LastAccessedAt,
		arg.ExpiresAt,
	)
	var i DmsCustomerTrackingLink
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.TrackingToken,
		&i.IsActive,
		&i.AccessCount,
		&i.LastAccessedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dmsPaginateCustomerTrackingLink = `-- name: DmsPaginateCustomerTrackingLink :many
select
  customer_tracking_links.id, customer_tracking_links.delivery_task_id, customer_tracking_links.tracking_token, customer_tracking_links.is_active, customer_tracking_links.access_count, customer_tracking_links.last_accessed_at, customer_tracking_links.expires_at, customer_tracking_links.created_at, customer_tracking_links.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."customer_tracking_links" as customer_tracking_links
  inner join "dms"."delivery_tasks" as delivery_task on customer_tracking_links.delivery_task_id = delivery_task.id
where
  (customer_tracking_links.tracking_token ilike $1::text
  or delivery_task.recipient_name ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type DmsPaginateCustomerTrackingLinkParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type DmsPaginateCustomerTrackingLinkRow struct {
	DmsCustomerTrackingLink DmsCustomerTrackingLink
	DmsDeliveryTask         DmsDeliveryTask
}

func (q *Queries) DmsPaginateCustomerTrackingLink(ctx context.Context, arg DmsPaginateCustomerTrackingLinkParams) ([]DmsPaginateCustomerTrackingLinkRow, error) {
	rows, err := q.db.Query(ctx, dmsPaginateCustomerTrackingLink, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsPaginateCustomerTrackingLinkRow
	for rows.Next() {
		var i DmsPaginateCustomerTrackingLinkRow
		if err := rows.Scan(
			&i.DmsCustomerTrackingLink.ID,
			&i.DmsCustomerTrackingLink.DeliveryTaskID,
			&i.DmsCustomerTrackingLink.TrackingToken,
			&i.DmsCustomerTrackingLink.IsActive,
			&i.DmsCustomerTrackingLink.AccessCount,
			&i.DmsCustomerTrackingLink.LastAccessedAt,
			&i.DmsCustomerTrackingLink.ExpiresAt,
			&i.DmsCustomerTrackingLink.CreatedAt,
			&i.DmsCustomerTrackingLink.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRangeCustomerTrackingLink = `-- name: DmsRangeCustomerTrackingLink :many
select
  customer_tracking_links.id, customer_tracking_links.delivery_task_id, customer_tracking_links.tracking_token, customer_tracking_links.is_active, customer_tracking_links.access_count, customer_tracking_links.last_accessed_at, customer_tracking_links.expires_at, customer_tracking_links.created_at, customer_tracking_links.updated_at,
  delivery_task.id, delivery_task.package_id, delivery_task.delivery_route_id, delivery_task.route_sequence, delivery_task.delivery_address, delivery_task.recipient_name, delivery_task.recipient_phone, delivery_task.delivery_instructions, delivery_task.estimated_arrival_time, delivery_task.actual_arrival_time, delivery_task.delivery_time, delivery_task.status, delivery_task.failure_reason, delivery_task.attempt_count, delivery_task.created_at, delivery_task.updated_at
from
  "dms"."customer_tracking_links" as customer_tracking_links
  inner join "dms"."delivery_tasks" as delivery_task on customer_tracking_links.delivery_task_id = delivery_task.id
where
  customer_tracking_links.created_at >= $1::date
  and customer_tracking_links.created_at <= $2::date
  and (customer_tracking_links.tracking_token ilike $3::text
  or delivery_task.recipient_name ilike $3::text
  or $3::text is null)
`

type DmsRangeCustomerTrackingLinkParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type DmsRangeCustomerTrackingLinkRow struct {
	DmsCustomerTrackingLink DmsCustomerTrackingLink
	DmsDeliveryTask         DmsDeliveryTask
}

func (q *Queries) DmsRangeCustomerTrackingLink(ctx context.Context, arg DmsRangeCustomerTrackingLinkParams) ([]DmsRangeCustomerTrackingLinkRow, error) {
	rows, err := q.db.Query(ctx, dmsRangeCustomerTrackingLink, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DmsRangeCustomerTrackingLinkRow
	for rows.Next() {
		var i DmsRangeCustomerTrackingLinkRow
		if err := rows.Scan(
			&i.DmsCustomerTrackingLink.ID,
			&i.DmsCustomerTrackingLink.DeliveryTaskID,
			&i.DmsCustomerTrackingLink.TrackingToken,
			&i.DmsCustomerTrackingLink.IsActive,
			&i.DmsCustomerTrackingLink.AccessCount,
			&i.DmsCustomerTrackingLink.LastAccessedAt,
			&i.DmsCustomerTrackingLink.ExpiresAt,
			&i.DmsCustomerTrackingLink.CreatedAt,
			&i.DmsCustomerTrackingLink.UpdatedAt,
			&i.DmsDeliveryTask.ID,
			&i.DmsDeliveryTask.PackageID,
			&i.DmsDeliveryTask.DeliveryRouteID,
			&i.DmsDeliveryTask.RouteSequence,
			&i.DmsDeliveryTask.DeliveryAddress,
			&i.DmsDeliveryTask.RecipientName,
			&i.DmsDeliveryTask.RecipientPhone,
			&i.DmsDeliveryTask.DeliveryInstructions,
			&i.DmsDeliveryTask.EstimatedArrivalTime,
			&i.DmsDeliveryTask.ActualArrivalTime,
			&i.DmsDeliveryTask.DeliveryTime,
			&i.DmsDeliveryTask.Status,
			&i.DmsDeliveryTask.FailureReason,
			&i.DmsDeliveryTask.AttemptCount,
			&i.DmsDeliveryTask.CreatedAt,
			&i.DmsDeliveryTask.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dmsRemoveCustomerTrackingLink = `-- name: DmsRemoveCustomerTrackingLink :exec
delete from "dms"."customer_tracking_links"
where id = $1::uuid
`

func (q *Queries) DmsRemoveCustomerTrackingLink(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, dmsRemoveCustomerTrackingLink, id)
	return err
}

const dmsUpdateCustomerTrackingLink = `-- name: DmsUpdateCustomerTrackingLink :one
update
  "dms"."customer_tracking_links"
set
  updated_at = now(),
  delivery_task_id = case when $1::boolean then
    $2::uuid
  else
    delivery_task_id
  end,
  tracking_token = case when $3::boolean then
    $4::varchar
  else
    tracking_token
  end,
  is_active = case when $5::boolean then
    $6::boolean
  else
    is_active
  end,
  access_count = case when $7::boolean then
    $8::integer
  else
    access_count
  end,
  last_accessed_at = case when $9::boolean then
    $10::timestamp
  else
    last_accessed_at
  end,
  expires_at = case when $11::boolean then
    $12::timestamp
  else
    expires_at
  end
where
  id = $13::uuid
returning
  id, delivery_task_id, tracking_token, is_active, access_count, last_accessed_at, expires_at, created_at, updated_at
`

type DmsUpdateCustomerTrackingLinkParams struct {
	SetDeliveryTaskID bool
	DeliveryTaskID    pgtype.UUID
	SetTrackingToken  bool
	TrackingToken     string
	SetIsActive       bool
	IsActive          bool
	SetAccessCount    bool
	AccessCount       int32
	SetLastAccessedAt bool
	LastAccessedAt    pgtype.Timestamp
	SetExpiresAt      bool
	ExpiresAt         pgtype.Timestamp
	ID                pgtype.UUID
}

func (q *Queries) DmsUpdateCustomerTrackingLink(ctx context.Context, arg DmsUpdateCustomerTrackingLinkParams) (DmsCustomerTrackingLink, error) {
	row := q.db.QueryRow(ctx, dmsUpdateCustomerTrackingLink,
		arg.SetDeliveryTaskID,
		arg.DeliveryTaskID,
		arg.SetTrackingToken,
		arg.TrackingToken,
		arg.SetIsActive,
		arg.IsActive,
		arg.SetAccessCount,
		arg.AccessCount,
		arg.SetLastAccessedAt,
		arg.LastAccessedAt,
		arg.SetExpiresAt,
		arg.ExpiresAt,
		arg.ID,
	)
	var i DmsCustomerTrackingLink
	err := row.Scan(
		&i.ID,
		&i.DeliveryTaskID,
		&i.TrackingToken,
		&i.IsActive,
		&i.AccessCount,
		&i.LastAccessedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
