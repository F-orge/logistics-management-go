// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_invoices.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyInvoice = `-- name: CrmAnyInvoice :many
select
  invoices.id, invoices.opportunity_id, invoices.status, invoices.total, invoices.issue_date, invoices.due_date, invoices.sent_at, invoices.paid_at, invoices.payment_method, invoices.created_at, invoices.updated_at, invoices.items,
  opportunity.id, opportunity.name, opportunity.stage, opportunity.deal_value, opportunity.probability, opportunity.expected_close_date, opportunity.lost_reason, opportunity.source, opportunity.owner_id, opportunity.contact_id, opportunity.company_id, opportunity.campaign_id, opportunity.created_at, opportunity.updated_at
from
  "crm"."invoices_view" as invoices
  left join "crm"."opportunities" as opportunity on invoices.opportunity_id = opportunity.id
where
  invoices.id = any ($1::uuid[])
`

type CrmAnyInvoiceRow struct {
	CrmInvoicesView CrmInvoicesView `db:"crm_invoices_view" json:"crm_invoices_view"`
	CrmOpportunity  CrmOpportunity  `db:"crm_opportunity" json:"crm_opportunity"`
}

func (q *Queries) CrmAnyInvoice(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyInvoiceRow, error) {
	rows, err := q.db.Query(ctx, crmAnyInvoice, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyInvoiceRow
	for rows.Next() {
		var i CrmAnyInvoiceRow
		if err := rows.Scan(
			&i.CrmInvoicesView.ID,
			&i.CrmInvoicesView.OpportunityID,
			&i.CrmInvoicesView.Status,
			&i.CrmInvoicesView.Total,
			&i.CrmInvoicesView.IssueDate,
			&i.CrmInvoicesView.DueDate,
			&i.CrmInvoicesView.SentAt,
			&i.CrmInvoicesView.PaidAt,
			&i.CrmInvoicesView.PaymentMethod,
			&i.CrmInvoicesView.CreatedAt,
			&i.CrmInvoicesView.UpdatedAt,
			&i.CrmInvoicesView.Items,
			&i.CrmOpportunity.ID,
			&i.CrmOpportunity.Name,
			&i.CrmOpportunity.Stage,
			&i.CrmOpportunity.DealValue,
			&i.CrmOpportunity.Probability,
			&i.CrmOpportunity.ExpectedCloseDate,
			&i.CrmOpportunity.LostReason,
			&i.CrmOpportunity.Source,
			&i.CrmOpportunity.OwnerID,
			&i.CrmOpportunity.ContactID,
			&i.CrmOpportunity.CompanyID,
			&i.CrmOpportunity.CampaignID,
			&i.CrmOpportunity.CreatedAt,
			&i.CrmOpportunity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindInvoice = `-- name: CrmFindInvoice :one
select
  invoices.id, invoices.opportunity_id, invoices.status, invoices.total, invoices.issue_date, invoices.due_date, invoices.sent_at, invoices.paid_at, invoices.payment_method, invoices.created_at, invoices.updated_at, invoices.items,
  opportunity.id, opportunity.name, opportunity.stage, opportunity.deal_value, opportunity.probability, opportunity.expected_close_date, opportunity.lost_reason, opportunity.source, opportunity.owner_id, opportunity.contact_id, opportunity.company_id, opportunity.campaign_id, opportunity.created_at, opportunity.updated_at
from
  "crm"."invoices_view" as invoices
  left join "crm"."opportunities" as opportunity on invoices.opportunity_id = opportunity.id
where
  invoices.id = $1::uuid
`

type CrmFindInvoiceRow struct {
	CrmInvoicesView CrmInvoicesView `db:"crm_invoices_view" json:"crm_invoices_view"`
	CrmOpportunity  CrmOpportunity  `db:"crm_opportunity" json:"crm_opportunity"`
}

func (q *Queries) CrmFindInvoice(ctx context.Context, id pgtype.UUID) (CrmFindInvoiceRow, error) {
	row := q.db.QueryRow(ctx, crmFindInvoice, id)
	var i CrmFindInvoiceRow
	err := row.Scan(
		&i.CrmInvoicesView.ID,
		&i.CrmInvoicesView.OpportunityID,
		&i.CrmInvoicesView.Status,
		&i.CrmInvoicesView.Total,
		&i.CrmInvoicesView.IssueDate,
		&i.CrmInvoicesView.DueDate,
		&i.CrmInvoicesView.SentAt,
		&i.CrmInvoicesView.PaidAt,
		&i.CrmInvoicesView.PaymentMethod,
		&i.CrmInvoicesView.CreatedAt,
		&i.CrmInvoicesView.UpdatedAt,
		&i.CrmInvoicesView.Items,
		&i.CrmOpportunity.ID,
		&i.CrmOpportunity.Name,
		&i.CrmOpportunity.Stage,
		&i.CrmOpportunity.DealValue,
		&i.CrmOpportunity.Probability,
		&i.CrmOpportunity.ExpectedCloseDate,
		&i.CrmOpportunity.LostReason,
		&i.CrmOpportunity.Source,
		&i.CrmOpportunity.OwnerID,
		&i.CrmOpportunity.ContactID,
		&i.CrmOpportunity.CompanyID,
		&i.CrmOpportunity.CampaignID,
		&i.CrmOpportunity.CreatedAt,
		&i.CrmOpportunity.UpdatedAt,
	)
	return i, err
}

const crmInsertInvoice = `-- name: CrmInsertInvoice :one
insert into "crm"."invoices"(opportunity_id, status, total, issue_date, due_date, sent_at, paid_at, payment_method)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, opportunity_id, status, total, issue_date, due_date, sent_at, paid_at, payment_method, created_at, updated_at
`

type CrmInsertInvoiceParams struct {
	OpportunityID pgtype.UUID          `db:"opportunity_id" json:"opportunity_id"`
	Status        NullCrmInvoiceStatus `db:"status" json:"status"`
	Total         pgtype.Numeric       `db:"total" json:"total"`
	IssueDate     pgtype.Date          `db:"issue_date" json:"issue_date"`
	DueDate       pgtype.Date          `db:"due_date" json:"due_date"`
	SentAt        pgtype.Timestamptz   `db:"sent_at" json:"sent_at"`
	PaidAt        pgtype.Timestamptz   `db:"paid_at" json:"paid_at"`
	PaymentMethod NullCrmPaymentMethod `db:"payment_method" json:"payment_method"`
}

func (q *Queries) CrmInsertInvoice(ctx context.Context, arg CrmInsertInvoiceParams) (CrmInvoice, error) {
	row := q.db.QueryRow(ctx, crmInsertInvoice,
		arg.OpportunityID,
		arg.Status,
		arg.Total,
		arg.IssueDate,
		arg.DueDate,
		arg.SentAt,
		arg.PaidAt,
		arg.PaymentMethod,
	)
	var i CrmInvoice
	err := row.Scan(
		&i.ID,
		&i.OpportunityID,
		&i.Status,
		&i.Total,
		&i.IssueDate,
		&i.DueDate,
		&i.SentAt,
		&i.PaidAt,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateInvoice = `-- name: CrmPaginateInvoice :many
select
  invoices.id, invoices.opportunity_id, invoices.status, invoices.total, invoices.issue_date, invoices.due_date, invoices.sent_at, invoices.paid_at, invoices.payment_method, invoices.created_at, invoices.updated_at, invoices.items,
  opportunity.id, opportunity.name, opportunity.stage, opportunity.deal_value, opportunity.probability, opportunity.expected_close_date, opportunity.lost_reason, opportunity.source, opportunity.owner_id, opportunity.contact_id, opportunity.company_id, opportunity.campaign_id, opportunity.created_at, opportunity.updated_at
from
  "crm"."invoices_view" as invoices
  left join "crm"."opportunities" as opportunity on invoices.opportunity_id = opportunity.id
where (opportunity.name ilike $1::text
  or invoices.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateInvoiceParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type CrmPaginateInvoiceRow struct {
	CrmInvoicesView CrmInvoicesView `db:"crm_invoices_view" json:"crm_invoices_view"`
	CrmOpportunity  CrmOpportunity  `db:"crm_opportunity" json:"crm_opportunity"`
}

func (q *Queries) CrmPaginateInvoice(ctx context.Context, arg CrmPaginateInvoiceParams) ([]CrmPaginateInvoiceRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateInvoice, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateInvoiceRow
	for rows.Next() {
		var i CrmPaginateInvoiceRow
		if err := rows.Scan(
			&i.CrmInvoicesView.ID,
			&i.CrmInvoicesView.OpportunityID,
			&i.CrmInvoicesView.Status,
			&i.CrmInvoicesView.Total,
			&i.CrmInvoicesView.IssueDate,
			&i.CrmInvoicesView.DueDate,
			&i.CrmInvoicesView.SentAt,
			&i.CrmInvoicesView.PaidAt,
			&i.CrmInvoicesView.PaymentMethod,
			&i.CrmInvoicesView.CreatedAt,
			&i.CrmInvoicesView.UpdatedAt,
			&i.CrmInvoicesView.Items,
			&i.CrmOpportunity.ID,
			&i.CrmOpportunity.Name,
			&i.CrmOpportunity.Stage,
			&i.CrmOpportunity.DealValue,
			&i.CrmOpportunity.Probability,
			&i.CrmOpportunity.ExpectedCloseDate,
			&i.CrmOpportunity.LostReason,
			&i.CrmOpportunity.Source,
			&i.CrmOpportunity.OwnerID,
			&i.CrmOpportunity.ContactID,
			&i.CrmOpportunity.CompanyID,
			&i.CrmOpportunity.CampaignID,
			&i.CrmOpportunity.CreatedAt,
			&i.CrmOpportunity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeInvoice = `-- name: CrmRangeInvoice :many
select
  invoices.id, invoices.opportunity_id, invoices.status, invoices.total, invoices.issue_date, invoices.due_date, invoices.sent_at, invoices.paid_at, invoices.payment_method, invoices.created_at, invoices.updated_at, invoices.items,
  opportunity.id, opportunity.name, opportunity.stage, opportunity.deal_value, opportunity.probability, opportunity.expected_close_date, opportunity.lost_reason, opportunity.source, opportunity.owner_id, opportunity.contact_id, opportunity.company_id, opportunity.campaign_id, opportunity.created_at, opportunity.updated_at
from
  "crm"."invoices_view" as invoices
  left join "crm"."opportunities" as opportunity on invoices.opportunity_id = opportunity.id
where
  invoices.created_at >= $1::date
  and invoices.created_at <= $2::date
  and (opportunity.name ilike $3::text
    or invoices.status::text ilike $3::text
    or $3::text is null)
`

type CrmRangeInvoiceParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type CrmRangeInvoiceRow struct {
	CrmInvoicesView CrmInvoicesView `db:"crm_invoices_view" json:"crm_invoices_view"`
	CrmOpportunity  CrmOpportunity  `db:"crm_opportunity" json:"crm_opportunity"`
}

func (q *Queries) CrmRangeInvoice(ctx context.Context, arg CrmRangeInvoiceParams) ([]CrmRangeInvoiceRow, error) {
	rows, err := q.db.Query(ctx, crmRangeInvoice, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeInvoiceRow
	for rows.Next() {
		var i CrmRangeInvoiceRow
		if err := rows.Scan(
			&i.CrmInvoicesView.ID,
			&i.CrmInvoicesView.OpportunityID,
			&i.CrmInvoicesView.Status,
			&i.CrmInvoicesView.Total,
			&i.CrmInvoicesView.IssueDate,
			&i.CrmInvoicesView.DueDate,
			&i.CrmInvoicesView.SentAt,
			&i.CrmInvoicesView.PaidAt,
			&i.CrmInvoicesView.PaymentMethod,
			&i.CrmInvoicesView.CreatedAt,
			&i.CrmInvoicesView.UpdatedAt,
			&i.CrmInvoicesView.Items,
			&i.CrmOpportunity.ID,
			&i.CrmOpportunity.Name,
			&i.CrmOpportunity.Stage,
			&i.CrmOpportunity.DealValue,
			&i.CrmOpportunity.Probability,
			&i.CrmOpportunity.ExpectedCloseDate,
			&i.CrmOpportunity.LostReason,
			&i.CrmOpportunity.Source,
			&i.CrmOpportunity.OwnerID,
			&i.CrmOpportunity.ContactID,
			&i.CrmOpportunity.CompanyID,
			&i.CrmOpportunity.CampaignID,
			&i.CrmOpportunity.CreatedAt,
			&i.CrmOpportunity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveInvoice = `-- name: CrmRemoveInvoice :exec
delete from "crm"."invoices"
where id = $1::uuid
`

func (q *Queries) CrmRemoveInvoice(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveInvoice, id)
	return err
}

const crmUpdateInvoice = `-- name: CrmUpdateInvoice :one
update
  "crm"."invoices"
set
  updated_at = now(),
  opportunity_id = case when $1 is not null then
    $1::uuid
  else
    opportunity_id
  end,
  status = case when $2 is not null then
    $2::crm.invoice_status
  else
    status
  end,
  total = case when $3 is not null then
    $3::numeric
  else
    total
  end,
  issue_date = case when $4 is not null then
    $4::date
  else
    issue_date
  end,
  due_date = case when $5 is not null then
    $5::date
  else
    due_date
  end,
  sent_at = case when $6 is not null then
    $6::timestamptz
  else
    sent_at
  end,
  paid_at = case when $7 is not null then
    $7::timestamptz
  else
    paid_at
  end,
  payment_method = case when $8 is not null then
    $8::crm.payment_method
  else
    payment_method
  end
where
  id = $9::uuid
returning
  id, opportunity_id, status, total, issue_date, due_date, sent_at, paid_at, payment_method, created_at, updated_at
`

type CrmUpdateInvoiceParams struct {
	OpportunityID pgtype.UUID          `db:"opportunity_id" json:"opportunity_id"`
	Status        NullCrmInvoiceStatus `db:"status" json:"status"`
	Total         pgtype.Numeric       `db:"total" json:"total"`
	IssueDate     pgtype.Date          `db:"issue_date" json:"issue_date"`
	DueDate       pgtype.Date          `db:"due_date" json:"due_date"`
	SentAt        pgtype.Timestamptz   `db:"sent_at" json:"sent_at"`
	PaidAt        pgtype.Timestamptz   `db:"paid_at" json:"paid_at"`
	PaymentMethod NullCrmPaymentMethod `db:"payment_method" json:"payment_method"`
	ID            pgtype.UUID          `db:"id" json:"id"`
}

func (q *Queries) CrmUpdateInvoice(ctx context.Context, arg CrmUpdateInvoiceParams) (CrmInvoice, error) {
	row := q.db.QueryRow(ctx, crmUpdateInvoice,
		arg.OpportunityID,
		arg.Status,
		arg.Total,
		arg.IssueDate,
		arg.DueDate,
		arg.SentAt,
		arg.PaidAt,
		arg.PaymentMethod,
		arg.ID,
	)
	var i CrmInvoice
	err := row.Scan(
		&i.ID,
		&i.OpportunityID,
		&i.Status,
		&i.Total,
		&i.IssueDate,
		&i.DueDate,
		&i.SentAt,
		&i.PaidAt,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
