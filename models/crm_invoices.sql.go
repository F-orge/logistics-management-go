// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_invoices.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyInvoice = `-- name: CrmAnyInvoice :many
select
  invoices.id, invoices.opportunity_id, invoices.status, invoices.total, invoices.issue_date, invoices.due_date, invoices.sent_at, invoices.paid_at, invoices.payment_method, invoices.created_at, invoices.updated_at,
  opportunity.id, opportunity.name, opportunity.stage, opportunity.deal_value, opportunity.probability, opportunity.expected_close_date, opportunity.lost_reason, opportunity.source, opportunity.owner_id, opportunity.contact_id, opportunity.company_id, opportunity.campaign_id, opportunity.created_at, opportunity.updated_at
from
  "crm"."invoices" as invoices
  left join "crm"."opportunities" as opportunity on invoices.opportunity_id = opportunity.id
where
  invoices.id = any ($1::uuid[])
`

type CrmAnyInvoiceRow struct {
	CrmInvoice     CrmInvoice
	CrmOpportunity CrmOpportunity
}

func (q *Queries) CrmAnyInvoice(ctx context.Context, ids []pgtype.UUID) ([]CrmAnyInvoiceRow, error) {
	rows, err := q.db.Query(ctx, crmAnyInvoice, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmAnyInvoiceRow
	for rows.Next() {
		var i CrmAnyInvoiceRow
		if err := rows.Scan(
			&i.CrmInvoice.ID,
			&i.CrmInvoice.OpportunityID,
			&i.CrmInvoice.Status,
			&i.CrmInvoice.Total,
			&i.CrmInvoice.IssueDate,
			&i.CrmInvoice.DueDate,
			&i.CrmInvoice.SentAt,
			&i.CrmInvoice.PaidAt,
			&i.CrmInvoice.PaymentMethod,
			&i.CrmInvoice.CreatedAt,
			&i.CrmInvoice.UpdatedAt,
			&i.CrmOpportunity.ID,
			&i.CrmOpportunity.Name,
			&i.CrmOpportunity.Stage,
			&i.CrmOpportunity.DealValue,
			&i.CrmOpportunity.Probability,
			&i.CrmOpportunity.ExpectedCloseDate,
			&i.CrmOpportunity.LostReason,
			&i.CrmOpportunity.Source,
			&i.CrmOpportunity.OwnerID,
			&i.CrmOpportunity.ContactID,
			&i.CrmOpportunity.CompanyID,
			&i.CrmOpportunity.CampaignID,
			&i.CrmOpportunity.CreatedAt,
			&i.CrmOpportunity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindInvoice = `-- name: CrmFindInvoice :one
select
  invoices.id, invoices.opportunity_id, invoices.status, invoices.total, invoices.issue_date, invoices.due_date, invoices.sent_at, invoices.paid_at, invoices.payment_method, invoices.created_at, invoices.updated_at,
  opportunity.id, opportunity.name, opportunity.stage, opportunity.deal_value, opportunity.probability, opportunity.expected_close_date, opportunity.lost_reason, opportunity.source, opportunity.owner_id, opportunity.contact_id, opportunity.company_id, opportunity.campaign_id, opportunity.created_at, opportunity.updated_at
from
  "crm"."invoices" as invoices
  left join "crm"."opportunities" as opportunity on invoices.opportunity_id = opportunity.id
where
  invoices.id = $1::uuid
`

type CrmFindInvoiceRow struct {
	CrmInvoice     CrmInvoice
	CrmOpportunity CrmOpportunity
}

func (q *Queries) CrmFindInvoice(ctx context.Context, id pgtype.UUID) (CrmFindInvoiceRow, error) {
	row := q.db.QueryRow(ctx, crmFindInvoice, id)
	var i CrmFindInvoiceRow
	err := row.Scan(
		&i.CrmInvoice.ID,
		&i.CrmInvoice.OpportunityID,
		&i.CrmInvoice.Status,
		&i.CrmInvoice.Total,
		&i.CrmInvoice.IssueDate,
		&i.CrmInvoice.DueDate,
		&i.CrmInvoice.SentAt,
		&i.CrmInvoice.PaidAt,
		&i.CrmInvoice.PaymentMethod,
		&i.CrmInvoice.CreatedAt,
		&i.CrmInvoice.UpdatedAt,
		&i.CrmOpportunity.ID,
		&i.CrmOpportunity.Name,
		&i.CrmOpportunity.Stage,
		&i.CrmOpportunity.DealValue,
		&i.CrmOpportunity.Probability,
		&i.CrmOpportunity.ExpectedCloseDate,
		&i.CrmOpportunity.LostReason,
		&i.CrmOpportunity.Source,
		&i.CrmOpportunity.OwnerID,
		&i.CrmOpportunity.ContactID,
		&i.CrmOpportunity.CompanyID,
		&i.CrmOpportunity.CampaignID,
		&i.CrmOpportunity.CreatedAt,
		&i.CrmOpportunity.UpdatedAt,
	)
	return i, err
}

const crmInsertInvoice = `-- name: CrmInsertInvoice :one
insert into "crm"."invoices"(opportunity_id, status, total, issue_date, due_date, sent_at, paid_at, payment_method)
  values ($1, $2, $3, $4, $5, $6, $7, $8)
returning
  id, opportunity_id, status, total, issue_date, due_date, sent_at, paid_at, payment_method, created_at, updated_at
`

type CrmInsertInvoiceParams struct {
	OpportunityID pgtype.UUID
	Status        NullCrmInvoiceStatus
	Total         pgtype.Numeric
	IssueDate     pgtype.Date
	DueDate       pgtype.Date
	SentAt        pgtype.Timestamptz
	PaidAt        pgtype.Timestamptz
	PaymentMethod NullCrmPaymentMethod
}

func (q *Queries) CrmInsertInvoice(ctx context.Context, arg CrmInsertInvoiceParams) (CrmInvoice, error) {
	row := q.db.QueryRow(ctx, crmInsertInvoice,
		arg.OpportunityID,
		arg.Status,
		arg.Total,
		arg.IssueDate,
		arg.DueDate,
		arg.SentAt,
		arg.PaidAt,
		arg.PaymentMethod,
	)
	var i CrmInvoice
	err := row.Scan(
		&i.ID,
		&i.OpportunityID,
		&i.Status,
		&i.Total,
		&i.IssueDate,
		&i.DueDate,
		&i.SentAt,
		&i.PaidAt,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateInvoice = `-- name: CrmPaginateInvoice :many
select
  invoices.id, invoices.opportunity_id, invoices.status, invoices.total, invoices.issue_date, invoices.due_date, invoices.sent_at, invoices.paid_at, invoices.payment_method, invoices.created_at, invoices.updated_at,
  opportunity.id, opportunity.name, opportunity.stage, opportunity.deal_value, opportunity.probability, opportunity.expected_close_date, opportunity.lost_reason, opportunity.source, opportunity.owner_id, opportunity.contact_id, opportunity.company_id, opportunity.campaign_id, opportunity.created_at, opportunity.updated_at
from
  "crm"."invoices" as invoices
  left join "crm"."opportunities" as opportunity on invoices.opportunity_id = opportunity.id
where (opportunity.name ilike $1::text
  or invoices.status::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateInvoiceParams struct {
	Search  pgtype.Text
	Page    int32
	Perpage int32
}

type CrmPaginateInvoiceRow struct {
	CrmInvoice     CrmInvoice
	CrmOpportunity CrmOpportunity
}

func (q *Queries) CrmPaginateInvoice(ctx context.Context, arg CrmPaginateInvoiceParams) ([]CrmPaginateInvoiceRow, error) {
	rows, err := q.db.Query(ctx, crmPaginateInvoice, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmPaginateInvoiceRow
	for rows.Next() {
		var i CrmPaginateInvoiceRow
		if err := rows.Scan(
			&i.CrmInvoice.ID,
			&i.CrmInvoice.OpportunityID,
			&i.CrmInvoice.Status,
			&i.CrmInvoice.Total,
			&i.CrmInvoice.IssueDate,
			&i.CrmInvoice.DueDate,
			&i.CrmInvoice.SentAt,
			&i.CrmInvoice.PaidAt,
			&i.CrmInvoice.PaymentMethod,
			&i.CrmInvoice.CreatedAt,
			&i.CrmInvoice.UpdatedAt,
			&i.CrmOpportunity.ID,
			&i.CrmOpportunity.Name,
			&i.CrmOpportunity.Stage,
			&i.CrmOpportunity.DealValue,
			&i.CrmOpportunity.Probability,
			&i.CrmOpportunity.ExpectedCloseDate,
			&i.CrmOpportunity.LostReason,
			&i.CrmOpportunity.Source,
			&i.CrmOpportunity.OwnerID,
			&i.CrmOpportunity.ContactID,
			&i.CrmOpportunity.CompanyID,
			&i.CrmOpportunity.CampaignID,
			&i.CrmOpportunity.CreatedAt,
			&i.CrmOpportunity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeInvoice = `-- name: CrmRangeInvoice :many
select
  invoices.id, invoices.opportunity_id, invoices.status, invoices.total, invoices.issue_date, invoices.due_date, invoices.sent_at, invoices.paid_at, invoices.payment_method, invoices.created_at, invoices.updated_at,
  opportunity.id, opportunity.name, opportunity.stage, opportunity.deal_value, opportunity.probability, opportunity.expected_close_date, opportunity.lost_reason, opportunity.source, opportunity.owner_id, opportunity.contact_id, opportunity.company_id, opportunity.campaign_id, opportunity.created_at, opportunity.updated_at
from
  "crm"."invoices" as invoices
  left join "crm"."opportunities" as opportunity on invoices.opportunity_id = opportunity.id
where
  invoices.created_at >= $1::date
  and invoices.created_at <= $2::date
  and (opportunity.name ilike $3::text
    or invoices.status::text ilike $3::text
    or $3::text is null)
`

type CrmRangeInvoiceParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
	Search   pgtype.Text
}

type CrmRangeInvoiceRow struct {
	CrmInvoice     CrmInvoice
	CrmOpportunity CrmOpportunity
}

func (q *Queries) CrmRangeInvoice(ctx context.Context, arg CrmRangeInvoiceParams) ([]CrmRangeInvoiceRow, error) {
	rows, err := q.db.Query(ctx, crmRangeInvoice, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmRangeInvoiceRow
	for rows.Next() {
		var i CrmRangeInvoiceRow
		if err := rows.Scan(
			&i.CrmInvoice.ID,
			&i.CrmInvoice.OpportunityID,
			&i.CrmInvoice.Status,
			&i.CrmInvoice.Total,
			&i.CrmInvoice.IssueDate,
			&i.CrmInvoice.DueDate,
			&i.CrmInvoice.SentAt,
			&i.CrmInvoice.PaidAt,
			&i.CrmInvoice.PaymentMethod,
			&i.CrmInvoice.CreatedAt,
			&i.CrmInvoice.UpdatedAt,
			&i.CrmOpportunity.ID,
			&i.CrmOpportunity.Name,
			&i.CrmOpportunity.Stage,
			&i.CrmOpportunity.DealValue,
			&i.CrmOpportunity.Probability,
			&i.CrmOpportunity.ExpectedCloseDate,
			&i.CrmOpportunity.LostReason,
			&i.CrmOpportunity.Source,
			&i.CrmOpportunity.OwnerID,
			&i.CrmOpportunity.ContactID,
			&i.CrmOpportunity.CompanyID,
			&i.CrmOpportunity.CampaignID,
			&i.CrmOpportunity.CreatedAt,
			&i.CrmOpportunity.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveInvoice = `-- name: CrmRemoveInvoice :exec
delete from "crm"."invoices"
where id = $1::uuid
`

func (q *Queries) CrmRemoveInvoice(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveInvoice, id)
	return err
}

const crmUpdateInvoice = `-- name: CrmUpdateInvoice :one
update
  "crm"."invoices"
set
  updated_at = now(),
  opportunity_id = case when $1::boolean then
    $2::uuid
  else
    opportunity_id
  end,
  status = case when $3::boolean then
    $4::crm.invoice_status
  else
    status
  end,
  total = case when $5::boolean then
    $6::numeric
  else
    total
  end,
  issue_date = case when $7::boolean then
    $8::date
  else
    issue_date
  end,
  due_date = case when $9::boolean then
    $10::date
  else
    due_date
  end,
  sent_at = case when $11::boolean then
    $12::timestamptz
  else
    sent_at
  end,
  paid_at = case when $13::boolean then
    $14::timestamptz
  else
    paid_at
  end,
  payment_method = case when $15::boolean then
    $16::crm.payment_method
  else
    payment_method
  end
where
  id = $17::uuid
returning
  id, opportunity_id, status, total, issue_date, due_date, sent_at, paid_at, payment_method, created_at, updated_at
`

type CrmUpdateInvoiceParams struct {
	SetOpportunityID bool
	OpportunityID    pgtype.UUID
	SetStatus        bool
	Status           CrmInvoiceStatus
	SetTotal         bool
	Total            pgtype.Numeric
	SetIssueDate     bool
	IssueDate        pgtype.Date
	SetDueDate       bool
	DueDate          pgtype.Date
	SetSentAt        bool
	SentAt           pgtype.Timestamptz
	SetPaidAt        bool
	PaidAt           pgtype.Timestamptz
	SetPaymentMethod bool
	PaymentMethod    CrmPaymentMethod
	ID               pgtype.UUID
}

func (q *Queries) CrmUpdateInvoice(ctx context.Context, arg CrmUpdateInvoiceParams) (CrmInvoice, error) {
	row := q.db.QueryRow(ctx, crmUpdateInvoice,
		arg.SetOpportunityID,
		arg.OpportunityID,
		arg.SetStatus,
		arg.Status,
		arg.SetTotal,
		arg.Total,
		arg.SetIssueDate,
		arg.IssueDate,
		arg.SetDueDate,
		arg.DueDate,
		arg.SetSentAt,
		arg.SentAt,
		arg.SetPaidAt,
		arg.PaidAt,
		arg.SetPaymentMethod,
		arg.PaymentMethod,
		arg.ID,
	)
	var i CrmInvoice
	err := row.Scan(
		&i.ID,
		&i.OpportunityID,
		&i.Status,
		&i.Total,
		&i.IssueDate,
		&i.DueDate,
		&i.SentAt,
		&i.PaidAt,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
