// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tms_proof_of_deliveries.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const tmsAnyProofOfDelivery = `-- name: TmsAnyProofOfDelivery :many
select
  proof_of_deliveries.id, proof_of_deliveries.trip_stop_id, proof_of_deliveries.type, proof_of_deliveries.file_path, proof_of_deliveries.timestamp, proof_of_deliveries.latitude, proof_of_deliveries.longitude, proof_of_deliveries.created_at, proof_of_deliveries.updated_at,
  trip_stop.id, trip_stop.trip_id, trip_stop.shipment_id, trip_stop.sequence, trip_stop.address, trip_stop.status, trip_stop.estimated_arrival_time, trip_stop.actual_arrival_time, trip_stop.estimated_departure_time, trip_stop.actual_departure_time, trip_stop.created_at, trip_stop.updated_at
from
  "tms"."proof_of_deliveries" as proof_of_deliveries
  inner join "tms"."trip_stops" as trip_stop on proof_of_deliveries.trip_stop_id = trip_stop.id
where
  proof_of_deliveries.id = any ($1::uuid[])
`

type TmsAnyProofOfDeliveryRow struct {
	ID          pgtype.UUID          `db:"id" json:"id"`
	TripStopID  pgtype.UUID          `db:"trip_stop_id" json:"trip_stop_id"`
	Type        NullTmsProofTypeEnum `db:"type" json:"type"`
	FilePath    pgtype.Text          `db:"file_path" json:"file_path"`
	Timestamp   pgtype.Timestamp     `db:"timestamp" json:"timestamp"`
	Latitude    pgtype.Float4        `db:"latitude" json:"latitude"`
	Longitude   pgtype.Float4        `db:"longitude" json:"longitude"`
	CreatedAt   pgtype.Timestamp     `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp     `db:"updated_at" json:"updated_at"`
	TmsTripStop TmsTripStop          `db:"tms_trip_stop" json:"tms_trip_stop"`
}

func (q *Queries) TmsAnyProofOfDelivery(ctx context.Context, ids []pgtype.UUID) ([]TmsAnyProofOfDeliveryRow, error) {
	rows, err := q.db.Query(ctx, tmsAnyProofOfDelivery, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsAnyProofOfDeliveryRow
	for rows.Next() {
		var i TmsAnyProofOfDeliveryRow
		if err := rows.Scan(
			&i.ID,
			&i.TripStopID,
			&i.Type,
			&i.FilePath,
			&i.Timestamp,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsTripStop.ID,
			&i.TmsTripStop.TripID,
			&i.TmsTripStop.ShipmentID,
			&i.TmsTripStop.Sequence,
			&i.TmsTripStop.Address,
			&i.TmsTripStop.Status,
			&i.TmsTripStop.EstimatedArrivalTime,
			&i.TmsTripStop.ActualArrivalTime,
			&i.TmsTripStop.EstimatedDepartureTime,
			&i.TmsTripStop.ActualDepartureTime,
			&i.TmsTripStop.CreatedAt,
			&i.TmsTripStop.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsFindProofOfDelivery = `-- name: TmsFindProofOfDelivery :one
select
  proof_of_deliveries.id, proof_of_deliveries.trip_stop_id, proof_of_deliveries.type, proof_of_deliveries.file_path, proof_of_deliveries.timestamp, proof_of_deliveries.latitude, proof_of_deliveries.longitude, proof_of_deliveries.created_at, proof_of_deliveries.updated_at,
  trip_stop.id, trip_stop.trip_id, trip_stop.shipment_id, trip_stop.sequence, trip_stop.address, trip_stop.status, trip_stop.estimated_arrival_time, trip_stop.actual_arrival_time, trip_stop.estimated_departure_time, trip_stop.actual_departure_time, trip_stop.created_at, trip_stop.updated_at
from
  "tms"."proof_of_deliveries" as proof_of_deliveries
  inner join "tms"."trip_stops" as trip_stop on proof_of_deliveries.trip_stop_id = trip_stop.id
where
  proof_of_deliveries.id = $1::uuid
`

type TmsFindProofOfDeliveryRow struct {
	ID          pgtype.UUID          `db:"id" json:"id"`
	TripStopID  pgtype.UUID          `db:"trip_stop_id" json:"trip_stop_id"`
	Type        NullTmsProofTypeEnum `db:"type" json:"type"`
	FilePath    pgtype.Text          `db:"file_path" json:"file_path"`
	Timestamp   pgtype.Timestamp     `db:"timestamp" json:"timestamp"`
	Latitude    pgtype.Float4        `db:"latitude" json:"latitude"`
	Longitude   pgtype.Float4        `db:"longitude" json:"longitude"`
	CreatedAt   pgtype.Timestamp     `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp     `db:"updated_at" json:"updated_at"`
	TmsTripStop TmsTripStop          `db:"tms_trip_stop" json:"tms_trip_stop"`
}

func (q *Queries) TmsFindProofOfDelivery(ctx context.Context, id pgtype.UUID) (TmsFindProofOfDeliveryRow, error) {
	row := q.db.QueryRow(ctx, tmsFindProofOfDelivery, id)
	var i TmsFindProofOfDeliveryRow
	err := row.Scan(
		&i.ID,
		&i.TripStopID,
		&i.Type,
		&i.FilePath,
		&i.Timestamp,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TmsTripStop.ID,
		&i.TmsTripStop.TripID,
		&i.TmsTripStop.ShipmentID,
		&i.TmsTripStop.Sequence,
		&i.TmsTripStop.Address,
		&i.TmsTripStop.Status,
		&i.TmsTripStop.EstimatedArrivalTime,
		&i.TmsTripStop.ActualArrivalTime,
		&i.TmsTripStop.EstimatedDepartureTime,
		&i.TmsTripStop.ActualDepartureTime,
		&i.TmsTripStop.CreatedAt,
		&i.TmsTripStop.UpdatedAt,
	)
	return i, err
}

const tmsInsertProofOfDelivery = `-- name: TmsInsertProofOfDelivery :one
insert into "tms"."proof_of_deliveries"(trip_stop_id, type, file_path, timestamp, latitude, longitude)
  values ($1, $2, $3, $4, $5, $6)
returning
  id, trip_stop_id, type, file_path, timestamp, latitude, longitude, created_at, updated_at
`

type TmsInsertProofOfDeliveryParams struct {
	TripStopID pgtype.UUID          `db:"trip_stop_id" json:"trip_stop_id"`
	Type       NullTmsProofTypeEnum `db:"type" json:"type"`
	FilePath   pgtype.Text          `db:"file_path" json:"file_path"`
	Timestamp  pgtype.Timestamp     `db:"timestamp" json:"timestamp"`
	Latitude   pgtype.Float4        `db:"latitude" json:"latitude"`
	Longitude  pgtype.Float4        `db:"longitude" json:"longitude"`
}

func (q *Queries) TmsInsertProofOfDelivery(ctx context.Context, arg TmsInsertProofOfDeliveryParams) (TmsProofOfDelivery, error) {
	row := q.db.QueryRow(ctx, tmsInsertProofOfDelivery,
		arg.TripStopID,
		arg.Type,
		arg.FilePath,
		arg.Timestamp,
		arg.Latitude,
		arg.Longitude,
	)
	var i TmsProofOfDelivery
	err := row.Scan(
		&i.ID,
		&i.TripStopID,
		&i.Type,
		&i.FilePath,
		&i.Timestamp,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tmsPaginateProofOfDelivery = `-- name: TmsPaginateProofOfDelivery :many
select
  proof_of_deliveries.id, proof_of_deliveries.trip_stop_id, proof_of_deliveries.type, proof_of_deliveries.file_path, proof_of_deliveries.timestamp, proof_of_deliveries.latitude, proof_of_deliveries.longitude, proof_of_deliveries.created_at, proof_of_deliveries.updated_at,
  trip_stop.id, trip_stop.trip_id, trip_stop.shipment_id, trip_stop.sequence, trip_stop.address, trip_stop.status, trip_stop.estimated_arrival_time, trip_stop.actual_arrival_time, trip_stop.estimated_departure_time, trip_stop.actual_departure_time, trip_stop.created_at, trip_stop.updated_at
from
  "tms"."proof_of_deliveries" as proof_of_deliveries
  inner join "tms"."trip_stops" as trip_stop on proof_of_deliveries.trip_stop_id = trip_stop.id
where (trip_stop.address ilike $1::text
  or proof_of_deliveries.type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type TmsPaginateProofOfDeliveryParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	PerPage int32       `db:"per_page" json:"per_page"`
}

type TmsPaginateProofOfDeliveryRow struct {
	ID          pgtype.UUID          `db:"id" json:"id"`
	TripStopID  pgtype.UUID          `db:"trip_stop_id" json:"trip_stop_id"`
	Type        NullTmsProofTypeEnum `db:"type" json:"type"`
	FilePath    pgtype.Text          `db:"file_path" json:"file_path"`
	Timestamp   pgtype.Timestamp     `db:"timestamp" json:"timestamp"`
	Latitude    pgtype.Float4        `db:"latitude" json:"latitude"`
	Longitude   pgtype.Float4        `db:"longitude" json:"longitude"`
	CreatedAt   pgtype.Timestamp     `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp     `db:"updated_at" json:"updated_at"`
	TmsTripStop TmsTripStop          `db:"tms_trip_stop" json:"tms_trip_stop"`
}

func (q *Queries) TmsPaginateProofOfDelivery(ctx context.Context, arg TmsPaginateProofOfDeliveryParams) ([]TmsPaginateProofOfDeliveryRow, error) {
	rows, err := q.db.Query(ctx, tmsPaginateProofOfDelivery, arg.Search, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsPaginateProofOfDeliveryRow
	for rows.Next() {
		var i TmsPaginateProofOfDeliveryRow
		if err := rows.Scan(
			&i.ID,
			&i.TripStopID,
			&i.Type,
			&i.FilePath,
			&i.Timestamp,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsTripStop.ID,
			&i.TmsTripStop.TripID,
			&i.TmsTripStop.ShipmentID,
			&i.TmsTripStop.Sequence,
			&i.TmsTripStop.Address,
			&i.TmsTripStop.Status,
			&i.TmsTripStop.EstimatedArrivalTime,
			&i.TmsTripStop.ActualArrivalTime,
			&i.TmsTripStop.EstimatedDepartureTime,
			&i.TmsTripStop.ActualDepartureTime,
			&i.TmsTripStop.CreatedAt,
			&i.TmsTripStop.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsPaginateProofOfDeliveryMetadata = `-- name: TmsPaginateProofOfDeliveryMetadata :one
select
  count(*) over () as total_items,
  ceil(count(*) over ()::numeric / NULLIF($1::int, 0)) as total_pages,
  $2::int as page,
  $1::int as per_page
from
  "tms"."proof_of_deliveries" as proof_of_deliveries
`

type TmsPaginateProofOfDeliveryMetadataParams struct {
	PerPage int32 `db:"per_page" json:"per_page"`
	Page    int32 `db:"page" json:"page"`
}

type TmsPaginateProofOfDeliveryMetadataRow struct {
	TotalItems int64   `db:"total_items" json:"total_items"`
	TotalPages float64 `db:"total_pages" json:"total_pages"`
	Page       int32   `db:"page" json:"page"`
	PerPage    int32   `db:"per_page" json:"per_page"`
}

func (q *Queries) TmsPaginateProofOfDeliveryMetadata(ctx context.Context, arg TmsPaginateProofOfDeliveryMetadataParams) (TmsPaginateProofOfDeliveryMetadataRow, error) {
	row := q.db.QueryRow(ctx, tmsPaginateProofOfDeliveryMetadata, arg.PerPage, arg.Page)
	var i TmsPaginateProofOfDeliveryMetadataRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalPages,
		&i.Page,
		&i.PerPage,
	)
	return i, err
}

const tmsRangeProofOfDelivery = `-- name: TmsRangeProofOfDelivery :many
select
  proof_of_deliveries.id, proof_of_deliveries.trip_stop_id, proof_of_deliveries.type, proof_of_deliveries.file_path, proof_of_deliveries.timestamp, proof_of_deliveries.latitude, proof_of_deliveries.longitude, proof_of_deliveries.created_at, proof_of_deliveries.updated_at,
  trip_stop.id, trip_stop.trip_id, trip_stop.shipment_id, trip_stop.sequence, trip_stop.address, trip_stop.status, trip_stop.estimated_arrival_time, trip_stop.actual_arrival_time, trip_stop.estimated_departure_time, trip_stop.actual_departure_time, trip_stop.created_at, trip_stop.updated_at
from
  "tms"."proof_of_deliveries" as proof_of_deliveries
  inner join "tms"."trip_stops" as trip_stop on proof_of_deliveries.trip_stop_id = trip_stop.id
where
  proof_of_deliveries.created_at >= $1::date
  and proof_of_deliveries.created_at <= $2::date
  and (trip_stop.address ilike $3::text
    or proof_of_deliveries.type::text ilike $3::text
    or $3::text is null)
`

type TmsRangeProofOfDeliveryParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type TmsRangeProofOfDeliveryRow struct {
	ID          pgtype.UUID          `db:"id" json:"id"`
	TripStopID  pgtype.UUID          `db:"trip_stop_id" json:"trip_stop_id"`
	Type        NullTmsProofTypeEnum `db:"type" json:"type"`
	FilePath    pgtype.Text          `db:"file_path" json:"file_path"`
	Timestamp   pgtype.Timestamp     `db:"timestamp" json:"timestamp"`
	Latitude    pgtype.Float4        `db:"latitude" json:"latitude"`
	Longitude   pgtype.Float4        `db:"longitude" json:"longitude"`
	CreatedAt   pgtype.Timestamp     `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp     `db:"updated_at" json:"updated_at"`
	TmsTripStop TmsTripStop          `db:"tms_trip_stop" json:"tms_trip_stop"`
}

func (q *Queries) TmsRangeProofOfDelivery(ctx context.Context, arg TmsRangeProofOfDeliveryParams) ([]TmsRangeProofOfDeliveryRow, error) {
	rows, err := q.db.Query(ctx, tmsRangeProofOfDelivery, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TmsRangeProofOfDeliveryRow
	for rows.Next() {
		var i TmsRangeProofOfDeliveryRow
		if err := rows.Scan(
			&i.ID,
			&i.TripStopID,
			&i.Type,
			&i.FilePath,
			&i.Timestamp,
			&i.Latitude,
			&i.Longitude,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TmsTripStop.ID,
			&i.TmsTripStop.TripID,
			&i.TmsTripStop.ShipmentID,
			&i.TmsTripStop.Sequence,
			&i.TmsTripStop.Address,
			&i.TmsTripStop.Status,
			&i.TmsTripStop.EstimatedArrivalTime,
			&i.TmsTripStop.ActualArrivalTime,
			&i.TmsTripStop.EstimatedDepartureTime,
			&i.TmsTripStop.ActualDepartureTime,
			&i.TmsTripStop.CreatedAt,
			&i.TmsTripStop.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tmsRemoveProofOfDelivery = `-- name: TmsRemoveProofOfDelivery :exec
delete from "tms"."proof_of_deliveries"
where id = $1::uuid
`

func (q *Queries) TmsRemoveProofOfDelivery(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, tmsRemoveProofOfDelivery, id)
	return err
}

const tmsUpdateProofOfDelivery = `-- name: TmsUpdateProofOfDelivery :one
update
  "tms"."proof_of_deliveries"
set
  updated_at = now(),
  trip_stop_id = case when $1 is not null then
    $1::uuid
  else
    trip_stop_id
  end,
  type = case when $2 is not null then
    $2::tms.proof_type_enum
  else
    type
  end,
  file_path = case when $3 is not null then
    $3::varchar
  else
    file_path
  end,
  timestamp = case when $4 is not null then
    $4::timestamp
  else
    timestamp
  end,
  latitude = case when $5 is not null then
    $5::real
  else
    latitude
  end,
  longitude = case when $6 is not null then
    $6::real
  else
    longitude
  end
where
  id = $7::uuid
returning
  id, trip_stop_id, type, file_path, timestamp, latitude, longitude, created_at, updated_at
`

type TmsUpdateProofOfDeliveryParams struct {
	TripStopID pgtype.UUID          `db:"trip_stop_id" json:"trip_stop_id"`
	Type       NullTmsProofTypeEnum `db:"type" json:"type"`
	FilePath   pgtype.Text          `db:"file_path" json:"file_path"`
	Timestamp  pgtype.Timestamp     `db:"timestamp" json:"timestamp"`
	Latitude   pgtype.Float4        `db:"latitude" json:"latitude"`
	Longitude  pgtype.Float4        `db:"longitude" json:"longitude"`
	ID         pgtype.UUID          `db:"id" json:"id"`
}

func (q *Queries) TmsUpdateProofOfDelivery(ctx context.Context, arg TmsUpdateProofOfDeliveryParams) (TmsProofOfDelivery, error) {
	row := q.db.QueryRow(ctx, tmsUpdateProofOfDelivery,
		arg.TripStopID,
		arg.Type,
		arg.FilePath,
		arg.Timestamp,
		arg.Latitude,
		arg.Longitude,
		arg.ID,
	)
	var i TmsProofOfDelivery
	err := row.Scan(
		&i.ID,
		&i.TripStopID,
		&i.Type,
		&i.FilePath,
		&i.Timestamp,
		&i.Latitude,
		&i.Longitude,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
