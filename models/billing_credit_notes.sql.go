// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_credit_notes.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyCreditNote = `-- name: BillingAnyCreditNote :many
select
  credit_notes.id, credit_notes.invoice_id, credit_notes.dispute_id, credit_notes.credit_note_number, credit_notes.amount, credit_notes.reason, credit_notes.issue_date, credit_notes.applied_at, credit_notes.currency, credit_notes.notes, credit_notes.created_by_user_id, credit_notes.created_at, credit_notes.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  dispute.id, dispute.line_item_id, dispute.client_id, dispute.reason, dispute.status, dispute.disputed_amount, dispute.resolution_notes, dispute.submitted_at, dispute.resolved_at, dispute.resolved_by_user_id, dispute.created_at, dispute.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."credit_notes" as credit_notes
  inner join "billing"."invoices" as invoice on credit_notes.invoice_id = invoice.id
  left join "billing"."disputes" as dispute on credit_notes.dispute_id = dispute.id
  left join "public"."user" as created_by_user on credit_notes.created_by_user_id = created_by_user.id
where
  credit_notes.id = any ($1::uuid[])
`

type BillingAnyCreditNoteRow struct {
	BillingCreditNote BillingCreditNote
	BillingInvoice    BillingInvoice
	BillingDispute    BillingDispute
	User              User
}

func (q *Queries) BillingAnyCreditNote(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyCreditNoteRow, error) {
	rows, err := q.db.Query(ctx, billingAnyCreditNote, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyCreditNoteRow
	for rows.Next() {
		var i BillingAnyCreditNoteRow
		if err := rows.Scan(
			&i.BillingCreditNote.ID,
			&i.BillingCreditNote.InvoiceID,
			&i.BillingCreditNote.DisputeID,
			&i.BillingCreditNote.CreditNoteNumber,
			&i.BillingCreditNote.Amount,
			&i.BillingCreditNote.Reason,
			&i.BillingCreditNote.IssueDate,
			&i.BillingCreditNote.AppliedAt,
			&i.BillingCreditNote.Currency,
			&i.BillingCreditNote.Notes,
			&i.BillingCreditNote.CreatedByUserID,
			&i.BillingCreditNote.CreatedAt,
			&i.BillingCreditNote.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.BillingDispute.ID,
			&i.BillingDispute.LineItemID,
			&i.BillingDispute.ClientID,
			&i.BillingDispute.Reason,
			&i.BillingDispute.Status,
			&i.BillingDispute.DisputedAmount,
			&i.BillingDispute.ResolutionNotes,
			&i.BillingDispute.SubmittedAt,
			&i.BillingDispute.ResolvedAt,
			&i.BillingDispute.ResolvedByUserID,
			&i.BillingDispute.CreatedAt,
			&i.BillingDispute.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindCreditNote = `-- name: BillingFindCreditNote :one
select
  credit_notes.id, credit_notes.invoice_id, credit_notes.dispute_id, credit_notes.credit_note_number, credit_notes.amount, credit_notes.reason, credit_notes.issue_date, credit_notes.applied_at, credit_notes.currency, credit_notes.notes, credit_notes.created_by_user_id, credit_notes.created_at, credit_notes.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  dispute.id, dispute.line_item_id, dispute.client_id, dispute.reason, dispute.status, dispute.disputed_amount, dispute.resolution_notes, dispute.submitted_at, dispute.resolved_at, dispute.resolved_by_user_id, dispute.created_at, dispute.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."credit_notes" as credit_notes
  inner join "billing"."invoices" as invoice on credit_notes.invoice_id = invoice.id
  left join "billing"."disputes" as dispute on credit_notes.dispute_id = dispute.id
  left join "public"."user" as created_by_user on credit_notes.created_by_user_id = created_by_user.id
where
  credit_notes.id = $1::uuid
`

type BillingFindCreditNoteRow struct {
	BillingCreditNote BillingCreditNote
	BillingInvoice    BillingInvoice
	BillingDispute    BillingDispute
	User              User
}

func (q *Queries) BillingFindCreditNote(ctx context.Context, id pgtype.UUID) (BillingFindCreditNoteRow, error) {
	row := q.db.QueryRow(ctx, billingFindCreditNote, id)
	var i BillingFindCreditNoteRow
	err := row.Scan(
		&i.BillingCreditNote.ID,
		&i.BillingCreditNote.InvoiceID,
		&i.BillingCreditNote.DisputeID,
		&i.BillingCreditNote.CreditNoteNumber,
		&i.BillingCreditNote.Amount,
		&i.BillingCreditNote.Reason,
		&i.BillingCreditNote.IssueDate,
		&i.BillingCreditNote.AppliedAt,
		&i.BillingCreditNote.Currency,
		&i.BillingCreditNote.Notes,
		&i.BillingCreditNote.CreatedByUserID,
		&i.BillingCreditNote.CreatedAt,
		&i.BillingCreditNote.UpdatedAt,
		&i.BillingInvoice.ID,
		&i.BillingInvoice.ClientID,
		&i.BillingInvoice.QuoteID,
		&i.BillingInvoice.InvoiceNumber,
		&i.BillingInvoice.Status,
		&i.BillingInvoice.IssueDate,
		&i.BillingInvoice.DueDate,
		&i.BillingInvoice.TotalAmount,
		&i.BillingInvoice.AmountPaid,
		&i.BillingInvoice.AmountOutstanding,
		&i.BillingInvoice.Currency,
		&i.BillingInvoice.TaxAmount,
		&i.BillingInvoice.DiscountAmount,
		&i.BillingInvoice.Subtotal,
		&i.BillingInvoice.PaymentTerms,
		&i.BillingInvoice.Notes,
		&i.BillingInvoice.SentAt,
		&i.BillingInvoice.PaidAt,
		&i.BillingInvoice.CreatedByUserID,
		&i.BillingInvoice.CreatedAt,
		&i.BillingInvoice.UpdatedAt,
		&i.BillingDispute.ID,
		&i.BillingDispute.LineItemID,
		&i.BillingDispute.ClientID,
		&i.BillingDispute.Reason,
		&i.BillingDispute.Status,
		&i.BillingDispute.DisputedAmount,
		&i.BillingDispute.ResolutionNotes,
		&i.BillingDispute.SubmittedAt,
		&i.BillingDispute.ResolvedAt,
		&i.BillingDispute.ResolvedByUserID,
		&i.BillingDispute.CreatedAt,
		&i.BillingDispute.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertCreditNote = `-- name: BillingInsertCreditNote :one
insert into "billing"."credit_notes"(invoice_id, dispute_id, credit_note_number, amount, reason, issue_date, applied_at, currency, notes, created_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning
  id, invoice_id, dispute_id, credit_note_number, amount, reason, issue_date, applied_at, currency, notes, created_by_user_id, created_at, updated_at
`

type BillingInsertCreditNoteParams struct {
	InvoiceID        pgtype.UUID
	DisputeID        pgtype.UUID
	CreditNoteNumber string
	Amount           pgtype.Numeric
	Reason           string
	IssueDate        pgtype.Date
	AppliedAt        pgtype.Timestamp
	Currency         pgtype.Text
	Notes            pgtype.Text
	CreatedByUserID  pgtype.Text
}

func (q *Queries) BillingInsertCreditNote(ctx context.Context, arg BillingInsertCreditNoteParams) (BillingCreditNote, error) {
	row := q.db.QueryRow(ctx, billingInsertCreditNote,
		arg.InvoiceID,
		arg.DisputeID,
		arg.CreditNoteNumber,
		arg.Amount,
		arg.Reason,
		arg.IssueDate,
		arg.AppliedAt,
		arg.Currency,
		arg.Notes,
		arg.CreatedByUserID,
	)
	var i BillingCreditNote
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.DisputeID,
		&i.CreditNoteNumber,
		&i.Amount,
		&i.Reason,
		&i.IssueDate,
		&i.AppliedAt,
		&i.Currency,
		&i.Notes,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateCreditNote = `-- name: BillingPaginateCreditNote :many
select
  credit_notes.id, credit_notes.invoice_id, credit_notes.dispute_id, credit_notes.credit_note_number, credit_notes.amount, credit_notes.reason, credit_notes.issue_date, credit_notes.applied_at, credit_notes.currency, credit_notes.notes, credit_notes.created_by_user_id, credit_notes.created_at, credit_notes.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  dispute.id, dispute.line_item_id, dispute.client_id, dispute.reason, dispute.status, dispute.disputed_amount, dispute.resolution_notes, dispute.submitted_at, dispute.resolved_at, dispute.resolved_by_user_id, dispute.created_at, dispute.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."credit_notes" as credit_notes
  inner join "billing"."invoices" as invoice on credit_notes.invoice_id = invoice.id
  left join "billing"."disputes" as dispute on credit_notes.dispute_id = dispute.id
  left join "public"."user" as created_by_user on credit_notes.created_by_user_id = created_by_user.id
limit $2::int offset ($1::int - 1) * $2::int
`

type BillingPaginateCreditNoteParams struct {
	Page    int32
	Perpage int32
}

type BillingPaginateCreditNoteRow struct {
	BillingCreditNote BillingCreditNote
	BillingInvoice    BillingInvoice
	BillingDispute    BillingDispute
	User              User
}

func (q *Queries) BillingPaginateCreditNote(ctx context.Context, arg BillingPaginateCreditNoteParams) ([]BillingPaginateCreditNoteRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateCreditNote, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateCreditNoteRow
	for rows.Next() {
		var i BillingPaginateCreditNoteRow
		if err := rows.Scan(
			&i.BillingCreditNote.ID,
			&i.BillingCreditNote.InvoiceID,
			&i.BillingCreditNote.DisputeID,
			&i.BillingCreditNote.CreditNoteNumber,
			&i.BillingCreditNote.Amount,
			&i.BillingCreditNote.Reason,
			&i.BillingCreditNote.IssueDate,
			&i.BillingCreditNote.AppliedAt,
			&i.BillingCreditNote.Currency,
			&i.BillingCreditNote.Notes,
			&i.BillingCreditNote.CreatedByUserID,
			&i.BillingCreditNote.CreatedAt,
			&i.BillingCreditNote.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.BillingDispute.ID,
			&i.BillingDispute.LineItemID,
			&i.BillingDispute.ClientID,
			&i.BillingDispute.Reason,
			&i.BillingDispute.Status,
			&i.BillingDispute.DisputedAmount,
			&i.BillingDispute.ResolutionNotes,
			&i.BillingDispute.SubmittedAt,
			&i.BillingDispute.ResolvedAt,
			&i.BillingDispute.ResolvedByUserID,
			&i.BillingDispute.CreatedAt,
			&i.BillingDispute.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeCreditNote = `-- name: BillingRangeCreditNote :many
select
  credit_notes.id, credit_notes.invoice_id, credit_notes.dispute_id, credit_notes.credit_note_number, credit_notes.amount, credit_notes.reason, credit_notes.issue_date, credit_notes.applied_at, credit_notes.currency, credit_notes.notes, credit_notes.created_by_user_id, credit_notes.created_at, credit_notes.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  dispute.id, dispute.line_item_id, dispute.client_id, dispute.reason, dispute.status, dispute.disputed_amount, dispute.resolution_notes, dispute.submitted_at, dispute.resolved_at, dispute.resolved_by_user_id, dispute.created_at, dispute.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."credit_notes" as credit_notes
  inner join "billing"."invoices" as invoice on credit_notes.invoice_id = invoice.id
  left join "billing"."disputes" as dispute on credit_notes.dispute_id = dispute.id
  left join "public"."user" as created_by_user on credit_notes.created_by_user_id = created_by_user.id
where
  credit_notes.created_at >= $1::date
  and credit_notes.created_at <= $2::date
`

type BillingRangeCreditNoteParams struct {
	Datefrom pgtype.Date
	Dateto   pgtype.Date
}

type BillingRangeCreditNoteRow struct {
	BillingCreditNote BillingCreditNote
	BillingInvoice    BillingInvoice
	BillingDispute    BillingDispute
	User              User
}

func (q *Queries) BillingRangeCreditNote(ctx context.Context, arg BillingRangeCreditNoteParams) ([]BillingRangeCreditNoteRow, error) {
	rows, err := q.db.Query(ctx, billingRangeCreditNote, arg.Datefrom, arg.Dateto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeCreditNoteRow
	for rows.Next() {
		var i BillingRangeCreditNoteRow
		if err := rows.Scan(
			&i.BillingCreditNote.ID,
			&i.BillingCreditNote.InvoiceID,
			&i.BillingCreditNote.DisputeID,
			&i.BillingCreditNote.CreditNoteNumber,
			&i.BillingCreditNote.Amount,
			&i.BillingCreditNote.Reason,
			&i.BillingCreditNote.IssueDate,
			&i.BillingCreditNote.AppliedAt,
			&i.BillingCreditNote.Currency,
			&i.BillingCreditNote.Notes,
			&i.BillingCreditNote.CreatedByUserID,
			&i.BillingCreditNote.CreatedAt,
			&i.BillingCreditNote.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.BillingDispute.ID,
			&i.BillingDispute.LineItemID,
			&i.BillingDispute.ClientID,
			&i.BillingDispute.Reason,
			&i.BillingDispute.Status,
			&i.BillingDispute.DisputedAmount,
			&i.BillingDispute.ResolutionNotes,
			&i.BillingDispute.SubmittedAt,
			&i.BillingDispute.ResolvedAt,
			&i.BillingDispute.ResolvedByUserID,
			&i.BillingDispute.CreatedAt,
			&i.BillingDispute.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveCreditNote = `-- name: BillingRemoveCreditNote :exec
delete from "billing"."credit_notes"
where id = $1::uuid
`

func (q *Queries) BillingRemoveCreditNote(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveCreditNote, id)
	return err
}

const billingUpdateCreditNote = `-- name: BillingUpdateCreditNote :one
update
  "billing"."credit_notes"
set
  invoice_id = case when $1::boolean then
    $2::uuid
  else
    invoice_id
  end,
  dispute_id = case when $3::boolean then
    $4::uuid
  else
    dispute_id
  end,
  credit_note_number = case when $5::boolean then
    $6::varchar
  else
    credit_note_number
  end,
  amount = case when $7::boolean then
    $8::numeric
  else
    amount
  end,
  reason = case when $9::boolean then
    $10::text
  else
    reason
  end,
  issue_date = case when $11::boolean then
    $12::date
  else
    issue_date
  end,
  applied_at = case when $13::boolean then
    $14::timestamp
  else
    applied_at
  end,
  currency = case when $15::boolean then
    $16::varchar
  else
    currency
  end,
  notes = case when $17::boolean then
    $18::text
  else
    notes
  end,
  created_by_user_id = case when $19::boolean then
    $20::text
  else
    created_by_user_id
  end
where
  id = $21::uuid
returning
  id, invoice_id, dispute_id, credit_note_number, amount, reason, issue_date, applied_at, currency, notes, created_by_user_id, created_at, updated_at
`

type BillingUpdateCreditNoteParams struct {
	SetInvoiceID        bool
	InvoiceID           pgtype.UUID
	SetDisputeID        bool
	DisputeID           pgtype.UUID
	SetCreditNoteNumber bool
	CreditNoteNumber    string
	SetAmount           bool
	Amount              pgtype.Numeric
	SetReason           bool
	Reason              string
	SetIssueDate        bool
	IssueDate           pgtype.Date
	SetAppliedAt        bool
	AppliedAt           pgtype.Timestamp
	SetCurrency         bool
	Currency            string
	SetNotes            bool
	Notes               string
	SetCreatedByUserID  bool
	CreatedByUserID     string
	ID                  pgtype.UUID
}

func (q *Queries) BillingUpdateCreditNote(ctx context.Context, arg BillingUpdateCreditNoteParams) (BillingCreditNote, error) {
	row := q.db.QueryRow(ctx, billingUpdateCreditNote,
		arg.SetInvoiceID,
		arg.InvoiceID,
		arg.SetDisputeID,
		arg.DisputeID,
		arg.SetCreditNoteNumber,
		arg.CreditNoteNumber,
		arg.SetAmount,
		arg.Amount,
		arg.SetReason,
		arg.Reason,
		arg.SetIssueDate,
		arg.IssueDate,
		arg.SetAppliedAt,
		arg.AppliedAt,
		arg.SetCurrency,
		arg.Currency,
		arg.SetNotes,
		arg.Notes,
		arg.SetCreatedByUserID,
		arg.CreatedByUserID,
		arg.ID,
	)
	var i BillingCreditNote
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.DisputeID,
		&i.CreditNoteNumber,
		&i.Amount,
		&i.Reason,
		&i.IssueDate,
		&i.AppliedAt,
		&i.Currency,
		&i.Notes,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
