// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_credit_notes.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const billingAnyCreditNote = `-- name: BillingAnyCreditNote :many
select
  credit_notes.id, credit_notes.invoice_id, credit_notes.dispute_id, credit_notes.credit_note_number, credit_notes.amount, credit_notes.reason, credit_notes.issue_date, credit_notes.applied_at, credit_notes.currency, credit_notes.notes, credit_notes.created_by_user_id, credit_notes.created_at, credit_notes.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  dispute.id, dispute.line_item_id, dispute.client_id, dispute.reason, dispute.status, dispute.disputed_amount, dispute.resolution_notes, dispute.submitted_at, dispute.resolved_at, dispute.resolved_by_user_id, dispute.created_at, dispute.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."credit_notes" as credit_notes
  inner join "billing"."invoices" as invoice on credit_notes.invoice_id = invoice.id
  left join "billing"."disputes" as dispute on credit_notes.dispute_id = dispute.id
  left join "public"."user" as created_by_user on credit_notes.created_by_user_id = created_by_user.id
where
  credit_notes.id = any ($1::uuid[])
`

type BillingAnyCreditNoteRow struct {
	BillingCreditNote BillingCreditNote `db:"billing_credit_note" json:"billing_credit_note"`
	BillingInvoice    BillingInvoice    `db:"billing_invoice" json:"billing_invoice"`
	BillingDispute    BillingDispute    `db:"billing_dispute" json:"billing_dispute"`
	User              User              `db:"user" json:"user"`
}

func (q *Queries) BillingAnyCreditNote(ctx context.Context, ids []pgtype.UUID) ([]BillingAnyCreditNoteRow, error) {
	rows, err := q.db.Query(ctx, billingAnyCreditNote, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingAnyCreditNoteRow
	for rows.Next() {
		var i BillingAnyCreditNoteRow
		if err := rows.Scan(
			&i.BillingCreditNote.ID,
			&i.BillingCreditNote.InvoiceID,
			&i.BillingCreditNote.DisputeID,
			&i.BillingCreditNote.CreditNoteNumber,
			&i.BillingCreditNote.Amount,
			&i.BillingCreditNote.Reason,
			&i.BillingCreditNote.IssueDate,
			&i.BillingCreditNote.AppliedAt,
			&i.BillingCreditNote.Currency,
			&i.BillingCreditNote.Notes,
			&i.BillingCreditNote.CreatedByUserID,
			&i.BillingCreditNote.CreatedAt,
			&i.BillingCreditNote.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.BillingDispute.ID,
			&i.BillingDispute.LineItemID,
			&i.BillingDispute.ClientID,
			&i.BillingDispute.Reason,
			&i.BillingDispute.Status,
			&i.BillingDispute.DisputedAmount,
			&i.BillingDispute.ResolutionNotes,
			&i.BillingDispute.SubmittedAt,
			&i.BillingDispute.ResolvedAt,
			&i.BillingDispute.ResolvedByUserID,
			&i.BillingDispute.CreatedAt,
			&i.BillingDispute.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingFindCreditNote = `-- name: BillingFindCreditNote :one
select
  credit_notes.id, credit_notes.invoice_id, credit_notes.dispute_id, credit_notes.credit_note_number, credit_notes.amount, credit_notes.reason, credit_notes.issue_date, credit_notes.applied_at, credit_notes.currency, credit_notes.notes, credit_notes.created_by_user_id, credit_notes.created_at, credit_notes.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  dispute.id, dispute.line_item_id, dispute.client_id, dispute.reason, dispute.status, dispute.disputed_amount, dispute.resolution_notes, dispute.submitted_at, dispute.resolved_at, dispute.resolved_by_user_id, dispute.created_at, dispute.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."credit_notes" as credit_notes
  inner join "billing"."invoices" as invoice on credit_notes.invoice_id = invoice.id
  left join "billing"."disputes" as dispute on credit_notes.dispute_id = dispute.id
  left join "public"."user" as created_by_user on credit_notes.created_by_user_id = created_by_user.id
where
  credit_notes.id = $1::uuid
`

type BillingFindCreditNoteRow struct {
	BillingCreditNote BillingCreditNote `db:"billing_credit_note" json:"billing_credit_note"`
	BillingInvoice    BillingInvoice    `db:"billing_invoice" json:"billing_invoice"`
	BillingDispute    BillingDispute    `db:"billing_dispute" json:"billing_dispute"`
	User              User              `db:"user" json:"user"`
}

func (q *Queries) BillingFindCreditNote(ctx context.Context, id pgtype.UUID) (BillingFindCreditNoteRow, error) {
	row := q.db.QueryRow(ctx, billingFindCreditNote, id)
	var i BillingFindCreditNoteRow
	err := row.Scan(
		&i.BillingCreditNote.ID,
		&i.BillingCreditNote.InvoiceID,
		&i.BillingCreditNote.DisputeID,
		&i.BillingCreditNote.CreditNoteNumber,
		&i.BillingCreditNote.Amount,
		&i.BillingCreditNote.Reason,
		&i.BillingCreditNote.IssueDate,
		&i.BillingCreditNote.AppliedAt,
		&i.BillingCreditNote.Currency,
		&i.BillingCreditNote.Notes,
		&i.BillingCreditNote.CreatedByUserID,
		&i.BillingCreditNote.CreatedAt,
		&i.BillingCreditNote.UpdatedAt,
		&i.BillingInvoice.ID,
		&i.BillingInvoice.ClientID,
		&i.BillingInvoice.QuoteID,
		&i.BillingInvoice.InvoiceNumber,
		&i.BillingInvoice.Status,
		&i.BillingInvoice.IssueDate,
		&i.BillingInvoice.DueDate,
		&i.BillingInvoice.TotalAmount,
		&i.BillingInvoice.AmountPaid,
		&i.BillingInvoice.AmountOutstanding,
		&i.BillingInvoice.Currency,
		&i.BillingInvoice.TaxAmount,
		&i.BillingInvoice.DiscountAmount,
		&i.BillingInvoice.Subtotal,
		&i.BillingInvoice.PaymentTerms,
		&i.BillingInvoice.Notes,
		&i.BillingInvoice.SentAt,
		&i.BillingInvoice.PaidAt,
		&i.BillingInvoice.CreatedByUserID,
		&i.BillingInvoice.CreatedAt,
		&i.BillingInvoice.UpdatedAt,
		&i.BillingDispute.ID,
		&i.BillingDispute.LineItemID,
		&i.BillingDispute.ClientID,
		&i.BillingDispute.Reason,
		&i.BillingDispute.Status,
		&i.BillingDispute.DisputedAmount,
		&i.BillingDispute.ResolutionNotes,
		&i.BillingDispute.SubmittedAt,
		&i.BillingDispute.ResolvedAt,
		&i.BillingDispute.ResolvedByUserID,
		&i.BillingDispute.CreatedAt,
		&i.BillingDispute.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.Image,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Role,
		&i.User.Banned,
		&i.User.BanReason,
		&i.User.BanExpires,
	)
	return i, err
}

const billingInsertCreditNote = `-- name: BillingInsertCreditNote :one
insert into "billing"."credit_notes"(invoice_id, dispute_id, credit_note_number, amount, reason, issue_date, applied_at, currency, notes, created_by_user_id)
  values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning
  id, invoice_id, dispute_id, credit_note_number, amount, reason, issue_date, applied_at, currency, notes, created_by_user_id, created_at, updated_at
`

type BillingInsertCreditNoteParams struct {
	InvoiceID        pgtype.UUID      `db:"invoice_id" json:"invoice_id"`
	DisputeID        pgtype.UUID      `db:"dispute_id" json:"dispute_id"`
	CreditNoteNumber string           `db:"credit_note_number" json:"credit_note_number"`
	Amount           pgtype.Numeric   `db:"amount" json:"amount"`
	Reason           string           `db:"reason" json:"reason"`
	IssueDate        pgtype.Date      `db:"issue_date" json:"issue_date"`
	AppliedAt        pgtype.Timestamp `db:"applied_at" json:"applied_at"`
	Currency         pgtype.Text      `db:"currency" json:"currency"`
	Notes            pgtype.Text      `db:"notes" json:"notes"`
	CreatedByUserID  pgtype.Text      `db:"created_by_user_id" json:"created_by_user_id"`
}

func (q *Queries) BillingInsertCreditNote(ctx context.Context, arg BillingInsertCreditNoteParams) (BillingCreditNote, error) {
	row := q.db.QueryRow(ctx, billingInsertCreditNote,
		arg.InvoiceID,
		arg.DisputeID,
		arg.CreditNoteNumber,
		arg.Amount,
		arg.Reason,
		arg.IssueDate,
		arg.AppliedAt,
		arg.Currency,
		arg.Notes,
		arg.CreatedByUserID,
	)
	var i BillingCreditNote
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.DisputeID,
		&i.CreditNoteNumber,
		&i.Amount,
		&i.Reason,
		&i.IssueDate,
		&i.AppliedAt,
		&i.Currency,
		&i.Notes,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const billingPaginateCreditNote = `-- name: BillingPaginateCreditNote :many
select
  credit_notes.id, credit_notes.invoice_id, credit_notes.dispute_id, credit_notes.credit_note_number, credit_notes.amount, credit_notes.reason, credit_notes.issue_date, credit_notes.applied_at, credit_notes.currency, credit_notes.notes, credit_notes.created_by_user_id, credit_notes.created_at, credit_notes.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  dispute.id, dispute.line_item_id, dispute.client_id, dispute.reason, dispute.status, dispute.disputed_amount, dispute.resolution_notes, dispute.submitted_at, dispute.resolved_at, dispute.resolved_by_user_id, dispute.created_at, dispute.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."credit_notes" as credit_notes
  inner join "billing"."invoices" as invoice on credit_notes.invoice_id = invoice.id
  left join "billing"."disputes" as dispute on credit_notes.dispute_id = dispute.id
  left join "public"."user" as created_by_user on credit_notes.created_by_user_id = created_by_user.id
where (invoice.invoice_number ilike $1::text
  or dispute.reason ilike $1::text
  or created_by_user.name ilike $1::text
  or credit_notes.credit_note_number ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type BillingPaginateCreditNoteParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	Perpage int32       `db:"perpage" json:"perpage"`
}

type BillingPaginateCreditNoteRow struct {
	BillingCreditNote BillingCreditNote `db:"billing_credit_note" json:"billing_credit_note"`
	BillingInvoice    BillingInvoice    `db:"billing_invoice" json:"billing_invoice"`
	BillingDispute    BillingDispute    `db:"billing_dispute" json:"billing_dispute"`
	User              User              `db:"user" json:"user"`
}

func (q *Queries) BillingPaginateCreditNote(ctx context.Context, arg BillingPaginateCreditNoteParams) ([]BillingPaginateCreditNoteRow, error) {
	rows, err := q.db.Query(ctx, billingPaginateCreditNote, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingPaginateCreditNoteRow
	for rows.Next() {
		var i BillingPaginateCreditNoteRow
		if err := rows.Scan(
			&i.BillingCreditNote.ID,
			&i.BillingCreditNote.InvoiceID,
			&i.BillingCreditNote.DisputeID,
			&i.BillingCreditNote.CreditNoteNumber,
			&i.BillingCreditNote.Amount,
			&i.BillingCreditNote.Reason,
			&i.BillingCreditNote.IssueDate,
			&i.BillingCreditNote.AppliedAt,
			&i.BillingCreditNote.Currency,
			&i.BillingCreditNote.Notes,
			&i.BillingCreditNote.CreatedByUserID,
			&i.BillingCreditNote.CreatedAt,
			&i.BillingCreditNote.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.BillingDispute.ID,
			&i.BillingDispute.LineItemID,
			&i.BillingDispute.ClientID,
			&i.BillingDispute.Reason,
			&i.BillingDispute.Status,
			&i.BillingDispute.DisputedAmount,
			&i.BillingDispute.ResolutionNotes,
			&i.BillingDispute.SubmittedAt,
			&i.BillingDispute.ResolvedAt,
			&i.BillingDispute.ResolvedByUserID,
			&i.BillingDispute.CreatedAt,
			&i.BillingDispute.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRangeCreditNote = `-- name: BillingRangeCreditNote :many
select
  credit_notes.id, credit_notes.invoice_id, credit_notes.dispute_id, credit_notes.credit_note_number, credit_notes.amount, credit_notes.reason, credit_notes.issue_date, credit_notes.applied_at, credit_notes.currency, credit_notes.notes, credit_notes.created_by_user_id, credit_notes.created_at, credit_notes.updated_at,
  invoice.id, invoice.client_id, invoice.quote_id, invoice.invoice_number, invoice.status, invoice.issue_date, invoice.due_date, invoice.total_amount, invoice.amount_paid, invoice.amount_outstanding, invoice.currency, invoice.tax_amount, invoice.discount_amount, invoice.subtotal, invoice.payment_terms, invoice.notes, invoice.sent_at, invoice.paid_at, invoice.created_by_user_id, invoice.created_at, invoice.updated_at,
  dispute.id, dispute.line_item_id, dispute.client_id, dispute.reason, dispute.status, dispute.disputed_amount, dispute.resolution_notes, dispute.submitted_at, dispute.resolved_at, dispute.resolved_by_user_id, dispute.created_at, dispute.updated_at,
  created_by_user.id, created_by_user.name, created_by_user.email, created_by_user.email_verified, created_by_user.image, created_by_user.created_at, created_by_user.updated_at, created_by_user.role, created_by_user.banned, created_by_user.ban_reason, created_by_user.ban_expires
from
  "billing"."credit_notes" as credit_notes
  inner join "billing"."invoices" as invoice on credit_notes.invoice_id = invoice.id
  left join "billing"."disputes" as dispute on credit_notes.dispute_id = dispute.id
  left join "public"."user" as created_by_user on credit_notes.created_by_user_id = created_by_user.id
where
  credit_notes.created_at >= $1::date
  and credit_notes.created_at <= $2::date
  and (invoice.invoice_number ilike $3::text
    or dispute.reason ilike $3::text
    or created_by_user.name ilike $3::text
    or credit_notes.credit_note_number ilike $3::text
    or $3::text is null)
`

type BillingRangeCreditNoteParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

type BillingRangeCreditNoteRow struct {
	BillingCreditNote BillingCreditNote `db:"billing_credit_note" json:"billing_credit_note"`
	BillingInvoice    BillingInvoice    `db:"billing_invoice" json:"billing_invoice"`
	BillingDispute    BillingDispute    `db:"billing_dispute" json:"billing_dispute"`
	User              User              `db:"user" json:"user"`
}

func (q *Queries) BillingRangeCreditNote(ctx context.Context, arg BillingRangeCreditNoteParams) ([]BillingRangeCreditNoteRow, error) {
	rows, err := q.db.Query(ctx, billingRangeCreditNote, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingRangeCreditNoteRow
	for rows.Next() {
		var i BillingRangeCreditNoteRow
		if err := rows.Scan(
			&i.BillingCreditNote.ID,
			&i.BillingCreditNote.InvoiceID,
			&i.BillingCreditNote.DisputeID,
			&i.BillingCreditNote.CreditNoteNumber,
			&i.BillingCreditNote.Amount,
			&i.BillingCreditNote.Reason,
			&i.BillingCreditNote.IssueDate,
			&i.BillingCreditNote.AppliedAt,
			&i.BillingCreditNote.Currency,
			&i.BillingCreditNote.Notes,
			&i.BillingCreditNote.CreatedByUserID,
			&i.BillingCreditNote.CreatedAt,
			&i.BillingCreditNote.UpdatedAt,
			&i.BillingInvoice.ID,
			&i.BillingInvoice.ClientID,
			&i.BillingInvoice.QuoteID,
			&i.BillingInvoice.InvoiceNumber,
			&i.BillingInvoice.Status,
			&i.BillingInvoice.IssueDate,
			&i.BillingInvoice.DueDate,
			&i.BillingInvoice.TotalAmount,
			&i.BillingInvoice.AmountPaid,
			&i.BillingInvoice.AmountOutstanding,
			&i.BillingInvoice.Currency,
			&i.BillingInvoice.TaxAmount,
			&i.BillingInvoice.DiscountAmount,
			&i.BillingInvoice.Subtotal,
			&i.BillingInvoice.PaymentTerms,
			&i.BillingInvoice.Notes,
			&i.BillingInvoice.SentAt,
			&i.BillingInvoice.PaidAt,
			&i.BillingInvoice.CreatedByUserID,
			&i.BillingInvoice.CreatedAt,
			&i.BillingInvoice.UpdatedAt,
			&i.BillingDispute.ID,
			&i.BillingDispute.LineItemID,
			&i.BillingDispute.ClientID,
			&i.BillingDispute.Reason,
			&i.BillingDispute.Status,
			&i.BillingDispute.DisputedAmount,
			&i.BillingDispute.ResolutionNotes,
			&i.BillingDispute.SubmittedAt,
			&i.BillingDispute.ResolvedAt,
			&i.BillingDispute.ResolvedByUserID,
			&i.BillingDispute.CreatedAt,
			&i.BillingDispute.UpdatedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.Image,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Role,
			&i.User.Banned,
			&i.User.BanReason,
			&i.User.BanExpires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingRemoveCreditNote = `-- name: BillingRemoveCreditNote :exec
delete from "billing"."credit_notes"
where id = $1::uuid
`

func (q *Queries) BillingRemoveCreditNote(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, billingRemoveCreditNote, id)
	return err
}

const billingUpdateCreditNote = `-- name: BillingUpdateCreditNote :one
update
  "billing"."credit_notes"
set
  updated_at = now(),
  invoice_id = case when $1 is not null then
    $1::uuid
  else
    invoice_id
  end,
  dispute_id = case when $2 is not null then
    $2::uuid
  else
    dispute_id
  end,
  credit_note_number = case when $3 is not null then
    $3::varchar
  else
    credit_note_number
  end,
  amount = case when $4 is not null then
    $4::numeric
  else
    amount
  end,
  reason = case when $5 is not null then
    $5::text
  else
    reason
  end,
  issue_date = case when $6 is not null then
    $6::date
  else
    issue_date
  end,
  applied_at = case when $7 is not null then
    $7::timestamp
  else
    applied_at
  end,
  currency = case when $8 is not null then
    $8::varchar
  else
    currency
  end,
  notes = case when $9 is not null then
    $9::text
  else
    notes
  end,
  created_by_user_id = case when $10 is not null then
    $10::text
  else
    created_by_user_id
  end
where
  id = $11::uuid
returning
  id, invoice_id, dispute_id, credit_note_number, amount, reason, issue_date, applied_at, currency, notes, created_by_user_id, created_at, updated_at
`

type BillingUpdateCreditNoteParams struct {
	InvoiceID        pgtype.UUID      `db:"invoice_id" json:"invoice_id"`
	DisputeID        pgtype.UUID      `db:"dispute_id" json:"dispute_id"`
	CreditNoteNumber string           `db:"credit_note_number" json:"credit_note_number"`
	Amount           pgtype.Numeric   `db:"amount" json:"amount"`
	Reason           string           `db:"reason" json:"reason"`
	IssueDate        pgtype.Date      `db:"issue_date" json:"issue_date"`
	AppliedAt        pgtype.Timestamp `db:"applied_at" json:"applied_at"`
	Currency         pgtype.Text      `db:"currency" json:"currency"`
	Notes            pgtype.Text      `db:"notes" json:"notes"`
	CreatedByUserID  pgtype.Text      `db:"created_by_user_id" json:"created_by_user_id"`
	ID               pgtype.UUID      `db:"id" json:"id"`
}

func (q *Queries) BillingUpdateCreditNote(ctx context.Context, arg BillingUpdateCreditNoteParams) (BillingCreditNote, error) {
	row := q.db.QueryRow(ctx, billingUpdateCreditNote,
		arg.InvoiceID,
		arg.DisputeID,
		arg.CreditNoteNumber,
		arg.Amount,
		arg.Reason,
		arg.IssueDate,
		arg.AppliedAt,
		arg.Currency,
		arg.Notes,
		arg.CreatedByUserID,
		arg.ID,
	)
	var i BillingCreditNote
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.DisputeID,
		&i.CreditNoteNumber,
		&i.Amount,
		&i.Reason,
		&i.IssueDate,
		&i.AppliedAt,
		&i.Currency,
		&i.Notes,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
