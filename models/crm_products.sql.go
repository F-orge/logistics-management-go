// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crm_products.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const crmAnyProduct = `-- name: CrmAnyProduct :many
select
  id, name, sku, price, type, description, created_at, updated_at
from
  "crm"."products"
where
  id = any ($1::uuid[])
`

func (q *Queries) CrmAnyProduct(ctx context.Context, ids []pgtype.UUID) ([]CrmProduct, error) {
	rows, err := q.db.Query(ctx, crmAnyProduct, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmProduct
	for rows.Next() {
		var i CrmProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.Price,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmFindProduct = `-- name: CrmFindProduct :one
select
  id, name, sku, price, type, description, created_at, updated_at
from
  "crm"."products"
where
  id = $1::uuid
`

func (q *Queries) CrmFindProduct(ctx context.Context, id pgtype.UUID) (CrmProduct, error) {
	row := q.db.QueryRow(ctx, crmFindProduct, id)
	var i CrmProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Price,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmInsertProduct = `-- name: CrmInsertProduct :one
insert into "crm"."products"(name, sku, price, type, description)
  values ($1, $2, $3, $4, $5)
returning
  id, name, sku, price, type, description, created_at, updated_at
`

type CrmInsertProductParams struct {
	Name        string             `db:"name" json:"name"`
	Sku         pgtype.Text        `db:"sku" json:"sku"`
	Price       pgtype.Numeric     `db:"price" json:"price"`
	Type        NullCrmProductType `db:"type" json:"type"`
	Description pgtype.Text        `db:"description" json:"description"`
}

func (q *Queries) CrmInsertProduct(ctx context.Context, arg CrmInsertProductParams) (CrmProduct, error) {
	row := q.db.QueryRow(ctx, crmInsertProduct,
		arg.Name,
		arg.Sku,
		arg.Price,
		arg.Type,
		arg.Description,
	)
	var i CrmProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Price,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const crmPaginateProduct = `-- name: CrmPaginateProduct :many
select
  id, name, sku, price, type, description, created_at, updated_at
from
  "crm"."products"
where (name ilike $1::text
  or sku ilike $1::text
  or type::text ilike $1::text
  or $1::text is null)
limit $3::int offset ($2::int - 1) * $3::int
`

type CrmPaginateProductParams struct {
	Search  pgtype.Text `db:"search" json:"search"`
	Page    int32       `db:"page" json:"page"`
	Perpage int32       `db:"perpage" json:"perpage"`
}

func (q *Queries) CrmPaginateProduct(ctx context.Context, arg CrmPaginateProductParams) ([]CrmProduct, error) {
	rows, err := q.db.Query(ctx, crmPaginateProduct, arg.Search, arg.Page, arg.Perpage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmProduct
	for rows.Next() {
		var i CrmProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.Price,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRangeProduct = `-- name: CrmRangeProduct :many
select
  id, name, sku, price, type, description, created_at, updated_at
from
  "crm"."products"
where
  created_at >= $1::date
  and created_at <= $2::date
  and (name ilike $3::text
    or sku ilike $3::text
    or type::text ilike $3::text
    or $3::text is null)
`

type CrmRangeProductParams struct {
	Datefrom pgtype.Date `db:"datefrom" json:"datefrom"`
	Dateto   pgtype.Date `db:"dateto" json:"dateto"`
	Search   pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) CrmRangeProduct(ctx context.Context, arg CrmRangeProductParams) ([]CrmProduct, error) {
	rows, err := q.db.Query(ctx, crmRangeProduct, arg.Datefrom, arg.Dateto, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrmProduct
	for rows.Next() {
		var i CrmProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sku,
			&i.Price,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const crmRemoveProduct = `-- name: CrmRemoveProduct :exec
delete from "crm"."products"
where id = $1::uuid
`

func (q *Queries) CrmRemoveProduct(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, crmRemoveProduct, id)
	return err
}

const crmUpdateProduct = `-- name: CrmUpdateProduct :one
update
  "crm"."products"
set
  updated_at = now(),
  name = case when $1 is not null then
    $1::text
  else
    name
  end,
  sku = case when $2 is not null then
    $2::text
  else
    sku
  end,
  price = case when $3 is not null then
    $3::numeric
  else
    price
  end,
  type = case when $4 is not null then
    $4::crm.product_type
  else
    type
  end,
  description = case when $5 is not null then
    $5::text
  else
    description
  end
where
  id = $6::uuid
returning
  id, name, sku, price, type, description, created_at, updated_at
`

type CrmUpdateProductParams struct {
	Name        string             `db:"name" json:"name"`
	Sku         pgtype.Text        `db:"sku" json:"sku"`
	Price       pgtype.Numeric     `db:"price" json:"price"`
	Type        NullCrmProductType `db:"type" json:"type"`
	Description pgtype.Text        `db:"description" json:"description"`
	ID          pgtype.UUID        `db:"id" json:"id"`
}

func (q *Queries) CrmUpdateProduct(ctx context.Context, arg CrmUpdateProductParams) (CrmProduct, error) {
	row := q.db.QueryRow(ctx, crmUpdateProduct,
		arg.Name,
		arg.Sku,
		arg.Price,
		arg.Type,
		arg.Description,
		arg.ID,
	)
	var i CrmProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Sku,
		&i.Price,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
