// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInventoryItem = `-- name: CreateInventoryItem :one
insert into inventory_items (
  product, 
  warehouse, 
  quantity_on_hand, 
  lot_number, 
  serial_number, 
  status, 
  expiry_date, 
  storage_location_code, 
  last_counted_date
)
values (
  $1::uuid,
  $2::uuid, 
  $3::integer,
  $4::text,
  $5::text, 
  $6::text, 
  $7::timestamptz, 
  $8::text, 
  $9::timestamptz
)
returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type CreateInventoryItemParams struct {
	ProductID           pgtype.UUID
	WarehouseID         pgtype.UUID
	QuantityOnHand      int32
	LotNumber           string
	SerialNumber        string
	Status              string
	ExpiryDate          pgtype.Timestamptz
	StorageLocationCode string
	LastCountedDate     pgtype.Timestamptz
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, createInventoryItem,
		arg.ProductID,
		arg.WarehouseID,
		arg.QuantityOnHand,
		arg.LotNumber,
		arg.SerialNumber,
		arg.Status,
		arg.ExpiryDate,
		arg.StorageLocationCode,
		arg.LastCountedDate,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteInventoryItem = `-- name: DeleteInventoryItem :one
delete from inventory_items where id = $1::uuid returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

func (q *Queries) DeleteInventoryItem(ctx context.Context, id pgtype.UUID) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, deleteInventoryItem, id)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getAllInventoryItems = `-- name: GetAllInventoryItems :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items order by created desc
`

func (q *Queries) GetAllInventoryItems(ctx context.Context) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, getAllInventoryItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryItemByID = `-- name: GetInventoryItemByID :one
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items where id = $1::uuid
`

func (q *Queries) GetInventoryItemByID(ctx context.Context, id pgtype.UUID) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, getInventoryItemByID, id)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getInventoryItemsByStatus = `-- name: GetInventoryItemsByStatus :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items where status = $1 order by created desc offset $2 limit $3
`

type GetInventoryItemsByStatusParams struct {
	Status string
	Offset int32
	Limit  int32
}

func (q *Queries) GetInventoryItemsByStatus(ctx context.Context, arg GetInventoryItemsByStatusParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, getInventoryItemsByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryItemsByWarehouse = `-- name: GetInventoryItemsByWarehouse :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items where warehouse = $1 order by created desc offset $2 limit $3
`

type GetInventoryItemsByWarehouseParams struct {
	Warehouse pgtype.UUID
	Offset    int32
	Limit     int32
}

func (q *Queries) GetInventoryItemsByWarehouse(ctx context.Context, arg GetInventoryItemsByWarehouseParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, getInventoryItemsByWarehouse, arg.Warehouse, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateInventoryItems = `-- name: PaginateInventoryItems :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items order by created desc offset $1::integer limit $2::integer
`

type PaginateInventoryItemsParams struct {
	Page    int32
	PerPage int32
}

func (q *Queries) PaginateInventoryItems(ctx context.Context, arg PaginateInventoryItemsParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, paginateInventoryItems, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInventoryItems = `-- name: SearchInventoryItems :many
select id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated from inventory_items where lot_number ilike '%' || $1::text || '%' or serial_number ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchInventoryItemsParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchInventoryItems(ctx context.Context, arg SearchInventoryItemsParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, searchInventoryItems, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.Product,
			&i.Warehouse,
			&i.QuantityOnHand,
			&i.LotNumber,
			&i.SerialNumber,
			&i.Status,
			&i.ExpiryDate,
			&i.StorageLocationCode,
			&i.LastCountedDate,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryItemExpiryDate = `-- name: UpdateInventoryItemExpiryDate :one
update inventory_items set expiry_date = $1::timestamptz where id = $2::uuid returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type UpdateInventoryItemExpiryDateParams struct {
	ExpiryDate pgtype.Timestamptz
	ID         pgtype.UUID
}

func (q *Queries) UpdateInventoryItemExpiryDate(ctx context.Context, arg UpdateInventoryItemExpiryDateParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemExpiryDate, arg.ExpiryDate, arg.ID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInventoryItemLastCountedDate = `-- name: UpdateInventoryItemLastCountedDate :one
update inventory_items set last_counted_date = now() where id = $1::uuid returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

func (q *Queries) UpdateInventoryItemLastCountedDate(ctx context.Context, id pgtype.UUID) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemLastCountedDate, id)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInventoryItemQuantity = `-- name: UpdateInventoryItemQuantity :one
update inventory_items set quantity_on_hand = $1::integer where id = $2::uuid returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type UpdateInventoryItemQuantityParams struct {
	QuantityOnHand int32
	ID             pgtype.UUID
}

func (q *Queries) UpdateInventoryItemQuantity(ctx context.Context, arg UpdateInventoryItemQuantityParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemQuantity, arg.QuantityOnHand, arg.ID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInventoryItemStatus = `-- name: UpdateInventoryItemStatus :one
update inventory_items set status = $1::text where id = $2::uuid returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type UpdateInventoryItemStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateInventoryItemStatus(ctx context.Context, arg UpdateInventoryItemStatusParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemStatus, arg.Status, arg.ID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInventoryItemStorageLocationCode = `-- name: UpdateInventoryItemStorageLocationCode :one
update inventory_items set storage_location_code = $1::text where id = $2::uuid returning id, product, warehouse, quantity_on_hand, lot_number, serial_number, status, expiry_date, storage_location_code, last_counted_date, created, updated
`

type UpdateInventoryItemStorageLocationCodeParams struct {
	StorageLocationCode string
	ID                  pgtype.UUID
}

func (q *Queries) UpdateInventoryItemStorageLocationCode(ctx context.Context, arg UpdateInventoryItemStorageLocationCodeParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemStorageLocationCode, arg.StorageLocationCode, arg.ID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Product,
		&i.Warehouse,
		&i.QuantityOnHand,
		&i.LotNumber,
		&i.SerialNumber,
		&i.Status,
		&i.ExpiryDate,
		&i.StorageLocationCode,
		&i.LastCountedDate,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
