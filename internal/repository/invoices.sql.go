// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invoices.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInvoice = `-- name: CreateInvoice :one
insert into invoices (
  invoice_number, 
  "order", 
  customer, 
  invoice_date, 
  due_date, 
  total_amount, 
  status, 
  invoice_pdf_url
)
values (
  $1::text, 
  $2::uuid, 
  $3::uuid, 
  $4::timestamptz, 
  $5::timestamptz, 
  $6::numeric, 
  $7::text, 
  $8::text
)
returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

type CreateInvoiceParams struct {
	InvoiceNumber string
	OrderID       pgtype.UUID
	CustomerID    pgtype.UUID
	InvoiceDate   pgtype.Timestamptz
	DueDate       pgtype.Timestamptz
	TotalAmount   pgtype.Numeric
	Status        string
	InvoicePdfUrl string
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.InvoiceNumber,
		arg.OrderID,
		arg.CustomerID,
		arg.InvoiceDate,
		arg.DueDate,
		arg.TotalAmount,
		arg.Status,
		arg.InvoicePdfUrl,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :one
delete from invoices where id = $1::uuid returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

func (q *Queries) DeleteInvoice(ctx context.Context, id pgtype.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, deleteInvoice, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getInvoiceByID = `-- name: GetInvoiceByID :one
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where id = $1::uuid
`

func (q *Queries) GetInvoiceByID(ctx context.Context, id pgtype.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByID, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getInvoices = `-- name: GetInvoices :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices order by created desc
`

func (q *Queries) GetInvoices(ctx context.Context) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomer = `-- name: GetInvoicesByCustomer :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetInvoicesByCustomerParams struct {
	CustomerID pgtype.UUID
	Page       int32
	PerPage    int32
}

func (q *Queries) GetInvoicesByCustomer(ctx context.Context, arg GetInvoicesByCustomerParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomer, arg.CustomerID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomerAndDateRange = `-- name: GetInvoicesByCustomerAndDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1::uuid and invoice_date >= $2::timestamptz and invoice_date <= $3::timestamptz
order by created desc offset $4::integer limit $5::integer
`

type GetInvoicesByCustomerAndDateRangeParams struct {
	CustomerID pgtype.UUID
	StartDate  pgtype.Timestamptz
	EndDate    pgtype.Timestamptz
	Page       int32
	PerPage    int32
}

func (q *Queries) GetInvoicesByCustomerAndDateRange(ctx context.Context, arg GetInvoicesByCustomerAndDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomerAndDateRange,
		arg.CustomerID,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomerAndDueDateRange = `-- name: GetInvoicesByCustomerAndDueDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1::uuid and due_date >= $2::timestamptz and due_date <= $3::timestamptz
order by created desc offset $4::integer limit $5::integer
`

type GetInvoicesByCustomerAndDueDateRangeParams struct {
	CustomerID pgtype.UUID
	StartDate  pgtype.Timestamptz
	EndDate    pgtype.Timestamptz
	Page       int32
	PerPage    int32
}

func (q *Queries) GetInvoicesByCustomerAndDueDateRange(ctx context.Context, arg GetInvoicesByCustomerAndDueDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomerAndDueDateRange,
		arg.CustomerID,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomerAndStatus = `-- name: GetInvoicesByCustomerAndStatus :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1::uuid and status = $2::text
order by created desc offset $3::integer limit $4::integer
`

type GetInvoicesByCustomerAndStatusParams struct {
	CustomerID pgtype.UUID
	Status     string
	Page       int32
	PerPage    int32
}

func (q *Queries) GetInvoicesByCustomerAndStatus(ctx context.Context, arg GetInvoicesByCustomerAndStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomerAndStatus,
		arg.CustomerID,
		arg.Status,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByCustomerAndStatusAndDateRange = `-- name: GetInvoicesByCustomerAndStatusAndDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where customer = $1::uuid and status = $2::text and invoice_date >= $3::timestamptz and invoice_date <= $4::timestamptz
order by created desc offset $5::integer limit $6::integer
`

type GetInvoicesByCustomerAndStatusAndDateRangeParams struct {
	CustomerID pgtype.UUID
	Status     string
	StartDate  pgtype.Timestamptz
	EndDate    pgtype.Timestamptz
	Page       int32
	PerPage    int32
}

func (q *Queries) GetInvoicesByCustomerAndStatusAndDateRange(ctx context.Context, arg GetInvoicesByCustomerAndStatusAndDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByCustomerAndStatusAndDateRange,
		arg.CustomerID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByDateRange = `-- name: GetInvoicesByDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where invoice_date >= $1::timestamptz and invoice_date <= $2::timestamptz
order by created desc offset $3::integer limit $4::integer
`

type GetInvoicesByDateRangeParams struct {
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Page      int32
	PerPage   int32
}

func (q *Queries) GetInvoicesByDateRange(ctx context.Context, arg GetInvoicesByDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByDateRange,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByDueDateRange = `-- name: GetInvoicesByDueDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where due_date >= $1::timestamptz and due_date <= $2::timestamptz
order by created desc offset $3::integer limit $4::integer
`

type GetInvoicesByDueDateRangeParams struct {
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Page      int32
	PerPage   int32
}

func (q *Queries) GetInvoicesByDueDateRange(ctx context.Context, arg GetInvoicesByDueDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByDueDateRange,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrder = `-- name: GetInvoicesByOrder :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetInvoicesByOrderParams struct {
	OrderID pgtype.UUID
	Page    int32
	PerPage int32
}

func (q *Queries) GetInvoicesByOrder(ctx context.Context, arg GetInvoicesByOrderParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrder, arg.OrderID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrderAndDateRange = `-- name: GetInvoicesByOrderAndDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1::uuid and invoice_date >= $2::timestamptz and invoice_date <= $3::timestamptz
order by created desc offset $4::integer limit $5::integer
`

type GetInvoicesByOrderAndDateRangeParams struct {
	OrderID   pgtype.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Page      int32
	PerPage   int32
}

func (q *Queries) GetInvoicesByOrderAndDateRange(ctx context.Context, arg GetInvoicesByOrderAndDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrderAndDateRange,
		arg.OrderID,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrderAndDueDateRange = `-- name: GetInvoicesByOrderAndDueDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1::uuid and due_date >= $2::timestamptz and due_date <= $3::timestamptz
order by created desc offset $4::integer limit $5::integer
`

type GetInvoicesByOrderAndDueDateRangeParams struct {
	OrderID   pgtype.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Page      int32
	PerPage   int32
}

func (q *Queries) GetInvoicesByOrderAndDueDateRange(ctx context.Context, arg GetInvoicesByOrderAndDueDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrderAndDueDateRange,
		arg.OrderID,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrderAndStatus = `-- name: GetInvoicesByOrderAndStatus :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1::uuid and status = $2::text
order by created desc offset $3::integer limit $4::integer
`

type GetInvoicesByOrderAndStatusParams struct {
	OrderID pgtype.UUID
	Status  string
	Page    int32
	PerPage int32
}

func (q *Queries) GetInvoicesByOrderAndStatus(ctx context.Context, arg GetInvoicesByOrderAndStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrderAndStatus,
		arg.OrderID,
		arg.Status,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByOrderAndStatusAndDateRange = `-- name: GetInvoicesByOrderAndStatusAndDateRange :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where "order" = $1::uuid and status = $2::text and invoice_date >= $3::timestamptz and invoice_date <= $4::timestamptz
order by created desc offset $5::integer limit $6::integer
`

type GetInvoicesByOrderAndStatusAndDateRangeParams struct {
	OrderID   pgtype.UUID
	Status    string
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Page      int32
	PerPage   int32
}

func (q *Queries) GetInvoicesByOrderAndStatusAndDateRange(ctx context.Context, arg GetInvoicesByOrderAndStatusAndDateRangeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByOrderAndStatusAndDateRange,
		arg.OrderID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByStatus = `-- name: GetInvoicesByStatus :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where status = $1::text order by created desc offset $2::integer limit $3::integer
`

type GetInvoicesByStatusParams struct {
	Status  string
	Page    int32
	PerPage int32
}

func (q *Queries) GetInvoicesByStatus(ctx context.Context, arg GetInvoicesByStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByStatus, arg.Status, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateInvoices = `-- name: PaginateInvoices :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices order by created desc offset $1::integer limit $2::integer
`

type PaginateInvoicesParams struct {
	Page    int32
	PerPage int32
}

func (q *Queries) PaginateInvoices(ctx context.Context, arg PaginateInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, paginateInvoices, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInvoices = `-- name: SearchInvoices :many
select id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated from invoices where invoice_number ilike '%' || $1::text || '%' or
  status ilike '%' || $1::text || '%' or
  customer ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchInvoicesParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchInvoices(ctx context.Context, arg SearchInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, searchInvoices, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Order,
			&i.Customer,
			&i.InvoiceDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Status,
			&i.InvoicePdfUrl,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoiceDueDate = `-- name: UpdateInvoiceDueDate :one
update invoices set due_date = $1::timestamptz where id = $2::uuid returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

type UpdateInvoiceDueDateParams struct {
	DueDate pgtype.Timestamptz
	ID      pgtype.UUID
}

func (q *Queries) UpdateInvoiceDueDate(ctx context.Context, arg UpdateInvoiceDueDateParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceDueDate, arg.DueDate, arg.ID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInvoiceStatus = `-- name: UpdateInvoiceStatus :one
update invoices set status = $1::text where id = $2::uuid returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

type UpdateInvoiceStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateInvoiceStatus(ctx context.Context, arg UpdateInvoiceStatusParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceStatus, arg.Status, arg.ID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateInvoiceTotalAmount = `-- name: UpdateInvoiceTotalAmount :one
update invoices set total_amount = $1::numeric where id = $2::uuid returning id, invoice_number, "order", customer, invoice_date, due_date, total_amount, status, invoice_pdf_url, created, updated
`

type UpdateInvoiceTotalAmountParams struct {
	TotalAmount pgtype.Numeric
	ID          pgtype.UUID
}

func (q *Queries) UpdateInvoiceTotalAmount(ctx context.Context, arg UpdateInvoiceTotalAmountParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceTotalAmount, arg.TotalAmount, arg.ID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Order,
		&i.Customer,
		&i.InvoiceDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Status,
		&i.InvoicePdfUrl,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
