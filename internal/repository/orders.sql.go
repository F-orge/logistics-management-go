// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: orders.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
insert into orders (
  custom_id, 
  customer, 
  order_date, 
  status, 
  total_amount, 
  created_by, 
  shipping_address, 
  billing_address, 
  assigned_warehouse
) values (
  $1::text,
  $2::uuid,
  $3::timestamptz,
  $4::text,
  $5::numeric,
  $6::uuid,
  $7::text,
  $8::text,
  $9::uuid
)
returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type CreateOrderParams struct {
	CustomID          string
	CustomerID        pgtype.UUID
	OrderDate         pgtype.Timestamptz
	Status            string
	TotalAmount       pgtype.Numeric
	CreatedBy         pgtype.UUID
	ShippingAddress   string
	BillingAddress    string
	AssignedWarehouse pgtype.UUID
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.CustomID,
		arg.CustomerID,
		arg.OrderDate,
		arg.Status,
		arg.TotalAmount,
		arg.CreatedBy,
		arg.ShippingAddress,
		arg.BillingAddress,
		arg.AssignedWarehouse,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const createOrderLineItem = `-- name: CreateOrderLineItem :one
insert into order_line_items (
  "order", 
  product, 
  quantity, 
  price_per_unit
) values (
  $1::uuid, 
  $2::uuid, 
  $3::integer, 
  $4::numeric
)
returning id, "order", product, quantity, price_per_unit, sub_total, created, updated
`

type CreateOrderLineItemParams struct {
	OrderID      pgtype.UUID
	ProductID    pgtype.UUID
	Quantity     int32
	PricePerUnit pgtype.Numeric
}

func (q *Queries) CreateOrderLineItem(ctx context.Context, arg CreateOrderLineItemParams) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, createOrderLineItem,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.PricePerUnit,
	)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :one
delete from orders where id = $1::uuid returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

func (q *Queries) DeleteOrder(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, deleteOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteOrderLineItem = `-- name: DeleteOrderLineItem :one
delete from order_line_items where id = $1::uuid returning id, "order", product, quantity, price_per_unit, sub_total, created, updated
`

func (q *Queries) DeleteOrderLineItem(ctx context.Context, id pgtype.UUID) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, deleteOrderLineItem, id)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getAllOrders = `-- name: GetAllOrders :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders order by created desc
`

func (q *Queries) GetAllOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.Query(ctx, getAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where id = $1::uuid
`

func (q *Queries) GetOrderByID(ctx context.Context, id pgtype.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getOrderLineItemByID = `-- name: GetOrderLineItemByID :one
select id, "order", product, quantity, price_per_unit, sub_total, created, updated from order_line_items where id = $1::uuid
`

func (q *Queries) GetOrderLineItemByID(ctx context.Context, id pgtype.UUID) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, getOrderLineItemByID, id)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getOrderLineItems = `-- name: GetOrderLineItems :many
select id, "order", product, quantity, price_per_unit, sub_total, created, updated from order_line_items where "order" = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetOrderLineItemsParams struct {
	OrderID pgtype.UUID
	Page    int32
	PerPage int32
}

func (q *Queries) GetOrderLineItems(ctx context.Context, arg GetOrderLineItemsParams) ([]OrderLineItem, error) {
	rows, err := q.db.Query(ctx, getOrderLineItems, arg.OrderID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderLineItem
	for rows.Next() {
		var i OrderLineItem
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.Product,
			&i.Quantity,
			&i.PricePerUnit,
			&i.SubTotal,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderLineItemsByOrder = `-- name: GetOrderLineItemsByOrder :many
select id, "order", product, quantity, price_per_unit, sub_total, created, updated from order_line_items where "order" = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetOrderLineItemsByOrderParams struct {
	OrderID pgtype.UUID
	Page    int32
	PerPage int32
}

func (q *Queries) GetOrderLineItemsByOrder(ctx context.Context, arg GetOrderLineItemsByOrderParams) ([]OrderLineItem, error) {
	rows, err := q.db.Query(ctx, getOrderLineItemsByOrder, arg.OrderID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderLineItem
	for rows.Next() {
		var i OrderLineItem
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.Product,
			&i.Quantity,
			&i.PricePerUnit,
			&i.SubTotal,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderLineItemsByProduct = `-- name: GetOrderLineItemsByProduct :many
select id, "order", product, quantity, price_per_unit, sub_total, created, updated from order_line_items where product = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetOrderLineItemsByProductParams struct {
	ProductID pgtype.UUID
	Page      int32
	PerPage   int32
}

func (q *Queries) GetOrderLineItemsByProduct(ctx context.Context, arg GetOrderLineItemsByProductParams) ([]OrderLineItem, error) {
	rows, err := q.db.Query(ctx, getOrderLineItemsByProduct, arg.ProductID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderLineItem
	for rows.Next() {
		var i OrderLineItem
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.Product,
			&i.Quantity,
			&i.PricePerUnit,
			&i.SubTotal,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByCustomer = `-- name: GetOrdersByCustomer :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where customer = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetOrdersByCustomerParams struct {
	CustomerID pgtype.UUID
	Page       int32
	PerPage    int32
}

func (q *Queries) GetOrdersByCustomer(ctx context.Context, arg GetOrdersByCustomerParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByCustomer, arg.CustomerID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByDateRange = `-- name: GetOrdersByDateRange :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where order_date >= $1::timestamptz and order_date <= $2::timestamptz order by created desc offset $3::integer limit $4::integer
`

type GetOrdersByDateRangeParams struct {
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Page      int32
	PerPage   int32
}

func (q *Queries) GetOrdersByDateRange(ctx context.Context, arg GetOrdersByDateRangeParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByDateRange,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByStatus = `-- name: GetOrdersByStatus :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where status = $1::text order by created desc offset $2::integer limit $3::integer
`

type GetOrdersByStatusParams struct {
	Status  string
	Page    int32
	PerPage int32
}

func (q *Queries) GetOrdersByStatus(ctx context.Context, arg GetOrdersByStatusParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByStatus, arg.Status, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByWarehouse = `-- name: GetOrdersByWarehouse :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where assigned_warehouse = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetOrdersByWarehouseParams struct {
	WarehouseID pgtype.UUID
	Page        int32
	PerPage     int32
}

func (q *Queries) GetOrdersByWarehouse(ctx context.Context, arg GetOrdersByWarehouseParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrdersByWarehouse, arg.WarehouseID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateOrders = `-- name: PaginateOrders :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders order by created desc offset $1::integer limit $2::integer
`

type PaginateOrdersParams struct {
	Page    int32
	PerPage int32
}

func (q *Queries) PaginateOrders(ctx context.Context, arg PaginateOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, paginateOrders, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOrders = `-- name: SearchOrders :many
select id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated from orders where custom_id ilike '%' || $1::text || '%' or shipping_address ilike '%' || $1::text || '%' or billing_address ilike '%' || $1::text || '%' order by created desc offset $2::integer limit $3::integer
`

type SearchOrdersParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchOrders(ctx context.Context, arg SearchOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, searchOrders, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomID,
			&i.Customer,
			&i.OrderDate,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedBy,
			&i.ShippingAddress,
			&i.BillingAddress,
			&i.AssignedWarehouse,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderAssignedWarehouse = `-- name: UpdateOrderAssignedWarehouse :one
update orders set assigned_warehouse = $1::uuid where id = $2::uuid returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderAssignedWarehouseParams struct {
	AssignedWarehouse pgtype.UUID
	ID                pgtype.UUID
}

func (q *Queries) UpdateOrderAssignedWarehouse(ctx context.Context, arg UpdateOrderAssignedWarehouseParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderAssignedWarehouse, arg.AssignedWarehouse, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderBillingAddress = `-- name: UpdateOrderBillingAddress :one
update orders set billing_address = $1::text where id = $2::uuid returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderBillingAddressParams struct {
	BillingAddress string
	ID             pgtype.UUID
}

func (q *Queries) UpdateOrderBillingAddress(ctx context.Context, arg UpdateOrderBillingAddressParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderBillingAddress, arg.BillingAddress, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderLineItemPricePerUnit = `-- name: UpdateOrderLineItemPricePerUnit :one
update order_line_items set price_per_unit = $1::numeric where id = $2::uuid returning id, "order", product, quantity, price_per_unit, sub_total, created, updated
`

type UpdateOrderLineItemPricePerUnitParams struct {
	PricePerUnit pgtype.Numeric
	ID           pgtype.UUID
}

func (q *Queries) UpdateOrderLineItemPricePerUnit(ctx context.Context, arg UpdateOrderLineItemPricePerUnitParams) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, updateOrderLineItemPricePerUnit, arg.PricePerUnit, arg.ID)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderLineItemQuantity = `-- name: UpdateOrderLineItemQuantity :one
update order_line_items set quantity = $1::integer where id = $2::uuid returning id, "order", product, quantity, price_per_unit, sub_total, created, updated
`

type UpdateOrderLineItemQuantityParams struct {
	Quantity int32
	ID       pgtype.UUID
}

func (q *Queries) UpdateOrderLineItemQuantity(ctx context.Context, arg UpdateOrderLineItemQuantityParams) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, updateOrderLineItemQuantity, arg.Quantity, arg.ID)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.Product,
		&i.Quantity,
		&i.PricePerUnit,
		&i.SubTotal,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderShippingAddress = `-- name: UpdateOrderShippingAddress :one
update orders set shipping_address = $1::text where id = $2::uuid returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderShippingAddressParams struct {
	ShippingAddress string
	ID              pgtype.UUID
}

func (q *Queries) UpdateOrderShippingAddress(ctx context.Context, arg UpdateOrderShippingAddressParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderShippingAddress, arg.ShippingAddress, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
update orders set status = $1::text where id = $2::uuid returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.Status, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateOrderTotalAmount = `-- name: UpdateOrderTotalAmount :one
update orders set total_amount = $1::numeric where id = $2::uuid returning id, custom_id, customer, order_date, status, total_amount, created_by, shipping_address, billing_address, assigned_warehouse, created, updated
`

type UpdateOrderTotalAmountParams struct {
	TotalAmount pgtype.Numeric
	ID          pgtype.UUID
}

func (q *Queries) UpdateOrderTotalAmount(ctx context.Context, arg UpdateOrderTotalAmountParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderTotalAmount, arg.TotalAmount, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomID,
		&i.Customer,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.CreatedBy,
		&i.ShippingAddress,
		&i.BillingAddress,
		&i.AssignedWarehouse,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
