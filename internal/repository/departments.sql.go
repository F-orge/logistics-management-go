// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: departments.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignUserToDepartment = `-- name: AssignUserToDepartment :one
insert into department_members (department_id, user_id, role)
values ($1::uuid, $2::uuid, $3::text)
returning department_id, user_id, role, created, updated
`

type AssignUserToDepartmentParams struct {
	DepartmentID pgtype.UUID
	UserID       pgtype.UUID
	Role         string
}

func (q *Queries) AssignUserToDepartment(ctx context.Context, arg AssignUserToDepartmentParams) (DepartmentMember, error) {
	row := q.db.QueryRow(ctx, assignUserToDepartment, arg.DepartmentID, arg.UserID, arg.Role)
	var i DepartmentMember
	err := row.Scan(
		&i.DepartmentID,
		&i.UserID,
		&i.Role,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const createDepartment = `-- name: CreateDepartment :one
insert into departments (name, description)
values ($1::text, $2::text)
returning id, name, description, created, updated
`

type CreateDepartmentParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateDepartment(ctx context.Context, arg CreateDepartmentParams) (Department, error) {
	row := q.db.QueryRow(ctx, createDepartment, arg.Name, arg.Description)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteDepartment = `-- name: DeleteDepartment :one
delete from departments where id = $1::uuid returning id, name, description, created, updated
`

func (q *Queries) DeleteDepartment(ctx context.Context, id pgtype.UUID) (Department, error) {
	row := q.db.QueryRow(ctx, deleteDepartment, id)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getAllDepartments = `-- name: GetAllDepartments :many
select id, name, description, created, updated from departments order by created desc
`

func (q *Queries) GetAllDepartments(ctx context.Context) ([]Department, error) {
	rows, err := q.db.Query(ctx, getAllDepartments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDepartmentByID = `-- name: GetDepartmentByID :one
select id, name, description, created, updated from departments where id = $1::uuid
`

func (q *Queries) GetDepartmentByID(ctx context.Context, id pgtype.UUID) (Department, error) {
	row := q.db.QueryRow(ctx, getDepartmentByID, id)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getDepartmentMembers = `-- name: GetDepartmentMembers :many
select u.id, dm.role, u.email, u.name from department_members dm
join auth.users u on dm.user_id = u.id
where dm.department_id = $1::uuid
order by dm.created desc offset $2::integer limit $3::integer
`

type GetDepartmentMembersParams struct {
	DepartmentID pgtype.UUID
	Page         int32
	PerPage      int32
}

type GetDepartmentMembersRow struct {
	ID    pgtype.UUID
	Role  string
	Email string
	Name  string
}

func (q *Queries) GetDepartmentMembers(ctx context.Context, arg GetDepartmentMembersParams) ([]GetDepartmentMembersRow, error) {
	rows, err := q.db.Query(ctx, getDepartmentMembers, arg.DepartmentID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDepartmentMembersRow
	for rows.Next() {
		var i GetDepartmentMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.Email,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateDepartment = `-- name: PaginateDepartment :many
select id, name, description, created, updated from departments order by created desc offset $1::integer limit $2::integer
`

type PaginateDepartmentParams struct {
	Page    int32
	PerPage int32
}

func (q *Queries) PaginateDepartment(ctx context.Context, arg PaginateDepartmentParams) ([]Department, error) {
	rows, err := q.db.Query(ctx, paginateDepartment, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDepartmentMembers = `-- name: SearchDepartmentMembers :many
select u.id, dm.role, u.email, u.name from department_members dm
join auth.users u on dm.user_id = u.id
where dm.department_id = $1::uuid 
and (
  u.email ilike '%' || $2::text || '%' 
  or u.name ilike '%' || $2::text || '%'
  or dm.role ilike '%' || $2::text || '%'
)
order by dm.created desc offset $3::integer limit $4::integer
`

type SearchDepartmentMembersParams struct {
	DepartmentID pgtype.UUID
	SearchText   string
	Page         int32
	PerPage      int32
}

type SearchDepartmentMembersRow struct {
	ID    pgtype.UUID
	Role  string
	Email string
	Name  string
}

func (q *Queries) SearchDepartmentMembers(ctx context.Context, arg SearchDepartmentMembersParams) ([]SearchDepartmentMembersRow, error) {
	rows, err := q.db.Query(ctx, searchDepartmentMembers,
		arg.DepartmentID,
		arg.SearchText,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchDepartmentMembersRow
	for rows.Next() {
		var i SearchDepartmentMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.Email,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDepartments = `-- name: SearchDepartments :many
select id, name, description, created, updated from departments where name ilike '%' || $1::text || '%' or description ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchDepartmentsParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchDepartments(ctx context.Context, arg SearchDepartmentsParams) ([]Department, error) {
	rows, err := q.db.Query(ctx, searchDepartments, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDepartmentDescription = `-- name: UpdateDepartmentDescription :one
update departments set description = $1::text where id = $2::uuid returning id, name, description, created, updated
`

type UpdateDepartmentDescriptionParams struct {
	Description string
	ID          pgtype.UUID
}

func (q *Queries) UpdateDepartmentDescription(ctx context.Context, arg UpdateDepartmentDescriptionParams) (Department, error) {
	row := q.db.QueryRow(ctx, updateDepartmentDescription, arg.Description, arg.ID)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateDepartmentName = `-- name: UpdateDepartmentName :one
update departments set name = $1::text where id = $2::uuid returning id, name, description, created, updated
`

type UpdateDepartmentNameParams struct {
	Name string
	ID   pgtype.UUID
}

func (q *Queries) UpdateDepartmentName(ctx context.Context, arg UpdateDepartmentNameParams) (Department, error) {
	row := q.db.QueryRow(ctx, updateDepartmentName, arg.Name, arg.ID)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
