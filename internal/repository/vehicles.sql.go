// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vehicles.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVehicle = `-- name: CreateVehicle :one
insert into vehicles (
  license_plate, 
  make, 
  model, 
  type, 
  capacity_volume, 
  capacity_weight, 
  status, 
  current_driver
)
values (
  $1::text, 
  $2::text, 
  $3::text, 
  $4::text, 
  $5::decimal, 
  $6::decimal, 
  $7::text, 
  $8::uuid
)
returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

type CreateVehicleParams struct {
	LicensePlate    string
	Make            string
	Model           string
	Type            string
	CapacityVolume  pgtype.Numeric
	CapacityWeight  pgtype.Numeric
	Status          string
	CurrentDriverID pgtype.UUID
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle,
		arg.LicensePlate,
		arg.Make,
		arg.Model,
		arg.Type,
		arg.CapacityVolume,
		arg.CapacityWeight,
		arg.Status,
		arg.CurrentDriverID,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteVehicle = `-- name: DeleteVehicle :one
delete from vehicles where id = $1::uuid returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

func (q *Queries) DeleteVehicle(ctx context.Context, id pgtype.UUID) (Vehicle, error) {
	row := q.db.QueryRow(ctx, deleteVehicle, id)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getVehicleByID = `-- name: GetVehicleByID :one
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles where id = $1::uuid
`

func (q *Queries) GetVehicleByID(ctx context.Context, id pgtype.UUID) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByID, id)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getVehicles = `-- name: GetVehicles :many
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles order by created desc offset $1::integer limit $2::integer
`

type GetVehiclesParams struct {
	Page    int32
	PerPage int32
}

func (q *Queries) GetVehicles(ctx context.Context, arg GetVehiclesParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, getVehicles, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.LicensePlate,
			&i.Make,
			&i.Model,
			&i.Type,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CurrentDriver,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByDriver = `-- name: GetVehiclesByDriver :many
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles where current_driver = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetVehiclesByDriverParams struct {
	DriverID pgtype.UUID
	Page     int32
	PerPage  int32
}

func (q *Queries) GetVehiclesByDriver(ctx context.Context, arg GetVehiclesByDriverParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, getVehiclesByDriver, arg.DriverID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.LicensePlate,
			&i.Make,
			&i.Model,
			&i.Type,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CurrentDriver,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByStatus = `-- name: GetVehiclesByStatus :many
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles where status = $1::text order by created desc offset $2::integer limit $3::integer
`

type GetVehiclesByStatusParams struct {
	Status  string
	Page    int32
	PerPage int32
}

func (q *Queries) GetVehiclesByStatus(ctx context.Context, arg GetVehiclesByStatusParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, getVehiclesByStatus, arg.Status, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.LicensePlate,
			&i.Make,
			&i.Model,
			&i.Type,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CurrentDriver,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVehicles = `-- name: SearchVehicles :many
select id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated from vehicles where license_plate ilike '%' || $1::text || '%' or
make ilike '%' || $1::text || '%' or
model ilike '%' || $1::text || '%' or
type ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchVehiclesParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchVehicles(ctx context.Context, arg SearchVehiclesParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, searchVehicles, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.LicensePlate,
			&i.Make,
			&i.Model,
			&i.Type,
			&i.CapacityVolume,
			&i.CapacityWeight,
			&i.Status,
			&i.CurrentDriver,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVehicleCapacity = `-- name: UpdateVehicleCapacity :one
update vehicles set capacity_volume = $1::decimal, capacity_weight = $2::decimal where id = $3::uuid
returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

type UpdateVehicleCapacityParams struct {
	CapacityVolume pgtype.Numeric
	CapacityWeight pgtype.Numeric
	ID             pgtype.UUID
}

func (q *Queries) UpdateVehicleCapacity(ctx context.Context, arg UpdateVehicleCapacityParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicleCapacity, arg.CapacityVolume, arg.CapacityWeight, arg.ID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateVehicleCurrentDriver = `-- name: UpdateVehicleCurrentDriver :one
update vehicles set current_driver = $1::uuid where id = $2::uuid returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

type UpdateVehicleCurrentDriverParams struct {
	CurrentDriverID pgtype.UUID
	ID              pgtype.UUID
}

func (q *Queries) UpdateVehicleCurrentDriver(ctx context.Context, arg UpdateVehicleCurrentDriverParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicleCurrentDriver, arg.CurrentDriverID, arg.ID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateVehicleStatus = `-- name: UpdateVehicleStatus :one
update vehicles set status = $1::text where id = $2::uuid returning id, license_plate, make, model, type, capacity_volume, capacity_weight, status, current_driver, created, updated
`

type UpdateVehicleStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateVehicleStatus(ctx context.Context, arg UpdateVehicleStatusParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicleStatus, arg.Status, arg.ID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.LicensePlate,
		&i.Make,
		&i.Model,
		&i.Type,
		&i.CapacityVolume,
		&i.CapacityWeight,
		&i.Status,
		&i.CurrentDriver,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
