// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: shipments.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addShipmentProofOfDeliveryImage = `-- name: AddShipmentProofOfDeliveryImage :one
update shipments 
set proof_of_delivery_image_url = 
  array_append(proof_of_delivery_image_url, $1::text)
where id = $2::uuid 
returning id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated
`

type AddShipmentProofOfDeliveryImageParams struct {
	ProofOfDeliveryImageUrl string
	ID                      pgtype.UUID
}

func (q *Queries) AddShipmentProofOfDeliveryImage(ctx context.Context, arg AddShipmentProofOfDeliveryImageParams) (Shipment, error) {
	row := q.db.QueryRow(ctx, addShipmentProofOfDeliveryImage, arg.ProofOfDeliveryImageUrl, arg.ID)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const createShipment = `-- name: CreateShipment :one
insert into shipments (
  "order", 
  tracking_number, 
  carrier, 
  status, 
  estimated_delivery_date, 
  actual_delivery_date, 
  proof_of_delivery_image_url, 
  driver, 
  current_location_notes, 
  department_assigned
)
values (
  $1::uuid, 
  $2::text, 
  $3::uuid, 
  $4::text, 
  $5::timestamptz, 
  $6::timestamptz, 
  $7::text[], 
  $8::uuid, 
  $9::text, 
  $10::uuid
)
returning id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated
`

type CreateShipmentParams struct {
	OrderID                 pgtype.UUID
	TrackingNumber          string
	Carrier                 pgtype.UUID
	Status                  string
	EstimatedDeliveryDate   pgtype.Timestamptz
	ActualDeliveryDate      pgtype.Timestamptz
	ProofOfDeliveryImageUrl []string
	DriverID                pgtype.UUID
	CurrentLocationNotes    string
	DepartmentID            pgtype.UUID
}

func (q *Queries) CreateShipment(ctx context.Context, arg CreateShipmentParams) (Shipment, error) {
	row := q.db.QueryRow(ctx, createShipment,
		arg.OrderID,
		arg.TrackingNumber,
		arg.Carrier,
		arg.Status,
		arg.EstimatedDeliveryDate,
		arg.ActualDeliveryDate,
		arg.ProofOfDeliveryImageUrl,
		arg.DriverID,
		arg.CurrentLocationNotes,
		arg.DepartmentID,
	)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const deleteShipment = `-- name: DeleteShipment :one
delete from shipments where id = $1::uuid returning id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated
`

func (q *Queries) DeleteShipment(ctx context.Context, id pgtype.UUID) (Shipment, error) {
	row := q.db.QueryRow(ctx, deleteShipment, id)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getShipmentByID = `-- name: GetShipmentByID :one
select id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated from shipments where id = $1::uuid
`

func (q *Queries) GetShipmentByID(ctx context.Context, id pgtype.UUID) (Shipment, error) {
	row := q.db.QueryRow(ctx, getShipmentByID, id)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getShipments = `-- name: GetShipments :many
select id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated from shipments order by created desc
`

func (q *Queries) GetShipments(ctx context.Context) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, getShipments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shipment
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.TrackingNumber,
			&i.Carrier,
			&i.Status,
			&i.EstimatedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.ProofOfDeliveryImageUrl,
			&i.Driver,
			&i.CurrentLocationNotes,
			&i.DepartmentAssigned,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShipmentsByCarrier = `-- name: GetShipmentsByCarrier :many
select id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated from shipments where carrier = $1::text order by created desc offset $2::integer limit $3::integer
`

type GetShipmentsByCarrierParams struct {
	Carrier string
	Page    int32
	PerPage int32
}

func (q *Queries) GetShipmentsByCarrier(ctx context.Context, arg GetShipmentsByCarrierParams) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, getShipmentsByCarrier, arg.Carrier, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shipment
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.TrackingNumber,
			&i.Carrier,
			&i.Status,
			&i.EstimatedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.ProofOfDeliveryImageUrl,
			&i.Driver,
			&i.CurrentLocationNotes,
			&i.DepartmentAssigned,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShipmentsByDepartment = `-- name: GetShipmentsByDepartment :many
select id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated from shipments where department_assigned = $1::text order by created desc offset $2::integer limit $3::integer
`

type GetShipmentsByDepartmentParams struct {
	DepartmentAssigned string
	Page               int32
	PerPage            int32
}

func (q *Queries) GetShipmentsByDepartment(ctx context.Context, arg GetShipmentsByDepartmentParams) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, getShipmentsByDepartment, arg.DepartmentAssigned, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shipment
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.TrackingNumber,
			&i.Carrier,
			&i.Status,
			&i.EstimatedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.ProofOfDeliveryImageUrl,
			&i.Driver,
			&i.CurrentLocationNotes,
			&i.DepartmentAssigned,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShipmentsByDriver = `-- name: GetShipmentsByDriver :many
select id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated from shipments where driver = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetShipmentsByDriverParams struct {
	DriverID pgtype.UUID
	Page     int32
	PerPage  int32
}

func (q *Queries) GetShipmentsByDriver(ctx context.Context, arg GetShipmentsByDriverParams) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, getShipmentsByDriver, arg.DriverID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shipment
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.TrackingNumber,
			&i.Carrier,
			&i.Status,
			&i.EstimatedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.ProofOfDeliveryImageUrl,
			&i.Driver,
			&i.CurrentLocationNotes,
			&i.DepartmentAssigned,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShipmentsByOrder = `-- name: GetShipmentsByOrder :many
select id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated from shipments where "order" = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetShipmentsByOrderParams struct {
	OrderID pgtype.UUID
	Page    int32
	PerPage int32
}

func (q *Queries) GetShipmentsByOrder(ctx context.Context, arg GetShipmentsByOrderParams) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, getShipmentsByOrder, arg.OrderID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shipment
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.TrackingNumber,
			&i.Carrier,
			&i.Status,
			&i.EstimatedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.ProofOfDeliveryImageUrl,
			&i.Driver,
			&i.CurrentLocationNotes,
			&i.DepartmentAssigned,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShipmentsByStatus = `-- name: GetShipmentsByStatus :many
select id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated from shipments where status = $1::text order by created desc offset $2::integer limit $3::integer
`

type GetShipmentsByStatusParams struct {
	Status  string
	Page    int32
	PerPage int32
}

func (q *Queries) GetShipmentsByStatus(ctx context.Context, arg GetShipmentsByStatusParams) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, getShipmentsByStatus, arg.Status, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shipment
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.TrackingNumber,
			&i.Carrier,
			&i.Status,
			&i.EstimatedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.ProofOfDeliveryImageUrl,
			&i.Driver,
			&i.CurrentLocationNotes,
			&i.DepartmentAssigned,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateShipments = `-- name: PaginateShipments :many
select id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated from shipments order by created desc offset $1::integer limit $2::integer
`

type PaginateShipmentsParams struct {
	Page    int32
	PerPage int32
}

func (q *Queries) PaginateShipments(ctx context.Context, arg PaginateShipmentsParams) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, paginateShipments, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shipment
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.TrackingNumber,
			&i.Carrier,
			&i.Status,
			&i.EstimatedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.ProofOfDeliveryImageUrl,
			&i.Driver,
			&i.CurrentLocationNotes,
			&i.DepartmentAssigned,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeShipmentProofOfDeliveryImage = `-- name: RemoveShipmentProofOfDeliveryImage :one
update shipments 
set proof_of_delivery_image_url = 
  array_remove(proof_of_delivery_image_url, $1::text) 
where id = $2::uuid 
returning id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated
`

type RemoveShipmentProofOfDeliveryImageParams struct {
	ProofOfDeliveryImageUrl string
	ID                      pgtype.UUID
}

func (q *Queries) RemoveShipmentProofOfDeliveryImage(ctx context.Context, arg RemoveShipmentProofOfDeliveryImageParams) (Shipment, error) {
	row := q.db.QueryRow(ctx, removeShipmentProofOfDeliveryImage, arg.ProofOfDeliveryImageUrl, arg.ID)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const searchShipments = `-- name: SearchShipments :many
select id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated from shipments where tracking_number ilike '%' || $1::text || '%' or status ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchShipmentsParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchShipments(ctx context.Context, arg SearchShipmentsParams) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, searchShipments, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shipment
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.Order,
			&i.TrackingNumber,
			&i.Carrier,
			&i.Status,
			&i.EstimatedDeliveryDate,
			&i.ActualDeliveryDate,
			&i.ProofOfDeliveryImageUrl,
			&i.Driver,
			&i.CurrentLocationNotes,
			&i.DepartmentAssigned,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShipmentActualDeliveryDate = `-- name: UpdateShipmentActualDeliveryDate :one
update shipments set actual_delivery_date = $1::timestamptz where id = $2::uuid returning id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated
`

type UpdateShipmentActualDeliveryDateParams struct {
	ActualDeliveryDate pgtype.Timestamptz
	ID                 pgtype.UUID
}

func (q *Queries) UpdateShipmentActualDeliveryDate(ctx context.Context, arg UpdateShipmentActualDeliveryDateParams) (Shipment, error) {
	row := q.db.QueryRow(ctx, updateShipmentActualDeliveryDate, arg.ActualDeliveryDate, arg.ID)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateShipmentCurrentLocationNotes = `-- name: UpdateShipmentCurrentLocationNotes :one
update shipments set current_location_notes = $1::text where id = $2::uuid returning id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated
`

type UpdateShipmentCurrentLocationNotesParams struct {
	CurrentLocationNotes string
	ID                   pgtype.UUID
}

func (q *Queries) UpdateShipmentCurrentLocationNotes(ctx context.Context, arg UpdateShipmentCurrentLocationNotesParams) (Shipment, error) {
	row := q.db.QueryRow(ctx, updateShipmentCurrentLocationNotes, arg.CurrentLocationNotes, arg.ID)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateShipmentDepartmentAssigned = `-- name: UpdateShipmentDepartmentAssigned :one
update shipments set department_assigned = $1::text where id = $2::uuid returning id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated
`

type UpdateShipmentDepartmentAssignedParams struct {
	DepartmentAssigned string
	ID                 pgtype.UUID
}

func (q *Queries) UpdateShipmentDepartmentAssigned(ctx context.Context, arg UpdateShipmentDepartmentAssignedParams) (Shipment, error) {
	row := q.db.QueryRow(ctx, updateShipmentDepartmentAssigned, arg.DepartmentAssigned, arg.ID)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateShipmentEstimatedDeliveryDate = `-- name: UpdateShipmentEstimatedDeliveryDate :one
update shipments set estimated_delivery_date = $1::timestamptz where id = $2::uuid returning id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated
`

type UpdateShipmentEstimatedDeliveryDateParams struct {
	EstimatedDeliveryDate pgtype.Timestamptz
	ID                    pgtype.UUID
}

func (q *Queries) UpdateShipmentEstimatedDeliveryDate(ctx context.Context, arg UpdateShipmentEstimatedDeliveryDateParams) (Shipment, error) {
	row := q.db.QueryRow(ctx, updateShipmentEstimatedDeliveryDate, arg.EstimatedDeliveryDate, arg.ID)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updateShipmentStatus = `-- name: UpdateShipmentStatus :one
update shipments set status = $1::text where id = $2::uuid returning id, "order", tracking_number, carrier, status, estimated_delivery_date, actual_delivery_date, proof_of_delivery_image_url, driver, current_location_notes, department_assigned, created, updated
`

type UpdateShipmentStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdateShipmentStatus(ctx context.Context, arg UpdateShipmentStatusParams) (Shipment, error) {
	row := q.db.QueryRow(ctx, updateShipmentStatus, arg.Status, arg.ID)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.Order,
		&i.TrackingNumber,
		&i.Carrier,
		&i.Status,
		&i.EstimatedDeliveryDate,
		&i.ActualDeliveryDate,
		&i.ProofOfDeliveryImageUrl,
		&i.Driver,
		&i.CurrentLocationNotes,
		&i.DepartmentAssigned,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
