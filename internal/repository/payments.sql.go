// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payments.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPayment = `-- name: CreatePayment :one
insert into payments (
  invoice, 
  payment_date, 
  amount_paid, 
  payment_method, 
  transaction_id, 
  status, 
  notes
)
values (
  $1::uuid, 
  $2::timestamptz, 
  $3::numeric, 
  $4::text, 
  $5::text, 
  $6::text, 
  $7::text
)
returning id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated
`

type CreatePaymentParams struct {
	InvoiceID     pgtype.UUID
	PaymentDate   pgtype.Timestamptz
	AmountPaid    pgtype.Numeric
	PaymentMethod string
	TransactionID string
	Status        string
	Notes         string
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.InvoiceID,
		arg.PaymentDate,
		arg.AmountPaid,
		arg.PaymentMethod,
		arg.TransactionID,
		arg.Status,
		arg.Notes,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where id = $1::uuid
`

func (q *Queries) GetPaymentByID(ctx context.Context, id pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getPayments = `-- name: GetPayments :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments order by created desc offset $1::integer limit $2::integer
`

type GetPaymentsParams struct {
	Page    int32
	PerPage int32
}

func (q *Queries) GetPayments(ctx context.Context, arg GetPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPayments, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByDateRange = `-- name: GetPaymentsByDateRange :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where payment_date >= $1::timestamptz and payment_date <= $2::timestamptz
order by created desc offset $3::integer limit $4::integer
`

type GetPaymentsByDateRangeParams struct {
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Page      int32
	PerPage   int32
}

func (q *Queries) GetPaymentsByDateRange(ctx context.Context, arg GetPaymentsByDateRangeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByDateRange,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByInvoice = `-- name: GetPaymentsByInvoice :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where invoice = $1::uuid order by created desc offset $2::integer limit $3::integer
`

type GetPaymentsByInvoiceParams struct {
	Invoice pgtype.UUID
	Page    int32
	PerPage int32
}

func (q *Queries) GetPaymentsByInvoice(ctx context.Context, arg GetPaymentsByInvoiceParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByInvoice, arg.Invoice, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByInvoiceAndDateRange = `-- name: GetPaymentsByInvoiceAndDateRange :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where invoice = $1::uuid and payment_date >= $2::timestamptz and payment_date <= $3::timestamptz
order by created desc offset $4::integer limit $5::integer
`

type GetPaymentsByInvoiceAndDateRangeParams struct {
	Invoice   pgtype.UUID
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Page      int32
	PerPage   int32
}

func (q *Queries) GetPaymentsByInvoiceAndDateRange(ctx context.Context, arg GetPaymentsByInvoiceAndDateRangeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByInvoiceAndDateRange,
		arg.Invoice,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByInvoiceAndStatus = `-- name: GetPaymentsByInvoiceAndStatus :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where invoice = $1::uuid and status = $2::text
order by created desc offset $3::integer limit $4::integer
`

type GetPaymentsByInvoiceAndStatusParams struct {
	Invoice pgtype.UUID
	Status  string
	Page    int32
	PerPage int32
}

func (q *Queries) GetPaymentsByInvoiceAndStatus(ctx context.Context, arg GetPaymentsByInvoiceAndStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByInvoiceAndStatus,
		arg.Invoice,
		arg.Status,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByMethod = `-- name: GetPaymentsByMethod :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where payment_method = $1::text order by created desc offset $2::integer limit $3::integer
`

type GetPaymentsByMethodParams struct {
	PaymentMethod string
	Page          int32
	PerPage       int32
}

func (q *Queries) GetPaymentsByMethod(ctx context.Context, arg GetPaymentsByMethodParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByMethod, arg.PaymentMethod, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByMethodAndDateRange = `-- name: GetPaymentsByMethodAndDateRange :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where payment_method = $1::text and payment_date >= $2::timestamptz and payment_date <= $3::timestamptz
order by created desc offset $4::integer limit $5::integer
`

type GetPaymentsByMethodAndDateRangeParams struct {
	PaymentMethod string
	StartDate     pgtype.Timestamptz
	EndDate       pgtype.Timestamptz
	Page          int32
	PerPage       int32
}

func (q *Queries) GetPaymentsByMethodAndDateRange(ctx context.Context, arg GetPaymentsByMethodAndDateRangeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByMethodAndDateRange,
		arg.PaymentMethod,
		arg.StartDate,
		arg.EndDate,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByMethodAndStatus = `-- name: GetPaymentsByMethodAndStatus :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where payment_method = $1::text and status = $2::text
order by created desc offset $3::integer limit $4::integer
`

type GetPaymentsByMethodAndStatusParams struct {
	PaymentMethod string
	Status        string
	Page          int32
	PerPage       int32
}

func (q *Queries) GetPaymentsByMethodAndStatus(ctx context.Context, arg GetPaymentsByMethodAndStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByMethodAndStatus,
		arg.PaymentMethod,
		arg.Status,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByStatus = `-- name: GetPaymentsByStatus :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where status = $1::text order by created desc offset $2::integer limit $3::integer
`

type GetPaymentsByStatusParams struct {
	Status  string
	Page    int32
	PerPage int32
}

func (q *Queries) GetPaymentsByStatus(ctx context.Context, arg GetPaymentsByStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByStatus, arg.Status, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByTransactionID = `-- name: GetPaymentsByTransactionID :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where transaction_id = $1::text order by created desc offset $2::integer limit $3::integer
`

type GetPaymentsByTransactionIDParams struct {
	TransactionID string
	Page          int32
	PerPage       int32
}

func (q *Queries) GetPaymentsByTransactionID(ctx context.Context, arg GetPaymentsByTransactionIDParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByTransactionID, arg.TransactionID, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPayments = `-- name: SearchPayments :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where transaction_id ilike '%' || $1::text || '%' or
  status ilike '%' || $1::text || '%' or
  notes ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchPaymentsParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchPayments(ctx context.Context, arg SearchPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, searchPayments, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentAmount = `-- name: UpdatePaymentAmount :one
update payments set amount_paid = $1::numeric where id = $2::uuid returning id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated
`

type UpdatePaymentAmountParams struct {
	AmountPaid pgtype.Numeric
	ID         pgtype.UUID
}

func (q *Queries) UpdatePaymentAmount(ctx context.Context, arg UpdatePaymentAmountParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentAmount, arg.AmountPaid, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updatePaymentNotes = `-- name: UpdatePaymentNotes :one
update payments set notes = $1::text where id = $2::uuid returning id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated
`

type UpdatePaymentNotesParams struct {
	Notes string
	ID    pgtype.UUID
}

func (q *Queries) UpdatePaymentNotes(ctx context.Context, arg UpdatePaymentNotesParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentNotes, arg.Notes, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
update payments set status = $1::text where id = $2::uuid returning id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated
`

type UpdatePaymentStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatus, arg.Status, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
