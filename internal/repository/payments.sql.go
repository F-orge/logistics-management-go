// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payments.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPayment = `-- name: CreatePayment :one
insert into payments (invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes)
values ($1, $2, $3, $4, $5, $6, $7)
returning id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated
`

type CreatePaymentParams struct {
	Invoice       pgtype.UUID
	PaymentDate   pgtype.Timestamptz
	AmountPaid    pgtype.Numeric
	PaymentMethod string
	TransactionID string
	Status        string
	Notes         pgtype.Text
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.Invoice,
		arg.PaymentDate,
		arg.AmountPaid,
		arg.PaymentMethod,
		arg.TransactionID,
		arg.Status,
		arg.Notes,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where id = $1
`

func (q *Queries) GetPaymentByID(ctx context.Context, id pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const getPayments = `-- name: GetPayments :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments order by created desc offset $1 limit $2
`

type GetPaymentsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetPayments(ctx context.Context, arg GetPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPayments, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByDateRange = `-- name: GetPaymentsByDateRange :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where payment_date >= $1 and payment_date <= $2
order by created desc offset $3 limit $4
`

type GetPaymentsByDateRangeParams struct {
	PaymentDate   pgtype.Timestamptz
	PaymentDate_2 pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) GetPaymentsByDateRange(ctx context.Context, arg GetPaymentsByDateRangeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByDateRange,
		arg.PaymentDate,
		arg.PaymentDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByInvoice = `-- name: GetPaymentsByInvoice :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where invoice = $1 order by created desc offset $2 limit $3
`

type GetPaymentsByInvoiceParams struct {
	Invoice pgtype.UUID
	Offset  int32
	Limit   int32
}

func (q *Queries) GetPaymentsByInvoice(ctx context.Context, arg GetPaymentsByInvoiceParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByInvoice, arg.Invoice, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByInvoiceAndDateRange = `-- name: GetPaymentsByInvoiceAndDateRange :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where invoice = $1 and payment_date >= $2 and payment_date <= $3
order by created desc offset $4 limit $5
`

type GetPaymentsByInvoiceAndDateRangeParams struct {
	Invoice       pgtype.UUID
	PaymentDate   pgtype.Timestamptz
	PaymentDate_2 pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) GetPaymentsByInvoiceAndDateRange(ctx context.Context, arg GetPaymentsByInvoiceAndDateRangeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByInvoiceAndDateRange,
		arg.Invoice,
		arg.PaymentDate,
		arg.PaymentDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByInvoiceAndStatus = `-- name: GetPaymentsByInvoiceAndStatus :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where invoice = $1 and status = $2
order by created desc offset $3 limit $4
`

type GetPaymentsByInvoiceAndStatusParams struct {
	Invoice pgtype.UUID
	Status  string
	Offset  int32
	Limit   int32
}

func (q *Queries) GetPaymentsByInvoiceAndStatus(ctx context.Context, arg GetPaymentsByInvoiceAndStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByInvoiceAndStatus,
		arg.Invoice,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByMethod = `-- name: GetPaymentsByMethod :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where payment_method = $1 order by created desc offset $2 limit $3
`

type GetPaymentsByMethodParams struct {
	PaymentMethod string
	Offset        int32
	Limit         int32
}

func (q *Queries) GetPaymentsByMethod(ctx context.Context, arg GetPaymentsByMethodParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByMethod, arg.PaymentMethod, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByMethodAndDateRange = `-- name: GetPaymentsByMethodAndDateRange :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where payment_method = $1 and payment_date >= $2 and payment_date <= $3
order by created desc offset $4 limit $5
`

type GetPaymentsByMethodAndDateRangeParams struct {
	PaymentMethod string
	PaymentDate   pgtype.Timestamptz
	PaymentDate_2 pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) GetPaymentsByMethodAndDateRange(ctx context.Context, arg GetPaymentsByMethodAndDateRangeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByMethodAndDateRange,
		arg.PaymentMethod,
		arg.PaymentDate,
		arg.PaymentDate_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByMethodAndStatus = `-- name: GetPaymentsByMethodAndStatus :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where payment_method = $1 and status = $2
order by created desc offset $3 limit $4
`

type GetPaymentsByMethodAndStatusParams struct {
	PaymentMethod string
	Status        string
	Offset        int32
	Limit         int32
}

func (q *Queries) GetPaymentsByMethodAndStatus(ctx context.Context, arg GetPaymentsByMethodAndStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByMethodAndStatus,
		arg.PaymentMethod,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByStatus = `-- name: GetPaymentsByStatus :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where status = $1 order by created desc offset $2 limit $3
`

type GetPaymentsByStatusParams struct {
	Status string
	Offset int32
	Limit  int32
}

func (q *Queries) GetPaymentsByStatus(ctx context.Context, arg GetPaymentsByStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByTransactionID = `-- name: GetPaymentsByTransactionID :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where transaction_id = $1 order by created desc offset $2 limit $3
`

type GetPaymentsByTransactionIDParams struct {
	TransactionID string
	Offset        int32
	Limit         int32
}

func (q *Queries) GetPaymentsByTransactionID(ctx context.Context, arg GetPaymentsByTransactionIDParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByTransactionID, arg.TransactionID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPayments = `-- name: SearchPayments :many
select id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated from payments where transaction_id ilike '%' || $1::text || '%' or
  status ilike '%' || $1::text || '%' or
  notes ilike '%' || $1::text || '%'
order by created desc offset $2::integer limit $3::integer
`

type SearchPaymentsParams struct {
	SearchText string
	Page       int32
	PerPage    int32
}

func (q *Queries) SearchPayments(ctx context.Context, arg SearchPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, searchPayments, arg.SearchText, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Invoice,
			&i.PaymentDate,
			&i.AmountPaid,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.Status,
			&i.Notes,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentAmount = `-- name: UpdatePaymentAmount :one
update payments set amount_paid = $1 where id = $2 returning id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated
`

type UpdatePaymentAmountParams struct {
	AmountPaid pgtype.Numeric
	ID         pgtype.UUID
}

func (q *Queries) UpdatePaymentAmount(ctx context.Context, arg UpdatePaymentAmountParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentAmount, arg.AmountPaid, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updatePaymentNotes = `-- name: UpdatePaymentNotes :one
update payments set notes = $1 where id = $2 returning id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated
`

type UpdatePaymentNotesParams struct {
	Notes pgtype.Text
	ID    pgtype.UUID
}

func (q *Queries) UpdatePaymentNotes(ctx context.Context, arg UpdatePaymentNotesParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentNotes, arg.Notes, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
update payments set status = $1 where id = $2 returning id, invoice, payment_date, amount_paid, payment_method, transaction_id, status, notes, created, updated
`

type UpdatePaymentStatusParams struct {
	Status string
	ID     pgtype.UUID
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatus, arg.Status, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Invoice,
		&i.PaymentDate,
		&i.AmountPaid,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.Status,
		&i.Notes,
		&i.Created,
		&i.Updated,
	)
	return i, err
}
