# Mutation Plan Template

This template provides a standardized structure for documenting mutation strategies for any domain (CRM, WMS, TMS, Billing, etc.) in the logistics management system.

**Instructions**: Copy this template and replace placeholders with domain-specific information. Follow the same format for consistency across all mutation documentation.

---

## [DOMAIN] Mutations Plan

> **Domain Description**: Brief explanation of what this domain manages (e.g., "CRM manages customer relationships, sales pipeline, and billing")

### Overview

This document outlines the mutation strategy for all [DOMAIN] entities in the logistics management system. Each entity includes Create, Update, and Delete mutation specifications with field-level metadata for frontend form generation and PocketBase backend operations.

### Key Principles

- **[Principle 1]**: e.g., Lead Conversion creates multiple related records atomically
- **[Principle 2]**: e.g., Status transitions follow a specific workflow
- **[Principle 3]**: e.g., Audit trail maintained for compliance
- **[Principle 4]**: e.g., Ownership model for access control
- **[Principle 5]**: e.g., Client-side validation via Zod

### Related Domains

- [Link to related domains if applicable]
- [e.g., CRM Invoices relate to Billing system]

---

## [Entity Name 1]

### Overview

**Purpose**: What is this entity used for?

**Key Relationships**:
- Belongs to: [Parent entities]
- Has many: [Child entities]
- Many-to-many with: [Related entities via junctions]

**User Roles Involved**: [e.g., Sales Manager, SDR, Admin]

### Create Mutation

#### Required Fields

- **field_name_1**
  - Type: `[string|number|date|datetime|enum|relation|file|boolean]`
  - Label: "Human-readable label"
  - Description: "What does this field store?"
  - Tooltip: "e.g., 'Next-Day Delivery', helpful context"
  - Constraints: Required, max X chars, format, uniqueness, etc.

- **field_name_2**
  - Type: `string`
  - Label: "Field Label"
  - Description: "Field description"
  - Tooltip: "User-facing help text"
  - Constraints: [Details]

#### Optional Fields

- **field_name_3**
  - Type: `[type]`
  - Label: "Field Label"
  - Description: "Field description"
  - Tooltip: "Help text"
  - Constraints: [Details]

- **field_name_4**
  - Type: `relation: [Entity]`
  - Label: "Field Label"
  - Description: "Field description"
  - Tooltip: "Help text"
  - Constraints: Optional, cascading behavior

#### Auto-Generated Fields

- **id**
  - Type: `string (uuid)`
  - Auto-generated by PocketBase
  - User cannot set or update

- **created**
  - Type: `datetime`
  - Auto-set to record creation timestamp
  - User cannot set or update

- **updated**
  - Type: `datetime`
  - Auto-updated on each modification
  - User cannot set or update

### Update Mutation

#### Mutable Fields

- **field_name_1**: Can be updated
  - Validation: [Any special rules when updating]
  - Side effects: [Does updating this field trigger other changes?]

- **field_name_2**: Can be updated
  - Validation: [Details]
  - Side effects: [Details]

#### Immutable Fields (Read-only after creation)

- **field_name_3**: Cannot be updated after creation (audit trail)
- **field_name_4**: Cannot be updated after creation (referential integrity)

#### Conditional Updates

- **field_name_5**: Can only be updated if [condition]
  - Example: Only update status if current status is 'draft'

### Delete Mutation

#### Deletion Rules

- **Role Requirements**: [Which roles can delete?]
- **State Constraints**: [Can only delete if in certain states]
- **Reference Constraints**: [Cannot delete if referenced elsewhere]
- **Time Constraints**: [e.g., Cannot delete within X days]

#### Recommended Deletion Strategy

- **Soft Delete** (Recommended):
  - Add fields: `deleted_at`, `deleted_by`
  - Mark records as archived instead of removing
  - Preserve audit trail

- **Hard Delete** (If applicable):
  - Cascading behavior: [What happens to child records?]
  - Archival before deletion: [Should records be archived first?]

---

## [Entity Name 2]

### Overview

**Purpose**: [Description]

**Key Relationships**: [Details]

**User Roles Involved**: [Details]

### Create Mutation

- **field_1**
  - Type: `[type]`
  - Label: "[Label]"
  - Description: "[Description]"
  - Tooltip: "[Help]"
  - Constraints: [Details]

- **[Additional fields following same format]**

### Update Mutation

- **field_1**: Can be updated [with any special rules]
- **field_2**: Cannot be updated (immutable)
- **[Additional fields following same format]**

### Delete Mutation

- Constraints: [Deletion rules]

---

## [Junction Table] (Many-to-Many)

### Overview

**Purpose**: Links [Entity A] to [Entity B]

**Primary Records**: 
- Parent: [Entity A]
- Related: [Entity B]

### Create Mutation

- **[entity_a_id]**
  - Type: `relation: [Entity A]`
  - Label: "[Entity A]"
  - Description: "[Which Entity A is this linking?]"
  - Tooltip: "[Help text]"
  - Constraints: Required, cannot be duplicated (unique constraint with entity_b_id)

- **[entity_b_id]**
  - Type: `relation: [Entity B]`
  - Label: "[Entity B]"
  - Description: "[Which Entity B is this linking?]"
  - Tooltip: "[Help text]"
  - Constraints: Required, cannot be duplicated

- **[quantity/amount/other_data]**
  - Type: `number`
  - Label: "[Label]"
  - Description: "[Description]"
  - Tooltip: "[Help]"
  - Constraints: [Optional, can be updated]

### Update Mutation

- **[entity_a_id]**: Cannot be updated (part of composite key)
- **[entity_b_id]**: Cannot be updated (move by deleting and re-adding)
- **[quantity/amount]**: Can be updated

### Delete Mutation

- Constraints: Can delete freely (unless parent record has constraints)

---

## Complex Mutation Scenarios

### Scenario 1: [Multi-Table Atomic Operation]

**Trigger**: [When does this happen?] e.g., User updates Status from 'X' to 'Y'

**Atomic Operation** (must all succeed or all fail):

1. Update [Entity A]:
   - Set field_a = value_a
   - Set field_b = value_b
   - [Additional updates]

2. Create [Entity B]:
   - field_1: [Value]
   - field_2: [Value]
   - [Additional fields]

3. Update [Entity C]:
   - Set field_x = value_x
   - [Additional updates]

4. Create Notification/Audit Entry (optional):
   - [Details about automatic side effects]

**Error Handling**:
- If step X fails, rollback all previous steps
- Return user-friendly error message

### Scenario 2: [Bulk Operation]

**Operation Type**: [e.g., Batch Import, Bulk Update]

**Process**:
1. Validate input format
2. Check for duplicates
3. Validate each record against constraints
4. Preview before confirmation
5. Execute atomically

**Result Reporting**:
- Total records processed
- Success count
- Failure count with reasons
- Partial success handling

### Scenario 3: [Cascading Updates]

**When [Event] happens**:
- Update [Entity A]: [Field changes]
- Update [Entity B]: [Field changes]
- Notify [User/Role]: [Message]
- Trigger [Workflow]: [Details]

**Constraints**:
- [Business rule 1]
- [Business rule 2]

---

## Validation Rules

### Global Validation Rules

- **Email Fields**: Must match RFC 5322 format
- **Date Fields**: Cannot be in the future (unless specified)
- **Currency Fields**: Must be >= 0, 2 decimal places
- **Relations**: Referenced entity must exist
- **Enums**: Must be one of predefined values

### Entity-Specific Validation Rules

#### [Entity Name]

- **field_1**: [Validation rule]
- **field_2**: [Validation rule]
- **Cross-field validation**: [If field_1 is X, then field_2 must be Y]

---

## Frontend Implementation Guidance

### Form Generation

```typescript
// Example Zod schema structure for this entity
const CreateSchema = z.object({
  field_1: z.string().max(200),
  field_2: z.number().min(0),
  field_3: z.enum(['option1', 'option2', 'option3']),
  // Additional fields...
});

type CreateInput = z.infer<typeof CreateSchema>;
```

### Form Metadata

The field definitions above can be used to auto-generate forms with:
- Input type inference from "Type" field
- Label and tooltip display
- Constraint validation feedback
- Help text tooltips
- Disabled states based on permissions

### Real-time Updates

- Use TanStack Query for mutations
- Invalidate related queries on success
- Show optimistic updates
- Revert on error with user notification

### Permissions

- Hide fields/buttons based on user role
- Disable immutable fields after creation
- Enforce role-based delete restrictions

---

## Backend Implementation Guidance

### PocketBase Hooks

```go
// Example hook structure
router.OnRecordBeforeCreate("collection_name").Add(func(e *core.RecordCreateEvent) error {
    // Validation logic
    // Set auto-fields
    // Check permissions
    return nil
})

router.OnRecordAfterCreate("collection_name").Add(func(e *core.RecordCreateEvent) error {
    // Side effects
    // Create related records
    // Send notifications
    // Audit logging
    return nil
})
```

### Validation Implementation

- Implement all constraints from "Constraints" field
- Cross-field validation for complex rules
- Database-level constraints (unique, foreign keys)
- Business logic validation in hooks

### Transaction Handling

- For multi-table mutations, use transactions
- Rollback all changes if any step fails
- Log failed transactions for debugging

### Audit Trail

- Log who created/updated/deleted each record
- Timestamp all changes
- Store old values for updates (optional)
- Never hard-delete, use soft-delete instead

---

## Database Implementation Guidance

### Migration Template

```go
// Example migration structure
package migrations

import (
    "github.com/pocketbase/pocketbase/core"
    "github.com/pocketbase/pocketbase/models"
)

func init() {
    migrations.Register(func(db dbx.Builder) error {
        // Create table
        // Add columns
        // Add indexes
        // Add constraints
        // Add triggers for auto-numbering
        return nil
    }, ...)
}
```

### Indexes

- Primary key: `id`
- Foreign keys: Index all `relation` fields
- Frequently queried: `created`, `updated`, `status`, `owner`
- Filtering: Any field used in common filters

### Constraints

- Unique constraints on: [Fields that must be unique]
- Foreign key constraints on: [All relation fields]
- Not null constraints on: [All required fields]
- Check constraints on: [Enum fields, numeric ranges]

### Triggers

- Auto-increment/generate: `invoiceNumber`, `caseNumber`, etc.
- Timestamp updates: Auto-set `updated` field
- Cascade behavior: Define on foreign keys

---

## Testing Strategy

### Unit Tests

- Test each validation rule
- Test field constraints
- Test enum values
- Test required field checks

### Integration Tests

- Test create operations
- Test update operations with immutable field checks
- Test delete operations with constraint checks
- Test complex multi-table mutations

### User Story Tests

- Test complete workflows from user stories
- Test edge cases and error scenarios
- Test permission enforcement
- Test audit trail completeness

---

## Workflow Examples

### [Workflow Name]: From State X to State Y

**Steps**:
1. [User Action 1]
2. [System validates...]
3. [System creates/updates...]
4. [System notifies...]
5. [Result shown to user]

**Permissions Required**: [Role]

**Possible Errors**:
- [Error 1]: [How to handle]
- [Error 2]: [How to handle]

---

## Related Documentation

- [Link to dataflow diagram]
- [Link to user stories]
- [Link to API documentation]
- [Link to database schema]

---

## Version History

| Date | Author | Changes |
|------|--------|---------|
| YYYY-MM-DD | [Name] | Initial creation |
| | | |

---

## Questions & Notes

- [Any open questions about this domain?]
- [Any known limitations?]
- [Future enhancements?]
