---
applyTo: '{src,tests}/db/*.repository.{test.ts,ts}'
---

# Copilot Database Instructions

## Database Technology Stack
- **Query Builder**: Kysely (TypeScript SQL query builder)
- **Database Types**: Auto-generated using `kysely-codegen`
- **Type Interface**: `DB` interface in `db/types.ts`
- **Testing Framework**: bun:test
- **Architecture Pattern**: Repository Pattern
- **Database Design**: Follow domain-driven design principles

## Core Principles

### 1. Repository Pattern Implementation
- Create repository interfaces for each domain entity
- Implement concrete repositories using Kysely
- Use dependency injection for repository instances
- Separate business logic from data access logic

### 2. Kysely Best Practices
- Always use type-safe queries with proper TypeScript interfaces
- Utilize CamelCasePlugin for automatic snake_case â†” camelCase conversion
- Use Kysely's transaction support for multi-table operations
- Implement proper error handling and connection management
- Use compiled queries for frequently executed operations
- Leverage Kysely's built-in SQL injection protection
- Return `undefined` instead of `null` when no record is found in repository methods

### 3. Database Schema Design
- Database columns use snake_case (e.g., `created_at`, `user_id`, `first_name`)
- TypeScript interfaces use camelCase (e.g., `createdAt`, `userId`, `firstName`)
- Database types are auto-generated by `kysely-codegen` into `db/types.ts`
- CamelCasePlugin automatically converts between snake_case and camelCase
- Include proper indexes for query optimization
- Implement soft deletes using `deletedAt` timestamp columns (stored as `deleted_at`)
- Use UUID primary keys for distributed systems
- Include audit fields: `createdAt`, `updatedAt`, `createdBy`, `updatedBy`

## Code Structure

### Repository File Naming Convention
- Each repository must be in a single file
- Follow the pattern: `<name>.repository.ts`
- Include both interface and implementation in the same file
- Examples: `user.repository.ts`, `product.repository.ts`, `order.repository.ts`

### Database Configuration
```typescript
// db/config.ts
import { Kysely, PostgresDialect, CamelCasePlugin } from 'kysely'
import { Pool } from 'pg'
import { DB } from './types' // Auto-generated by kysely-codegen

export const db = new Kysely<DB>({
  dialect: new PostgresDialect({
    pool: new Pool({
      connectionString: process.env.DATABASE_URL,
    }),
  }),
  plugins: [new CamelCasePlugin()],
})
```

### Database Types
```typescript
// db/types.ts
// This file is auto-generated by kysely-codegen
// DO NOT MODIFY MANUALLY - regenerate using: npx kysely-codegen

export interface DB {
  // Auto-generated table interfaces
  // Will be populated by kysely-codegen based on your database schema
}
```

### Repository Pattern Structure
Each repository should be in a single file following the naming convention: `<name>.repository.ts`

```typescript
// repositories/user.repository.ts
import { Kysely, Selectable, Updateable, Insertable } from 'kysely'
import { Database } from '../db/config'

// Repository interface
export interface IUserRepository {
  findById(id: string): Promise<Selectable<User> | undefined>
  findByEmail(email: string): Promise<Selectable<User> | undefined>
  create(user: Insertable<User>): Promise<Selectable<User>>
  update(id: string, updates: Updateable<User>): Promise<Selectable<User>>
  delete(id: string): Promise<void>
  softDelete(id: string): Promise<void>
  findAllPaginated(limit: number, offset: number): Promise<Selectable<User>[]>
}

// Repository implementation
export class KyselyUserRepository implements IUserRepository {
  constructor(private db: Kysely<Database>) {}

  async findById(id: string): Promise<Selectable<User> | undefined> {
    return await this.db
      .selectFrom('users')
      .selectAll()
      .where('id', '=', id)
      .where('deletedAt', 'is', null) // CamelCasePlugin converts deleted_at to deletedAt
      .executeTakeFirst()
  }

  async create(user: Insertable<User>): Promise<Selectable<User>> {
    return await this.db
      .insertInto('users')
      .values({
        ...user,
        id: crypto.randomUUID(),
        createdAt: new Date(), // Converted to created_at in database
        updatedAt: new Date(), // Converted to updated_at in database
      })
      .returningAll()
      .executeTakeFirstOrThrow()
  }

  async update(id: string, updates: Updateable<User>): Promise<Selectable<User>> {
    return await this.db
      .updateTable('users')
      .set({
        ...updates,
        updatedAt: new Date(),
      })
      .where('id', '=', id)
      .where('deletedAt', 'is', null)
      .returningAll()
      .executeTakeFirstOrThrow()
  }

  async softDelete(id: string): Promise<void> {
    await this.db
      .updateTable('users')
      .set({
        deletedAt: new Date(),
        updatedAt: new Date(),
      })
      .where('id', '=', id)
      .execute()
  }

  async findAllPaginated(limit: number, offset: number): Promise<Selectable<User>[]> {
    return await this.db
      .selectFrom('users')
      .selectAll()
      .where('deletedAt', 'is', null) // Exclude soft-deleted records
      .limit(limit)
      .offset(offset)
      .execute();
  }
}
```

## Database Operation Guidelines

### Query Construction
- Always use parameterized queries (Kysely handles this automatically)
- Use `selectAll()` or explicitly specify columns - avoid `select('*')`
- Implement proper pagination using `limit()` and `offset()`
- Use `executeTakeFirst()` for single record queries
- Use `executeTakeFirstOrThrow()` when record must exist

### Transaction Management
```typescript
async transferFunds(fromId: string, toId: string, amount: number): Promise<void> {
  await this.db.transaction().execute(async (trx) => {
    await trx
      .updateTable('accounts')
      .set('balance', (eb) => eb('balance', '-', amount))
      .where('id', '=', fromId)
      .execute()

    await trx
      .updateTable('accounts')
      .set('balance', (eb) => eb('balance', '+', amount))
      .where('id', '=', toId)
      .execute()
  })
}
```

### Error Handling
- Use try-catch blocks around database operations
- Implement specific error types for different database errors
- Log database errors with appropriate context
- Return meaningful error messages to the application layer

### Soft Deletes
- Implement `deletedAt` timestamp column (stored as `deleted_at` in database)
- Always filter out soft-deleted records using `where('deletedAt', 'is', null)`
- Provide separate methods for hard and soft deletes
- Include restore functionality for soft-deleted records

## Testing with bun:test

### Test Setup Configuration
The testing environment uses a global setup file that manages database connections:

```typescript
// tests/setup.ts
import { beforeAll, afterAll } from 'bun:test'
import { Kysely, PostgresDialect, CamelCasePlugin } from 'kysely'
import { Pool } from 'pg'
import { DB } from '../db/types'

// Global test setup - runs once before all tests
beforeAll(async () => {
  // Create test database instance using environment variable
  globalThis.testDb = new Kysely<DB>({
    dialect: new PostgresDialect({
      pool: new Pool({
        connectionString: process.env.TEST_DB_URL,
      }),
    }),
    plugins: [new CamelCasePlugin()],
  })

  // Run any necessary database migrations or seed data here
  // await runMigrations(globalThis.testDb)
})

// Global test teardown - runs once after all tests
afterAll(async () => {
  // Clean up database connection
  if (globalThis.testDb) {
    await globalThis.testDb.destroy()
  }
})

// Extend globalThis type for TypeScript
declare global {
  var testDb: Kysely<DB>
}
```

### Test Execution
Tests are executed using the preload setup:
```bash
bun --preload tests/setup.ts test
```

### Repository Test Structure
```typescript
// tests/repositories/user.repository.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'bun:test'
import { KyselyUserRepository } from '../../repositories/user.repository'

describe('UserRepository', () => {
  let repository: KyselyUserRepository
  
  beforeEach(async () => {
    // Use the global test database instance
    repository = new KyselyUserRepository(globalThis.testDb)
    // Setup test data if needed
  })

  afterEach(async () => {
    // Cleanup test data after each test
    await globalThis.testDb.deleteFrom('users').execute()
  })

  it('should create a user successfully', async () => {
    const userData = {
      email: 'test@example.com',
      name: 'Test User',
    }

    const user = await repository.create(userData)

    expect(user).toBeDefined()
    expect(user.email).toBe(userData.email)
    expect(user.id).toBeDefined()
    expect(user.createdAt).toBeDefined()
  })

  it('should find user by id', async () => {
    // Create test user first
    const userData = {
      email: 'test@example.com',
      name: 'Test User',
    }
    const createdUser = await repository.create(userData)

    // Test finding by ID
    const foundUser = await repository.findById(createdUser.id)

    expect(foundUser).toBeDefined()
    expect(foundUser?.id).toBe(createdUser.id)
    expect(foundUser?.email).toBe(userData.email)
  })

  it('should soft delete user', async () => {
    // Create test user
    const userData = {
      email: 'test@example.com',
      name: 'Test User',
    }
    const createdUser = await repository.create(userData)

    // Soft delete the user
    await repository.softDelete(createdUser.id)

    // Verify user is not found (soft deleted)
    const foundUser = await repository.findById(createdUser.id)
    expect(foundUser).toBeNull()
  })

  it('should find all users with pagination', async () => {
    // Create test users
    const userData1 = { email: 'user1@example.com', name: 'User One' }
    const userData2 = { email: 'user2@example.com', name: 'User Two' }
    await repository.create(userData1)
    await repository.create(userData2)

    // Find all users with pagination
    const usersPage1 = await repository.findAllPaginated(1, 0)
    const usersPage2 = await repository.findAllPaginated(1, 1)

    expect(usersPage1).toHaveLength(1)
    expect(usersPage1[0].email).toBe(userData1.email)

    expect(usersPage2).toHaveLength(1)
    expect(usersPage2[0].email).toBe(userData2.email)
  })
})
```

### Test Database Setup
- Use `tests/setup.ts` for global test configuration
- Execute tests with: `bun --preload tests/setup.ts test`
- Leverage testcontainers for isolated database testing
- Use `globalThis` to share test resources across all test files
- Implement proper cleanup in global teardown functions

## Performance Optimization

### Query Optimization
- Use appropriate indexes for frequently queried columns
- Implement query result caching where appropriate
- Use `select()` to limit returned columns
- Implement database connection pooling
- Use compiled queries for repeated operations

### Batch Operations
```typescript
async createMultipleUsers(users: CreateUserInput[]): Promise<User[]> {
  return await this.db
    .insertInto('users')
    .values(users.map(user => ({
      ...user,
      id: crypto.randomUUID(),
      createdAt: new Date(), // Converted to created_at in database
      updatedAt: new Date(), // Converted to updated_at in database
    })))
    .returningAll()
    .execute()
}
```

## Security Considerations

### Data Validation
- Validate all input data before database operations
- Use TypeScript interfaces to ensure type safety
- Implement input sanitization for user-provided data
- Use Kysely's built-in SQL injection protection

### Access Control
- Implement row-level security where applicable
- Use database roles and permissions appropriately
- Audit sensitive database operations
- Implement proper logging for security events

## Migration Exclusions
- Do not include database migration code or logic
- Focus only on query operations and repository patterns
- Migration handling is managed separately from this codebase

## Common Patterns to Follow

1. **Use single-file repositories with `<n>.repository.ts` naming**
2. **Include both interface and implementation in the same file**
3. **Always use interfaces for repositories**
4. **Import DB types from auto-generated `db/types.ts`**
5. **Use global test setup with `tests/setup.ts` and testcontainers**
6. **Execute tests with `bun --preload tests/setup.ts test`**
7. **Access test database via `globalThis.testDb`**
8. **Implement proper error handling**
9. **Use transactions for multi-table operations**
10. **Include audit fields in all tables**
11. **Implement soft deletes by default**
12. **Write comprehensive tests for all repository methods**
13. **Use TypeScript strictly with proper interfaces**
14. **Implement proper logging and monitoring**
15. **Follow consistent naming conventions**
16. **Use dependency injection for better testability**

## Code Review Checklist
- [ ] Repository implements the defined interface
- [ ] Proper error handling is implemented
- [ ] SQL queries are type-safe with Kysely
- [ ] Tests cover all repository methods
- [ ] Soft delete logic is implemented where applicable
- [ ] Transaction boundaries are properly defined
- [ ] Input validation is performed
- [ ] Logging is implemented for important operations
- [ ] Performance considerations are addressed