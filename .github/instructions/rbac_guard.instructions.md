# RBAC Guards (async-graphql)

This document summarizes the recent work done in the `graphql-crm` domain and contains a detailed, repeatable set of instructions to implement Role-Based Access Control (RBAC) using async-graphql field guards so you can replicate the behavior across other domains/services.

---

## Conversation summary

- We applied role-based guards across all resolvers in `services/graphql-crm/src/queries/*` following the permission mappings in `docs/permission/crm.md`.
- Implementation approach used existing guard utilities from the `graphql-auth` crate: `RoleGuard` and the `UserRole` enum (generated by SeaORM codegen), and removed redundant `RequireSession` uses in resolvers that are already guarded at the merged `lib.rs` level.
- For permissions that include `owner` or `user (self)` we deferred ownership checks because they require either resolver-level runtime checks or an extended guard that accepts parameters — both approaches are documented below.
- Repeated `cargo check -p graphql-crm` after each change to ensure compilation remained green.

---

## High-level approach used

- Keep session enforcement at a single top-level place (e.g., `lib.rs` or global middleware). Do not add `RequireSession` to each resolver if it's already enforced globally.
- Implement a simple `RoleGuard` that checks the current user's role (already available in `services/graphql-auth/src/guards.rs` in this repo).
- Apply guards on fields and resolver methods using the `#[graphql(guard = "...")]` attribute. Use `.or(...)` to compose multiple allowed roles.
- For owner/self checks, either do a runtime check in the resolver or implement a parameterized guard that accepts the record owner id (see examples below).

---

## Pattern: RoleGuard implementation (reference)

This repo has a working `RoleGuard` in `graphql-auth`. The pattern is:

```rust
pub struct RoleGuard {
    role: UserRole,
}

impl RoleGuard {
    pub fn new(role: UserRole) -> Self { Self { role } }
}

impl Guard for RoleGuard {
    async fn check(&self, ctx: &Context<'_>) -> async_graphql::Result<()> {
        let current_user = ctx.data::<user::Model>()?;

        // developer bypass example (optional)
        if current_user.role == Some(UserRole::Developer) { return Ok(()); }

        if current_user.role == Some(self.role) { Ok(()) } else { Err("Forbidden".into()) }
    }
}
```

Notes:
- The guard reads the current user from the GraphQL context. Make sure your application injects `user::Model` (or equivalent) into the context before executing resolvers.
- Use `async_graphql::Result<()>` and return `Err("Forbidden".into())` on denial.

---

## How to add a guard to a resolver field

1. Import the guard and the role enum into your resolver file:

```rust
use graphql_auth::guards::RoleGuard;
use graphql_auth::entities::_generated::sea_orm_active_enums::UserRole;
```

2. Put the guard attribute on the field or method. Example (single role):

```rust
#[Object]
impl companies::Entity {
    #[graphql(name = "company", guard = "RoleGuard::new(UserRole::Admin)")]
    async fn view(&self, ctx: &Context<'_>, id: Uuid) -> Result<Option<companies::Model>> {
        // ...
    }
}
```

3. For multiple allowed roles, use `.or(...)` to compose:

```rust
#[graphql(guard = "RoleGuard::new(UserRole::Admin).or(RoleGuard::new(UserRole::SalesManager)).or(RoleGuard::new(UserRole::SalesRep))")]
```

4. If you need to pass a resolver parameter into the guard (e.g., pass `owner_id`) you can construct the guard from parameters as documented in async-graphql. E.g. `guard = "OwnerGuard::new(owner)")` where `owner` is a function parameter name.

---

## Implementing owner/self checks

There are two practical ways to enforce "owner" rules.

Option A — Runtime resolver check (simplest, most explicit)
- In the resolver implementation, after loading the record, fetch the current user from context and compare the owner's id.

Example:

```rust
async fn updateContact(&self, ctx: &Context<'_>, id: Uuid, value: UpdateContact) -> Result<contacts::Model> {
    let db = ctx.data::<DatabaseConnection>()?;
    let current_user = ctx.data::<user::Model>()?;

    // fetch existing record
    let existing = contacts::Entity::find_by_id(id).one(db).await?.ok_or("Not found")?;

    // allow if admin or owner
    if current_user.role != Some(UserRole::Admin) && existing.owner_id != current_user.id {
        return Err("Forbidden".into());
    }

    // update logic...
}
```

Pros: straightforward, flexible; you can include any logic you need (teams, multi-owner, permissions by field).
Cons: repeated logic across resolvers unless factored out.

Option B — Parameterized Guard (reusable)
- Implement a guard that accepts a parameter (owner id). async-graphql supports parameter usage when creating guards from resolver field arguments.

Example guard skeleton:

```rust
pub struct OwnerGuard {
    owner_id: Uuid,
}

impl OwnerGuard {
    pub fn new(owner_id: Uuid) -> Self { Self { owner_id } }
}

impl Guard for OwnerGuard {
    async fn check(&self, ctx: &Context<'_>) -> async_graphql::Result<()> {
        let user = ctx.data::<user::Model>()?;
        if user.role == Some(UserRole::Admin) { return Ok(()); }
        if user.id == self.owner_id { return Ok(()); }
        Err("Forbidden".into())
    }
}
```

Use it in a resolver where the owner id is a parameter or computed value:

```rust
#[graphql(guard = "OwnerGuard::new(owner_id).or(RoleGuard::new(UserRole::Admin))")]
async fn update_contact(&self, ctx: &Context<'_>, id: Uuid, owner_id: Uuid, input: UpdateContact) -> Result<contacts::Model> {
    // `owner_id` must be a resolver argument or expression available in the attribute's scope
}
```

Important: The value you pass to `OwnerGuard::new(...)` must be available as a variable in the resolver scope (for example, a function argument name). See async-graphql docs on using parameter values in guards.

Pros: DRY, reusable guard that encodes ownership logic in one place.
Cons: Slightly more complex; you must ensure the parameter is available where the guard attribute is evaluated.

---

## Example: combining role and owner logic

If `sales rep (owner)` can update but other roles can't, you can combine like:

```rust
#[graphql(guard = "RoleGuard::new(UserRole::Admin).or(OwnerGuard::new(owner_id))")]
async fn update_company(&self, ctx: &Context<'_>, id: Uuid, owner_id: Uuid, payload: UpdateCompany) -> Result<companies::Model> {
    // ...
}
```

Or perform a short runtime check in resolver if constructing `owner_id` for guard is awkward.

---

## Practical checklist to replicate across domains

1. Ensure you have a `UserRole` enum accessible to all services that need role checks (SeaORM codegen or shared crate).
2. Implement the simple `RoleGuard` in a shared crate (`graphql-auth` in this repository) that reads the current user from GraphQL context.
3. Inject the authenticated `user::Model` (and `session::Model` if relevant) into the async-graphql `Schema` request context during request handling.
4. For each resolver file:
   - Import `RoleGuard` and `UserRole`.
   - Add `#[graphql(guard = "...")]` to fields and mutation methods according to your permissions matrix.
   - For owner/self rules, decide between runtime checks or parameterized guards and implement accordingly.
5. After edits run:

```bash
cargo check -p graphql-crm
# or to check entire workspace
cargo check
```

6. Add unit or integration tests that validate: allowed roles succeed, denied roles are rejected, ownership checks behave as expected.

---

## Testing and validation

- Write small GraphQL integration tests that call guarded fields under different context user roles.
- Validate error messages/HTTP status from GraphQL when forbidden (async-graphql will return an error where Guard::check returned Err).
- Add tests that ensure `developer` or other bypass roles (if used) still get access.

---

## Pitfalls and gotchas

- Guard attribute expressions are evaluated at compile-time in the sense of syntax; values you refer to in the guard expression must be available as variable names (resolver args or in scope) — otherwise the attribute will not compile.
- Don't duplicate session checking everywhere. Prefer a single central session guard if every resolver requires authentication.
- Owner checks need access to record owner id — plan whether the resolver will fetch the record first or whether the owner id will be provided as an argument.
- Be careful with import paths for `UserRole`: in this repo we used `graphql_auth::entities::_generated::sea_orm_active_enums::UserRole` to match `RoleGuard` code. Keep the source of `UserRole` consistent with `RoleGuard`.

---

## Recommended follow-ups (optional)

- Implement `OwnerGuard` to centralize the owner checks.
- Add small helper macros or wrapper functions to reduce boilerplate for composing role/or/owner guards.
- Create automated tests for permission matrices (matrix of roles x operations).
- Add a short code snippet in a README that documents the canonical import paths for guards and role enums in your repo layout.

---

If you'd like, I can:
- Implement `OwnerGuard` in `graphql-auth` and wire it into one resolver as an example, or
- Add tests that exercise the new guards, or
- Propagate the same guard pattern to other services/domains.

Tell me which of those you'd like next and I'll proceed.
