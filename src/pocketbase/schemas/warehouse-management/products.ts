/**
 * Auto-generated Zod schema for WarehouseManagementProducts
 * Generated by: scripts/generate-zod-schemas.ts
 * DO NOT EDIT MANUALLY
 */

import { ClientResponseError } from "pocketbase";
import { z } from "zod";
import { Collections, TypedPocketBase } from "@/lib/pb.types";

export const ProductsSchema = z.object({
  id: z.string(),
  sku: z.string(),
  name: z.string(),
  barcode: z.string().optional(),
  description: z.string().optional(),
  category: z.string().optional(),
  price: z.number().optional(),
  unit: z.string().optional(),
  weight: z.number().optional(),
  length: z.number().optional(),
  width: z.number().optional(),
  height: z.number().optional(),
  status: z.enum(["active", "discontinued", "obsolete"]).optional(),
  supplier: z.string().optional(),
  client: z.string().optional(),
  images: z.array(z.string()).optional(),
  created: z.iso.datetime().optional(),
  updated: z.iso.datetime().optional(),
});

export type Products = z.infer<typeof ProductsSchema>;

export const CreateProductsSchema = (pocketbase: TypedPocketBase) =>
  ProductsSchema.omit({
    id: true,
    created: true,
    updated: true,
  }).superRefine(async (data, ctx) => {
    // Validate SKU is not empty
    if (!data.sku || data.sku.trim().length === 0) {
      ctx.addIssue({
        code: "custom",
        path: ["sku"],
        message: "SKU is required",
      });
    }

    // Validate name is not empty
    if (!data.name || data.name.trim().length === 0) {
      ctx.addIssue({
        code: "custom",
        path: ["name"],
        message: "Product name is required",
      });
    }

    // Validate price is non-negative if provided
    if (data.price !== undefined && data.price < 0) {
      ctx.addIssue({
        code: "custom",
        path: ["price"],
        message: "Price cannot be negative",
      });
    }

    // Validate dimensions are positive if provided
    if (data.weight !== undefined && data.weight <= 0) {
      ctx.addIssue({
        code: "custom",
        path: ["weight"],
        message: "Weight must be a positive value",
      });
    }
    if (data.length !== undefined && data.length <= 0) {
      ctx.addIssue({
        code: "custom",
        path: ["length"],
        message: "Length must be a positive value",
      });
    }
    if (data.width !== undefined && data.width <= 0) {
      ctx.addIssue({
        code: "custom",
        path: ["width"],
        message: "Width must be a positive value",
      });
    }
    if (data.height !== undefined && data.height <= 0) {
      ctx.addIssue({
        code: "custom",
        path: ["height"],
        message: "Height must be a positive value",
      });
    }

    // Verify supplier exists if provided
    if (data.supplier) {
      try {
        const supplier = await pocketbase
          .collection(Collections.WarehouseManagementSuppliers)
          .getOne(data.supplier, { requestKey: null });
        if (!supplier) {
          ctx.addIssue({
            code: "custom",
            path: ["supplier"],
            message: "Supplier does not exist",
          });
        }
      } catch (error) {
        ctx.addIssue({
          code: "custom",
          path: ["supplier"],
          message: "Supplier does not exist",
        });
      }
    }

    // New products must start with "active" status (if status is provided)
    if (data.status && data.status !== "active") {
      ctx.addIssue({
        code: "custom",
        path: ["status"],
        message: "New products must start with 'active' status",
      });
    }

    // Unique constraint: sku + barcode combination must be unique
    try {
      const existingProduct = await pocketbase
        .collection(Collections.WarehouseManagementProducts)
        .getFirstListItem(
          `sku = "${data.sku.replace(/"/g, '\\"')}" && barcode = "${(data.barcode || "").replace(/"/g, '\\"')}"`
        );
      if (existingProduct) {
        ctx.addIssue({
          code: "custom",
          path: ["sku"],
          message:
            "A product with this SKU and barcode combination already exists",
        });
      }
    } catch (error) {
      // Record not found is expected - combination is unique
      if (!(error instanceof ClientResponseError) || error.status !== 404) {
        console.warn("Product uniqueness check error:", error);
      }
    }
  });

export const UpdateProductsSchema = (
  pocketbase: TypedPocketBase,
  id?: string
) =>
  ProductsSchema.partial()
    .omit({
      id: true,
      created: true,
      updated: true,
    })
    .superRefine(async (data, ctx) => {
      // Validate supplier exists if being updated
      if (data.supplier) {
        try {
          const supplier = await pocketbase
            .collection(Collections.WarehouseManagementSuppliers)
            .getOne(data.supplier, { requestKey: null });
          if (!supplier) {
            ctx.addIssue({
              code: "custom",
              path: ["supplier"],
              message: "Supplier does not exist",
            });
          }
        } catch (error) {
          ctx.addIssue({
            code: "custom",
            path: ["supplier"],
            message: "Supplier does not exist",
          });
        }
      }

      // Unique constraint: sku + barcode combination must be unique (when being updated)
      if ((data.sku || data.barcode) && id) {
        try {
          const currentProduct = await pocketbase
            .collection(Collections.WarehouseManagementProducts)
            .getOne(id, { requestKey: null });

          const skuToCheck = data.sku || currentProduct.sku;
          const barcodeToCheck =
            data.barcode !== undefined ? data.barcode : currentProduct.barcode;

          const existingProduct = await pocketbase
            .collection(Collections.WarehouseManagementProducts)
            .getFirstListItem(
              `sku = "${skuToCheck.replace(/"/g, '\\"')}" && barcode = "${(barcodeToCheck || "").replace(/"/g, '\\"')}" && id != "${id}"`
            );

          if (existingProduct) {
            ctx.addIssue({
              code: "custom",
              path: ["sku"],
              message:
                "A product with this SKU and barcode combination already exists",
            });
          }
        } catch (error) {
          // Record not found is expected - combination is unique
          if (!(error instanceof ClientResponseError) || error.status !== 404) {
            console.warn("Product uniqueness check error:", error);
          }
        }
      }
    });
