/**
 * Auto-generated Zod schema for WarehouseManagementOutboundShipments
 * Generated by: scripts/generate-zod-schemas.ts
 * DO NOT EDIT MANUALLY
 */

import { ClientResponseError } from "pocketbase";
import { z } from "zod";
import {
	Collections,
	TypedPocketBase,
	WarehouseManagementOutboundShipmentsRecord,
} from "@/lib/pb.types";
import { CreateOutboundShipmentItemsSchema } from "./outbound-shipment-items";

export const OutboundShipmentsSchema = z.object({
	id: z.string(),
	salesOrder: z.string(),
	status: z
		.enum(["picking", "packed", "shipped", "delivered", "cancelled"])
		.optional(),
	trackingNumber: z.string(),
	carrier: z.string().optional(),
	warehouse: z.string(),
	items: z.array(z.string()).nonempty("At least one shipment item is required"),
	created: z.iso.datetime().optional(),
	updated: z.iso.datetime().optional(),
});

export type OutboundShipments = z.infer<typeof OutboundShipmentsSchema>;

export const CreateOutboundShipmentsSchema = (pocketbase: TypedPocketBase) =>
	OutboundShipmentsSchema.omit({
		id: true,
		created: true,
		updated: true,
	})
		.extend({
			items: CreateOutboundShipmentItemsSchema(pocketbase).array(),
		})
		.superRefine(async (data, ctx) => {
			// Verify sales order exists
			try {
				const salesOrder = await pocketbase
					.collection(Collections.WarehouseManagementSalesOrders)
					.getOne(data.salesOrder, { requestKey: null });
				if (!salesOrder) {
					ctx.addIssue({
						code: "custom",
						path: ["salesOrder"],
						message: "Sales order does not exist",
					});
				}
			} catch (error) {
				ctx.addIssue({
					code: "custom",
					path: ["salesOrder"],
					message: "Sales order does not exist",
				});
			}

			// Verify warehouse exists
			try {
				const warehouse = await pocketbase
					.collection(Collections.WarehouseManagementWarehouses)
					.getOne(data.warehouse, { requestKey: null });
				if (!warehouse) {
					ctx.addIssue({
						code: "custom",
						path: ["warehouse"],
						message: "Warehouse does not exist",
					});
				}
			} catch (error) {
				ctx.addIssue({
					code: "custom",
					path: ["warehouse"],
					message: "Warehouse does not exist",
				});
			}

			// Verify carrier exists if provided
			if (data.carrier) {
				try {
					const carrier = await pocketbase
						.collection(Collections.TransportManagementCarriers)
						.getOne(data.carrier, { requestKey: null });
					if (!carrier) {
						ctx.addIssue({
							code: "custom",
							path: ["carrier"],
							message: "Carrier does not exist",
						});
					}
				} catch (error) {
					ctx.addIssue({
						code: "custom",
						path: ["carrier"],
						message: "Carrier does not exist",
					});
				}
			}
		});

export const UpdateOutboundShipmentsSchema = (
	pocketbase: TypedPocketBase,
	record?: WarehouseManagementOutboundShipmentsRecord,
) =>
	OutboundShipmentsSchema.partial()
		.omit({
			id: true,
			created: true,
			updated: true,
		})
		.superRefine(async (data, ctx) => {
			// Verify sales order exists if being updated
			if (data.salesOrder) {
				try {
					const salesOrder = await pocketbase
						.collection(Collections.WarehouseManagementSalesOrders)
						.getOne(data.salesOrder, { requestKey: null });
					if (!salesOrder) {
						ctx.addIssue({
							code: "custom",
							path: ["salesOrder"],
							message: "Sales order does not exist",
						});
					}
				} catch (error) {
					ctx.addIssue({
						code: "custom",
						path: ["salesOrder"],
						message: "Sales order does not exist",
					});
				}
			}

			// Verify warehouse exists if being updated
			if (data.warehouse) {
				try {
					const warehouse = await pocketbase
						.collection(Collections.WarehouseManagementWarehouses)
						.getOne(data.warehouse, { requestKey: null });
					if (!warehouse) {
						ctx.addIssue({
							code: "custom",
							path: ["warehouse"],
							message: "Warehouse does not exist",
						});
					}
				} catch (error) {
					ctx.addIssue({
						code: "custom",
						path: ["warehouse"],
						message: "Warehouse does not exist",
					});
				}
			}

			// Verify carrier exists if being updated
			if (data.carrier) {
				try {
					const carrier = await pocketbase
						.collection(Collections.TransportManagementCarriers)
						.getOne(data.carrier, { requestKey: null });
					if (!carrier) {
						ctx.addIssue({
							code: "custom",
							path: ["carrier"],
							message: "Carrier does not exist",
						});
					}
				} catch (error) {
					ctx.addIssue({
						code: "custom",
						path: ["carrier"],
						message: "Carrier does not exist",
					});
				}
			}

			// Validate status transitions (State Machine)
			if (data.status && record?.id) {
				try {
					const currentShipment = await pocketbase
						.collection(Collections.WarehouseManagementOutboundShipments)
						.getOne(record.id, { requestKey: null });

					const currentStatus = currentShipment.status;
					const newStatus = data.status;

					// Define valid transitions: picking -> packed -> shipped -> delivered
					// Can be cancelled at any stage
					const validTransitions: Record<string, string[]> = {
						picking: ["packed", "cancelled"],
						packed: ["shipped", "cancelled"],
						shipped: ["delivered", "cancelled"],
						delivered: [], // Terminal state
						cancelled: [], // Terminal state
					};

					if (!validTransitions[currentStatus]?.includes(newStatus)) {
						ctx.addIssue({
							code: "custom",
							path: ["status"],
							message: `Cannot transition outbound shipment status from '${currentStatus}' to '${newStatus}'`,
						});
					}
				} catch (error) {
					if (!(error instanceof ClientResponseError) || error.status !== 404) {
						console.warn(
							"Outbound shipment status transition check error:",
							error,
						);
					}
				}
			}
		});
