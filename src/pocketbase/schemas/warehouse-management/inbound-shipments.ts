/**
 * Auto-generated Zod schema for WarehouseManagementInboundShipments
 * Generated by: scripts/generate-zod-schemas.ts
 * DO NOT EDIT MANUALLY
 */

import { ClientResponseError } from "pocketbase";
import { z } from "zod";
import {
  Collections,
  TypedPocketBase,
  WarehouseManagementInboundShipmentsRecord,
} from "@/lib/pb.types";
import { CreateInboundShipmentItemsSchema } from "./inbound-shipment-items";

export const InboundShipmentsSchema = z.object({
  id: z.string(),
  client: z.string(),
  status: z
    .enum(["pending", "arrived", "processing", "completed", "cancelled"])
    .optional(),
  expectedArrivalDate: z.date().optional(),
  actualArrivalDate: z.date().optional(),
  warehouse: z.string(),
  created: z.iso.datetime().optional(),
  updated: z.iso.datetime().optional(),
  items: z.array(z.string()).optional(),
});

export type InboundShipments = z.infer<typeof InboundShipmentsSchema>;

export const CreateInboundShipmentsSchema = (pocketbase: TypedPocketBase) =>
  InboundShipmentsSchema.omit({
    id: true,
    created: true,
    updated: true,
  })
    .extend({
      items: CreateInboundShipmentItemsSchema(pocketbase).array(),
    })
    .superRefine(async (data, ctx) => {
      // Verify warehouse exists
      try {
        const warehouse = await pocketbase
          .collection(Collections.WarehouseManagementWarehouses)
          .getOne(data.warehouse, { requestKey: null });
        if (!warehouse) {
          ctx.addIssue({
            code: "custom",
            path: ["warehouse"],
            message: "Warehouse does not exist",
          });
        }
      } catch (error) {
        ctx.addIssue({
          code: "custom",
          path: ["warehouse"],
          message: "Warehouse does not exist",
        });
      }

      // Verify client exists
      try {
        const client = await pocketbase
          .collection(Collections.CustomerRelationsCompanies)
          .getOne(data.client, { requestKey: null });
        if (!client) {
          ctx.addIssue({
            code: "custom",
            path: ["client"],
            message: "Client does not exist",
          });
        }
      } catch (error) {
        ctx.addIssue({
          code: "custom",
          path: ["client"],
          message: "Client does not exist",
        });
      }

      // Validate date logic if both dates are provided
      if (data.expectedArrivalDate && data.actualArrivalDate) {
        if (data.actualArrivalDate < data.expectedArrivalDate) {
          ctx.addIssue({
            code: "custom",
            path: ["actualArrivalDate"],
            message:
              "Actual arrival date cannot be before expected arrival date",
          });
        }
      }
    });

export const UpdateInboundShipmentsSchema = (
  pocketbase: TypedPocketBase,
  record?: WarehouseManagementInboundShipmentsRecord
) =>
  InboundShipmentsSchema.partial()
    .omit({
      id: true,
      created: true,
      updated: true,
    })
    .extend({
      items: CreateInboundShipmentItemsSchema(pocketbase).array().optional(),
    })
    .superRefine(async (data, ctx) => {
      // Verify warehouse exists if being updated
      if (data.warehouse) {
        try {
          const warehouse = await pocketbase
            .collection(Collections.WarehouseManagementWarehouses)
            .getOne(data.warehouse, { requestKey: null });
          if (!warehouse) {
            ctx.addIssue({
              code: "custom",
              path: ["warehouse"],
              message: "Warehouse does not exist",
            });
          }
        } catch (error) {
          ctx.addIssue({
            code: "custom",
            path: ["warehouse"],
            message: "Warehouse does not exist",
          });
        }
      }

      // Verify client exists if being updated
      if (data.client) {
        try {
          const client = await pocketbase
            .collection(Collections.CustomerRelationsCompanies)
            .getOne(data.client, { requestKey: null });
          if (!client) {
            ctx.addIssue({
              code: "custom",
              path: ["client"],
              message: "Client does not exist",
            });
          }
        } catch (error) {
          ctx.addIssue({
            code: "custom",
            path: ["client"],
            message: "Client does not exist",
          });
        }
      }

      // Validate status transitions (State Machine)
      if (data.status && record?.id) {
        try {
          const currentShipment = await pocketbase
            .collection(Collections.WarehouseManagementInboundShipments)
            .getOne(record.id, { requestKey: null });

          const currentStatus = currentShipment.status;
          const newStatus = data.status;

          // Define valid transitions: pending -> arrived -> processing -> completed
          // Can be cancelled at any stage
          const validTransitions: Record<string, string[]> = {
            pending: ["arrived", "cancelled"],
            arrived: ["processing", "cancelled"],
            processing: ["completed", "cancelled"],
            completed: [], // Terminal state
            cancelled: [], // Terminal state
          };

          if (!validTransitions[currentStatus]?.includes(newStatus)) {
            ctx.addIssue({
              code: "custom",
              path: ["status"],
              message: `Cannot transition inbound shipment status from '${currentStatus}' to '${newStatus}'`,
            });
          }
        } catch (error) {
          if (!(error instanceof ClientResponseError) || error.status !== 404) {
            console.warn(
              "Inbound shipment status transition check error:",
              error
            );
          }
        }
      }
    });
