/**
 * Auto-generated Zod schema for CustomerRelationsOpportunityProducts
 * Generated by: scripts/generate-zod-schemas.ts
 * DO NOT EDIT MANUALLY
 */

import { ClientResponseError } from "pocketbase";
import { z } from "zod";
import { Collections, TypedPocketBase } from "@/lib/pb.types";

export const OpportunityProductsSchema = z.object({
  id: z.string(),
  opportunity: z.string().optional(),
  product: z.string().optional(),
  quantity: z
    .number()
    .min(0, "Quantity must be non-negative")
    .int("Quantity must be an integer"),
  priceSnapshot: z
    .number()
    .min(0, "Price snapshot must be non-negative")
    .optional(),
  created: z.iso.datetime().optional(),
  updated: z.iso.datetime().optional(),
});

export type OpportunityProducts = z.infer<typeof OpportunityProductsSchema>;

export const CreateOpportunityProductsSchema = (pocketbase: TypedPocketBase) =>
  OpportunityProductsSchema.omit({
    id: true,
    created: true,
    updated: true,
  }).superRefine(async (data, ctx) => {
    // Validate required references
    if (!data.opportunity) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        path: ["opportunity"],
        message: "Opportunity reference is required",
      });
    }

    if (!data.product) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        path: ["product"],
        message: "Product reference is required",
      });
      return; // Skip uniqueness check if references are missing
    }

    // Validate quantity
    if (data.quantity <= 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        path: ["quantity"],
        message: "Quantity must be greater than 0",
      });
    }

    // Composite unique constraint: (opportunity, product) must be unique
    if (data.opportunity && data.product) {
      try {
        const existingOpportunityProduct = await pocketbase
          .collection(Collections.CustomerRelationsOpportunityProducts)
          .getFirstListItem(
            `opportunity = "${data.opportunity.replace(/"/g, '\\"')}" && product = "${data.product.replace(/"/g, '\\"')}"`,
            { requestKey: null }
          );

        if (existingOpportunityProduct) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ["product"],
            message: "This product is already added to the opportunity",
          });
        }
      } catch (error) {
        // Record not found is expected - combination is unique
        if (!(error instanceof ClientResponseError) || error.status !== 404) {
          console.warn("Opportunity-product uniqueness check error:", error);
        }
      }
    }

    // Price snapshot: Fetch and capture the current product price if not provided
    if (data.product && !data.priceSnapshot) {
      try {
        const product = await pocketbase
          .collection(Collections.CustomerRelationsProducts)
          .getOne(data.product);
        if (product && typeof product.price === "number") {
          // In a real implementation, this would be automatically set
          // For validation purposes, we're ensuring a price is captured
          if (product.price < 0) {
            ctx.addIssue({
              code: z.ZodIssueCode.custom,
              path: ["priceSnapshot"],
              message: "Product has an invalid price",
            });
          }
        }
      } catch (error) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ["product"],
          message: "Product reference not found",
        });
      }
    }
  });

export const UpdateOpportunityProductsSchema = (pocketbase: TypedPocketBase) =>
  OpportunityProductsSchema.partial()
    .omit({
      id: true,
      created: true,
      updated: true,
    })
    .superRefine(async (data, ctx) => {
      // Validate quantity if being updated
      if (data.quantity !== undefined && data.quantity <= 0) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ["quantity"],
          message: "Quantity must be greater than 0",
        });
      }

      // Price snapshot should generally not be updated after creation
      // to maintain historical accuracy, but we allow it if explicitly changed
      if (data.priceSnapshot !== undefined && data.priceSnapshot < 0) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ["priceSnapshot"],
          message: "Price snapshot cannot be negative",
        });
      }

      // Composite unique constraint: (opportunity, product) must be unique if either is being changed
      if (data.opportunity || data.product) {
        // Note: In a real implementation, we would have the current record's IDs
        // to exclude from the uniqueness check
        try {
          if (data.opportunity && data.product) {
            const existingOpportunityProduct = await pocketbase
              .collection(Collections.CustomerRelationsOpportunityProducts)
              .getFirstListItem(
                `opportunity = "${data.opportunity.replace(/"/g, '\\"')}" && product = "${data.product.replace(/"/g, '\\"')}"`,
                { requestKey: null }
              );

            if (existingOpportunityProduct) {
              ctx.addIssue({
                code: z.ZodIssueCode.custom,
                path: ["product"],
                message: "This product is already added to the opportunity",
              });
            }
          }
        } catch (error) {
          // Record not found is expected - combination is unique
          if (!(error instanceof ClientResponseError) || error.status !== 404) {
            console.warn("Opportunity-product uniqueness check error:", error);
          }
        }
      }
    });
