/**
 * Auto-generated Zod schema for CustomerRelationsOpportunities
 * Generated by: scripts/generate-zod-schemas.ts
 * DO NOT EDIT MANUALLY
 */

import { ClientResponseError } from "pocketbase";
import { z } from "zod";
import {
  Collections,
  CustomerRelationsOpportunitiesRecord,
  TypedPocketBase,
} from "@/lib/pb.types";
import { CreateOpportunityProductsSchema } from "./opportunity-products";

export const OpportunitiesSchema = z.object({
  id: z.string(),
  name: z.string(),
  stage: z
    .enum([
      "prospecting",
      "qualification",
      "need-analysis",
      "demo",
      "proposal",
      "negotiation",
      "closed-won",
      "closed-lost",
    ])
    .optional(),
  dealValue: z.number().optional(),
  probability: z
    .number()
    .min(0, "Probability must be at least 0")
    .max(1, "Probability must be at most 1 (0-1 scale, not 0-100)")
    .optional(),
  expectedCloseDate: z.date().optional(),
  lostReason: z.string().optional(),
  source: z.enum([
    "website",
    "referral",
    "social-media",
    "email-campaign",
    "cold-call",
    "event",
    "advertisment",
    "partner",
    "existing-customer",
    "other",
  ]),
  owner: z.string(),
  contact: z.string().optional(),
  company: z.string().optional(),
  campaign: z.string().optional(),
  products: z.array(z.string()).nonempty("At least one product is required"),
  attachments: z.file().array().optional(),
  created: z.iso.datetime().optional(),
  updated: z.iso.datetime().optional(),
});

export type Opportunities = z.infer<typeof OpportunitiesSchema>;

export const CreateOpportunitiesSchema = (pocketbase: TypedPocketBase) =>
  OpportunitiesSchema.omit({
    id: true,
    created: true,
    updated: true,
  })
    .extend({
      products: CreateOpportunityProductsSchema(pocketbase).array(),
    })
    .superRefine((data, ctx) => {
      // Validate opportunity name is provided
      if (!data.name || data.name.trim().length === 0) {
        ctx.addIssue({
          code: "custom",
          path: ["name"],
          message: "Opportunity name is required",
        });
      }

      // Validate deal value is provided and positive
      if (data.dealValue !== undefined && data.dealValue < 0) {
        ctx.addIssue({
          code: "custom",
          path: ["dealValue"],
          message: "Deal value cannot be negative",
        });
      }
    });

export const UpdateOpportunitiesSchema = (
  pocketbase: TypedPocketBase,
  record?: CustomerRelationsOpportunitiesRecord
) =>
  OpportunitiesSchema.partial()
    .omit({
      id: true,
      created: true,
      updated: true,
      attachments: true,
    })
    .superRefine(async (data, ctx) => {
      // Get current opportunity stage from existing record
      const currentStage = record?.stage;
      const newStage = data.stage;

      // Prevent modification if opportunity is already in a terminal state
      if (currentStage === "closed-won" || currentStage === "closed-lost") {
        ctx.addIssue({
          code: "custom",
          path: ["stage"],
          message: `Opportunities in '${currentStage}' stage cannot be modified`,
        });
        return;
      }

      // Validate stage transitions using state machine rules
      if (newStage && currentStage) {
        const validTransitions: Record<string, string[]> = {
          prospecting: ["qualification", "closed-lost"],
          qualification: ["need-analysis", "closed-lost", "prospecting"],
          "need-analysis": ["demo", "closed-lost", "qualification"],
          demo: ["proposal", "closed-lost", "need-analysis"],
          proposal: ["negotiation", "closed-lost", "demo"],
          negotiation: ["closed-won", "closed-lost", "proposal"],
          "closed-won": [], // Terminal state
          "closed-lost": [], // Terminal state
        };

        const allowedTransitions = validTransitions[currentStage] || [];

        if (!allowedTransitions.includes(newStage)) {
          ctx.addIssue({
            code: "custom",
            path: ["stage"],
            message: `Cannot transition from '${currentStage}' to '${newStage}'. Valid transitions: ${allowedTransitions.join(", ")}`,
          });
        }
      }

      // If name is being updated, ensure it's not empty
      if (data.name !== undefined && data.name.trim().length === 0) {
        ctx.addIssue({
          code: "custom",
          path: ["name"],
          message: "Opportunity name cannot be empty",
        });
      }

      // Validate deal value is not negative
      if (data.dealValue !== undefined && data.dealValue < 0) {
        ctx.addIssue({
          code: "custom",
          path: ["dealValue"],
          message: "Deal value cannot be negative",
        });
      }

      // Validate lost reason is provided when marking as closed-lost
      if (
        newStage === "closed-lost" &&
        !data.lostReason &&
        !record?.lostReason
      ) {
        ctx.addIssue({
          code: "custom",
          path: ["lostReason"],
          message:
            "Lost reason is required when marking opportunity as closed-lost",
        });
      }

      // Note: Probability is typically auto-calculated based on stage
      // If manually provided, ensure it's within valid range (0-1)
      // This is already validated in the base schema
    });
