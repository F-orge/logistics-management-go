/**
 * Auto-generated Zod schema for CustomerRelationsLeads
 * Generated by: scripts/generate-zod-schemas.ts
 * DO NOT EDIT MANUALLY
 */

import { ClientResponseError } from "pocketbase";
import { z } from "zod";
import {
  Collections,
  CustomerRelationsLeadsRecord,
  TypedPocketBase,
} from "@/lib/pb.types";

export const LeadsSchema = z.object({
  id: z.string(),
  name: z.string().nonempty("Lead name is required"),
  email: z.string().email().optional(),
  source: z.enum([
    "website",
    "referral",
    "social-media",
    "email-campaign",
    "cold-call",
    "event",
    "advertisment",
    "partner",
    "other",
  ]),
  status: z
    .enum(["new", "contacted", "qualified", "unqualified", "converted"])
    .optional(),
  score: z.number().min(0, "Lead score must be non-negative"),
  owner: z.string(),
  campaign: z.string().optional(),
  convertedAt: z.date().optional(),
  convertedContact: z.string().optional(),
  convertedCompany: z.string().optional(),
  convertedOpportunity: z.string().optional(),
  attachments: z.file().array().optional(),
  created: z.iso.datetime().optional(),
  updated: z.iso.datetime().optional(),
});

export type Leads = z.infer<typeof LeadsSchema>;

export const CreateLeadsSchema = (pocketbase: TypedPocketBase) =>
  LeadsSchema.omit({
    id: true,
    created: true,
    updated: true,
  })
    .refine((data) => data.name && data.name.trim().length > 0, {
      message: "Lead name is required",
      path: ["name"],
    })
    .superRefine(async (data, ctx) => {
      // Unique constraint: Email must be unique if provided
      if (data.email) {
        try {
          const existingLead = await pocketbase
            .collection(Collections.CustomerRelationsLeads)
            .getFirstListItem(`email = "${data.email.replace(/"/g, '\\"')}"`, {
              requestKey: null,
            });

          if (existingLead) {
            ctx.addIssue({
              code: "custom",
              path: ["email"],
              message: `Email "${data.email}" is already in use`,
            });
          }
        } catch (error) {
          // Record not found is expected - email is unique
          if (!(error instanceof ClientResponseError) || error.status !== 404) {
            console.warn("Email uniqueness check error:", error);
          }
        }
      }
    });

export const UpdateLeadsSchema = (
  pocketbase: TypedPocketBase,
  record?: CustomerRelationsLeadsRecord
) =>
  LeadsSchema.partial()
    .omit({
      id: true,
      created: true,
      updated: true,
      attachments: true,
    })
    .refine(
      (data) =>
        data.name === undefined || (data.name && data.name.trim().length > 0),
      {
        message: "Lead name cannot be empty",
        path: ["name"],
      }
    )
    .superRefine(async (data, ctx) => {
      // Get current lead status from existing record
      const currentStatus = record?.status;
      const newStatus = data.status;

      // Prevent modification if lead is already in terminal state (converted)
      if (currentStatus === "converted" || record?.convertedAt) {
        ctx.addIssue({
          code: "custom",
          path: ["status"],
          message: "Converted leads are immutable and cannot be modified",
        });
        return;
      }

      // Prevent setting converted status or convertedAt without both
      if (data.status === "converted" || data.convertedAt !== undefined) {
        if (!data.convertedAt && !record?.convertedAt) {
          ctx.addIssue({
            code: "custom",
            path: ["convertedAt"],
            message: "convertedAt must be set when converting a lead",
          });
        }
        if (!data.status && record?.status !== "converted") {
          ctx.addIssue({
            code: "custom",
            path: ["status"],
            message: "Status must be set to 'converted' when converting a lead",
          });
        }
      }

      // Validate status transitions using state machine rules
      if (newStatus && currentStatus) {
        const validTransitions: Record<string, string[]> = {
          new: ["contacted", "qualified", "unqualified"],
          contacted: ["qualified", "unqualified", "new"],
          qualified: ["converted", "new", "contacted"],
          unqualified: ["new", "contacted"],
          converted: [], // Terminal state
        };

        const allowedTransitions = validTransitions[currentStatus] || [];

        if (!allowedTransitions.includes(newStatus)) {
          ctx.addIssue({
            code: "custom",
            path: ["status"],
            message: `Cannot transition from '${currentStatus}' to '${newStatus}'. Valid transitions: ${allowedTransitions.join(", ")}`,
          });
        }
      }

      // Unique constraint: Email must be unique if being updated
      if (data.email) {
        try {
          const existingLead = await pocketbase
            .collection(Collections.CustomerRelationsLeads)
            .getFirstListItem(`email = "${data.email.replace(/"/g, '\\"')}"`, {
              requestKey: null,
            });

          // If found, check if it's a different record (not the one being updated)
          if (existingLead && existingLead.id !== record?.id) {
            ctx.addIssue({
              code: "custom",
              path: ["email"],
              message: `Email "${data.email}" is already in use`,
            });
          }
        } catch (error) {
          // Record not found is expected - email is unique
          if (!(error instanceof ClientResponseError) || error.status !== 404) {
            console.warn("Email uniqueness check error:", error);
          }
        }
      }
    });
