type ClientAccounts {
	id: ID!
	client: Companies!
	creditLimit: Float
	availableCredit: Float
	walletBalance: Float
	currency: String
	paymentTermsDays: Int
	isCreditApproved: Boolean
	lastPaymentDate: String
	createdAt: Date
	updatedAt: Date
	transactions: [AccountTransactions!]
}

extend type BillingQuery {
	clientAccounts(
		page: Int
		perPage: Int
		from: Date
		to: Date
		search: String
	): [ClientAccounts!]!
	clientAccount(id: ID!): ClientAccounts!
}

input CreateClientAccountInput {
	clientId: ID!
	creditLimit: Float @constraint(min: 0)
	availableCredit: Float @constraint(min: 0)
	walletBalance: Float @constraint(min: 0)
	currency: String @constraint(minLength: 1)
	paymentTermsDays: Int @constraint(min: 0)
	isCreditApproved: Boolean
	lastPaymentDate: String @constraint(minLength: 1)
}

input UpdateClientAccountInput {
	creditLimit: Float @constraint(min: 0)
	availableCredit: Float @constraint(min: 0)
	walletBalance: Float @constraint(min: 0)
	currency: String @constraint(minLength: 1)
	paymentTermsDays: Int @constraint(min: 0)
	isCreditApproved: Boolean
	lastPaymentDate: Date
}

extend type BillingMutation {
	createClientAccount(value: CreateClientAccountInput!): ClientAccounts!
	updateClientAccount(id: ID!, value: UpdateClientAccountInput): ClientAccounts!
	removeClientAccount(id: ID!): DeleteResult!
}

type ClientAccountBalanceUpdatedEvent {
	clientId: ID!
	newAvailableCredit: String!
	newWalletBalance: String!
}

type ClientAccountLastPaymentDateUpdatedEvent {
	clientId: ID!
	lastPaymentDate: String!
	paymentId: ID!
}

extend type Subscription {
	clientAccountBalanceUpdated: ClientAccountBalanceUpdatedEvent!
	clientAccountLastPaymentDateUpdated: ClientAccountLastPaymentDateUpdatedEvent!
}
