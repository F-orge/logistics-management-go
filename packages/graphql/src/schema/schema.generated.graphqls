type AccountTransactions {
  amount: Float!
  clientAccount: ClientAccounts!
  createdAt: String
  description: String
  id: ID!
  processedByUser: User
  referenceNumber: String
  runningBalance: Float
  sourceRecordId: ID
  sourceRecordType: String
  transactionDate: String
  type: TransactionType!
  updatedAt: String
}

type AccountingSyncLogs {
  createdAt: String
  errorMessage: String
  externalId: String
  externalSystem: String!
  id: ID!
  lastSyncAt: String
  nextRetryAt: String
  recordId: ID!
  recordType: String!
  requestPayload: String
  responsePayload: String
  retryCount: Int
  status: SyncStatus
  updatedAt: String
}

type Attachments {
  createdAt: String
  fileName: String!
  filePath: String!
  id: ID!
  mimeType: String
  recordId: ID
  recordType: RecordType
  updatedAt: String
}

enum BillingInvoiceStatus {
  CANCELLED
  DISPUTED
  DRAFT
  PAID
  PARTIAL_PAID
  PAST_DUE
  SENT
  VIEWED
  VOID
}

type BillingInvoices {
  amountOutstanding: Float
  amountPaid: Float
  client: Companies!
  createdAt: String
  createdByUser: User
  creditNotes: [CreditNotes!]
  currency: String
  discountAmount: Float
  dueDate: String!
  id: ID!
  invoiceNumber: String!
  issueDate: String!
  lineItems: [InvoiceLineItems!]
  notes: String
  paidAt: String
  paymentTerms: String
  payments: [Payments!]
  quote: Quotes
  sentAt: String
  status: BillingInvoiceStatus
  subtotal: Float
  taxAmount: Float
  totalAmount: Float!
  updatedAt: String
}

type BillingMutation {
  createAccountTransaction(value: CreateAccountTransactionInput!): AccountTransactions!
  createAccountingSyncLog(value: CreateAccountingSyncLogInput!): AccountingSyncLogs!
  createBillingInvoice(value: CreateBillingInvoiceInput!): BillingInvoices!
  createClientAccount(value: CreateClientAccountInput!): ClientAccounts!
  createCreditNote(value: CreateCreditNoteInput!): CreditNotes!
  createDispute(value: CreateDisputeInput!): Disputes!
  createDocument(value: CreateDocumentInput!): Documents!
  createInvoiceLineItem(value: CreateInvoiceLineItemInput!): InvoiceLineItems!
  createPayment(value: CreatePaymentInput!): Payments!
  createQuote(value: CreateQuoteInput!): Quotes!
  createRateCard(value: CreateRateCardInput!): RateCards!
  createRateRule(value: CreateRateRuleInput!): RateRules!
  createSurcharge(value: CreateSurchargeInput!): Surcharges!
  removeAccountTransaction(id: ID!): DeleteResult!
  removeAccountingSyncLog(id: ID!): DeleteResult!
  removeBillingInvoice(id: ID!): DeleteResult!
  removeClientAccount(id: ID!): DeleteResult!
  removeCreditNote(id: ID!): DeleteResult!
  removeDispute(id: ID!): DeleteResult!
  removeDocument(id: ID!): DeleteResult!
  removeInvoiceLineItem(id: ID!): DeleteResult!
  removePayment(id: ID!): DeleteResult!
  removeQuote(id: ID!): DeleteResult!
  removeRateCard(id: ID!): DeleteResult!
  removeRateRule(id: ID!): DeleteResult!
  removeSurcharge(id: ID!): DeleteResult!
  updateAccountTransaction(id: ID!, value: UpdateAccountTransactionInput): AccountTransactions!
  updateAccountingSyncLog(id: ID!, value: UpdateAccountingSyncLogInput): AccountingSyncLogs!
  updateBillingInvoice(id: ID!, value: UpdateBillingInvoiceInput): BillingInvoices!
  updateClientAccount(id: ID!, value: UpdateClientAccountInput): ClientAccounts!
  updateCreditNote(id: ID!, value: UpdateCreditNoteInput): CreditNotes!
  updateDispute(id: ID!, value: UpdateDisputeInput): Disputes!
  updateDocument(id: ID!, value: UpdateDocumentInput): Documents!
  updateInvoiceLineItem(id: ID!, value: UpdateInvoiceLineItemInput): InvoiceLineItems!
  updatePayment(id: ID!, value: UpdatePaymentInput): Payments!
  updateQuote(id: ID!, value: UpdateQuoteInput): Quotes!
  updateRateCard(id: ID!, value: UpdateRateCardInput): RateCards!
  updateRateRule(id: ID!, value: UpdateRateRuleInput): RateRules!
  updateSurcharge(id: ID!, value: UpdateSurchargeInput): Surcharges!
}

type BillingQuery {
  accountTransaction(id: ID!): AccountTransactions!
  accountTransactions(from: Date, page: Int, perPage: Int, to: Date): [AccountTransactions!]!
  accountingSyncLog(id: ID!): AccountingSyncLogs!
  accountingSyncLogs(from: Date, page: Int, perPage: Int, to: Date): [AccountingSyncLogs!]!
  billingInvoice(id: ID!): BillingInvoices!
  billingInvoices(from: Date, page: Int, perPage: Int, to: Date): [BillingInvoices!]!
  clientAccount(id: ID!): ClientAccounts!
  clientAccounts(from: Date, page: Int, perPage: Int, to: Date): [ClientAccounts!]!
  creditNote(id: ID!): CreditNotes!
  creditNotes(from: Date, page: Int, perPage: Int, to: Date): [CreditNotes!]!
  dispute(id: ID!): Disputes!
  disputes(from: Date, page: Int, perPage: Int, to: Date): [Disputes!]!
  document(id: ID!): Documents!
  documents(from: Date, page: Int, perPage: Int, to: Date): [Documents!]!
  payment(id: ID!): Payments!
  payments(from: Date, page: Int, perPage: Int, to: Date): [Payments!]!
  quote(id: ID!): Quotes!
  quotes(from: Date, page: Int, perPage: Int, to: Date): [Quotes!]!
  rateCard(id: ID!): RateCards!
  rateCards(from: Date, page: Int, perPage: Int, to: Date): [RateCards!]!
  rateRule(id: ID!): RateRules!
  rateRules(from: Date, page: Int, perPage: Int, to: Date): [RateRules!]!
  surcharge(id: ID!): Surcharges!
  surcharges(from: Date, page: Int, perPage: Int, to: Date): [Surcharges!]!
}

type BinThresholds {
  alertThreshold: Int
  createdAt: String
  id: ID!
  isActive: Boolean
  location: Locations!
  maxQuantity: Int!
  minQuantity: Int!
  product: WmsProducts!
  reorderQuantity: Int
  updatedAt: String
}

type Campaigns {
  budget: Float
  createdAt: String
  endDate: String
  id: ID!
  name: String!
  startDate: String
  updatedAt: String
}

enum CarrierRateUnit {
  FLAT_RATE
  PER_CONTAINER
  PER_KG
  PER_KM
  PER_MILE
}

type CarrierRates {
  carrier: Carriers!
  createdAt: String
  destination: String
  id: ID!
  origin: String
  rate: Float!
  serviceType: String
  unit: CarrierRateUnit
  updatedAt: String
}

type Carriers {
  contactEmail: String
  contactPerson: String
  contactPhone: String
  createdAt: String
  id: ID!
  name: String!
  partnerInvoices: [PartnerInvoices!]
  rates: [CarrierRates!]
  servicesOffered: String
  shipmentLegs: [ShipmentLegs!]
  updatedAt: String
}

enum CasePriority {
  CRITICAL
  HIGH
  LOW
  MEDIUM
}

enum CaseStatus {
  CANCELLED
  CLOSED
  ESCALATED
  IN_PROGRESS
  NEW
  RESOLVED
  WAITING_FOR_CUSTOMER
  WAITING_FOR_INTERNAL
}

enum CaseType {
  BUG_REPORT
  COMPLAINT
  FEATURE_REQUEST
  PROBLEM
  QUESTION
  TECHNICAL_SUPPORT
}

type Cases {
  caseNumber: String!
  contact: Contacts
  createdAt: String
  description: String
  id: ID!
  owner: User!
  priority: CasePriority
  status: CaseStatus
  type: CaseType
  updatedAt: String
}

type ClientAccounts {
  availableCredit: Float
  client: Companies!
  createdAt: String
  creditLimit: Float
  currency: String
  id: ID!
  isCreditApproved: Boolean
  lastPaymentDate: String
  paymentTermsDays: Int
  transactions: [AccountTransactions!]
  updatedAt: String
  walletBalance: Float
}

type Companies {
  annualRevenue: String
  billingInvoices: [BillingInvoices!]
  city: String
  clientAccount: ClientAccounts
  country: String
  createdAt: String
  disputes: [Disputes!]
  id: ID!
  inboundShipments: [InboundShipments!]
  industry: String
  name: String!
  owner: User
  phoneNumber: String
  postalCode: String
  putawayRules: [PutawayRules!]
  quotes: [Quotes!]
  returns: [Returns!]
  salesOrders: [SalesOrders!]
  state: String
  street: String
  updatedAt: String
  website: String
}

type Contacts {
  company: Companies
  createdAt: String
  email: String!
  id: ID!
  jobTitle: String
  name: String!
  owner: User!
  phoneNumber: String
  updatedAt: String
}

input CreateAccountTransactionInput {
  amount: Float!
  clientAccountId: ID!
  description: String
  processedByUserId: ID
  referenceNumber: String
  runningBalance: Float
  sourceRecordId: ID
  sourceRecordType: String
  transactionDate: String
  type: TransactionType!
}

input CreateAccountingSyncLogInput {
  errorMessage: String
  externalId: String
  externalSystem: String!
  lastSyncAt: String
  nextRetryAt: String
  recordId: ID!
  recordType: String!
  requestPayload: String
  responsePayload: String
  retryCount: Int
  status: SyncStatus
}

input CreateAttachmentInput {
  file: File
  recordId: ID
  recordType: RecordType
}

input CreateBillingInvoiceInput {
  amountPaid: Float
  clientId: ID!
  createdByUserId: ID
  currency: String
  discountAmount: Float
  dueDate: String!
  invoiceNumber: String!
  issueDate: String!
  notes: String
  paidAt: String
  paymentTerms: String
  quoteId: ID
  sentAt: String
  status: BillingInvoiceStatus
  subtotal: Float
  taxAmount: Float
  totalAmount: Float!
}

input CreateBinThresholdInput {
  alertThreshold: Int
  isActive: Boolean
  locationId: ID!
  maxQuantity: Int!
  minQuantity: Int!
  productId: ID!
  reorderQuantity: Int
}

input CreateCampaignInput {
  budget: Float
  endDate: String
  name: String!
  startDate: String
}

input CreateCarrierInput {
  contactEmail: String
  contactPerson: String
  contactPhone: String
  name: String!
  servicesOffered: String
}

input CreateCarrierRateInput {
  carrierId: ID!
  destination: String
  origin: String
  rate: Float!
  serviceType: String
  unit: CarrierRateUnit
}

input CreateCaseInput {
  caseNumber: String!
  contactId: ID
  description: String
  ownerId: ID!
  priority: CasePriority
  status: CaseStatus
  type: CaseType
}

input CreateClientAccountInput {
  availableCredit: Float
  clientId: ID!
  creditLimit: Float
  currency: String
  isCreditApproved: Boolean
  lastPaymentDate: String
  paymentTermsDays: Int
  walletBalance: Float
}

input CreateCompanyInput {
  annualRevenue: Float
  city: String
  country: String
  industry: String
  name: String!
  ownerId: ID
  phoneNumber: String
  postalCode: String
  state: String
  street: String
  website: String
}

input CreateContactInput {
  companyId: ID
  email: String!
  jobTitle: String
  name: String!
  ownerId: ID!
  phoneNumber: String
}

input CreateCreditNoteInput {
  amount: Float!
  appliedAt: String
  createdByUserId: ID
  creditNoteNumber: String!
  currency: String
  disputeId: ID
  invoiceId: ID!
  issueDate: String!
  notes: String
  reason: String!
}

input CreateCustomerTrackingLinkInput {
  accessCount: Int
  deliveryTaskId: ID!
  expiresAt: String
  isActive: Boolean
  lastAccessedAt: String
  trackingToken: String!
}

input CreateDeliveryRouteInput {
  completedAt: String
  driverId: ID!
  estimatedDurationMinutes: Int
  optimizedRouteData: String
  routeDate: String!
  startedAt: String
  status: DeliveryRouteStatus
  totalDistanceKm: Float
}

input CreateDeliveryTaskInput {
  actualArrivalTime: String
  attemptCount: Int
  deliveryAddress: String!
  deliveryInstructions: String
  deliveryRouteId: ID!
  deliveryTime: String
  estimatedArrivalTime: String
  failureReason: DeliveryFailureReason
  packageId: ID!
  recipientName: String
  recipientPhone: String
  routeSequence: Int!
  status: DeliveryTaskStatus
}

input CreateDisputeInput {
  clientId: ID!
  disputedAmount: Float
  lineItemId: ID!
  reason: String!
  resolutionNotes: String
  resolvedAt: String
  resolvedByUserId: ID
  status: DisputeStatus
  submittedAt: String
}

input CreateDmsProofOfDeliveryInput {
  deliveryTaskId: ID!
  filePath: String
  latitude: Float
  longitude: Float
  recipientName: String
  signatureData: String
  timestamp: String
  type: ProofOfDeliveryType!
  verificationCode: String
}

input CreateDocumentInput {
  documentType: DocumentType!
  fileName: String!
  filePath: String!
  fileSize: Int
  mimeType: String
  recordId: ID!
  recordType: String!
  uploadedByUserId: ID
}

input CreateDriverInput {
  contactPhone: String
  licenseExpiryDate: String
  licenseNumber: String!
  status: DriverStatus
  userId: ID!
}

input CreateDriverLocationInput {
  accuracy: Float
  altitude: Float
  driverId: ID!
  heading: Float
  latitude: Float!
  longitude: Float!
  speedKmh: Float
  timestamp: String
}

input CreateDriverScheduleInput {
  driverId: ID!
  endDate: String!
  reason: DriverScheduleReason
  startDate: String!
}

input CreateExpenseInput {
  amount: Float!
  currency: Currency
  description: String
  driverId: ID
  expenseDate: String
  fuelQuantity: Float
  odometerReading: Int
  receiptUrl: String
  status: ExpenseStatus
  tripId: ID
  type: ExpenseType
}

input CreateGeofenceEventInput {
  eventType: GeofenceEventType!
  geofenceId: ID!
  timestamp: String!
  vehicleId: ID!
}

input CreateGeofenceInput {
  latitude: Float
  longitude: Float
  name: String!
}

input CreateGpsPingInput {
  latitude: Float!
  longitude: Float!
  timestamp: String!
  vehicleId: ID!
}

input CreateInboundShipmentInput {
  actualArrivalDate: String
  clientId: ID
  expectedArrivalDate: String
  status: InboundShipmentStatus
  warehouseId: ID!
}

input CreateInboundShipmentItemInput {
  discrepancyNotes: String
  expectedQuantity: Int!
  inboundShipmentId: ID!
  productId: ID!
  receivedQuantity: Int
}

input CreateInteractionInput {
  caseId: ID
  contactId: ID!
  interactionDate: String
  notes: String
  outcome: String
  type: InteractionType
  userId: ID!
}

input CreateInventoryAdjustmentInput {
  notes: String
  productId: ID!
  quantityChange: Int!
  reason: InventoryAdjustmentReason
  userId: ID!
  warehouseId: ID!
}

input CreateInventoryBatchInput {
  batchNumber: String!
  expirationDate: String
  productId: ID!
}

input CreateInventoryStockInput {
  batchId: ID
  lastCountedAt: String
  lastMovementAt: String
  locationId: ID!
  productId: ID!
  quantity: Int!
  reservedQuantity: Int!
  status: InventoryStockStatus
}

input CreateInvoiceInput {
  dueDate: String
  issueDate: String
  opportunityId: ID
  paidAt: String
  paymentMethod: PaymentMethod
  sentAt: String
  status: InvoiceStatus
  total: Float
}

input CreateInvoiceItemInput {
  invoiceId: ID!
  price: Float!
  productId: ID!
  quantity: Int!
}

input CreateInvoiceLineItemInput {
  description: String!
  discountRate: Float
  invoiceId: ID!
  quantity: Float!
  sourceRecordId: ID
  sourceRecordType: String
  taxRate: Float
  unitPrice: Float!
}

input CreateLeadInput {
  campaignId: ID
  email: String!
  leadScore: Int
  leadSource: LeadSource
  name: String!
  ownerId: ID!
  status: LeadStatus
}

input CreateLocationInput {
  barcode: String
  hazmatApproved: Boolean
  isActive: Boolean
  isPickable: Boolean
  isReceivable: Boolean
  level: Int
  maxPallets: Int
  maxVolume: Float
  maxWeight: Float
  name: String!
  parentLocationId: ID
  path: String
  temperatureControlled: Boolean
  type: LocationType!
  warehouseId: ID!
  xCoordinate: Float
  yCoordinate: Float
  zCoordinate: Float
}

input CreateNotificationInput {
  isRead: Boolean
  link: String
  message: String!
  userId: ID!
}

input CreateOpportunityInput {
  campaignId: ID
  companyId: ID
  contactId: ID
  dealValue: Float
  expectedCloseDate: String
  lostReason: String
  name: String!
  ownerId: ID!
  probability: Float
  source: OpportunitySource
  stage: OpportunityStage
}

input CreateOpportunityProductInput {
  opportunityId: ID!
  productId: ID!
  quantity: Int!
}

input CreateOutboundShipmentInput {
  carrier: String
  salesOrderId: ID!
  status: OutboundShipmentStatus
  trackingNumber: String
  warehouseId: ID!
}

input CreateOutboundShipmentItemInput {
  batchId: ID
  outboundShipmentId: ID!
  productId: ID!
  quantityShipped: Int!
  salesOrderItemId: ID!
}

input CreatePackageInput {
  carrier: String
  height: Float
  insuranceValue: Float
  isFragile: Boolean
  isHazmat: Boolean
  length: Float
  packageNumber: String!
  packageType: String
  packedAt: String
  packedByUserId: ID
  requiresSignature: Boolean
  salesOrderId: ID!
  serviceLevel: String
  shippedAt: String
  trackingNumber: String
  warehouseId: ID!
  weight: Float
  width: Float
}

input CreatePackageItemInput {
  batchId: ID
  expiryDate: String
  lotNumber: String
  packageId: ID!
  productId: ID!
  quantity: Int!
  serialNumbers: [String]
  unitWeight: Float
}

input CreatePartnerInvoiceInput {
  carrierId: ID!
  invoiceDate: String!
  invoiceNumber: String!
  status: PartnerInvoiceStatus
  totalAmount: Float!
}

input CreatePartnerInvoiceItemInput {
  amount: Float!
  partnerInvoiceId: ID!
  shipmentLegId: ID!
}

input CreatePaymentInput {
  amount: Float!
  currency: String
  exchangeRate: Float
  fees: Float
  gatewayReference: String
  invoiceId: ID!
  notes: String
  paymentDate: String
  paymentMethod: PaymentMethod!
  processedAt: String
  processedByUserId: ID
  status: PaymentStatus
  transactionId: String
}

input CreatePickBatchInput {
  actualDuration: Int
  assignedUserId: ID
  batchNumber: String!
  completedAt: String
  completedItems: Int
  estimatedDuration: Int
  priority: Int
  startedAt: String
  status: PickBatchStatus
  strategy: PickStrategy!
  totalItems: Int
  warehouseId: ID!
  waveId: String
  zoneRestrictions: [String]
}

input CreatePickBatchItemInput {
  actualPickTime: Int
  estimatedPickTime: Int
  orderPriority: Int
  pickBatchId: ID!
  salesOrderId: ID!
}

input CreateProductInput {
  description: String
  name: String!
  price: Float!
  sku: String
  type: ProductType
}

input CreateProofOfDeliveryInput {
  filePath: String
  latitude: Float
  longitude: Float
  timestamp: String!
  tripStopId: ID!
  type: ProofType
}

input CreatePutawayRuleInput {
  clientId: ID
  isActive: Boolean
  locationType: LocationType
  maxQuantity: Int
  minQuantity: Int
  preferredLocationId: ID
  priority: Int!
  productId: ID!
  requiresHazmatApproval: Boolean
  requiresTemperatureControl: Boolean
  volumeThreshold: Float
  warehouseId: ID!
  weightThreshold: Float
}

input CreateQuoteInput {
  clientId: ID
  createdByUserId: ID
  destinationDetails: String!
  expiresAt: String
  height: Float
  length: Float
  notes: String
  originDetails: String!
  quoteNumber: String
  quotedPrice: Float!
  serviceLevel: String
  status: QuoteStatus
  weight: Float
  width: Float
}

input CreateRateCardInput {
  createdByUserId: ID
  description: String
  isActive: Boolean
  name: String!
  serviceType: ServiceType!
  validFrom: String!
  validTo: String
}

input CreateRateRuleInput {
  condition: String!
  isActive: Boolean
  maxValue: Float
  minValue: Float
  price: Float!
  pricingModel: PricingModel!
  priority: Int
  rateCardId: ID!
  value: String!
}

input CreateReorderPointInput {
  productId: ID!
  threshold: Int!
  warehouseId: ID!
}

input CreateReturnInput {
  clientId: ID!
  reason: String
  returnNumber: String!
  salesOrderId: ID
  status: ReturnStatus
}

input CreateReturnItemInput {
  condition: ReturnItemCondition
  productId: ID!
  quantityExpected: Int!
  quantityReceived: Int
  returnId: ID!
}

input CreateRouteInput {
  optimizedRouteData: String
  totalDistance: Float
  totalDuration: Float
  tripId: ID!
}

input CreateSalesOrderInput {
  clientId: ID!
  crmOpportunityId: ID
  orderNumber: String!
  shippingAddress: String
  status: SalesOrderStatus
}

input CreateSalesOrderItemInput {
  productId: ID!
  quantityOrdered: Int!
  salesOrderId: ID!
}

input CreateShipmentLegEventInput {
  eventTimestamp: String!
  location: String
  shipmentLegId: ID!
  statusMessage: String
}

input CreateShipmentLegInput {
  carrierId: ID
  endLocation: String
  internalTripId: ID
  legSequence: Int!
  shipmentId: ID
  startLocation: String
  status: ShipmentLegStatus
}

input CreateStockTransferInput {
  destinationWarehouseId: ID!
  productId: ID!
  quantity: Int!
  sourceWarehouseId: ID!
  status: StockTransferStatus
}

input CreateSupplierInput {
  contactPerson: String
  email: String
  name: String!
  phoneNumber: String
}

input CreateSurchargeInput {
  amount: Float!
  calculationMethod: SurchargeCalculationMethod!
  description: String
  isActive: Boolean
  name: String!
  type: String!
  validFrom: String
  validTo: String
}

input CreateTaskEventInput {
  deliveryTaskId: ID!
  latitude: Float
  longitude: Float
  notes: String
  reason: String
  status: TaskEventStatus!
  timestamp: String
}

input CreateTaskInput {
  actualDuration: Int
  endTime: String
  estimatedDuration: Int
  instructions: String
  notes: String
  pickBatchId: ID
  priority: Int
  sourceEntityId: ID
  sourceEntityType: String
  startTime: String
  status: TaskStatus
  taskNumber: String!
  type: TaskType!
  userId: ID
  warehouseId: ID!
}

input CreateTaskItemInput {
  batchId: ID
  completedAt: String
  destinationLocationId: ID
  expiryDate: String
  lotNumber: String
  notes: String
  productId: ID!
  quantityCompleted: Int!
  quantityRequired: Int!
  serialNumbers: [String]
  sourceLocationId: ID
  status: TaskItemStatus
  taskId: ID!
}

input CreateTripInput {
  driverId: ID
  endLocation: String
  endTime: String
  startLocation: String
  startTime: String
  status: TripStatus
  vehicleId: ID
}

input CreateTripStopInput {
  actualArrivalTime: String
  actualDepartureTime: String
  address: String
  estimatedArrivalTime: String
  estimatedDepartureTime: String
  sequence: Int!
  shipmentId: ID
  status: TripStopStatus
  tripId: ID!
}

input CreateVehicleInput {
  capacityVolume: Float
  capacityWeight: Float
  currentMileage: Int
  lastMaintenanceDate: String
  make: String
  model: String
  registrationNumber: String!
  status: VehicleStatus
  vin: String
  year: Int
}

input CreateVehicleMaintenanceInput {
  cost: Float
  notes: String
  serviceDate: String!
  serviceType: VehicleServiceType
  vehicleId: ID!
}

input CreateWarehouseInput {
  address: String
  city: String
  contactEmail: String
  contactPerson: String
  contactPhone: String
  country: String
  isActive: Boolean
  name: String!
  postalCode: String
  state: String
  timezone: String
}

input CreateWmsProductInput {
  barcode: String
  clientId: ID
  costPrice: Float
  description: String
  height: Float
  length: Float
  name: String!
  sku: String!
  status: ProductStatus
  supplierId: ID
  weight: Float
  width: Float
}

type CreditNotes {
  amount: Float!
  appliedAt: String
  createdAt: String
  createdByUser: User
  creditNoteNumber: String!
  currency: String
  dispute: Disputes
  id: ID!
  invoice: BillingInvoices!
  issueDate: String!
  notes: String
  reason: String!
  updatedAt: String
}

type CrmMutation {
  createAttachment(value: CreateAttachmentInput!): Attachments!
  createCampaign(value: CreateCampaignInput!): Campaigns!
  createCase(value: CreateCaseInput!): Cases!
  createCompany(value: CreateCompanyInput!): Companies!
  createContact(value: CreateContactInput!): Contacts!
  createInteraction(value: CreateInteractionInput!): Interactions!
  createInvoice(value: CreateInvoiceInput!): Invoices!
  createInvoiceItem(value: CreateInvoiceItemInput!): InvoiceItems!
  createLead(value: CreateLeadInput!): Leads!
  createNotification(value: CreateNotificationInput!): Notifications!
  createOpportunity(value: CreateOpportunityInput!): Opportunities!
  createOpportunityProduct(value: CreateOpportunityProductInput!): OpportunityProducts!
  createProduct(value: CreateProductInput!): Products!
  removeAttachment(id: ID!): DeleteResult!
  removeCampaign(id: ID!): DeleteResult!
  removeCase(id: ID!): DeleteResult!
  removeCompany(id: ID!): DeleteResult!
  removeContact(id: ID!): DeleteResult!
  removeInteraction(id: ID!): DeleteResult!
  removeInvoice(id: ID!): DeleteResult!
  removeInvoiceItem(id: ID!): DeleteResult!
  removeLead(id: ID!): DeleteResult!
  removeNotification(id: ID!): DeleteResult!
  removeOpportunity(id: ID!): DeleteResult!
  removeOpportunityProduct(opportunityId: ID!, productId: ID!): DeleteResult!
  removeProduct(id: ID!): DeleteResult!
  updateCampaign(id: ID!, value: UpdateCampaignInput): Campaigns!
  updateCase(id: ID!, value: UpdateCaseInput): Cases!
  updateCompany(id: ID!, value: UpdateCompanyInput): Companies!
  updateContact(id: ID!, value: UpdateContactInput): Contacts!
  updateInteraction(id: ID!, value: UpdateInteractionInput): Interactions!
  updateInvoice(id: ID!, value: UpdateInvoiceInput): Invoices!
  updateInvoiceItem(id: ID!, value: UpdateInvoiceItemInput): InvoiceItems!
  updateLead(id: ID!, value: UpdateLeadInput): Leads!
  updateNotification(id: ID!, value: UpdateNotificationInput): Notifications!
  updateOpportunity(id: ID!, value: UpdateOpportunityInput): Opportunities!
  updateOpportunityProduct(opportunityId: ID!, productId: ID!, value: UpdateOpportunityProductInput): OpportunityProducts!
  updateProduct(id: ID!, value: UpdateProductInput): Products!
}

type CrmQuery {
  attachment(id: ID!): Attachments!
  attachments(from: Date, page: Int, perPage: Int, to: Date): [Attachments!]!
  campaign(id: ID!): Campaigns!
  campaigns(from: Date, page: Int, perPage: Int, to: Date): [Campaigns!]!
  case(id: ID!): Cases!
  cases(from: Date, page: Int, perPage: Int, to: Date): [Cases!]!
  companies(from: Date, page: Int, perPage: Int, to: Date): [Companies!]!
  company(id: ID!): Companies!
  contact(id: ID!): Contacts!
  contacts(from: Date, page: Int, perPage: Int, to: Date): [Contacts!]!
  interaction(id: ID!): Interactions!
  interactions(from: Date, page: Int, perPage: Int, to: Date): [Interactions!]!
  invoice(id: ID!): Invoices!
  invoices(from: Date, page: Int, perPage: Int, to: Date): [Invoices!]!
  lead(id: ID!): Leads!
  leads(from: Date, page: Int, perPage: Int, to: Date): [Leads!]!
  notification(id: ID!): Notifications!
  notifications(from: Date, page: Int, perPage: Int, to: Date): [Notifications!]!
  opportunities(from: Date, page: Int, perPage: Int, to: Date): [Opportunities!]!
  opportunity(id: ID!): Opportunities!
  product(id: ID!): Products!
  products(from: Date, page: Int, perPage: Int, to: Date): [Products!]!
}

enum Currency {
  AUD
  CAD
  EUR
  GBP
  JPY
  PHP
  USD
}

type CustomerTrackingLinks {
  accessCount: Int
  createdAt: String
  deliveryTask: DeliveryTasks!
  expiresAt: String
  id: ID!
  isActive: Boolean
  lastAccessedAt: String
  trackingToken: String!
  updatedAt: String
}

scalar Date

type DeleteResult {
  numDeletedRows: Int!
  success: Boolean!
}

enum DeliveryFailureReason {
  ACCESS_DENIED
  ADDRESS_NOT_FOUND
  DAMAGED_PACKAGE
  OTHER
  RECIPIENT_NOT_HOME
  REFUSED_DELIVERY
  VEHICLE_BREAKDOWN
  WEATHER_CONDITIONS
}

enum DeliveryRouteStatus {
  CANCELLED
  COMPLETED
  IN_PROGRESS
  PAUSED
  PLANNED
}

type DeliveryRoutes {
  actualDurationMinutes: Int
  completedAt: String
  createdAt: String
  driver: Drivers!
  estimatedDurationMinutes: Int
  id: ID!
  optimizedRouteData: String
  routeDate: String!
  startedAt: String
  status: DeliveryRouteStatus
  tasks: [DeliveryTasks!]
  totalDistanceKm: Float
  updatedAt: String
}

enum DeliveryTaskStatus {
  ASSIGNED
  CANCELLED
  DELIVERED
  FAILED
  OUT_FOR_DELIVERY
  PENDING
  RESCHEDULED
}

type DeliveryTasks {
  actualArrivalTime: String
  attemptCount: Int
  createdAt: String
  customerTrackingLinks: [CustomerTrackingLinks!]
  deliveryAddress: String!
  deliveryInstructions: String
  deliveryRoute: DeliveryRoutes!
  deliveryTime: String
  estimatedArrivalTime: String
  events: [TaskEvents!]
  failureReason: DeliveryFailureReason
  id: ID!
  package: Packages!
  proofOfDeliveries: [DmsProofOfDeliveries!]
  recipientName: String
  recipientPhone: String
  routeSequence: Int!
  status: DeliveryTaskStatus
  updatedAt: String
}

enum DisputeStatus {
  APPROVED
  CLOSED
  DENIED
  ESCALATED
  OPEN
  UNDER_REVIEW
}

type Disputes {
  client: Companies!
  createdAt: String
  creditNotes: [CreditNotes!]
  disputedAmount: Float
  id: ID!
  lineItem: InvoiceLineItems!
  reason: String!
  resolutionNotes: String
  resolvedAt: String
  resolvedByUser: User
  status: DisputeStatus
  submittedAt: String
  updatedAt: String
}

type DmsMutation {
  createCustomerTrackingLink(value: CreateCustomerTrackingLinkInput!): CustomerTrackingLinks!
  createDeliveryRoute(value: CreateDeliveryRouteInput!): DeliveryRoutes!
  createDeliveryTask(value: CreateDeliveryTaskInput!): DeliveryTasks!
  createDmsProofOfDelivery(value: CreateDmsProofOfDeliveryInput!): DmsProofOfDeliveries!
  createDriverLocation(value: CreateDriverLocationInput!): DriverLocations!
  createTaskEvent(value: CreateTaskEventInput!): TaskEvents!
  removeCustomerTrackingLink(id: ID!): DeleteResult!
  removeDeliveryRoute(id: ID!): DeleteResult!
  removeDeliveryTask(id: ID!): DeleteResult!
  removeDmsProofOfDelivery(id: ID!): DeleteResult!
  removeDriverLocation(id: ID!): DeleteResult!
  removeTaskEvent(id: ID!): DeleteResult!
  updateCustomerTrackingLink(id: ID!, value: UpdateCustomerTrackingLinkInput): CustomerTrackingLinks!
  updateDeliveryRoute(id: ID!, value: UpdateDeliveryRouteInput): DeliveryRoutes!
  updateDeliveryTask(id: ID!, value: UpdateDeliveryTaskInput): DeliveryTasks!
  updateDmsProofOfDelivery(id: ID!, value: UpdateDmsProofOfDeliveryInput): DmsProofOfDeliveries!
  updateDriverLocation(id: ID!, value: UpdateDriverLocationInput): DriverLocations!
  updateTaskEvent(id: ID!, value: UpdateTaskEventInput): TaskEvents!
}

type DmsProofOfDeliveries {
  createdAt: String
  deliveryTask: DeliveryTasks!
  filePath: String
  id: ID!
  latitude: Float
  longitude: Float
  recipientName: String
  signatureData: String
  timestamp: String
  type: ProofOfDeliveryType!
  updatedAt: String
  verificationCode: String
}

type DmsQuery {
  customerTrackingLink(id: ID!): CustomerTrackingLinks!
  customerTrackingLinks(from: Date, page: Int, perPage: Int, to: Date): [CustomerTrackingLinks!]!
  deliveryRoute(id: ID!): DeliveryRoutes!
  deliveryRoutes(from: Date, page: Int, perPage: Int, to: Date): [DeliveryRoutes!]!
  deliveryTask(id: ID!): DeliveryTasks!
  deliveryTasks(from: Date, page: Int, perPage: Int, to: Date): [DeliveryTasks!]!
  dmsProofOfDeliveries(from: Date, page: Int, perPage: Int, to: Date): [DmsProofOfDeliveries!]!
  dmsProofOfDelivery(id: ID!): DmsProofOfDeliveries!
  driverLocation(id: ID!): DriverLocations!
  driverLocations(from: Date, page: Int, perPage: Int, to: Date): [DriverLocations!]!
  taskEvent(id: ID!): TaskEvents!
  taskEvents(from: Date, page: Int, perPage: Int, to: Date): [TaskEvents!]!
}

enum DocumentType {
  BOL
  COMMERCIAL_INVOICE
  CREDIT_NOTE
  CUSTOMS_DECLARATION
  PACKING_LIST
  PROOF_OF_DELIVERY
  RECEIPT
  SHIPPING_LABEL
}

type Documents {
  createdAt: String
  documentType: DocumentType!
  fileName: String!
  filePath: String!
  fileSize: Int
  id: ID!
  mimeType: String
  recordId: ID!
  recordType: String!
  updatedAt: String
  uploadedByUser: User
}

type DriverLocations {
  accuracy: Float
  altitude: Float
  createdAt: String
  driver: Drivers!
  heading: Float
  id: ID!
  latitude: Float!
  longitude: Float!
  speedKmh: Float
  timestamp: String
  updatedAt: String
}

enum DriverScheduleReason {
  PERSONAL_LEAVE
  SICK_LEAVE
  TRAINING
  VACATION
}

type DriverSchedules {
  createdAt: String
  driver: Drivers!
  endDate: String!
  id: ID!
  reason: DriverScheduleReason
  startDate: String!
  updatedAt: String
}

enum DriverStatus {
  ACTIVE
  INACTIVE
  ON_LEAVE
}

type Drivers {
  contactPhone: String
  createdAt: String
  deliveryRoutes: [DeliveryRoutes!]
  driverLocations: [DriverLocations!]
  expenses: [Expenses!]
  id: ID!
  licenseExpiryDate: String
  licenseNumber: String!
  schedules: [DriverSchedules!]
  status: DriverStatus
  trips: [Trips!]
  updatedAt: String
  user: User!
}

enum ExpenseStatus {
  APPROVED
  PENDING
  REIMBURSED
  REJECTED
}

enum ExpenseType {
  ACCOMMODATION
  FUEL
  MAINTENANCE
  MEALS
  PARKING
  TOLLS
}

type Expenses {
  amount: Float!
  createdAt: String
  currency: Currency
  description: String
  driver: Drivers
  expenseDate: String
  fuelQuantity: Float
  id: ID!
  odometerReading: Int
  receiptUrl: String
  status: ExpenseStatus
  trip: Trips
  type: ExpenseType
  updatedAt: String
}

scalar File

enum GeofenceEventType {
  ENTER
  EXIT
}

type GeofenceEvents {
  eventType: GeofenceEventType!
  geofence: Geofences!
  id: ID!
  timestamp: String!
  vehicle: Vehicles!
}

type Geofences {
  createdAt: String
  events: [GeofenceEvents!]
  id: ID!
  latitude: Float
  longitude: Float
  name: String!
  updatedAt: String
}

type GpsPings {
  id: ID!
  latitude: Float!
  longitude: Float!
  timestamp: String!
  vehicle: Vehicles!
}

type InboundShipmentItems {
  createdAt: String
  discrepancyNotes: String
  discrepancyQuantity: Int
  expectedQuantity: Int!
  id: ID!
  inboundShipment: InboundShipments!
  product: WmsProducts!
  receivedQuantity: Int
  updatedAt: String
}

enum InboundShipmentStatus {
  ARRIVED
  CANCELLED
  COMPLETED
  PENDING
  PROCESSING
}

type InboundShipments {
  actualArrivalDate: String
  client: Companies
  createdAt: String
  expectedArrivalDate: String
  id: ID!
  items: [InboundShipmentItems!]
  status: InboundShipmentStatus
  updatedAt: String
  warehouseId: ID!
}

enum InteractionType {
  CALL
  EMAIL
  MEETING
  TEXT
}

type Interactions {
  case: Cases
  contact: Contacts!
  createdAt: String
  id: ID!
  interactionDate: String
  notes: String
  outcome: String
  type: InteractionType
  updatedAt: String
  user: User!
}

enum InventoryAdjustmentReason {
  CYCLE_COUNT
  DAMAGED_GOODS
  EXPIRED
  MANUAL_CORRECTION
  RETURN_TO_VENDOR
  THEFT
}

type InventoryAdjustments {
  createdAt: String
  id: ID!
  notes: String
  product: WmsProducts!
  quantityChange: Int!
  reason: InventoryAdjustmentReason
  updatedAt: String
  user: User!
  warehouseId: ID!
}

type InventoryBatches {
  batchNumber: String!
  createdAt: String
  expirationDate: String
  id: ID!
  inventoryStock: [InventoryStock!]
  outboundShipmentItems: [OutboundShipmentItems!]
  packageItems: [PackageItems!]
  product: WmsProducts!
  taskItems: [TaskItems!]
  updatedAt: String
}

type InventoryStock {
  availableQuantity: Int
  batch: InventoryBatches
  createdAt: String
  id: ID!
  lastCountedAt: String
  lastMovementAt: String
  location: Locations!
  product: WmsProducts!
  quantity: Int!
  reservedQuantity: Int!
  status: InventoryStockStatus
  updatedAt: String
}

enum InventoryStockStatus {
  ALLOCATED
  AVAILABLE
  DAMAGED
  EXPIRED
  HOLD
  QUARANTINE
  SHIPPED
}

type InvoiceItems {
  createdAt: String
  id: ID!
  invoice: Invoices!
  price: Float!
  product: Products!
  quantity: Int!
  updatedAt: String
}

type InvoiceLineItems {
  createdAt: String
  description: String!
  discountAmount: Float
  discountRate: Float
  disputes: [Disputes!]
  id: ID!
  invoice: BillingInvoices!
  lineTotal: Float
  quantity: Float!
  sourceRecordId: ID
  sourceRecordType: String
  taxAmount: Float
  taxRate: Float
  totalPrice: Float
  unitPrice: Float!
  updatedAt: String
}

enum InvoiceStatus {
  CANCELLED
  DRAFT
  OVERDUE
  PAID
  SENT
}

type Invoices {
  createdAt: String
  dueDate: String
  id: ID!
  issueDate: String
  items: [InvoiceItems!]
  opportunity: Opportunities
  paidAt: String
  paymentMethod: PaymentMethod
  sentAt: String
  status: InvoiceStatus
  total: Float
  updatedAt: String
}

enum LeadSource {
  ADVERTISEMENT
  COLD_CALL
  EMAIL_CAMPAIGN
  EVENT
  OTHER
  PARTNER
  REFERRAL
  SOCIAL_MEDIA
  WEBSITE
}

enum LeadStatus {
  CONTACTED
  CONVERTED
  NEW
  QUALIFIED
  UNQUALIFIED
}

type Leads {
  campaign: Campaigns
  convertedAt: String
  convertedCompany: Companies
  convertedContact: Contacts
  convertedOpportunity: Opportunities
  createdAt: String
  email: String!
  id: ID!
  leadScore: Int
  leadSource: LeadSource
  name: String!
  owner: User!
  status: LeadStatus
  updatedAt: String
}

enum LocationType {
  BULK_STORAGE
  CROSS_DOCK_AREA
  DAMAGED_GOODS
  PACKING_STATION
  PICK_BIN
  QUALITY_CONTROL
  RECEIVING_DOCK
  RESERVE_STORAGE
  RETURNS_AREA
  STAGING_AREA
}

type Locations {
  barcode: String
  binThresholds: [BinThresholds!]
  createdAt: String
  destinationTaskItems: [TaskItems!]
  hazmatApproved: Boolean
  id: ID!
  inventoryStock: [InventoryStock!]
  isActive: Boolean
  isPickable: Boolean
  isReceivable: Boolean
  level: Int
  maxPallets: Int
  maxVolume: Float
  maxWeight: Float
  name: String!
  parentLocation: Locations
  path: String
  putawayRules: [PutawayRules!]
  sourceTaskItems: [TaskItems!]
  temperatureControlled: Boolean
  type: LocationType!
  updatedAt: String
  warehouse: Warehouses!
  xCoordinate: Float
  yCoordinate: Float
  zCoordinate: Float
}

type Mutation {
  billing: BillingMutation
  crm: CrmMutation
  dms: DmsMutation
  tms: TmsMutation
  wms: WmsMutation
}

type Notifications {
  createdAt: String
  id: ID!
  isRead: Boolean
  link: String
  message: String!
  updatedAt: String
  user: User!
}

type Opportunities {
  campaign: Campaigns
  company: Companies
  contact: Contacts
  createdAt: String
  dealValue: Float
  expectedCloseDate: String
  id: ID!
  lostReason: String
  name: String!
  owner: User!
  probability: Float
  products: [OpportunityProducts!]
  salesOrders: [SalesOrders!]
  source: OpportunitySource
  stage: OpportunityStage
  updatedAt: String
}

type OpportunityProducts {
  opportunity: Opportunities!
  product: Products!
  quantity: Int!
}

enum OpportunitySource {
  ADVERTISEMENT
  COLD_CALL
  EMAIL_CAMPAIGN
  EVENT
  EXISTING_CUSTOMER
  OTHER
  PARTNER
  REFERRAL
  SOCIAL_MEDIA
  WEBSITE
}

enum OpportunityStage {
  CLOSED_LOST
  CLOSED_WON
  DEMO
  NEED_ANALYSIS
  NEGOTIATION
  PROPOSAL
  PROSPECTING
  QUALIFICATION
}

type OutboundShipmentItems {
  batch: InventoryBatches
  createdAt: String
  id: ID!
  outboundShipment: OutboundShipments!
  product: WmsProducts!
  quantityShipped: Int!
  salesOrderItem: SalesOrderItems!
  updatedAt: String
}

enum OutboundShipmentStatus {
  CANCELLED
  DELIVERED
  PACKED
  PICKING
  SHIPPED
}

type OutboundShipments {
  carrier: String
  createdAt: String
  id: ID!
  items: [OutboundShipmentItems!]
  salesOrder: SalesOrders!
  status: OutboundShipmentStatus
  trackingNumber: String
  updatedAt: String
  warehouseId: ID!
}

type PackageItems {
  batch: InventoryBatches
  createdAt: String
  expiryDate: String
  id: ID!
  lotNumber: String
  package: Packages!
  product: WmsProducts!
  quantity: Int!
  serialNumbers: [String]
  totalWeight: Float
  unitWeight: Float
  updatedAt: String
}

type Packages {
  carrier: String
  createdAt: String
  deliveryTasks: [DeliveryTasks!]
  height: Float
  id: ID!
  insuranceValue: Float
  isFragile: Boolean
  isHazmat: Boolean
  items: [PackageItems!]
  length: Float
  packageNumber: String!
  packageType: String
  packedAt: String
  packedByUser: User
  requiresSignature: Boolean
  salesOrder: SalesOrders!
  serviceLevel: String
  shippedAt: String
  trackingNumber: String
  updatedAt: String
  volume: Float
  warehouse: Warehouses!
  weight: Float
  width: Float
}

type PartnerInvoiceItems {
  amount: Float!
  id: ID!
  partnerInvoice: PartnerInvoices!
  shipmentLeg: ShipmentLegs!
}

enum PartnerInvoiceStatus {
  CANCELLED
  DISPUTED
  OVERDUE
  PAID
  PENDING
}

type PartnerInvoices {
  carrier: Carriers!
  createdAt: String
  id: ID!
  invoiceDate: String!
  invoiceNumber: String!
  items: [PartnerInvoiceItems!]
  status: PartnerInvoiceStatus
  totalAmount: Float!
  updatedAt: String
}

enum PaymentMethod {
  BANK_TRANSFER
  CASH
  CHECK
  CLIENT_CREDIT
  CREDIT_CARD
  DEBIT_CARD
  MAYA
  OTHER
  PAYPAL
  QR_PH
  STRIPE
  WALLET
  WIRE_TRANSFER
}

enum PaymentStatus {
  CANCELLED
  FAILED
  PENDING
  PROCESSING
  REFUNDED
  SUCCESSFUL
}

type Payments {
  amount: Float!
  createdAt: String
  currency: String
  exchangeRate: Float
  fees: Float
  gatewayReference: String
  id: ID!
  invoice: BillingInvoices!
  netAmount: Float
  notes: String
  paymentDate: String
  paymentMethod: PaymentMethod!
  processedAt: String
  processedByUser: User
  status: PaymentStatus
  transactionId: String
  updatedAt: String
}

type PickBatchItems {
  actualPickTime: Int
  createdAt: String
  estimatedPickTime: Int
  id: ID!
  orderPriority: Int
  pickBatch: PickBatches!
  salesOrder: SalesOrders!
  updatedAt: String
}

enum PickBatchStatus {
  CANCELLED
  COMPLETED
  IN_PROGRESS
  OPEN
}

type PickBatches {
  actualDuration: Int
  assignedUser: User
  batchNumber: String!
  completedAt: String
  completedItems: Int
  createdAt: String
  estimatedDuration: Int
  id: ID!
  items: [PickBatchItems!]
  priority: Int
  startedAt: String
  status: PickBatchStatus
  strategy: PickStrategy!
  tasks: [Tasks!]
  totalItems: Int
  updatedAt: String
  warehouse: Warehouses!
  waveId: String
  zoneRestrictions: [String]
}

enum PickStrategy {
  BATCH_PICKING
  CLUSTER_PICKING
  SINGLE_ORDER_PICKING
  WAVE_PICKING
  ZONE_PICKING
}

enum PricingModel {
  FLAT_RATE
  PERCENTAGE
  PER_CUBIC_METER
  PER_ITEM
  PER_KG
  PER_ZONE
  TIERED
}

enum ProductStatus {
  ACTIVE
  DISCONTINUED
  INACTIVE
  OBSOLETE
}

enum ProductType {
  DIGITAL
  GOOD
  SERVICE
  SUBSCRIPTION
}

type Products {
  createdAt: String
  description: String
  id: ID!
  name: String!
  price: Float!
  sku: String
  type: ProductType
  updatedAt: String
}

type ProofOfDeliveries {
  createdAt: String
  filePath: String
  id: ID!
  latitude: Float
  longitude: Float
  timestamp: String!
  tripStop: TripStops!
  type: ProofType
  updatedAt: String
}

enum ProofOfDeliveryType {
  CODE_VERIFICATION
  CONTACTLESS_DELIVERY
  LEFT_AT_DOOR
  PHOTO
  SIGNATURE
}

enum ProofType {
  BARCODE_SCAN
  PHOTO
  PIN_VERIFICATION
  SIGNATURE
}

type PutawayRules {
  client: Companies
  createdAt: String
  id: ID!
  isActive: Boolean
  locationType: LocationType
  maxQuantity: Int
  minQuantity: Int
  preferredLocation: Locations
  priority: Int!
  product: WmsProducts!
  requiresHazmatApproval: Boolean
  requiresTemperatureControl: Boolean
  updatedAt: String
  volumeThreshold: Float
  warehouse: Warehouses!
  weightThreshold: Float
}

type Query {
  billing: BillingQuery
  crm: CrmQuery
  dms: DmsQuery
  tms: TmsQuery
  wms: WmsQuery
}

enum QuoteStatus {
  ACCEPTED
  CANCELLED
  CONVERTED
  EXPIRED
  PENDING
}

type Quotes {
  billingInvoices: [BillingInvoices!]
  client: Companies
  createdAt: String
  createdByUser: User
  destinationDetails: String!
  expiresAt: String
  height: Float
  id: ID!
  length: Float
  notes: String
  originDetails: String!
  quoteNumber: String
  quotedPrice: Float!
  serviceLevel: String
  status: QuoteStatus
  updatedAt: String
  volume: Float
  weight: Float
  width: Float
}

type RateCards {
  createdAt: String
  createdByUser: User
  description: String
  id: ID!
  isActive: Boolean
  name: String!
  rules: [RateRules!]
  serviceType: ServiceType!
  updatedAt: String
  validFrom: String!
  validTo: String
}

type RateRules {
  condition: String!
  createdAt: String
  id: ID!
  isActive: Boolean
  maxValue: Float
  minValue: Float
  price: Float!
  pricingModel: PricingModel!
  priority: Int
  rateCard: RateCards!
  updatedAt: String
  value: String!
}

enum RecordType {
  CAMPAIGNS
  CASES
  COMPANIES
  CONTACTS
  INTERACTIONS
  INVOICES
  LEADS
  OPPORTUNITIES
  PRODUCTS
}

type ReorderPoints {
  createdAt: String
  id: ID!
  product: WmsProducts!
  threshold: Int!
  updatedAt: String
  warehouse: Warehouses!
}

enum ReturnItemCondition {
  DAMAGED
  DEFECTIVE
  EXPIRED
  SELLABLE
  UNSELLABLE
}

type ReturnItems {
  condition: ReturnItemCondition
  createdAt: String
  id: ID!
  product: WmsProducts!
  quantityExpected: Int!
  quantityReceived: Int
  quantityVariance: Int
  return: Returns!
  updatedAt: String
}

enum ReturnStatus {
  APPROVED
  PROCESSED
  RECEIVED
  REJECTED
  REQUESTED
}

type Returns {
  client: Companies!
  createdAt: String
  id: ID!
  items: [ReturnItems!]
  reason: String
  returnNumber: String!
  salesOrder: SalesOrders
  status: ReturnStatus
  updatedAt: String
}

type Routes {
  createdAt: String
  id: ID!
  optimizedRouteData: String
  totalDistance: Float
  totalDuration: Float
  trip: Trips!
  updatedAt: String
}

type SalesOrderItems {
  createdAt: String
  id: ID!
  outboundShipmentItems: [OutboundShipmentItems!]
  product: WmsProducts!
  quantityOrdered: Int!
  salesOrder: SalesOrders!
  updatedAt: String
}

enum SalesOrderStatus {
  CANCELLED
  COMPLETED
  PENDING
  PROCESSING
  SHIPPED
}

type SalesOrders {
  client: Companies!
  createdAt: String
  crmOpportunity: Opportunities
  id: ID!
  items: [SalesOrderItems!]
  orderNumber: String!
  outboundShipments: [OutboundShipments!]
  packages: [Packages!]
  pickBatchItems: [PickBatchItems!]
  returns: [Returns!]
  shippingAddress: String
  status: SalesOrderStatus
  updatedAt: String
}

enum ServiceType {
  CUSTOMS
  FULFILLMENT
  HANDLING
  INSURANCE
  PACKAGING
  RETURNS
  SHIPPING
  STORAGE
}

type ShipmentLegEvents {
  eventTimestamp: String!
  id: ID!
  location: String
  shipmentLeg: ShipmentLegs!
  statusMessage: String
}

enum ShipmentLegStatus {
  CANCELLED
  DELIVERED
  FAILED
  IN_TRANSIT
  PENDING
}

type ShipmentLegs {
  carrier: Carriers
  createdAt: String
  endLocation: String
  events: [ShipmentLegEvents!]
  id: ID!
  internalTrip: Trips
  legSequence: Int!
  partnerInvoiceItems: [PartnerInvoiceItems!]
  shipment: OutboundShipments
  startLocation: String
  status: ShipmentLegStatus
  updatedAt: String
}

enum StockTransferStatus {
  CANCELLED
  IN_TRANSIT
  PENDING
  RECEIVED
}

type StockTransfers {
  createdAt: String
  destinationWarehouse: Warehouses!
  id: ID!
  product: WmsProducts!
  quantity: Int!
  sourceWarehouse: Warehouses!
  status: StockTransferStatus
  updatedAt: String
}

type Suppliers {
  contactPerson: String
  createdAt: String
  email: String
  id: ID!
  name: String!
  phoneNumber: String
  products: [WmsProducts!]
  updatedAt: String
}

enum SurchargeCalculationMethod {
  FIXED
  PERCENTAGE
  PER_UNIT
  SLIDING_SCALE
}

type Surcharges {
  amount: Float!
  calculationMethod: SurchargeCalculationMethod!
  createdAt: String
  description: String
  id: ID!
  isActive: Boolean
  name: String!
  type: String!
  updatedAt: String
  validFrom: String
  validTo: String
}

enum SyncStatus {
  FAILED
  IN_PROGRESS
  PENDING
  RETRY
  SUCCESS
}

enum TaskEventStatus {
  ARRIVED
  ASSIGNED
  CANCELLED
  DELIVERED
  EXCEPTION
  FAILED
  RESCHEDULED
  STARTED
}

type TaskEvents {
  createdAt: String
  deliveryTask: DeliveryTasks!
  id: ID!
  latitude: Float
  longitude: Float
  notes: String
  reason: String
  status: TaskEventStatus!
  timestamp: String
  updatedAt: String
}

enum TaskItemStatus {
  COMPLETED
  DAMAGED
  IN_PROGRESS
  NOT_FOUND
  PENDING
  SHORT_PICKED
}

type TaskItems {
  batch: InventoryBatches
  completedAt: String
  createdAt: String
  destinationLocation: Locations
  expiryDate: String
  id: ID!
  lotNumber: String
  notes: String
  product: WmsProducts!
  quantityCompleted: Int!
  quantityRemaining: Int
  quantityRequired: Int!
  serialNumbers: [String]
  sourceLocation: Locations
  status: TaskItemStatus
  task: Tasks!
  updatedAt: String
}

enum TaskStatus {
  ASSIGNED
  CANCELLED
  COMPLETED
  ERROR
  IN_PROGRESS
  PENDING
}

enum TaskType {
  CROSS_DOCK
  CYCLE_COUNT
  DAMAGE_INSPECTION
  PACK
  PICK
  PUTAWAY
  QUALITY_CHECK
  REPLENISHMENT
  RETURNS_PROCESSING
}

type Tasks {
  actualDuration: Int
  createdAt: String
  durationSeconds: Int
  endTime: String
  estimatedDuration: Int
  id: ID!
  instructions: String
  items: [TaskItems!]
  notes: String
  pickBatch: PickBatches
  priority: Int
  sourceEntityId: ID
  sourceEntityType: String
  startTime: String
  status: TaskStatus
  taskNumber: String!
  type: TaskType!
  updatedAt: String
  user: User
  warehouse: Warehouses!
}

type TmsMutation {
  createCarrier(value: CreateCarrierInput!): Carriers!
  createCarrierRate(value: CreateCarrierRateInput!): CarrierRates!
  createDriver(value: CreateDriverInput!): Drivers!
  createDriverSchedule(value: CreateDriverScheduleInput!): DriverSchedules!
  createExpense(value: CreateExpenseInput!): Expenses!
  createGeofence(value: CreateGeofenceInput!): Geofences!
  createGeofenceEvent(value: CreateGeofenceEventInput!): GeofenceEvents!
  createGpsPing(value: CreateGpsPingInput!): GpsPings!
  createPartnerInvoice(value: CreatePartnerInvoiceInput!): PartnerInvoices!
  createPartnerInvoiceItem(value: CreatePartnerInvoiceItemInput!): PartnerInvoiceItems!
  createProofOfDelivery(value: CreateProofOfDeliveryInput!): ProofOfDeliveries!
  createRoute(value: CreateRouteInput!): Routes!
  createShipmentLeg(value: CreateShipmentLegInput!): ShipmentLegs!
  createShipmentLegEvent(value: CreateShipmentLegEventInput!): ShipmentLegEvents!
  createTrip(value: CreateTripInput!): Trips!
  createTripStop(value: CreateTripStopInput!): TripStops!
  createVehicle(value: CreateVehicleInput!): Vehicles!
  createVehicleMaintenance(value: CreateVehicleMaintenanceInput!): VehicleMaintenance!
  removeCarrier(id: ID!): DeleteResult!
  removeCarrierRate(id: ID!): DeleteResult!
  removeDriver(id: ID!): DeleteResult!
  removeDriverSchedule(id: ID!): DeleteResult!
  removeExpense(id: ID!): DeleteResult!
  removeGeofence(id: ID!): DeleteResult!
  removeGeofenceEvent(id: ID!): DeleteResult!
  removeGpsPing(id: ID!): DeleteResult!
  removePartnerInvoice(id: ID!): DeleteResult!
  removePartnerInvoiceItem(id: ID!): DeleteResult!
  removeProofOfDelivery(id: ID!): DeleteResult!
  removeRoute(id: ID!): DeleteResult!
  removeShipmentLeg(id: ID!): DeleteResult!
  removeShipmentLegEvent(id: ID!): DeleteResult!
  removeTrip(id: ID!): DeleteResult!
  removeTripStop(id: ID!): DeleteResult!
  removeVehicle(id: ID!): DeleteResult!
  removeVehicleMaintenance(id: ID!): DeleteResult!
  updateCarrier(id: ID!, value: UpdateCarrierInput): Carriers!
  updateCarrierRate(id: ID!, value: UpdateCarrierRateInput): CarrierRates!
  updateDriver(id: ID!, value: UpdateDriverInput): Drivers!
  updateDriverSchedule(id: ID!, value: UpdateDriverScheduleInput): DriverSchedules!
  updateExpense(id: ID!, value: UpdateExpenseInput): Expenses!
  updateGeofence(id: ID!, value: UpdateGeofenceInput): Geofences!
  updateGeofenceEvent(id: ID!, value: UpdateGeofenceEventInput): GeofenceEvents!
  updateGpsPing(id: ID!, value: UpdateGpsPingInput): GpsPings!
  updatePartnerInvoice(id: ID!, value: UpdatePartnerInvoiceInput): PartnerInvoices!
  updatePartnerInvoiceItem(id: ID!, value: UpdatePartnerInvoiceItemInput): PartnerInvoiceItems!
  updateProofOfDelivery(id: ID!, value: UpdateProofOfDeliveryInput): ProofOfDeliveries!
  updateRoute(id: ID!, value: UpdateRouteInput): Routes!
  updateShipmentLeg(id: ID!, value: UpdateShipmentLegInput): ShipmentLegs!
  updateShipmentLegEvent(id: ID!, value: UpdateShipmentLegEventInput): ShipmentLegEvents!
  updateTrip(id: ID!, value: UpdateTripInput): Trips!
  updateTripStop(id: ID!, value: UpdateTripStopInput): TripStops!
  updateVehicle(id: ID!, value: UpdateVehicleInput): Vehicles!
  updateVehicleMaintenance(id: ID!, value: UpdateVehicleMaintenanceInput): VehicleMaintenance!
}

type TmsQuery {
  carrier(id: ID!): Carriers!
  carriers(from: Date, page: Int, perPage: Int, to: Date): [Carriers!]!
  driver(id: ID!): Drivers!
  drivers(from: Date, page: Int, perPage: Int, to: Date): [Drivers!]!
  expense(id: ID!): Expenses!
  expenses(from: Date, page: Int, perPage: Int, to: Date): [Expenses!]!
  geofence(id: ID!): Geofences!
  geofences(from: Date, page: Int, perPage: Int, to: Date): [Geofences!]!
  gpsPing(id: ID!): GpsPings!
  gpsPings(from: Date, page: Int, perPage: Int, to: Date): [GpsPings!]!
  partnerInvoice(id: ID!): PartnerInvoices!
  partnerInvoices(from: Date, page: Int, perPage: Int, to: Date): [PartnerInvoices!]!
  proofOfDeliveries(from: Date, page: Int, perPage: Int, to: Date): [ProofOfDeliveries!]!
  proofOfDelivery(id: ID!): ProofOfDeliveries!
  route(id: ID!): Routes!
  routes(from: Date, page: Int, perPage: Int, to: Date): [Routes!]!
  shipmentLeg(id: ID!): ShipmentLegs!
  shipmentLegs(from: Date, page: Int, perPage: Int, to: Date): [ShipmentLegs!]!
  trip(id: ID!): Trips!
  trips(from: Date, page: Int, perPage: Int, to: Date): [Trips!]!
  vehicle(id: ID!): Vehicles!
  vehicles(from: Date, page: Int, perPage: Int, to: Date): [Vehicles!]!
}

enum TransactionType {
  ADJUSTMENT
  CREDIT
  DEBIT
  FEE
  REFUND
  TOP_UP
}

enum TripStatus {
  CANCELLED
  COMPLETED
  IN_PROGRESS
  PLANNED
}

enum TripStopStatus {
  ARRIVED
  COMPLETED
  PENDING
  SKIPPED
}

type TripStops {
  actualArrivalTime: String
  actualDepartureTime: String
  address: String
  createdAt: String
  estimatedArrivalTime: String
  estimatedDepartureTime: String
  id: ID!
  proofOfDeliveries: [ProofOfDeliveries!]
  sequence: Int!
  shipment: OutboundShipments
  status: TripStopStatus
  trip: Trips!
  updatedAt: String
}

type Trips {
  createdAt: String
  driver: Drivers
  endLocation: String
  endTime: String
  expenses: [Expenses!]
  id: ID!
  routes: [Routes!]
  shipmentLegs: [ShipmentLegs!]
  startLocation: String
  startTime: String
  status: TripStatus
  stops: [TripStops!]
  updatedAt: String
  vehicle: Vehicles
}

input UpdateAccountTransactionInput {
  amount: Float
  clientAccountId: ID
  description: String
  processedByUserId: ID
  referenceNumber: String
  runningBalance: Float
  sourceRecordId: ID
  sourceRecordType: String
  transactionDate: String
  type: TransactionType
}

input UpdateAccountingSyncLogInput {
  errorMessage: String
  externalId: String
  externalSystem: String
  lastSyncAt: String
  nextRetryAt: String
  recordId: ID
  recordType: String
  requestPayload: String
  responsePayload: String
  retryCount: Int
  status: SyncStatus
}

input UpdateBillingInvoiceInput {
  amountPaid: Float
  clientId: ID
  createdByUserId: ID
  currency: String
  discountAmount: Float
  dueDate: String
  invoiceNumber: String
  issueDate: String
  notes: String
  paidAt: String
  paymentTerms: String
  quoteId: ID
  sentAt: String
  status: BillingInvoiceStatus
  subtotal: Float
  taxAmount: Float
  totalAmount: Float
}

input UpdateBinThresholdInput {
  alertThreshold: Int
  isActive: Boolean
  locationId: ID
  maxQuantity: Int
  minQuantity: Int
  productId: ID
  reorderQuantity: Int
}

input UpdateCampaignInput {
  budget: Float
  endDate: String
  name: String
  startDate: String
}

input UpdateCarrierInput {
  contactEmail: String
  contactPerson: String
  contactPhone: String
  name: String
  servicesOffered: String
}

input UpdateCarrierRateInput {
  carrierId: ID
  destination: String
  origin: String
  rate: Float
  serviceType: String
  unit: CarrierRateUnit
}

input UpdateCaseInput {
  caseNumber: String
  contactId: ID
  description: String
  ownerId: ID
  priority: CasePriority
  status: CaseStatus
  type: CaseType
}

input UpdateClientAccountInput {
  availableCredit: Float
  clientId: ID
  creditLimit: Float
  currency: String
  isCreditApproved: Boolean
  lastPaymentDate: String
  paymentTermsDays: Int
  walletBalance: Float
}

input UpdateCompanyInput {
  annualRevenue: Float
  city: String
  country: String
  industry: String
  name: String
  ownerId: ID
  phoneNumber: String
  postalCode: String
  state: String
  street: String
  website: String
}

input UpdateContactInput {
  companyId: ID
  email: String
  jobTitle: String
  name: String
  ownerId: ID
  phoneNumber: String
}

input UpdateCreditNoteInput {
  amount: Float
  appliedAt: String
  createdByUserId: ID
  creditNoteNumber: String
  currency: String
  disputeId: ID
  invoiceId: ID
  issueDate: String
  notes: String
  reason: String
}

input UpdateCustomerTrackingLinkInput {
  accessCount: Int
  deliveryTaskId: ID
  expiresAt: String
  isActive: Boolean
  lastAccessedAt: String
  trackingToken: String
}

input UpdateDeliveryRouteInput {
  completedAt: String
  driverId: ID
  estimatedDurationMinutes: Int
  optimizedRouteData: String
  routeDate: String
  startedAt: String
  status: DeliveryRouteStatus
  totalDistanceKm: Float
}

input UpdateDeliveryTaskInput {
  actualArrivalTime: String
  attemptCount: Int
  deliveryAddress: String
  deliveryInstructions: String
  deliveryRouteId: ID
  deliveryTime: String
  estimatedArrivalTime: String
  failureReason: DeliveryFailureReason
  packageId: ID
  recipientName: String
  recipientPhone: String
  routeSequence: Int
  status: DeliveryTaskStatus
}

input UpdateDisputeInput {
  clientId: ID
  disputedAmount: Float
  lineItemId: ID
  reason: String
  resolutionNotes: String
  resolvedAt: String
  resolvedByUserId: ID
  status: DisputeStatus
  submittedAt: String
}

input UpdateDmsProofOfDeliveryInput {
  deliveryTaskId: ID
  filePath: String
  latitude: Float
  longitude: Float
  recipientName: String
  signatureData: String
  timestamp: String
  type: ProofOfDeliveryType
  verificationCode: String
}

input UpdateDocumentInput {
  documentType: DocumentType
  fileName: String
  filePath: String
  fileSize: Int
  mimeType: String
  recordId: ID
  recordType: String
  uploadedByUserId: ID
}

input UpdateDriverInput {
  contactPhone: String
  licenseExpiryDate: String
  licenseNumber: String
  status: DriverStatus
  userId: ID
}

input UpdateDriverLocationInput {
  accuracy: Float
  altitude: Float
  driverId: ID
  heading: Float
  latitude: Float
  longitude: Float
  speedKmh: Float
  timestamp: String
}

input UpdateDriverScheduleInput {
  driverId: ID
  endDate: String
  reason: DriverScheduleReason
  startDate: String
}

input UpdateExpenseInput {
  amount: Float
  currency: Currency
  description: String
  driverId: ID
  expenseDate: String
  fuelQuantity: Float
  odometerReading: Int
  receiptUrl: String
  status: ExpenseStatus
  tripId: ID
  type: ExpenseType
}

input UpdateGeofenceEventInput {
  eventType: GeofenceEventType
  geofenceId: ID
  timestamp: String
  vehicleId: ID
}

input UpdateGeofenceInput {
  latitude: Float
  longitude: Float
  name: String
}

input UpdateGpsPingInput {
  latitude: Float
  longitude: Float
  timestamp: String
  vehicleId: ID
}

input UpdateInboundShipmentInput {
  actualArrivalDate: String
  clientId: ID
  expectedArrivalDate: String
  status: InboundShipmentStatus
  warehouseId: ID
}

input UpdateInboundShipmentItemInput {
  discrepancyNotes: String
  expectedQuantity: Int
  inboundShipmentId: ID
  productId: ID
  receivedQuantity: Int
}

input UpdateInteractionInput {
  caseId: ID
  contactId: ID
  interactionDate: String
  notes: String
  outcome: String
  type: InteractionType
  userId: ID
}

input UpdateInventoryAdjustmentInput {
  notes: String
  productId: ID
  quantityChange: Int
  reason: InventoryAdjustmentReason
  userId: ID
  warehouseId: ID
}

input UpdateInventoryBatchInput {
  batchNumber: String
  expirationDate: String
  productId: ID
}

input UpdateInventoryStockInput {
  batchId: ID
  lastCountedAt: String
  lastMovementAt: String
  locationId: ID
  productId: ID
  quantity: Int
  reservedQuantity: Int
  status: InventoryStockStatus
}

input UpdateInvoiceInput {
  dueDate: String
  issueDate: String
  opportunityId: ID
  paidAt: String
  paymentMethod: PaymentMethod
  sentAt: String
  status: InvoiceStatus
  total: Float
}

input UpdateInvoiceItemInput {
  invoiceId: ID
  price: Float
  productId: ID
  quantity: Int
}

input UpdateInvoiceLineItemInput {
  description: String
  discountRate: Float
  invoiceId: ID
  quantity: Float
  sourceRecordId: ID
  sourceRecordType: String
  taxRate: Float
  unitPrice: Float
}

input UpdateLeadInput {
  campaignId: ID
  email: String
  leadScore: Int
  leadSource: LeadSource
  name: String
  ownerId: ID
  status: LeadStatus
}

input UpdateLocationInput {
  barcode: String
  hazmatApproved: Boolean
  isActive: Boolean
  isPickable: Boolean
  isReceivable: Boolean
  level: Int
  maxPallets: Int
  maxVolume: Float
  maxWeight: Float
  name: String
  parentLocationId: ID
  path: String
  temperatureControlled: Boolean
  type: LocationType
  warehouseId: ID
  xCoordinate: Float
  yCoordinate: Float
  zCoordinate: Float
}

input UpdateNotificationInput {
  isRead: Boolean
  link: String
  message: String
  userId: ID
}

input UpdateOpportunityInput {
  campaignId: ID
  companyId: ID
  contactId: ID
  dealValue: Float
  expectedCloseDate: String
  lostReason: String
  name: String
  ownerId: ID
  probability: Float
  source: OpportunitySource
  stage: OpportunityStage
}

input UpdateOpportunityProductInput {
  quantity: Int
}

input UpdateOutboundShipmentInput {
  carrier: String
  salesOrderId: ID
  status: OutboundShipmentStatus
  trackingNumber: String
  warehouseId: ID
}

input UpdateOutboundShipmentItemInput {
  batchId: ID
  outboundShipmentId: ID
  productId: ID
  quantityShipped: Int
  salesOrderItemId: ID
}

input UpdatePackageInput {
  carrier: String
  height: Float
  insuranceValue: Float
  isFragile: Boolean
  isHazmat: Boolean
  length: Float
  packageNumber: String
  packageType: String
  packedAt: String
  packedByUserId: ID
  requiresSignature: Boolean
  salesOrderId: ID
  serviceLevel: String
  shippedAt: String
  trackingNumber: String
  warehouseId: ID
  weight: Float
  width: Float
}

input UpdatePackageItemInput {
  batchId: ID
  expiryDate: String
  lotNumber: String
  packageId: ID
  productId: ID
  quantity: Int
  serialNumbers: [String]
  unitWeight: Float
}

input UpdatePartnerInvoiceInput {
  carrierId: ID
  invoiceDate: String
  invoiceNumber: String
  status: PartnerInvoiceStatus
  totalAmount: Float
}

input UpdatePartnerInvoiceItemInput {
  amount: Float
  partnerInvoiceId: ID
  shipmentLegId: ID
}

input UpdatePaymentInput {
  amount: Float
  currency: String
  exchangeRate: Float
  fees: Float
  gatewayReference: String
  invoiceId: ID
  notes: String
  paymentDate: String
  paymentMethod: PaymentMethod
  processedAt: String
  processedByUserId: ID
  status: PaymentStatus
  transactionId: String
}

input UpdatePickBatchInput {
  actualDuration: Int
  assignedUserId: ID
  batchNumber: String
  completedAt: String
  completedItems: Int
  estimatedDuration: Int
  priority: Int
  startedAt: String
  status: PickBatchStatus
  strategy: PickStrategy
  totalItems: Int
  warehouseId: ID
  waveId: String
  zoneRestrictions: [String]
}

input UpdatePickBatchItemInput {
  actualPickTime: Int
  estimatedPickTime: Int
  orderPriority: Int
  pickBatchId: ID
  salesOrderId: ID
}

input UpdateProductInput {
  description: String
  name: String
  price: Float
  sku: String
  type: ProductType
}

input UpdateProofOfDeliveryInput {
  filePath: String
  latitude: Float
  longitude: Float
  timestamp: String
  tripStopId: ID
  type: ProofType
}

input UpdatePutawayRuleInput {
  clientId: ID
  isActive: Boolean
  locationType: LocationType
  maxQuantity: Int
  minQuantity: Int
  preferredLocationId: ID
  priority: Int
  productId: ID
  requiresHazmatApproval: Boolean
  requiresTemperatureControl: Boolean
  volumeThreshold: Float
  warehouseId: ID
  weightThreshold: Float
}

input UpdateQuoteInput {
  clientId: ID
  createdByUserId: ID
  destinationDetails: String
  expiresAt: String
  height: Float
  length: Float
  notes: String
  originDetails: String
  quoteNumber: String
  quotedPrice: Float
  serviceLevel: String
  status: QuoteStatus
  weight: Float
  width: Float
}

input UpdateRateCardInput {
  createdByUserId: ID
  description: String
  isActive: Boolean
  name: String
  serviceType: ServiceType
  validFrom: String
  validTo: String
}

input UpdateRateRuleInput {
  condition: String
  isActive: Boolean
  maxValue: Float
  minValue: Float
  price: Float
  pricingModel: PricingModel
  priority: Int
  rateCardId: ID
  value: String
}

input UpdateReorderPointInput {
  productId: ID
  threshold: Int
  warehouseId: ID
}

input UpdateReturnInput {
  clientId: ID
  reason: String
  returnNumber: String
  salesOrderId: ID
  status: ReturnStatus
}

input UpdateReturnItemInput {
  condition: ReturnItemCondition
  productId: ID
  quantityExpected: Int
  quantityReceived: Int
  returnId: ID
}

input UpdateRouteInput {
  optimizedRouteData: String
  totalDistance: Float
  totalDuration: Float
  tripId: ID
}

input UpdateSalesOrderInput {
  clientId: ID
  crmOpportunityId: ID
  orderNumber: String
  shippingAddress: String
  status: SalesOrderStatus
}

input UpdateSalesOrderItemInput {
  productId: ID
  quantityOrdered: Int
  salesOrderId: ID
}

input UpdateShipmentLegEventInput {
  eventTimestamp: String
  location: String
  shipmentLegId: ID
  statusMessage: String
}

input UpdateShipmentLegInput {
  carrierId: ID
  endLocation: String
  internalTripId: ID
  legSequence: Int
  shipmentId: ID
  startLocation: String
  status: ShipmentLegStatus
}

input UpdateStockTransferInput {
  destinationWarehouseId: ID
  productId: ID
  quantity: Int
  sourceWarehouseId: ID
  status: StockTransferStatus
}

input UpdateSupplierInput {
  contactPerson: String
  email: String
  name: String
  phoneNumber: String
}

input UpdateSurchargeInput {
  amount: Float
  calculationMethod: SurchargeCalculationMethod
  description: String
  isActive: Boolean
  name: String
  type: String
  validFrom: String
  validTo: String
}

input UpdateTaskEventInput {
  deliveryTaskId: ID
  latitude: Float
  longitude: Float
  notes: String
  reason: String
  status: TaskEventStatus
  timestamp: String
}

input UpdateTaskInput {
  actualDuration: Int
  endTime: String
  estimatedDuration: Int
  instructions: String
  notes: String
  pickBatchId: ID
  priority: Int
  sourceEntityId: ID
  sourceEntityType: String
  startTime: String
  status: TaskStatus
  taskNumber: String
  type: TaskType
  userId: ID
  warehouseId: ID
}

input UpdateTaskItemInput {
  batchId: ID
  completedAt: String
  destinationLocationId: ID
  expiryDate: String
  lotNumber: String
  notes: String
  productId: ID
  quantityCompleted: Int
  quantityRequired: Int
  serialNumbers: [String]
  sourceLocationId: ID
  status: TaskItemStatus
  taskId: ID
}

input UpdateTripInput {
  driverId: ID
  endLocation: String
  endTime: String
  startLocation: String
  startTime: String
  status: TripStatus
  vehicleId: ID
}

input UpdateTripStopInput {
  actualArrivalTime: String
  actualDepartureTime: String
  address: String
  estimatedArrivalTime: String
  estimatedDepartureTime: String
  sequence: Int
  shipmentId: ID
  status: TripStopStatus
  tripId: ID
}

input UpdateVehicleInput {
  capacityVolume: Float
  capacityWeight: Float
  currentMileage: Int
  lastMaintenanceDate: String
  make: String
  model: String
  registrationNumber: String
  status: VehicleStatus
  vin: String
  year: Int
}

input UpdateVehicleMaintenanceInput {
  cost: Float
  notes: String
  serviceDate: String
  serviceType: VehicleServiceType
  vehicleId: ID
}

input UpdateWarehouseInput {
  address: String
  city: String
  contactEmail: String
  contactPerson: String
  contactPhone: String
  country: String
  isActive: Boolean
  name: String
  postalCode: String
  state: String
  timezone: String
}

input UpdateWmsProductInput {
  barcode: String
  clientId: ID
  costPrice: Float
  description: String
  height: Float
  length: Float
  name: String
  sku: String
  status: ProductStatus
  supplierId: ID
  weight: Float
  width: Float
}

type User {
  email: String!
  emailVerified: Boolean!
  image: String
  name: String!
}

type VehicleMaintenance {
  cost: Float
  createdAt: String
  id: ID!
  notes: String
  serviceDate: String!
  serviceType: VehicleServiceType
  updatedAt: String
  vehicle: Vehicles!
}

enum VehicleServiceType {
  BRAKE_SERVICE
  INSPECTION
  OIL_CHANGE
  REPAIR
  ROUTINE_MAINTENANCE
  TIRE_REPLACEMENT
}

enum VehicleStatus {
  AVAILABLE
  IN_MAINTENANCE
  ON_TRIP
  OUT_OF_SERVICE
}

type Vehicles {
  capacityVolume: Float
  capacityWeight: Float
  createdAt: String
  currentMileage: Int
  geofenceEvents: [GeofenceEvents!]
  gpsPings: [GpsPings!]
  id: ID!
  lastMaintenanceDate: String
  maintenances: [VehicleMaintenance!]
  make: String
  model: String
  registrationNumber: String!
  status: VehicleStatus
  trips: [Trips!]
  updatedAt: String
  vin: String
  year: Int
}

type Warehouses {
  address: String
  city: String
  contactEmail: String
  contactPerson: String
  contactPhone: String
  country: String
  createdAt: String
  destinationStockTransfers: [StockTransfers!]
  id: ID!
  inboundShipments: [InboundShipments!]
  isActive: Boolean
  locations: [Locations!]
  name: String!
  outboundShipments: [OutboundShipments!]
  packages: [Packages!]
  pickBatches: [PickBatches!]
  postalCode: String
  putawayRules: [PutawayRules!]
  sourceStockTransfers: [StockTransfers!]
  state: String
  tasks: [Tasks!]
  timezone: String
  updatedAt: String
}

type WmsMutation {
  createBinThreshold(value: CreateBinThresholdInput!): BinThresholds!
  createInboundShipment(value: CreateInboundShipmentInput!): InboundShipments!
  createInboundShipmentItem(value: CreateInboundShipmentItemInput!): InboundShipmentItems!
  createInventoryAdjustment(value: CreateInventoryAdjustmentInput!): InventoryAdjustments!
  createInventoryBatch(value: CreateInventoryBatchInput!): InventoryBatches!
  createInventoryStock(value: CreateInventoryStockInput!): InventoryStock!
  createLocation(value: CreateLocationInput!): Locations!
  createOutboundShipment(value: CreateOutboundShipmentInput!): OutboundShipments!
  createOutboundShipmentItem(value: CreateOutboundShipmentItemInput!): OutboundShipmentItems!
  createPackage(value: CreatePackageInput!): Packages!
  createPackageItem(value: CreatePackageItemInput!): PackageItems!
  createPickBatch(value: CreatePickBatchInput!): PickBatches!
  createPickBatchItem(value: CreatePickBatchItemInput!): PickBatchItems!
  createPutawayRule(value: CreatePutawayRuleInput!): PutawayRules!
  createReorderPoint(value: CreateReorderPointInput!): ReorderPoints!
  createReturn(value: CreateReturnInput!): Returns!
  createReturnItem(value: CreateReturnItemInput!): ReturnItems!
  createSalesOrder(value: CreateSalesOrderInput!): SalesOrders!
  createSalesOrderItem(value: CreateSalesOrderItemInput!): SalesOrderItems!
  createStockTransfer(value: CreateStockTransferInput!): StockTransfers!
  createSupplier(value: CreateSupplierInput!): Suppliers!
  createTask(value: CreateTaskInput!): Tasks!
  createTaskItem(value: CreateTaskItemInput!): TaskItems!
  createWarehouse(value: CreateWarehouseInput!): Warehouses!
  createWmsProduct(value: CreateWmsProductInput!): WmsProducts!
  removeBinThreshold(id: ID!): DeleteResult!
  removeInboundShipment(id: ID!): DeleteResult!
  removeInboundShipmentItem(id: ID!): DeleteResult!
  removeInventoryAdjustment(id: ID!): DeleteResult!
  removeInventoryBatch(id: ID!): DeleteResult!
  removeInventoryStock(id: ID!): DeleteResult!
  removeLocation(id: ID!): DeleteResult!
  removeOutboundShipment(id: ID!): DeleteResult!
  removeOutboundShipmentItem(id: ID!): DeleteResult!
  removePackage(id: ID!): DeleteResult!
  removePackageItem(id: ID!): DeleteResult!
  removePickBatch(id: ID!): DeleteResult!
  removePickBatchItem(id: ID!): DeleteResult!
  removePutawayRule(id: ID!): DeleteResult!
  removeReorderPoint(id: ID!): DeleteResult!
  removeReturn(id: ID!): DeleteResult!
  removeReturnItem(id: ID!): DeleteResult!
  removeSalesOrder(id: ID!): DeleteResult!
  removeSalesOrderItem(id: ID!): DeleteResult!
  removeStockTransfer(id: ID!): DeleteResult!
  removeSupplier(id: ID!): DeleteResult!
  removeTask(id: ID!): DeleteResult!
  removeTaskItem(id: ID!): DeleteResult!
  removeWarehouse(id: ID!): DeleteResult!
  removeWmsProduct(id: ID!): DeleteResult!
  updateBinThreshold(id: ID!, value: UpdateBinThresholdInput): BinThresholds!
  updateInboundShipment(id: ID!, value: UpdateInboundShipmentInput): InboundShipments!
  updateInboundShipmentItem(id: ID!, value: UpdateInboundShipmentItemInput): InboundShipmentItems!
  updateInventoryAdjustment(id: ID!, value: UpdateInventoryAdjustmentInput): InventoryAdjustments!
  updateInventoryBatch(id: ID!, value: UpdateInventoryBatchInput): InventoryBatches!
  updateInventoryStock(id: ID!, value: UpdateInventoryStockInput): InventoryStock!
  updateLocation(id: ID!, value: UpdateLocationInput): Locations!
  updateOutboundShipment(id: ID!, value: UpdateOutboundShipmentInput): OutboundShipments!
  updateOutboundShipmentItem(id: ID!, value: UpdateOutboundShipmentItemInput): OutboundShipmentItems!
  updatePackage(id: ID!, value: UpdatePackageInput): Packages!
  updatePackageItem(id: ID!, value: UpdatePackageItemInput): PackageItems!
  updatePickBatch(id: ID!, value: UpdatePickBatchInput): PickBatches!
  updatePickBatchItem(id: ID!, value: UpdatePickBatchItemInput): PickBatchItems!
  updatePutawayRule(id: ID!, value: UpdatePutawayRuleInput): PutawayRules!
  updateReorderPoint(id: ID!, value: UpdateReorderPointInput): ReorderPoints!
  updateReturn(id: ID!, value: UpdateReturnInput): Returns!
  updateReturnItem(id: ID!, value: UpdateReturnItemInput): ReturnItems!
  updateSalesOrder(id: ID!, value: UpdateSalesOrderInput): SalesOrders!
  updateSalesOrderItem(id: ID!, value: UpdateSalesOrderItemInput): SalesOrderItems!
  updateStockTransfer(id: ID!, value: UpdateStockTransferInput): StockTransfers!
  updateSupplier(id: ID!, value: UpdateSupplierInput): Suppliers!
  updateTask(id: ID!, value: UpdateTaskInput): Tasks!
  updateTaskItem(id: ID!, value: UpdateTaskItemInput): TaskItems!
  updateWarehouse(id: ID!, value: UpdateWarehouseInput): Warehouses!
  updateWmsProduct(id: ID!, value: UpdateWmsProductInput): WmsProducts!
}

type WmsProducts {
  adjustments: [InventoryAdjustments!]
  barcode: String
  batches: [InventoryBatches!]
  binThresholds: [BinThresholds!]
  client: Companies
  costPrice: Float
  createdAt: String
  description: String
  height: Float
  id: ID!
  inboundShipmentItems: [InboundShipmentItems!]
  inventoryStock: [InventoryStock!]
  length: Float
  name: String!
  outboundShipmentItems: [OutboundShipmentItems!]
  packageItems: [PackageItems!]
  putawayRules: [PutawayRules!]
  reorderPoints: [ReorderPoints!]
  returnItems: [ReturnItems!]
  salesOrderItems: [SalesOrderItems!]
  sku: String!
  status: ProductStatus
  stockTransfers: [StockTransfers!]
  supplier: Suppliers
  taskItems: [TaskItems!]
  updatedAt: String
  volume: Float
  weight: Float
  width: Float
}

type WmsQuery {
  binThreshold(id: ID!): BinThresholds!
  binThresholds(page: Int, perPage: Int): [BinThresholds!]!
  inboundShipment(id: ID!): InboundShipments!
  inboundShipments(page: Int, perPage: Int): [InboundShipments!]!
  inventoryAdjustment(id: ID!): InventoryAdjustments!
  inventoryAdjustments(page: Int, perPage: Int): [InventoryAdjustments!]!
  inventoryBatch(id: ID!): InventoryBatches!
  inventoryBatches(page: Int, perPage: Int): [InventoryBatches!]!
  inventoryStock(id: ID!): InventoryStock!
  inventoryStocks(page: Int, perPage: Int): [InventoryStock!]!
  location(id: ID!): Locations!
  locations(page: Int, perPage: Int): [Locations!]!
  outboundShipment(id: ID!): OutboundShipments!
  outboundShipments(page: Int, perPage: Int): [OutboundShipments!]!
  package(id: ID!): Packages!
  packages(page: Int, perPage: Int): [Packages!]!
  pickBatch(id: ID!): PickBatches!
  pickBatches(page: Int, perPage: Int): [PickBatches!]!
  putawayRule(id: ID!): PutawayRules!
  putawayRules(page: Int, perPage: Int): [PutawayRules!]!
  reorderPoint(id: ID!): ReorderPoints!
  reorderPoints(page: Int, perPage: Int): [ReorderPoints!]!
  return(id: ID!): Returns!
  returns(page: Int, perPage: Int): [Returns!]!
  salesOrder(id: ID!): SalesOrders!
  salesOrders(page: Int, perPage: Int): [SalesOrders!]!
  stockTransfer(id: ID!): StockTransfers!
  stockTransfers(page: Int, perPage: Int): [StockTransfers!]!
  supplier(id: ID!): Suppliers!
  suppliers(page: Int, perPage: Int): [Suppliers!]!
  task(id: ID!): Tasks!
  tasks(page: Int, perPage: Int): [Tasks!]!
  warehouse(id: ID!): Warehouses!
  warehouses(page: Int, perPage: Int): [Warehouses!]!
  wmsProduct(id: ID!): WmsProducts!
  wmsProducts(page: Int, perPage: Int): [WmsProducts!]!
}