type Attachments {
  createdAt: String
  fileName: String!
  filePath: String!
  id: ID!
  mimeType: String
  recordId: ID
  recordType: RecordType
  updatedAt: String
}

type BinThresholds {
  alertThreshold: Int
  createdAt: String
  id: ID!
  isActive: Boolean
  location: Locations!
  maxQuantity: Int!
  minQuantity: Int!
  product: WmsProducts!
  reorderQuantity: Int
  updatedAt: String
}

type Campaigns {
  budget: Float
  createdAt: String
  endDate: String
  id: ID!
  name: String!
  startDate: String
  updatedAt: String
}

enum CarrierRateUnit {
  FLAT_RATE
  PER_CONTAINER
  PER_KG
  PER_KM
  PER_MILE
}

type CarrierRates {
  carrier: Carriers!
  createdAt: String
  destination: String
  id: ID!
  origin: String
  rate: Float!
  serviceType: String
  unit: CarrierRateUnit
  updatedAt: String
}

type Carriers {
  contactDetails: String
  createdAt: String
  id: ID!
  name: String!
  partnerInvoices: [PartnerInvoices!]
  rates: [CarrierRates!]
  servicesOffered: String
  shipmentLegs: [ShipmentLegs!]
  updatedAt: String
}

enum CasePriority {
  CRITICAL
  HIGH
  LOW
  MEDIUM
}

enum CaseStatus {
  CANCELLED
  CLOSED
  ESCALATED
  IN_PROGRESS
  NEW
  RESOLVED
  WAITING_FOR_CUSTOMER
  WAITING_FOR_INTERNAL
}

enum CaseType {
  BUG_REPORT
  COMPLAINT
  FEATURE_REQUEST
  PROBLEM
  QUESTION
  TECHNICAL_SUPPORT
}

type Cases {
  caseNumber: String!
  contact: Contacts
  createdAt: String
  description: String
  id: ID!
  owner: User!
  priority: CasePriority
  status: CaseStatus
  type: CaseType
  updatedAt: String
}

type Companies {
  annualRevenue: Float
  city: String
  country: String
  createdAt: String
  id: ID!
  inboundShipments: [InboundShipments!]
  industry: String
  name: String!
  owner: User
  phoneNumber: String
  postalCode: String
  putawayRules: [PutawayRules!]
  returns: [Returns!]
  salesOrders: [SalesOrders!]
  state: String
  street: String
  updatedAt: String
  website: String
}

type Contacts {
  company: Companies
  createdAt: String
  email: String!
  id: ID!
  jobTitle: String
  name: String!
  owner: User!
  phoneNumber: String
  updatedAt: String
}

input CreateAttachmentInput {
  fileName: String!
  filePath: String!
  mimeType: String
  recordId: ID
  recordType: RecordType
}

input CreateBinThresholdInput {
  alertThreshold: Int
  isActive: Boolean
  locationId: ID!
  maxQuantity: Int!
  minQuantity: Int!
  productId: ID!
  reorderQuantity: Int
}

input CreateCampaignInput {
  budget: Float
  endDate: String
  name: String!
  startDate: String
}

input CreateCarrierInput {
  contactDetails: String
  name: String!
  servicesOffered: String
}

input CreateCarrierRateInput {
  carrierId: ID!
  destination: String
  origin: String
  rate: Float!
  serviceType: String
  unit: CarrierRateUnit
}

input CreateCaseInput {
  caseNumber: String!
  contactId: ID
  description: String
  ownerId: ID!
  priority: CasePriority
  status: CaseStatus
  type: CaseType
}

input CreateCompanyInput {
  annualRevenue: Float
  city: String
  country: String
  industry: String
  name: String!
  ownerId: ID
  phoneNumber: String
  postalCode: String
  state: String
  street: String
  website: String
}

input CreateContactInput {
  companyId: ID
  email: String!
  jobTitle: String
  name: String!
  ownerId: ID!
  phoneNumber: String
}

input CreateDriverInput {
  licenseExpiryDate: String
  licenseNumber: String!
  status: DriverStatus
  userId: ID!
}

input CreateDriverScheduleInput {
  driverId: ID!
  endDate: String!
  reason: DriverScheduleReason
  startDate: String!
}

input CreateExpenseInput {
  amount: Float!
  currency: Currency
  driverId: ID
  fuelQuantity: Float
  odometerReading: Int
  receiptUrl: String
  status: ExpenseStatus
  tripId: ID
  type: ExpenseType
}

input CreateGeofenceEventInput {
  eventType: GeofenceEventType!
  geofenceId: ID!
  timestamp: String!
  vehicleId: ID!
}

input CreateGeofenceInput {
  coordinates: String
  name: String!
}

input CreateGpsPingInput {
  latitude: Float!
  longitude: Float!
  timestamp: String!
  vehicleId: ID!
}

input CreateInboundShipmentInput {
  actualArrivalDate: String
  clientId: ID
  expectedArrivalDate: String
  status: InboundShipmentStatus
  warehouseId: ID!
}

input CreateInboundShipmentItemInput {
  discrepancyNotes: String
  expectedQuantity: Int!
  inboundShipmentId: ID!
  productId: ID!
  receivedQuantity: Int
}

input CreateInteractionInput {
  caseId: ID
  contactId: ID!
  interactionDate: String
  notes: String
  outcome: String
  type: InteractionType
  userId: ID!
}

input CreateInventoryAdjustmentInput {
  notes: String
  productId: ID!
  quantityChange: Int!
  reason: InventoryAdjustmentReason
  userId: ID!
  warehouseId: ID!
}

input CreateInventoryBatchInput {
  batchNumber: String!
  expirationDate: String
  productId: ID!
}

input CreateInventoryStockInput {
  batchId: ID
  lastCountedAt: String
  lastMovementAt: String
  locationId: ID!
  productId: ID!
  quantity: Int!
  reservedQuantity: Int!
  status: InventoryStockStatus
}

input CreateInvoiceInput {
  dueDate: String
  issueDate: String
  opportunityId: ID
  paidAt: String
  paymentMethod: PaymentMethod
  sentAt: String
  status: InvoiceStatus
  total: Float
}

input CreateInvoiceItemInput {
  invoiceId: ID!
  price: Float!
  productId: ID!
  quantity: Int!
}

input CreateLeadInput {
  campaignId: ID
  email: String!
  leadScore: Int
  leadSource: LeadSource
  name: String!
  ownerId: ID!
  status: LeadStatus
}

input CreateLocationInput {
  barcode: String
  hazmatApproved: Boolean
  isActive: Boolean
  isPickable: Boolean
  isReceivable: Boolean
  level: Int
  maxPallets: Int
  maxVolume: Float
  maxWeight: Float
  name: String!
  parentLocationId: ID
  path: String
  temperatureControlled: Boolean
  type: LocationType!
  warehouseId: ID!
  xCoordinate: Float
  yCoordinate: Float
  zCoordinate: Float
}

input CreateNotificationInput {
  isRead: Boolean
  link: String
  message: String!
  userId: ID!
}

input CreateOpportunityInput {
  campaignId: ID
  companyId: ID
  contactId: ID
  dealValue: Float
  expectedCloseDate: String
  lostReason: String
  name: String!
  ownerId: ID!
  probability: Float
  source: OpportunitySource
  stage: OpportunityStage
}

input CreateOpportunityProductInput {
  opportunityId: ID!
  productId: ID!
  quantity: Int!
}

input CreateOutboundShipmentInput {
  carrier: String
  salesOrderId: ID!
  status: OutboundShipmentStatus
  trackingNumber: String
  warehouseId: ID!
}

input CreateOutboundShipmentItemInput {
  batchId: ID
  outboundShipmentId: ID!
  productId: ID!
  quantityShipped: Int!
  salesOrderItemId: ID!
}

input CreatePackageInput {
  carrier: String
  height: Float
  insuranceValue: Float
  isFragile: Boolean
  isHazmat: Boolean
  length: Float
  packageNumber: String!
  packageType: String
  packedAt: String
  packedByUserId: ID
  requiresSignature: Boolean
  salesOrderId: ID!
  serviceLevel: String
  shippedAt: String
  trackingNumber: String
  warehouseId: ID!
  weight: Float
  width: Float
}

input CreatePackageItemInput {
  batchId: ID
  expiryDate: String
  lotNumber: String
  packageId: ID!
  productId: ID!
  quantity: Int!
  serialNumbers: [String]
  unitWeight: Float
}

input CreatePartnerInvoiceInput {
  carrierId: ID!
  invoiceDate: String!
  invoiceNumber: String!
  status: PartnerInvoiceStatus
  totalAmount: Float!
}

input CreatePartnerInvoiceItemInput {
  amount: Float!
  partnerInvoiceId: ID!
  shipmentLegId: ID!
}

input CreatePickBatchInput {
  actualDuration: Int
  assignedUserId: ID
  batchNumber: String!
  completedAt: String
  completedItems: Int
  estimatedDuration: Int
  priority: Int
  startedAt: String
  status: PickBatchStatus
  strategy: PickStrategy!
  totalItems: Int
  warehouseId: ID!
  waveId: String
  zoneRestrictions: [String]
}

input CreatePickBatchItemInput {
  actualPickTime: Int
  estimatedPickTime: Int
  orderPriority: Int
  pickBatchId: ID!
  salesOrderId: ID!
}

input CreateProductInput {
  description: String
  name: String!
  price: Float!
  sku: String
  type: ProductType
}

input CreateProofOfDeliveryInput {
  filePath: String
  latitude: Float
  longitude: Float
  timestamp: String!
  tripStopId: ID!
  type: ProofType
}

input CreatePutawayRuleInput {
  clientId: ID
  isActive: Boolean
  locationType: LocationType
  maxQuantity: Int
  minQuantity: Int
  preferredLocationId: ID
  priority: Int!
  productId: ID!
  requiresHazmatApproval: Boolean
  requiresTemperatureControl: Boolean
  volumeThreshold: Float
  warehouseId: ID!
  weightThreshold: Float
}

input CreateReorderPointInput {
  productId: ID!
  threshold: Int!
  warehouseId: ID!
}

input CreateReturnInput {
  clientId: ID!
  reason: String
  returnNumber: String!
  salesOrderId: ID
  status: ReturnStatus
}

input CreateReturnItemInput {
  condition: ReturnItemCondition
  productId: ID!
  quantityExpected: Int!
  quantityReceived: Int
  returnId: ID!
}

input CreateRouteInput {
  optimizedRouteData: String
  totalDistance: Float
  totalDuration: Float
  tripId: ID!
}

input CreateSalesOrderInput {
  clientId: ID!
  crmOpportunityId: ID
  orderNumber: String!
  shippingAddress: String
  status: SalesOrderStatus
}

input CreateSalesOrderItemInput {
  productId: ID!
  quantityOrdered: Int!
  salesOrderId: ID!
}

input CreateShipmentLegEventInput {
  eventTimestamp: String!
  location: String
  shipmentLegId: ID!
  statusMessage: String
}

input CreateShipmentLegInput {
  carrierId: ID
  endLocation: String
  internalTripId: ID
  legSequence: Int!
  shipment: OutboundShipments
  startLocation: String
  status: ShipmentLegStatus
}

input CreateStockTransferInput {
  destinationWarehouseId: ID!
  productId: ID!
  quantity: Int!
  sourceWarehouseId: ID!
  status: StockTransferStatus
}

input CreateSupplierInput {
  contactPerson: String
  email: String
  name: String!
  phoneNumber: String
}

input CreateTaskInput {
  actualDuration: Int
  endTime: String
  estimatedDuration: Int
  instructions: String
  notes: String
  pickBatchId: ID
  priority: Int
  sourceEntityId: ID
  sourceEntityType: String
  startTime: String
  status: TaskStatus
  taskNumber: String!
  type: TaskType!
  userId: ID
  warehouseId: ID!
}

input CreateTaskItemInput {
  batchId: ID
  completedAt: String
  destinationLocationId: ID
  expiryDate: String
  lotNumber: String
  notes: String
  productId: ID!
  quantityCompleted: Int!
  quantityRequired: Int!
  serialNumbers: [String]
  sourceLocationId: ID
  status: TaskItemStatus
  taskId: ID!
}

input CreateTripInput {
  driverId: ID
  status: TripStatus
  vehicleId: ID
}

input CreateTripStopInput {
  actualArrivalTime: String
  actualDepartureTime: String
  address: String
  estimatedArrivalTime: String
  estimatedDepartureTime: String
  sequence: Int!
  shipment: OutboundShipments
  status: TripStopStatus
  tripId: ID!
}

input CreateVehicleInput {
  capacityVolume: Float
  capacityWeight: Float
  model: String
  registrationNumber: String!
  status: VehicleStatus
}

input CreateVehicleMaintenanceInput {
  cost: Float
  notes: String
  serviceDate: String!
  serviceType: VehicleServiceType
  vehicleId: ID!
}

input CreateWarehouseInput {
  address: String
  city: String
  contactEmail: String
  contactPerson: String
  contactPhone: String
  country: String
  isActive: Boolean
  name: String!
  postalCode: String
  state: String
  timezone: String
}

input CreateWmsProductInput {
  barcode: String
  clientId: ID
  costPrice: Float
  description: String
  height: Float
  length: Float
  name: String!
  sku: String!
  status: ProductStatus
  supplierId: ID
  weight: Float
  width: Float
}

type CrmMutation {
  createAttachment(value: CreateAttachmentInput!): Attachments!
  createCampaign(value: CreateCampaignInput!): Campaigns!
  createCase(value: CreateCaseInput!): Cases!
  createCompany(value: CreateCompanyInput!): Companies!
  createContact(value: CreateContactInput!): Contacts!
  createInteraction(value: CreateInteractionInput!): Interactions!
  createInvoice(value: CreateInvoiceInput!): Invoices!
  createInvoiceItem(value: CreateInvoiceItemInput!): InvoiceItems!
  createLead(value: CreateLeadInput!): Leads!
  createNotification(value: CreateNotificationInput!): Notifications!
  createOpportunity(value: CreateOpportunityInput!): Opportunities!
  createOpportunityProduct(value: CreateOpportunityProductInput!): OpportunityProducts!
  createProduct(value: CreateProductInput!): Products!
  removeAttachment(id: ID!): DeleteResult!
  removeCampaign(id: ID!): DeleteResult!
  removeCase(id: ID!): DeleteResult!
  removeCompany(id: ID!): DeleteResult!
  removeContact(id: ID!): DeleteResult!
  removeInteraction(id: ID!): DeleteResult!
  removeInvoice(id: ID!): DeleteResult!
  removeInvoiceItem(id: ID!): DeleteResult!
  removeLead(id: ID!): DeleteResult!
  removeNotification(id: ID!): DeleteResult!
  removeOpportunity(id: ID!): DeleteResult!
  removeOpportunityProduct(opportunityId: ID!, productId: ID!): DeleteResult!
  removeProduct(id: ID!): DeleteResult!
  updateAttachment(id: ID!, value: UpdateAttachmentInput): Attachments!
  updateCampaign(id: ID!, value: UpdateCampaignInput): Campaigns!
  updateCase(id: ID!, value: UpdateCaseInput): Cases!
  updateCompany(id: ID!, value: UpdateCompanyInput): Companies!
  updateContact(id: ID!, value: UpdateContactInput): Contacts!
  updateInteraction(id: ID!, value: UpdateInteractionInput): Interactions!
  updateInvoice(id: ID!, value: UpdateInvoiceInput): Invoices!
  updateInvoiceItem(id: ID!, value: UpdateInvoiceItemInput): InvoiceItems!
  updateLead(id: ID!, value: UpdateLeadInput): Leads!
  updateNotification(id: ID!, value: UpdateNotificationInput): Notifications!
  updateOpportunity(id: ID!, value: UpdateOpportunityInput): Opportunities!
  updateOpportunityProduct(opportunityId: ID!, productId: ID!, value: UpdateOpportunityProductInput): OpportunityProducts!
  updateProduct(id: ID!, value: UpdateProductInput): Products!
}

type CrmQuery {
  attachment(id: ID!): Attachments!
  attachments(page: Int, perPage: Int): [Attachments!]!
  campaign(id: ID!): Campaigns!
  campaigns(page: Int, perPage: Int): [Campaigns!]!
  case(id: ID!): Cases!
  cases(page: Int, perPage: Int): [Cases!]!
  companies(page: Int, perPage: Int): [Companies!]!
  company(id: ID!): Companies!
  contact(id: ID!): Contacts!
  contacts(page: Int, perPage: Int): [Contacts!]!
  interaction(id: ID!): Interactions!
  interactions(page: Int, perPage: Int): [Interactions!]!
  invoice(id: ID!): Invoices!
  invoiceItem(id: ID!): InvoiceItems!
  invoiceItems(page: Int, perPage: Int): [InvoiceItems!]!
  invoices(page: Int, perPage: Int): [Invoices!]!
  lead(id: ID!): Leads!
  leads(page: Int, perPage: Int): [Leads!]!
  notification(id: ID!): Notifications!
  notifications(page: Int, perPage: Int): [Notifications!]!
  opportunities(page: Int, perPage: Int): [Opportunities!]!
  opportunity(id: ID!): Opportunities!
  opportunityProduct(opportunityId: ID!, productId: ID!): OpportunityProducts!
  opportunityProducts(page: Int, perPage: Int): [OpportunityProducts!]!
  product(id: ID!): Products!
  products(page: Int, perPage: Int): [Products!]!
}

enum Currency {
  AUD
  CAD
  EUR
  GBP
  JPY
  PHP
  USD
}

type DeleteResult {
  numDeletedRows: Int!
  success: Boolean!
}

enum DriverScheduleReason {
  PERSONAL_LEAVE
  SICK_LEAVE
  TRAINING
  VACATION
}

type DriverSchedules {
  createdAt: String
  driver: Drivers!
  endDate: String!
  id: ID!
  reason: DriverScheduleReason
  startDate: String!
  updatedAt: String
}

enum DriverStatus {
  ACTIVE
  INACTIVE
  ON_LEAVE
}

type Drivers {
  createdAt: String
  expenses: [Expenses!]
  id: ID!
  licenseExpiryDate: String
  licenseNumber: String!
  schedules: [DriverSchedules!]
  status: DriverStatus
  trips: [Trips!]
  updatedAt: String
  user: User!
}

enum ExpenseStatus {
  APPROVED
  PENDING
  REIMBURSED
  REJECTED
}

enum ExpenseType {
  ACCOMMODATION
  FUEL
  MAINTENANCE
  MEALS
  PARKING
  TOLLS
}

type Expenses {
  amount: Float!
  createdAt: String
  currency: Currency
  driver: Drivers
  fuelQuantity: Float
  id: ID!
  odometerReading: Int
  receiptUrl: String
  status: ExpenseStatus
  trip: Trips
  type: ExpenseType
  updatedAt: String
}

enum GeofenceEventType {
  ENTER
  EXIT
}

type GeofenceEvents {
  eventType: GeofenceEventType!
  geofence: Geofences!
  id: ID!
  timestamp: String!
  vehicle: Vehicles!
}

type Geofences {
  coordinates: String
  createdAt: String
  events: [GeofenceEvents!]
  id: ID!
  name: String!
  updatedAt: String
}

type GpsPings {
  id: ID!
  latitude: Float!
  longitude: Float!
  timestamp: String!
  vehicle: Vehicles!
}

type InboundShipmentItems {
  createdAt: String
  discrepancyNotes: String
  discrepancyQuantity: Int
  expectedQuantity: Int!
  id: ID!
  inboundShipment: InboundShipments!
  product: WmsProducts!
  receivedQuantity: Int
  updatedAt: String
}

enum InboundShipmentStatus {
  ARRIVED
  CANCELLED
  COMPLETED
  PENDING
  PROCESSING
}

type InboundShipments {
  actualArrivalDate: String
  client: Companies
  createdAt: String
  expectedArrivalDate: String
  id: ID!
  items: [InboundShipmentItems!]
  status: InboundShipmentStatus
  updatedAt: String
  warehouseId: ID!
}

enum InteractionType {
  CALL
  EMAIL
  MEETING
  TEXT
}

type Interactions {
  case: Cases
  contact: Contacts!
  createdAt: String
  id: ID!
  interactionDate: String
  notes: String
  outcome: String
  type: InteractionType
  updatedAt: String
  user: User!
}

enum InventoryAdjustmentReason {
  CYCLE_COUNT
  DAMAGED_GOODS
  EXPIRED
  MANUAL_CORRECTION
  RETURN_TO_VENDOR
  THEFT
}

type InventoryAdjustments {
  createdAt: String
  id: ID!
  notes: String
  product: WmsProducts!
  quantityChange: Int!
  reason: InventoryAdjustmentReason
  updatedAt: String
  user: User!
  warehouseId: ID!
}

type InventoryBatches {
  batchNumber: String!
  createdAt: String
  expirationDate: String
  id: ID!
  inventoryStock: [InventoryStock!]
  outboundShipmentItems: [OutboundShipmentItems!]
  packageItems: [PackageItems!]
  product: WmsProducts!
  taskItems: [TaskItems!]
  updatedAt: String
}

type InventoryStock {
  availableQuantity: Int
  batch: InventoryBatches
  createdAt: String
  id: ID!
  lastCountedAt: String
  lastMovementAt: String
  location: Locations!
  product: WmsProducts!
  quantity: Int!
  reservedQuantity: Int!
  status: InventoryStockStatus
  updatedAt: String
}

enum InventoryStockStatus {
  ALLOCATED
  AVAILABLE
  DAMAGED
  EXPIRED
  HOLD
  QUARANTINE
  SHIPPED
}

type InvoiceItems {
  createdAt: String
  id: ID!
  invoice: Invoices!
  price: Float!
  product: Products!
  quantity: Int!
  updatedAt: String
}

enum InvoiceStatus {
  CANCELLED
  DRAFT
  OVERDUE
  PAID
  SENT
}

type Invoices {
  createdAt: String
  dueDate: String
  id: ID!
  issueDate: String
  items: [InvoiceItems!]
  opportunity: Opportunities
  paidAt: String
  paymentMethod: PaymentMethod
  sentAt: String
  status: InvoiceStatus
  total: Float
  updatedAt: String
}

enum LeadSource {
  ADVERTISEMENT
  COLD_CALL
  EMAIL_CAMPAIGN
  EVENT
  OTHER
  PARTNER
  REFERRAL
  SOCIAL_MEDIA
  WEBSITE
}

enum LeadStatus {
  CONTACTED
  CONVERTED
  NEW
  QUALIFIED
  UNQUALIFIED
}

type Leads {
  campaign: Campaigns
  convertedAt: String
  convertedCompany: Companies
  convertedContact: Contacts
  convertedOpportunity: Opportunities
  createdAt: String
  email: String!
  id: ID!
  leadScore: Int
  leadSource: LeadSource
  name: String!
  owner: User!
  status: LeadStatus
  updatedAt: String
}

enum LocationType {
  BULK_STORAGE
  CROSS_DOCK_AREA
  DAMAGED_GOODS
  PACKING_STATION
  PICK_BIN
  QUALITY_CONTROL
  RECEIVING_DOCK
  RESERVE_STORAGE
  RETURNS_AREA
  STAGING_AREA
}

type Locations {
  barcode: String
  binThresholds: [BinThresholds!]
  createdAt: String
  destinationTaskItems: [TaskItems!]
  hazmatApproved: Boolean
  id: ID!
  inventoryStock: [InventoryStock!]
  isActive: Boolean
  isPickable: Boolean
  isReceivable: Boolean
  level: Int
  maxPallets: Int
  maxVolume: Float
  maxWeight: Float
  name: String!
  parentLocation: Locations
  path: String
  putawayRules: [PutawayRules!]
  sourceTaskItems: [TaskItems!]
  temperatureControlled: Boolean
  type: LocationType!
  updatedAt: String
  warehouse: Warehouses!
  xCoordinate: Float
  yCoordinate: Float
  zCoordinate: Float
}

type Mutation {
  crm: CrmMutation
  tms: TmsMutation
  wms: WmsMutation
}

type Notifications {
  createdAt: String
  id: ID!
  isRead: Boolean
  link: String
  message: String!
  updatedAt: String
  user: User!
}

type Opportunities {
  campaign: Campaigns
  company: Companies
  contact: Contacts
  createdAt: String
  dealValue: Float
  expectedCloseDate: String
  id: ID!
  lostReason: String
  name: String!
  owner: User!
  probability: Float
  products: [OpportunityProducts!]
  salesOrders: [SalesOrders!]
  source: OpportunitySource
  stage: OpportunityStage
  updatedAt: String
}

type OpportunityProducts {
  opportunity: Opportunities!
  product: Products!
  quantity: Int!
}

enum OpportunitySource {
  ADVERTISEMENT
  COLD_CALL
  EMAIL_CAMPAIGN
  EVENT
  EXISTING_CUSTOMER
  OTHER
  PARTNER
  REFERRAL
  SOCIAL_MEDIA
  WEBSITE
}

enum OpportunityStage {
  CLOSED_LOST
  CLOSED_WON
  DEMO
  NEED_ANALYSIS
  NEGOTIATION
  PROPOSAL
  PROSPECTING
  QUALIFICATION
}

type OutboundShipmentItems {
  batch: InventoryBatches
  createdAt: String
  id: ID!
  outboundShipment: OutboundShipments!
  product: WmsProducts!
  quantityShipped: Int!
  salesOrderItem: SalesOrderItems!
  updatedAt: String
}

enum OutboundShipmentStatus {
  CANCELLED
  DELIVERED
  PACKED
  PICKING
  SHIPPED
}

type OutboundShipments {
  carrier: String
  createdAt: String
  id: ID!
  items: [OutboundShipmentItems!]
  salesOrder: SalesOrders!
  status: OutboundShipmentStatus
  trackingNumber: String
  updatedAt: String
  warehouseId: ID!
}

type PackageItems {
  batch: InventoryBatches
  createdAt: String
  expiryDate: String
  id: ID!
  lotNumber: String
  package: Packages!
  product: WmsProducts!
  quantity: Int!
  serialNumbers: [String]
  totalWeight: Float
  unitWeight: Float
  updatedAt: String
}

type Packages {
  carrier: String
  createdAt: String
  height: Float
  id: ID!
  insuranceValue: Float
  isFragile: Boolean
  isHazmat: Boolean
  items: [PackageItems!]
  length: Float
  packageNumber: String!
  packageType: String
  packedAt: String
  packedByUser: User
  requiresSignature: Boolean
  salesOrder: SalesOrders!
  serviceLevel: String
  shippedAt: String
  trackingNumber: String
  updatedAt: String
  volume: Float
  warehouse: Warehouses!
  weight: Float
  width: Float
}

type PartnerInvoiceItems {
  amount: Float!
  id: ID!
  partnerInvoice: PartnerInvoices!
  shipmentLeg: ShipmentLegs!
}

enum PartnerInvoiceStatus {
  CANCELLED
  DISPUTED
  OVERDUE
  PAID
  PENDING
}

type PartnerInvoices {
  carrier: Carriers!
  createdAt: String
  id: ID!
  invoiceDate: String!
  invoiceNumber: String!
  items: [PartnerInvoiceItems!]
  status: PartnerInvoiceStatus
  totalAmount: Float!
  updatedAt: String
}

enum PaymentMethod {
  BANK_TRANSFER
  CASH
  CHECK
  CREDIT_CARD
  PAYPAL
  STRIPE
  WIRE_TRANSFER
}

type PickBatchItems {
  actualPickTime: Int
  createdAt: String
  estimatedPickTime: Int
  id: ID!
  orderPriority: Int
  pickBatch: PickBatches!
  salesOrder: SalesOrders!
  updatedAt: String
}

enum PickBatchStatus {
  CANCELLED
  COMPLETED
  IN_PROGRESS
  OPEN
}

type PickBatches {
  actualDuration: Int
  assignedUser: User
  batchNumber: String!
  completedAt: String
  completedItems: Int
  createdAt: String
  estimatedDuration: Int
  id: ID!
  items: [PickBatchItems!]
  priority: Int
  startedAt: String
  status: PickBatchStatus
  strategy: PickStrategy!
  tasks: [Tasks!]
  totalItems: Int
  updatedAt: String
  warehouse: Warehouses!
  waveId: String
  zoneRestrictions: [String]
}

enum PickStrategy {
  BATCH_PICKING
  CLUSTER_PICKING
  SINGLE_ORDER_PICKING
  WAVE_PICKING
  ZONE_PICKING
}

enum ProductStatus {
  ACTIVE
  DISCONTINUED
  INACTIVE
  OBSOLETE
}

enum ProductType {
  DIGITAL
  GOOD
  SERVICE
  SUBSCRIPTION
}

type Products {
  createdAt: String
  description: String
  id: ID!
  name: String!
  price: Float!
  sku: String
  type: ProductType
  updatedAt: String
}

type ProofOfDeliveries {
  createdAt: String
  filePath: String
  id: ID!
  latitude: Float
  longitude: Float
  timestamp: String!
  tripStop: TripStops!
  type: ProofType
  updatedAt: String
}

enum ProofType {
  BARCODE_SCAN
  PHOTO
  PIN_VERIFICATION
  SIGNATURE
}

type PutawayRules {
  client: Companies
  createdAt: String
  id: ID!
  isActive: Boolean
  locationType: LocationType
  maxQuantity: Int
  minQuantity: Int
  preferredLocation: Locations
  priority: Int!
  product: WmsProducts!
  requiresHazmatApproval: Boolean
  requiresTemperatureControl: Boolean
  updatedAt: String
  volumeThreshold: Float
  warehouse: Warehouses!
  weightThreshold: Float
}

type Query {
  crm: CrmQuery
  tms: TmsQuery
  wms: WmsQuery
}

enum RecordType {
  CAMPAIGNS
  CASES
  COMPANIES
  CONTACTS
  INTERACTIONS
  INVOICES
  LEADS
  OPPORTUNITIES
  PRODUCTS
}

type ReorderPoints {
  createdAt: String
  id: ID!
  product: WmsProducts!
  threshold: Int!
  updatedAt: String
  warehouseId: ID!
}

enum ReturnItemCondition {
  DAMAGED
  DEFECTIVE
  EXPIRED
  SELLABLE
  UNSELLABLE
}

type ReturnItems {
  condition: ReturnItemCondition
  createdAt: String
  id: ID!
  product: WmsProducts!
  quantityExpected: Int!
  quantityReceived: Int
  quantityVariance: Int
  return: Returns!
  updatedAt: String
}

enum ReturnStatus {
  APPROVED
  PROCESSED
  RECEIVED
  REJECTED
  REQUESTED
}

type Returns {
  client: Companies!
  createdAt: String
  id: ID!
  items: [ReturnItems!]
  reason: String
  returnNumber: String!
  salesOrder: SalesOrders
  status: ReturnStatus
  updatedAt: String
}

type Routes {
  createdAt: String
  id: ID!
  optimizedRouteData: String
  totalDistance: Float
  totalDuration: Float
  trip: Trips!
  updatedAt: String
}

type SalesOrderItems {
  createdAt: String
  id: ID!
  outboundShipmentItems: [OutboundShipmentItems!]
  product: WmsProducts!
  quantityOrdered: Int!
  salesOrder: SalesOrders!
  updatedAt: String
}

enum SalesOrderStatus {
  CANCELLED
  COMPLETED
  PENDING
  PROCESSING
  SHIPPED
}

type SalesOrders {
  client: Companies!
  createdAt: String
  crmOpportunity: Opportunities
  id: ID!
  items: [SalesOrderItems!]
  orderNumber: String!
  outboundShipments: [OutboundShipments!]
  packages: [Packages!]
  pickBatchItems: [PickBatchItems!]
  returns: [Returns!]
  shippingAddress: String
  status: SalesOrderStatus
  updatedAt: String
}

type ShipmentLegEvents {
  eventTimestamp: String!
  id: ID!
  location: String
  shipmentLeg: ShipmentLegs!
  statusMessage: String
}

enum ShipmentLegStatus {
  CANCELLED
  DELIVERED
  FAILED
  IN_TRANSIT
  PENDING
}

type ShipmentLegs {
  carrier: Carriers
  createdAt: String
  endLocation: String
  events: [ShipmentLegEvents!]
  id: ID!
  internalTrip: Trips
  legSequence: Int!
  partnerInvoiceItems: [PartnerInvoiceItems!]
  shipment: OutboundShipments
  startLocation: String
  status: ShipmentLegStatus
  updatedAt: String
}

enum StockTransferStatus {
  CANCELLED
  IN_TRANSIT
  PENDING
  RECEIVED
}

type StockTransfers {
  createdAt: String
  destinationWarehouseId: ID!
  id: ID!
  product: WmsProducts!
  quantity: Int!
  sourceWarehouseId: ID!
  status: StockTransferStatus
  updatedAt: String
}

type Suppliers {
  contactPerson: String
  createdAt: String
  email: String
  id: ID!
  name: String!
  phoneNumber: String
  products: [WmsProducts!]
  updatedAt: String
}

enum TaskItemStatus {
  COMPLETED
  DAMAGED
  IN_PROGRESS
  NOT_FOUND
  PENDING
  SHORT_PICKED
}

type TaskItems {
  batch: InventoryBatches
  completedAt: String
  createdAt: String
  destinationLocation: Locations
  expiryDate: String
  id: ID!
  lotNumber: String
  notes: String
  product: WmsProducts!
  quantityCompleted: Int!
  quantityRemaining: Int
  quantityRequired: Int!
  serialNumbers: [String]
  sourceLocation: Locations
  status: TaskItemStatus
  task: Tasks!
  updatedAt: String
}

enum TaskStatus {
  ASSIGNED
  CANCELLED
  COMPLETED
  ERROR
  IN_PROGRESS
  PENDING
}

enum TaskType {
  CROSS_DOCK
  CYCLE_COUNT
  DAMAGE_INSPECTION
  PACK
  PICK
  PUTAWAY
  QUALITY_CHECK
  REPLENISHMENT
  RETURNS_PROCESSING
}

type Tasks {
  actualDuration: Int
  createdAt: String
  durationSeconds: Int
  endTime: String
  estimatedDuration: Int
  id: ID!
  instructions: String
  items: [TaskItems!]
  notes: String
  pickBatch: PickBatches
  priority: Int
  sourceEntityId: ID
  sourceEntityType: String
  startTime: String
  status: TaskStatus
  taskNumber: String!
  type: TaskType!
  updatedAt: String
  user: User
  warehouse: Warehouses!
}

type TmsMutation {
  createCarrier(value: CreateCarrierInput!): Carriers!
  createCarrierRate(value: CreateCarrierRateInput!): CarrierRates!
  createDriver(value: CreateDriverInput!): Drivers!
  createDriverSchedule(value: CreateDriverScheduleInput!): DriverSchedules!
  createExpense(value: CreateExpenseInput!): Expenses!
  createGeofence(value: CreateGeofenceInput!): Geofences!
  createGeofenceEvent(value: CreateGeofenceEventInput!): GeofenceEvents!
  createGpsPing(value: CreateGpsPingInput!): GpsPings!
  createPartnerInvoice(value: CreatePartnerInvoiceInput!): PartnerInvoices!
  createPartnerInvoiceItem(value: CreatePartnerInvoiceItemInput!): PartnerInvoiceItems!
  createProofOfDelivery(value: CreateProofOfDeliveryInput!): ProofOfDeliveries!
  createRoute(value: CreateRouteInput!): Routes!
  createShipmentLeg(value: CreateShipmentLegInput!): ShipmentLegs!
  createShipmentLegEvent(value: CreateShipmentLegEventInput!): ShipmentLegEvents!
  createTrip(value: CreateTripInput!): Trips!
  createTripStop(value: CreateTripStopInput!): TripStops!
  createVehicle(value: CreateVehicleInput!): Vehicles!
  createVehicleMaintenance(value: CreateVehicleMaintenanceInput!): VehicleMaintenance!
  removeCarrier(id: ID!): DeleteResult!
  removeCarrierRate(id: ID!): DeleteResult!
  removeDriver(id: ID!): DeleteResult!
  removeDriverSchedule(id: ID!): DeleteResult!
  removeExpense(id: ID!): DeleteResult!
  removeGeofence(id: ID!): DeleteResult!
  removeGeofenceEvent(id: ID!): DeleteResult!
  removeGpsPing(id: ID!): DeleteResult!
  removePartnerInvoice(id: ID!): DeleteResult!
  removePartnerInvoiceItem(id: ID!): DeleteResult!
  removeProofOfDelivery(id: ID!): DeleteResult!
  removeRoute(id: ID!): DeleteResult!
  removeShipmentLeg(id: ID!): DeleteResult!
  removeShipmentLegEvent(id: ID!): DeleteResult!
  removeTrip(id: ID!): DeleteResult!
  removeTripStop(id: ID!): DeleteResult!
  removeVehicle(id: ID!): DeleteResult!
  removeVehicleMaintenance(id: ID!): DeleteResult!
  updateCarrier(id: ID!, value: UpdateCarrierInput): Carriers!
  updateCarrierRate(id: ID!, value: UpdateCarrierRateInput): CarrierRates!
  updateDriver(id: ID!, value: UpdateDriverInput): Drivers!
  updateDriverSchedule(id: ID!, value: UpdateDriverScheduleInput): DriverSchedules!
  updateExpense(id: ID!, value: UpdateExpenseInput): Expenses!
  updateGeofence(id: ID!, value: UpdateGeofenceInput): Geofences!
  updateGeofenceEvent(id: ID!, value: UpdateGeofenceEventInput): GeofenceEvents!
  updateGpsPing(id: ID!, value: UpdateGpsPingInput): GpsPings!
  updatePartnerInvoice(id: ID!, value: UpdatePartnerInvoiceInput): PartnerInvoices!
  updatePartnerInvoiceItem(id: ID!, value: UpdatePartnerInvoiceItemInput): PartnerInvoiceItems!
  updateProofOfDelivery(id: ID!, value: UpdateProofOfDeliveryInput): ProofOfDeliveries!
  updateRoute(id: ID!, value: UpdateRouteInput): Routes!
  updateShipmentLeg(id: ID!, value: UpdateShipmentLegInput): ShipmentLegs!
  updateShipmentLegEvent(id: ID!, value: UpdateShipmentLegEventInput): ShipmentLegEvents!
  updateTrip(id: ID!, value: UpdateTripInput): Trips!
  updateTripStop(id: ID!, value: UpdateTripStopInput): TripStops!
  updateVehicle(id: ID!, value: UpdateVehicleInput): Vehicles!
  updateVehicleMaintenance(id: ID!, value: UpdateVehicleMaintenanceInput): VehicleMaintenance!
}

type TmsQuery {
  carrier(id: ID!): Carriers!
  carrierRate(id: ID!): CarrierRates!
  carrierRates(page: Int, perPage: Int): [CarrierRates!]!
  carriers(page: Int, perPage: Int): [Carriers!]!
  driver(id: ID!): Drivers!
  driverSchedule(id: ID!): DriverSchedules!
  driverSchedules(page: Int, perPage: Int): [DriverSchedules!]!
  drivers(page: Int, perPage: Int): [Drivers!]!
  expense(id: ID!): Expenses!
  expenses(page: Int, perPage: Int): [Expenses!]!
  geofence(id: ID!): Geofences!
  geofenceEvent(id: ID!): GeofenceEvents!
  geofenceEvents(page: Int, perPage: Int): [GeofenceEvents!]!
  geofences(page: Int, perPage: Int): [Geofences!]!
  gpsPing(id: ID!): GpsPings!
  gpsPings(page: Int, perPage: Int): [GpsPings!]!
  partnerInvoice(id: ID!): PartnerInvoices!
  partnerInvoiceItem(id: ID!): PartnerInvoiceItems!
  partnerInvoiceItems(page: Int, perPage: Int): [PartnerInvoiceItems!]!
  partnerInvoices(page: Int, perPage: Int): [PartnerInvoices!]!
  proofOfDeliveries(page: Int, perPage: Int): [ProofOfDeliveries!]!
  proofOfDelivery(id: ID!): ProofOfDeliveries!
  route(id: ID!): Routes!
  routes(page: Int, perPage: Int): [Routes!]!
  shipmentLeg(id: ID!): ShipmentLegs!
  shipmentLegEvent(id: ID!): ShipmentLegEvents!
  shipmentLegEvents(page: Int, perPage: Int): [ShipmentLegEvents!]!
  shipmentLegs(page: Int, perPage: Int): [ShipmentLegs!]!
  trip(id: ID!): Trips!
  tripStop(id: ID!): TripStops!
  tripStops(page: Int, perPage: Int): [TripStops!]!
  trips(page: Int, perPage: Int): [Trips!]!
  vehicle(id: ID!): Vehicles!
  vehicleMaintenance(id: ID!): VehicleMaintenance!
  vehicleMaintenances(page: Int, perPage: Int): [VehicleMaintenance!]!
  vehicles(page: Int, perPage: Int): [Vehicles!]!
}

enum TripStatus {
  CANCELLED
  COMPLETED
  IN_PROGRESS
  PLANNED
}

enum TripStopStatus {
  ARRIVED
  COMPLETED
  PENDING
  SKIPPED
}

type TripStops {
  actualArrivalTime: String
  actualDepartureTime: String
  address: String
  createdAt: String
  estimatedArrivalTime: String
  estimatedDepartureTime: String
  id: ID!
  proofOfDeliveries: [ProofOfDeliveries!]
  sequence: Int!
  shipment: OutboundShipments
  status: TripStopStatus
  trip: Trips!
  updatedAt: String
}

type Trips {
  createdAt: String
  driver: Drivers
  expenses: [Expenses!]
  id: ID!
  routes: [Routes!]
  shipmentLegs: [ShipmentLegs!]
  status: TripStatus
  stops: [TripStops!]
  updatedAt: String
  vehicle: Vehicles
}

input UpdateAttachmentInput {
  fileName: String
  filePath: String
  mimeType: String
  recordId: ID
  recordType: RecordType
}

input UpdateBinThresholdInput {
  alertThreshold: Int
  isActive: Boolean
  locationId: ID
  maxQuantity: Int
  minQuantity: Int
  productId: ID
  reorderQuantity: Int
}

input UpdateCampaignInput {
  budget: Float
  endDate: String
  name: String
  startDate: String
}

input UpdateCarrierInput {
  contactDetails: String
  name: String
  servicesOffered: String
}

input UpdateCarrierRateInput {
  carrierId: ID
  destination: String
  origin: String
  rate: Float
  serviceType: String
  unit: CarrierRateUnit
}

input UpdateCaseInput {
  caseNumber: String
  contactId: ID
  description: String
  ownerId: ID
  priority: CasePriority
  status: CaseStatus
  type: CaseType
}

input UpdateCompanyInput {
  annualRevenue: Float
  city: String
  country: String
  industry: String
  name: String
  ownerId: ID
  phoneNumber: String
  postalCode: String
  state: String
  street: String
  website: String
}

input UpdateContactInput {
  companyId: ID
  email: String
  jobTitle: String
  name: String
  ownerId: ID
  phoneNumber: String
}

input UpdateDriverInput {
  licenseExpiryDate: String
  licenseNumber: String
  status: DriverStatus
  userId: ID
}

input UpdateDriverScheduleInput {
  driverId: ID
  endDate: String
  reason: DriverScheduleReason
  startDate: String
}

input UpdateExpenseInput {
  amount: Float
  currency: Currency
  driverId: ID
  fuelQuantity: Float
  odometerReading: Int
  receiptUrl: String
  status: ExpenseStatus
  tripId: ID
  type: ExpenseType
}

input UpdateGeofenceEventInput {
  eventType: GeofenceEventType
  geofenceId: ID
  timestamp: String
  vehicleId: ID
}

input UpdateGeofenceInput {
  coordinates: String
  name: String
}

input UpdateGpsPingInput {
  latitude: Float
  longitude: Float
  timestamp: String
  vehicleId: ID
}

input UpdateInboundShipmentInput {
  actualArrivalDate: String
  clientId: ID
  expectedArrivalDate: String
  status: InboundShipmentStatus
  warehouseId: ID
}

input UpdateInboundShipmentItemInput {
  discrepancyNotes: String
  expectedQuantity: Int
  inboundShipmentId: ID
  productId: ID
  receivedQuantity: Int
}

input UpdateInteractionInput {
  caseId: ID
  contactId: ID
  interactionDate: String
  notes: String
  outcome: String
  type: InteractionType
  userId: ID
}

input UpdateInventoryAdjustmentInput {
  notes: String
  productId: ID
  quantityChange: Int
  reason: InventoryAdjustmentReason
  userId: ID
  warehouseId: ID
}

input UpdateInventoryBatchInput {
  batchNumber: String
  expirationDate: String
  productId: ID
}

input UpdateInventoryStockInput {
  batchId: ID
  lastCountedAt: String
  lastMovementAt: String
  locationId: ID
  productId: ID
  quantity: Int
  reservedQuantity: Int
  status: InventoryStockStatus
}

input UpdateInvoiceInput {
  dueDate: String
  issueDate: String
  opportunityId: ID
  paidAt: String
  paymentMethod: PaymentMethod
  sentAt: String
  status: InvoiceStatus
  total: Float
}

input UpdateInvoiceItemInput {
  invoiceId: ID
  price: Float
  productId: ID
  quantity: Int
}

input UpdateLeadInput {
  campaignId: ID
  email: String
  leadScore: Int
  leadSource: LeadSource
  name: String
  ownerId: ID
  status: LeadStatus
}

input UpdateLocationInput {
  barcode: String
  hazmatApproved: Boolean
  isActive: Boolean
  isPickable: Boolean
  isReceivable: Boolean
  level: Int
  maxPallets: Int
  maxVolume: Float
  maxWeight: Float
  name: String
  parentLocationId: ID
  path: String
  temperatureControlled: Boolean
  type: LocationType
  warehouseId: ID
  xCoordinate: Float
  yCoordinate: Float
  zCoordinate: Float
}

input UpdateNotificationInput {
  isRead: Boolean
  link: String
  message: String
  userId: ID
}

input UpdateOpportunityInput {
  campaignId: ID
  companyId: ID
  contactId: ID
  dealValue: Float
  expectedCloseDate: String
  lostReason: String
  name: String
  ownerId: ID
  probability: Float
  source: OpportunitySource
  stage: OpportunityStage
}

input UpdateOpportunityProductInput {
  quantity: Int
}

input UpdateOutboundShipmentInput {
  carrier: String
  salesOrderId: ID
  status: OutboundShipmentStatus
  trackingNumber: String
  warehouseId: ID
}

input UpdateOutboundShipmentItemInput {
  batchId: ID
  outboundShipmentId: ID
  productId: ID
  quantityShipped: Int
  salesOrderItemId: ID
}

input UpdatePackageInput {
  carrier: String
  height: Float
  insuranceValue: Float
  isFragile: Boolean
  isHazmat: Boolean
  length: Float
  packageNumber: String
  packageType: String
  packedAt: String
  packedByUserId: ID
  requiresSignature: Boolean
  salesOrderId: ID
  serviceLevel: String
  shippedAt: String
  trackingNumber: String
  warehouseId: ID
  weight: Float
  width: Float
}

input UpdatePackageItemInput {
  batchId: ID
  expiryDate: String
  lotNumber: String
  packageId: ID
  productId: ID
  quantity: Int
  serialNumbers: [String]
  unitWeight: Float
}

input UpdatePartnerInvoiceInput {
  carrierId: ID
  invoiceDate: String
  invoiceNumber: String
  status: PartnerInvoiceStatus
  totalAmount: Float
}

input UpdatePartnerInvoiceItemInput {
  amount: Float
  partnerInvoiceId: ID
  shipmentLegId: ID
}

input UpdatePickBatchInput {
  actualDuration: Int
  assignedUserId: ID
  batchNumber: String
  completedAt: String
  completedItems: Int
  estimatedDuration: Int
  priority: Int
  startedAt: String
  status: PickBatchStatus
  strategy: PickStrategy
  totalItems: Int
  warehouseId: ID
  waveId: String
  zoneRestrictions: [String]
}

input UpdatePickBatchItemInput {
  actualPickTime: Int
  estimatedPickTime: Int
  orderPriority: Int
  pickBatchId: ID
  salesOrderId: ID
}

input UpdateProductInput {
  description: String
  name: String
  price: Float
  sku: String
  type: ProductType
}

input UpdateProofOfDeliveryInput {
  filePath: String
  latitude: Float
  longitude: Float
  timestamp: String
  tripStopId: ID
  type: ProofType
}

input UpdatePutawayRuleInput {
  clientId: ID
  isActive: Boolean
  locationType: LocationType
  maxQuantity: Int
  minQuantity: Int
  preferredLocationId: ID
  priority: Int
  productId: ID
  requiresHazmatApproval: Boolean
  requiresTemperatureControl: Boolean
  volumeThreshold: Float
  warehouseId: ID
  weightThreshold: Float
}

input UpdateReorderPointInput {
  productId: ID
  threshold: Int
  warehouseId: ID
}

input UpdateReturnInput {
  clientId: ID
  reason: String
  returnNumber: String
  salesOrderId: ID
  status: ReturnStatus
}

input UpdateReturnItemInput {
  condition: ReturnItemCondition
  productId: ID
  quantityExpected: Int
  quantityReceived: Int
  returnId: ID
}

input UpdateRouteInput {
  optimizedRouteData: String
  totalDistance: Float
  totalDuration: Float
  tripId: ID
}

input UpdateSalesOrderInput {
  clientId: ID
  crmOpportunityId: ID
  orderNumber: String
  shippingAddress: String
  status: SalesOrderStatus
}

input UpdateSalesOrderItemInput {
  productId: ID
  quantityOrdered: Int
  salesOrderId: ID
}

input UpdateShipmentLegEventInput {
  eventTimestamp: String
  location: String
  shipmentLegId: ID
  statusMessage: String
}

input UpdateShipmentLegInput {
  carrierId: ID
  endLocation: String
  internalTripId: ID
  legSequence: Int
  shipment: OutboundShipments
  startLocation: String
  status: ShipmentLegStatus
}

input UpdateStockTransferInput {
  destinationWarehouseId: ID
  productId: ID
  quantity: Int
  sourceWarehouseId: ID
  status: StockTransferStatus
}

input UpdateSupplierInput {
  contactPerson: String
  email: String
  name: String
  phoneNumber: String
}

input UpdateTaskInput {
  actualDuration: Int
  endTime: String
  estimatedDuration: Int
  instructions: String
  notes: String
  pickBatchId: ID
  priority: Int
  sourceEntityId: ID
  sourceEntityType: String
  startTime: String
  status: TaskStatus
  taskNumber: String
  type: TaskType
  userId: ID
  warehouseId: ID
}

input UpdateTaskItemInput {
  batchId: ID
  completedAt: String
  destinationLocationId: ID
  expiryDate: String
  lotNumber: String
  notes: String
  productId: ID
  quantityCompleted: Int
  quantityRequired: Int
  serialNumbers: [String]
  sourceLocationId: ID
  status: TaskItemStatus
  taskId: ID
}

input UpdateTripInput {
  driverId: ID
  status: TripStatus
  vehicleId: ID
}

input UpdateTripStopInput {
  actualArrivalTime: String
  actualDepartureTime: String
  address: String
  estimatedArrivalTime: String
  estimatedDepartureTime: String
  sequence: Int
  shipment: OutboundShipments
  status: TripStopStatus
  tripId: ID
}

input UpdateVehicleInput {
  capacityVolume: Float
  capacityWeight: Float
  model: String
  registrationNumber: String
  status: VehicleStatus
}

input UpdateVehicleMaintenanceInput {
  cost: Float
  notes: String
  serviceDate: String
  serviceType: VehicleServiceType
  vehicleId: ID
}

input UpdateWarehouseInput {
  address: String
  city: String
  contactEmail: String
  contactPerson: String
  contactPhone: String
  country: String
  isActive: Boolean
  name: String
  postalCode: String
  state: String
  timezone: String
}

input UpdateWmsProductInput {
  barcode: String
  clientId: ID
  costPrice: Float
  description: String
  height: Float
  length: Float
  name: String
  sku: String
  status: ProductStatus
  supplierId: ID
  weight: Float
  width: Float
}

type User {
  email: String!
  emailVerified: String!
  image: String!
  name: String!
}

type VehicleMaintenance {
  cost: Float
  createdAt: String
  id: ID!
  notes: String
  serviceDate: String!
  serviceType: VehicleServiceType
  updatedAt: String
  vehicle: Vehicles!
}

enum VehicleServiceType {
  BRAKE_SERVICE
  INSPECTION
  OIL_CHANGE
  REPAIR
  ROUTINE_MAINTENANCE
  TIRE_REPLACEMENT
}

enum VehicleStatus {
  AVAILABLE
  IN_MAINTENANCE
  ON_TRIP
  OUT_OF_SERVICE
}

type Vehicles {
  capacityVolume: Float
  capacityWeight: Float
  createdAt: String
  geofenceEvents: [GeofenceEvents!]
  gpsPings: [GpsPings!]
  id: ID!
  maintenances: [VehicleMaintenance!]
  model: String
  registrationNumber: String!
  status: VehicleStatus
  trips: [Trips!]
  updatedAt: String
}

type Warehouses {
  address: String
  city: String
  contactEmail: String
  contactPerson: String
  contactPhone: String
  country: String
  createdAt: String
  destinationStockTransfers: [StockTransfers!]
  id: ID!
  inboundShipments: [InboundShipments!]
  isActive: Boolean
  locations: [Locations!]
  name: String!
  outboundShipments: [OutboundShipments!]
  packages: [Packages!]
  pickBatches: [PickBatches!]
  postalCode: String
  putawayRules: [PutawayRules!]
  sourceStockTransfers: [StockTransfers!]
  state: String
  tasks: [Tasks!]
  timezone: String
  updatedAt: String
}

type WmsMutation {
  createBinThreshold(value: CreateBinThresholdInput!): BinThresholds!
  createInboundShipment(value: CreateInboundShipmentInput!): InboundShipments!
  createInboundShipmentItem(value: CreateInboundShipmentItemInput!): InboundShipmentItems!
  createInventoryAdjustment(value: CreateInventoryAdjustmentInput!): InventoryAdjustments!
  createInventoryBatch(value: CreateInventoryBatchInput!): InventoryBatches!
  createInventoryStock(value: CreateInventoryStockInput!): InventoryStock!
  createLocation(value: CreateLocationInput!): Locations!
  createOutboundShipment(value: CreateOutboundShipmentInput!): OutboundShipments!
  createOutboundShipmentItem(value: CreateOutboundShipmentItemInput!): OutboundShipmentItems!
  createPackage(value: CreatePackageInput!): Packages!
  createPackageItem(value: CreatePackageItemInput!): PackageItems!
  createPickBatch(value: CreatePickBatchInput!): PickBatches!
  createPickBatchItem(value: CreatePickBatchItemInput!): PickBatchItems!
  createPutawayRule(value: CreatePutawayRuleInput!): PutawayRules!
  createReorderPoint(value: CreateReorderPointInput!): ReorderPoints!
  createReturn(value: CreateReturnInput!): Returns!
  createReturnItem(value: CreateReturnItemInput!): ReturnItems!
  createSalesOrder(value: CreateSalesOrderInput!): SalesOrders!
  createSalesOrderItem(value: CreateSalesOrderItemInput!): SalesOrderItems!
  createStockTransfer(value: CreateStockTransferInput!): StockTransfers!
  createSupplier(value: CreateSupplierInput!): Suppliers!
  createTask(value: CreateTaskInput!): Tasks!
  createTaskItem(value: CreateTaskItemInput!): TaskItems!
  createWarehouse(value: CreateWarehouseInput!): Warehouses!
  createWmsProduct(value: CreateWmsProductInput!): WmsProducts!
  removeBinThreshold(id: ID!): DeleteResult!
  removeInboundShipment(id: ID!): DeleteResult!
  removeInboundShipmentItem(id: ID!): DeleteResult!
  removeInventoryAdjustment(id: ID!): DeleteResult!
  removeInventoryBatch(id: ID!): DeleteResult!
  removeInventoryStock(id: ID!): DeleteResult!
  removeLocation(id: ID!): DeleteResult!
  removeOutboundShipment(id: ID!): DeleteResult!
  removeOutboundShipmentItem(id: ID!): DeleteResult!
  removePackage(id: ID!): DeleteResult!
  removePackageItem(id: ID!): DeleteResult!
  removePickBatch(id: ID!): DeleteResult!
  removePickBatchItem(id: ID!): DeleteResult!
  removePutawayRule(id: ID!): DeleteResult!
  removeReorderPoint(id: ID!): DeleteResult!
  removeReturn(id: ID!): DeleteResult!
  removeReturnItem(id: ID!): DeleteResult!
  removeSalesOrder(id: ID!): DeleteResult!
  removeSalesOrderItem(id: ID!): DeleteResult!
  removeStockTransfer(id: ID!): DeleteResult!
  removeSupplier(id: ID!): DeleteResult!
  removeTask(id: ID!): DeleteResult!
  removeTaskItem(id: ID!): DeleteResult!
  removeWarehouse(id: ID!): DeleteResult!
  removeWmsProduct(id: ID!): DeleteResult!
  updateBinThreshold(id: ID!, value: UpdateBinThresholdInput): BinThresholds!
  updateInboundShipment(id: ID!, value: UpdateInboundShipmentInput): InboundShipments!
  updateInboundShipmentItem(id: ID!, value: UpdateInboundShipmentItemInput): InboundShipmentItems!
  updateInventoryAdjustment(id: ID!, value: UpdateInventoryAdjustmentInput): InventoryAdjustments!
  updateInventoryBatch(id: ID!, value: UpdateInventoryBatchInput): InventoryBatches!
  updateInventoryStock(id: ID!, value: UpdateInventoryStockInput): InventoryStock!
  updateLocation(id: ID!, value: UpdateLocationInput): Locations!
  updateOutboundShipment(id: ID!, value: UpdateOutboundShipmentInput): OutboundShipments!
  updateOutboundShipmentItem(id: ID!, value: UpdateOutboundShipmentItemInput): OutboundShipmentItems!
  updatePackage(id: ID!, value: UpdatePackageInput): Packages!
  updatePackageItem(id: ID!, value: UpdatePackageItemInput): PackageItems!
  updatePickBatch(id: ID!, value: UpdatePickBatchInput): PickBatches!
  updatePickBatchItem(id: ID!, value: UpdatePickBatchItemInput): PickBatchItems!
  updatePutawayRule(id: ID!, value: UpdatePutawayRuleInput): PutawayRules!
  updateReorderPoint(id: ID!, value: UpdateReorderPointInput): ReorderPoints!
  updateReturn(id: ID!, value: UpdateReturnInput): Returns!
  updateReturnItem(id: ID!, value: UpdateReturnItemInput): ReturnItems!
  updateSalesOrder(id: ID!, value: UpdateSalesOrderInput): SalesOrders!
  updateSalesOrderItem(id: ID!, value: UpdateSalesOrderItemInput): SalesOrderItems!
  updateStockTransfer(id: ID!, value: UpdateStockTransferInput): StockTransfers!
  updateSupplier(id: ID!, value: UpdateSupplierInput): Suppliers!
  updateTask(id: ID!, value: UpdateTaskInput): Tasks!
  updateTaskItem(id: ID!, value: UpdateTaskItemInput): TaskItems!
  updateWarehouse(id: ID!, value: UpdateWarehouseInput): Warehouses!
  updateWmsProduct(id: ID!, value: UpdateWmsProductInput): WmsProducts!
}

type WmsProducts {
  adjustments: [InventoryAdjustments!]
  barcode: String
  batches: [InventoryBatches!]
  binThresholds: [BinThresholds!]
  client: Companies
  costPrice: Float
  createdAt: String
  description: String
  height: Float
  id: ID!
  inboundShipmentItems: [InboundShipmentItems!]
  inventoryStock: [InventoryStock!]
  length: Float
  name: String!
  outboundShipmentItems: [OutboundShipmentItems!]
  packageItems: [PackageItems!]
  putawayRules: [PutawayRules!]
  reorderPoints: [ReorderPoints!]
  returnItems: [ReturnItems!]
  salesOrderItems: [SalesOrderItems!]
  sku: String!
  status: ProductStatus
  stockTransfers: [StockTransfers!]
  supplier: Suppliers
  taskItems: [TaskItems!]
  updatedAt: String
  volume: Float
  weight: Float
  width: Float
}

type WmsQuery {
  binThreshold(id: ID!): BinThresholds!
  binThresholds(page: Int, perPage: Int): [BinThresholds!]!
  inboundShipment(id: ID!): InboundShipments!
  inboundShipmentItem(id: ID!): InboundShipmentItems!
  inboundShipmentItems(page: Int, perPage: Int): [InboundShipmentItems!]!
  inboundShipments(page: Int, perPage: Int): [InboundShipments!]!
  inventoryAdjustment(id: ID!): InventoryAdjustments!
  inventoryAdjustments(page: Int, perPage: Int): [InventoryAdjustments!]!
  inventoryBatch(id: ID!): InventoryBatches!
  inventoryBatches(page: Int, perPage: Int): [InventoryBatches!]!
  inventoryStock(id: ID!): InventoryStock!
  inventoryStocks(page: Int, perPage: Int): [InventoryStock!]!
  location(id: ID!): Locations!
  locations(page: Int, perPage: Int): [Locations!]!
  outboundShipment(id: ID!): OutboundShipments!
  outboundShipmentItem(id: ID!): OutboundShipmentItems!
  outboundShipmentItems(page: Int, perPage: Int): [OutboundShipmentItems!]!
  outboundShipments(page: Int, perPage: Int): [OutboundShipments!]!
  package(id: ID!): Packages!
  packageItem(id: ID!): PackageItems!
  packageItems(page: Int, perPage: Int): [PackageItems!]!
  packages(page: Int, perPage: Int): [Packages!]!
  pickBatch(id: ID!): PickBatches!
  pickBatchItem(id: ID!): PickBatchItems!
  pickBatchItems(page: Int, perPage: Int): [PickBatchItems!]!
  pickBatches(page: Int, perPage: Int): [PickBatches!]!
  putawayRule(id: ID!): PutawayRules!
  putawayRules(page: Int, perPage: Int): [PutawayRules!]!
  reorderPoint(id: ID!): ReorderPoints!
  reorderPoints(page: Int, perPage: Int): [ReorderPoints!]!
  return(id: ID!): Returns!
  returnItem(id: ID!): ReturnItems!
  returnItems(page: Int, perPage: Int): [ReturnItems!]!
  returns(page: Int, perPage: Int): [Returns!]!
  salesOrder(id: ID!): SalesOrders!
  salesOrderItem(id: ID!): SalesOrderItems!
  salesOrderItems(page: Int, perPage: Int): [SalesOrderItems!]!
  salesOrders(page: Int, perPage: Int): [SalesOrders!]!
  stockTransfer(id: ID!): StockTransfers!
  stockTransfers(page: Int, perPage: Int): [StockTransfers!]!
  supplier(id: ID!): Suppliers!
  suppliers(page: Int, perPage: Int): [Suppliers!]!
  task(id: ID!): Tasks!
  taskItem(id: ID!): TaskItems!
  taskItems(page: Int, perPage: Int): [TaskItems!]!
  tasks(page: Int, perPage: Int): [Tasks!]!
  warehouse(id: ID!): Warehouses!
  warehouses(page: Int, perPage: Int): [Warehouses!]!
  wmsProduct(id: ID!): WmsProducts!
  wmsProducts(page: Int, perPage: Int): [WmsProducts!]!
}