type AccountTransactions {
  amount: Float!
  clientAccount: ClientAccounts!
  createdAt: Date
  description: String
  id: ID!
  processedByUser: User
  referenceNumber: String
  runningBalance: Float
  sourceRecordId: ID
  sourceRecordType: String
  transactionDate: String
  type: TransactionType!
  updatedAt: Date
}

type AccountingSyncFailedEvent {
  errorMessage: String
  sourceType: String!
  syncLogId: ID!
}

type AccountingSyncLogs {
  createdAt: Date
  errorMessage: String
  externalId: String
  externalSystem: String!
  id: ID!
  lastSyncAt: String
  nextRetryAt: String
  recordId: ID!
  recordType: String!
  requestPayload: String
  responsePayload: String
  retryCount: Int
  status: SyncStatus
  updatedAt: Date
}

type AccountingSyncSucceededEvent {
  sourceType: String!
  syncLogId: ID!
}

type AccountingSyncTriggeredEvent {
  sourceId: ID!
  sourceType: String!
  syncLogId: ID!
}

input AddInvoiceItemInput {
  productId: ID!
  quantity: Float!
}

input AddOpportunityProductInput {
  productId: ID!
  quantity: Float!
}

type Attachments {
  createdAt: Date
  fileName: String!
  filePath: String!
  id: ID!
  mimeType: String
  recordId: ID
  recordType: RecordType
  updatedAt: Date
}

enum BillingInvoiceStatus {
  CANCELLED
  DISPUTED
  DRAFT
  PAID
  PARTIAL_PAID
  PAST_DUE
  SENT
  VIEWED
  VOID
}

type BillingInvoices {
  amountOutstanding: Float
  amountPaid: Float
  client: Companies!
  createdAt: Date
  createdByUser: User
  creditNotes: [CreditNotes!]
  currency: String
  discountAmount: Float
  dueDate: String!
  id: ID!
  invoiceNumber: String!
  issueDate: String!
  lineItems: [InvoiceLineItems!]
  notes: String
  paidAt: String
  paymentTerms: String
  payments: [Payments!]
  quote: Quotes
  sentAt: String
  status: BillingInvoiceStatus
  subtotal: Float
  taxAmount: Float
  totalAmount: Float!
  updatedAt: Date
}

type BillingMutation {
  addInvoiceLineItem(id: ID!, value: CreateInvoiceLineItemInput!): InvoiceLineItems!
  createAccountTransaction(value: CreateAccountTransactionInput!): AccountTransactions!
  createAccountingSyncLog(value: CreateAccountingSyncLogInput!): AccountingSyncLogs!
  createBillingInvoice(value: CreateBillingInvoiceInput!): BillingInvoices!
  createClientAccount(value: CreateClientAccountInput!): ClientAccounts!
  createCreditNote(value: CreateCreditNoteInput!): CreditNotes!
  createDispute(value: CreateDisputeInput!): Disputes!
  createDocument(value: CreateDocumentInput!): Documents!
  createPayment(value: CreatePaymentInput!): Payments!
  createQuote(value: CreateQuoteInput!): Quotes!
  createRateCard(value: CreateRateCardInput!): RateCards!
  createRateRule(value: CreateRateRuleInput!): RateRules!
  createSurcharge(value: CreateSurchargeInput!): Surcharges!
  removeBillingInvoice(id: ID!): DeleteResult!
  removeClientAccount(id: ID!): DeleteResult!
  removeCreditNote(id: ID!): DeleteResult!
  removeDocument(id: ID!): DeleteResult!
  removeInvoiceLineItem(id: ID!): DeleteResult!
  removePayment(id: ID!): DeleteResult!
  removeQuote(id: ID!): DeleteResult!
  removeRateCard(id: ID!): DeleteResult!
  removeRateRule(id: ID!): DeleteResult!
  removeSurcharge(id: ID!): DeleteResult!
  updateBillingInvoice(id: ID!, value: UpdateBillingInvoiceInput): BillingInvoices!
  updateClientAccount(id: ID!, value: UpdateClientAccountInput): ClientAccounts!
  updateCreditNote(id: ID!, value: UpdateCreditNoteInput): CreditNotes!
  updateDispute(id: ID!, value: UpdateDisputeInput): Disputes!
  updateDocument(id: ID!, value: UpdateDocumentInput): Documents!
  updateInvoiceLineItem(id: ID!, value: UpdateInvoiceLineItemInput): InvoiceLineItems!
  updatePayment(id: ID!, value: UpdatePaymentInput): Payments!
  updateQuote(id: ID!, value: UpdateQuoteInput): Quotes!
  updateRateCard(id: ID!, value: UpdateRateCardInput): RateCards!
  updateRateRule(id: ID!, value: UpdateRateRuleInput): RateRules!
  updateSurcharge(id: ID!, value: UpdateSurchargeInput): Surcharges!
}

type BillingQuery {
  accountTransaction(id: ID!): AccountTransactions!
  accountTransactions(from: Date, page: Int, perPage: Int, search: String, to: Date, type: TransactionType): [AccountTransactions!]!
  accountingSyncLog(id: ID!): AccountingSyncLogs!
  accountingSyncLogs(from: Date, page: Int, perPage: Int, search: String, status: SyncStatus, to: Date): [AccountingSyncLogs!]!
  billingInvoice(id: ID!): BillingInvoices!
  billingInvoices(from: Date, page: Int, perPage: Int, search: String, status: BillingInvoiceStatus, to: Date): [BillingInvoices!]!
  clientAccount(id: ID!): ClientAccounts!
  clientAccounts(from: Date, page: Int, perPage: Int, search: String, to: Date): [ClientAccounts!]!
  creditNote(id: ID!): CreditNotes!
  creditNotes(from: Date, page: Int, perPage: Int, search: String, to: Date): [CreditNotes!]!
  dispute(id: ID!): Disputes!
  disputes(from: Date, page: Int, perPage: Int, search: String, status: DisputeStatus, to: Date): [Disputes!]!
  document(id: ID!): Documents!
  documents(from: Date, page: Int, perPage: Int, to: Date): [Documents!]!
  payment(id: ID!): Payments!
  payments(from: Date, page: Int, paymentMethod: PaymentMethod, perPage: Int, search: String, status: PaymentStatus, to: Date): [Payments!]!
  quote(id: ID!): Quotes!
  quotes(from: Date, page: Int, perPage: Int, search: String, status: QuoteStatus, to: Date): [Quotes!]!
  rateCard(id: ID!): RateCards!
  rateCards(from: Date, page: Int, perPage: Int, search: String, serviceType: ServiceType, to: Date): [RateCards!]!
  rateRule(id: ID!): RateRules!
  rateRules(from: Date, page: Int, perPage: Int, pricingModel: PricingModel, search: String, to: Date): [RateRules!]!
  surcharge(id: ID!): Surcharges!
  surcharges(calculationMethod: SurchargeCalculationMethod, from: Date, page: Int, perPage: Int, search: String, to: Date): [Surcharges!]!
}

type BillingSubscription {
  accountingSyncFailed: AccountingSyncFailedEvent!
  accountingSyncSucceeded: AccountingSyncSucceededEvent!
  accountingSyncTriggered: AccountingSyncTriggeredEvent!
  clientAccountBalanceUpdated: ClientAccountBalanceUpdatedEvent!
  clientAccountLastPaymentDateUpdated: ClientAccountLastPaymentDateUpdatedEvent!
  creditNoteApplied: CreditNoteAppliedEvent!
  creditNoteIssued: CreditNotes!
  creditNoteOnDisputeApproval: CreditNoteOnDisputeApprovalEvent!
  disputeApproved: DisputeApprovedEvent!
  disputeDenied: DisputeDeniedEvent!
  disputeOpened: Disputes!
  disputeResolved: DisputeResolvedEvent!
  disputeStatusChanged: DisputeStatusChangedEvent!
  disputeUnderReview: Disputes!
  documentGenerated: DocumentGeneratedEvent!
  invoiceCreated: BillingInvoices!
  invoiceDisputed: InvoiceDisputedEvent!
  invoiceOverdue: InvoiceOverdueEvent!
  invoicePaid: InvoicePaidEvent!
  invoicePartiallyPaid: InvoicePartiallyPaidEvent!
  invoiceSent: BillingInvoices!
  invoiceStatusChanged: InvoiceStatusChangedEvent!
  invoiceViewed: BillingInvoices!
  paymentFailed: PaymentFailedEvent!
  paymentInitiated: Payments!
  paymentProcessing: Payments!
  paymentRefunded: PaymentRefundedEvent!
  paymentStatusChanged: PaymentStatusChangedEvent!
  paymentSuccessful: Payments!
  quoteAccepted: Quotes!
  quoteConverted: QuoteConvertedEvent!
  quoteCreated: Quotes!
  quoteExpired: QuoteExpiredEvent!
  quoteSent: Quotes!
  quoteStatusChanged: QuoteStatusChangedEvent!
  rateCardDeactivated: RateCardDeactivatedEvent!
  shipmentCreatedFromPayment: ShipmentCreatedFromPaymentEvent!
  surchargeDeactivated: SurchargeDeactivatedEvent!
  transactionCredited: TransactionCreditedEvent!
  transactionDebited: TransactionDebitedEvent!
}

type BinThresholds {
  alertThreshold: Int
  createdAt: Date
  id: ID!
  isActive: Boolean
  location: Locations!
  maxQuantity: Int!
  minQuantity: Int!
  product: WmsProducts!
  reorderQuantity: Int
  updatedAt: Date
}

type Campaigns {
  budget: Float
  createdAt: Date
  endDate: Date
  id: ID!
  name: String!
  startDate: Date!
  updatedAt: Date
}

enum CarrierRateUnit {
  FLAT_RATE
  PER_CONTAINER
  PER_KG
  PER_KM
  PER_MILE
}

type CarrierRates {
  carrier: Carriers!
  createdAt: Date
  destination: String
  id: ID!
  origin: String
  rate: Float!
  serviceType: String
  unit: CarrierRateUnit
  updatedAt: Date
}

type Carriers {
  contactEmail: String
  contactPerson: String
  contactPhone: String
  createdAt: Date
  id: ID!
  name: String!
  partnerInvoices: [PartnerInvoices!]
  rates: [CarrierRates!]
  servicesOffered: String
  shipmentLegs: [ShipmentLegs!]
  updatedAt: Date
}

enum CasePriority {
  CRITICAL
  HIGH
  LOW
  MEDIUM
}

enum CaseStatus {
  CANCELLED
  CLOSED
  ESCALATED
  IN_PROGRESS
  NEW
  RESOLVED
  WAITING_FOR_CUSTOMER
  WAITING_FOR_INTERNAL
}

enum CaseType {
  BUG_REPORT
  COMPLAINT
  FEATURE_REQUEST
  PROBLEM
  QUESTION
  TECHNICAL_SUPPORT
}

type Cases {
  caseNumber: String!
  contact: Contacts
  createdAt: Date
  description: String
  id: ID!
  owner: User
  priority: CasePriority
  status: CaseStatus
  type: CaseType
  updatedAt: Date
}

type ClientAccountBalanceUpdatedEvent {
  clientId: ID!
  newAvailableCredit: String!
  newWalletBalance: String!
}

type ClientAccountLastPaymentDateUpdatedEvent {
  clientId: ID!
  lastPaymentDate: String!
  paymentId: ID!
}

type ClientAccounts {
  availableCredit: Float
  client: Companies!
  createdAt: Date
  creditLimit: Float
  currency: String
  id: ID!
  isCreditApproved: Boolean
  lastPaymentDate: String
  paymentTermsDays: Int
  transactions: [AccountTransactions!]
  updatedAt: Date
  walletBalance: Float
}

type Companies {
  annualRevenue: Float
  billingInvoices: [BillingInvoices!]
  city: String
  clientAccount: ClientAccounts
  country: String
  createdAt: Date
  disputes: [Disputes!]
  id: ID!
  inboundShipments: [InboundShipments!]
  industry: String
  name: String!
  owner: User
  phoneNumber: String
  postalCode: String
  putawayRules: [PutawayRules!]
  quotes: [Quotes!]
  returns: [Returns!]
  salesOrders: [SalesOrders!]
  state: String
  street: String
  updatedAt: Date
  website: String
}

type Contacts {
  company: Companies!
  createdAt: Date
  email: String
  id: ID!
  jobTitle: String
  name: String!
  owner: User
  phoneNumber: String
  updatedAt: Date
}

input CreateAccountTransactionInput {
  amount: Float!
  clientAccountId: ID!
  description: String
  processedByUserId: ID
  referenceNumber: String
  runningBalance: Float
  sourceRecordId: ID
  sourceRecordType: String
  transactionDate: String
  type: TransactionType!
}

input CreateAccountingSyncLogInput {
  errorMessage: String
  externalId: String
  externalSystem: String!
  lastSyncAt: String
  nextRetryAt: String
  recordId: ID!
  recordType: String!
  requestPayload: String
  responsePayload: String
  retryCount: Int
  status: SyncStatus
}

input CreateAttachmentInput {
  file: File!
  recordId: ID!
  recordType: RecordType!
}

input CreateBillingInvoiceInput {
  clientId: ID!
  createdByUserId: ID
  currency: String
  dueDate: String!
  invoiceNumber: String!
  issueDate: String!
  items: [CreateInvoiceLineItemInput!]!
  notes: String
  paymentTerms: String
  quoteId: ID
  sentAt: Date
  status: BillingInvoiceStatus
}

input CreateBinThresholdInput {
  alertThreshold: Int
  isActive: Boolean
  locationId: ID!
  maxQuantity: Int!
  minQuantity: Int!
  productId: ID!
  reorderQuantity: Int
}

input CreateCampaignInput {
  budget: Float
  endDate: Date
  name: String!
  startDate: Date!
}

input CreateCarrierInput {
  contactEmail: String
  contactPerson: String
  contactPhone: String
  name: String!
  servicesOffered: String
}

input CreateCarrierRateInput {
  carrierId: ID!
  destination: String
  origin: String
  rate: Float!
  serviceType: String
  unit: CarrierRateUnit
}

input CreateCaseInput {
  caseNumber: String!
  contactId: ID
  description: String
  ownerId: ID!
  priority: CasePriority
  status: CaseStatus
  type: CaseType
}

input CreateClientAccountInput {
  availableCredit: Float
  clientId: ID!
  creditLimit: Float
  currency: String
  isCreditApproved: Boolean
  lastPaymentDate: String
  paymentTermsDays: Int
  walletBalance: Float
}

input CreateCompanyInput {
  annualRevenue: Float
  city: String
  country: String
  industry: String
  name: String!
  ownerId: ID
  phoneNumber: String
  postalCode: String
  state: String
  street: String
  website: String
}

input CreateContactInput {
  companyId: ID!
  email: String!
  jobTitle: String
  name: String!
  ownerId: ID!
  phoneNumber: String
}

input CreateCreditNoteInput {
  amount: Float!
  appliedAt: String
  createdByUserId: ID
  creditNoteNumber: String!
  currency: String
  disputeId: ID
  invoiceId: ID!
  issueDate: String!
  notes: String
  reason: String!
}

input CreateCustomerTrackingLinkInput {
  deliveryTaskId: ID!
  expiresAt: String
  trackingToken: String!
}

input CreateDeliveryRouteInput {
  driverId: ID!
  estimatedDurationMinutes: Int
  optimizedRouteData: String
  routeDate: String!
  startedAt: String
  status: DeliveryRouteStatus
  totalDistanceKm: Float
}

input CreateDeliveryTaskInput {
  actualArrivalTime: String
  deliveryAddress: String!
  deliveryInstructions: String
  deliveryRouteId: ID!
  estimatedArrivalTime: String
  packageId: ID!
  recipientName: String
  recipientPhone: String
  routeSequence: Int!
  status: DeliveryTaskStatus
}

input CreateDisputeInput {
  clientId: ID!
  disputedAmount: Float
  lineItemId: ID!
  reason: String!
  resolutionNotes: String
  resolvedAt: String
  resolvedByUserId: ID
  status: DisputeStatus
}

input CreateDmsProofOfDeliveryInput {
  deliveryTaskId: ID!
  file: File
  latitude: Float
  longitude: Float
  recipientName: String
  signatureData: String
  timestamp: String
  type: ProofOfDeliveryType!
  verificationCode: String
}

input CreateDocumentInput {
  documentType: DocumentType!
  fileName: String!
  filePath: String!
  fileSize: Int
  mimeType: String
  recordId: ID!
  recordType: String!
  uploadedByUserId: ID
}

input CreateDriverInput {
  contactPhone: String
  licenseExpiryDate: String
  licenseNumber: String!
  status: DriverStatus
  userId: ID!
}

input CreateDriverLocationInput {
  accuracy: Float
  altitude: Float
  driverId: ID!
  heading: Float
  latitude: Float!
  longitude: Float!
  speedKmh: Float
}

input CreateDriverScheduleInput {
  driverId: ID!
  endDate: String!
  reason: DriverScheduleReason
  startDate: String!
}

input CreateExpenseInput {
  amount: Float!
  currency: Currency
  description: String
  driverId: ID
  expenseDate: Date
  fuelQuantity: Float
  odometerReading: Int
  receiptUrl: String
  status: ExpenseStatus
  tripId: ID
  type: ExpenseType
}

input CreateGeofenceEventInput {
  eventType: GeofenceEventType!
  geofenceId: ID!
  timestamp: String!
  vehicleId: ID!
}

input CreateGeofenceInput {
  latitude: Float
  longitude: Float
  name: String!
}

input CreateGpsPingInput {
  latitude: Float!
  longitude: Float!
  timestamp: Date!
  vehicleId: ID!
}

input CreateInboundShipmentInput {
  clientId: ID
  expectedArrivalDate: String
  items: [CreateInboundShipmentItemInput!]!
  status: InboundShipmentStatus
  warehouseId: ID!
}

input CreateInboundShipmentItemInput {
  expectedQuantity: Int!
  productId: ID!
}

input CreateInteractionInput {
  caseId: ID
  contactId: ID!
  interactionDate: Date
  notes: String
  outcome: InteractionOutcome
  type: InteractionType
  userId: ID!
}

input CreateInventoryAdjustmentInput {
  notes: String
  productId: ID!
  quantityChange: Int!
  reason: InventoryAdjustmentReason
  userId: ID!
  warehouseId: ID!
}

input CreateInventoryBatchInput {
  batchNumber: String!
  expirationDate: Date
  productId: ID!
}

input CreateInventoryStockInput {
  batchId: ID
  locationId: ID!
  productId: ID!
  quantity: Int!
  reservedQuantity: Int!
  status: InventoryStockStatus
}

input CreateInvoiceInput {
  dueDate: Date!
  issueDate: Date!
  items: [CreateInvoiceItemInput!]!
  opportunityId: ID!
  paidAt: Date
  paymentMethod: CrmInvoicePaymentMethod
  status: InvoiceStatus
}

input CreateInvoiceItemInput {
  productId: ID!
  quantity: Float!
}

input CreateInvoiceLineItemInput {
  description: String!
  discountRate: Float
  quantity: Float!
  sourceRecordId: ID
  sourceRecordType: String
  taxRate: Float
  unitPrice: Float!
}

input CreateLeadInput {
  campaignId: ID
  email: String!
  leadScore: Int
  leadSource: LeadSource
  name: String!
  ownerId: ID!
  status: LeadStatus
}

input CreateLocationInput {
  barcode: String
  hazmatApproved: Boolean
  isPickable: Boolean
  isReceivable: Boolean
  level: Int
  maxPallets: Int
  maxVolume: Float
  maxWeight: Float
  name: String!
  parentLocationId: ID
  path: String
  temperatureControlled: Boolean
  type: LocationType!
  warehouseId: ID!
  xCoordinate: Float
  yCoordinate: Float
  zCoordinate: Float
}

input CreateNotificationInput {
  isRead: Boolean
  link: String
  message: String!
  userId: ID!
}

input CreateOpportunityInput {
  campaignId: ID
  companyId: ID
  contactId: ID
  dealValue: Float
  expectedCloseDate: Date
  lostReason: String
  name: String!
  ownerId: ID!
  probability: Float
  products: [CreateOpportunityProductInput!]!
  source: OpportunitySource!
  stage: OpportunityStage!
}

input CreateOpportunityProductInput {
  productId: ID!
  quantity: Float!
}

input CreateOutboundShipmentInput {
  carrier: String
  items: [CreateOutboundShipmentItemInput!]!
  salesOrderId: ID!
  status: OutboundShipmentStatus
  trackingNumber: String
  warehouseId: ID!
}

input CreateOutboundShipmentItemInput {
  batchId: ID
  productId: ID!
  quantityShipped: Int!
  salesOrderItemId: ID!
}

input CreatePackageInput {
  carrier: String
  height: Float
  insuranceValue: Float
  isFragile: Boolean
  isHazmat: Boolean
  length: Float
  packageNumber: String!
  packageType: String
  packedAt: String
  packedByUserId: ID
  requiresSignature: Boolean
  salesOrderId: ID!
  serviceLevel: String
  shippedAt: String
  trackingNumber: String
  warehouseId: ID!
  weight: Float
  width: Float
}

input CreatePackageItemInput {
  batchId: ID
  expiryDate: String
  lotNumber: String
  packageId: ID!
  productId: ID!
  quantity: Int!
  serialNumbers: [String!]!
  unitWeight: Float
}

input CreatePartnerInvoiceInput {
  carrierId: ID!
  invoiceDate: String!
  invoiceNumber: String!
  items: [CreatePartnerInvoiceItemInput!]!
  status: PartnerInvoiceStatus
}

input CreatePartnerInvoiceItemInput {
  amount: Float!
  shipmentLegId: ID!
}

input CreatePaymentInput {
  amount: Float!
  currency: String
  exchangeRate: Float
  fees: Float
  gatewayReference: String
  invoiceId: ID!
  notes: String
  paymentDate: String
  paymentMethod: PaymentMethod!
  processedAt: String
  processedByUserId: ID
  status: PaymentStatus
  transactionId: String
}

input CreatePickBatchInput {
  assignedUserId: ID
  batchNumber: String!
  estimatedDuration: Int
  items: [CreatePickBatchItemInput!]!
  priority: Int
  startedAt: String
  status: PickBatchStatus
  strategy: PickStrategy!
  warehouseId: ID!
  waveId: String
  zoneRestrictions: [String!]!
}

input CreatePickBatchItemInput {
  actualPickTime: Int
  estimatedPickTime: Int
  orderPriority: Int
  salesOrderId: ID!
}

input CreateProductInput {
  description: String
  name: String!
  price: Float!
  sku: String
  type: ProductType
}

input CreateProofOfDeliveryInput {
  files: [File!]!
  latitude: Float
  longitude: Float
  tripStopId: ID!
  type: ProofType
}

input CreatePutawayRuleInput {
  clientId: ID
  isActive: Boolean
  locationType: LocationType
  maxQuantity: Int
  minQuantity: Int
  preferredLocationId: ID
  priority: Int!
  productId: ID!
  requiresHazmatApproval: Boolean
  requiresTemperatureControl: Boolean
  volumeThreshold: Float
  warehouseId: ID!
  weightThreshold: Float
}

input CreateQuoteInput {
  clientId: ID
  createdByUserId: ID
  destinationDetails: String!
  expiresAt: String
  height: Float
  length: Float
  notes: String
  originDetails: String!
  quoteNumber: String
  quotedPrice: Float!
  serviceLevel: String
  status: QuoteStatus
  weight: Float
  width: Float
}

input CreateRateCardInput {
  createdByUserId: ID
  description: String
  isActive: Boolean
  name: String!
  serviceType: ServiceType!
  validFrom: String!
  validTo: String
}

input CreateRateRuleInput {
  condition: String!
  isActive: Boolean
  maxValue: Float
  minValue: Float
  price: Float!
  pricingModel: PricingModel!
  priority: Int
  rateCardId: ID!
  value: String!
}

input CreateReorderPointInput {
  productId: ID!
  threshold: Int!
  warehouseId: ID!
}

input CreateReturnInput {
  clientId: ID!
  items: [CreateReturnItemInput!]!
  reason: String
  returnNumber: String!
  salesOrderId: ID
  status: ReturnStatus
}

input CreateReturnItemInput {
  condition: ReturnItemCondition
  productId: ID!
  quantityExpected: Int!
}

input CreateRouteInput {
  optimizedRouteData: String
  totalDistance: Float
  totalDuration: Float
  tripId: ID!
}

input CreateSalesOrderInput {
  clientId: ID!
  crmOpportunityId: ID
  items: [CreateSalesOrderItemInput!]!
  orderNumber: String!
  shippingAddress: String
  status: SalesOrderStatus
}

input CreateSalesOrderItemInput {
  productId: ID!
  quantityOrdered: Int!
}

input CreateShipmentLegEventInput {
  location: String
  shipmentLegId: ID!
  statusMessage: String
}

input CreateShipmentLegInput {
  carrierId: ID
  endLocation: String
  internalTripId: ID
  legSequence: Int!
  shipmentId: ID!
  startLocation: String
  status: ShipmentLegStatus
}

input CreateStockTransferInput {
  destinationWarehouseId: ID!
  productId: ID!
  quantity: Int!
  sourceWarehouseId: ID!
  status: StockTransferStatus
}

input CreateSupplierInput {
  contactPerson: String
  email: String
  name: String!
  phoneNumber: String
}

input CreateSurchargeInput {
  amount: Float!
  calculationMethod: SurchargeCalculationMethod!
  description: String
  isActive: Boolean
  name: String!
  type: String!
  validFrom: String
  validTo: String
}

input CreateTaskEventInput {
  deliveryTaskId: ID!
  latitude: Float
  longitude: Float
  notes: String
  reason: String
  status: TaskEventStatus!
  timestamp: String
}

input CreateTaskInput {
  actualDuration: Int
  endTime: Date
  estimatedDuration: Int
  instructions: String
  notes: String
  pickBatchId: ID
  priority: Int
  sourceEntityId: ID
  sourceEntityType: String
  startTime: Date
  status: TaskStatus
  taskNumber: String!
  type: TaskType!
  userId: ID
  warehouseId: ID!
}

input CreateTaskItemInput {
  batchId: ID
  destinationLocationId: ID
  expiryDate: String
  lotNumber: String
  notes: String
  productId: ID!
  quantityCompleted: Int!
  quantityRequired: Int!
  serialNumbers: [String!]!
  sourceLocationId: ID
  status: TaskItemStatus
}

input CreateTripInput {
  driverId: ID
  endLocation: String
  endTime: String
  startLocation: String
  startTime: String
  status: TripStatus
  vehicleId: ID
}

input CreateTripStopInput {
  address: String
  estimatedArrivalTime: String
  estimatedDepartureTime: String
  sequence: Int!
  shipmentId: ID
  status: TripStopStatus
  tripId: ID!
}

input CreateVehicleInput {
  capacityVolume: Float
  capacityWeight: Float
  currentMileage: Int
  lastMaintenanceDate: String
  make: String
  model: String
  registrationNumber: String!
  status: VehicleStatus
  vin: String
  year: Int
}

input CreateVehicleMaintenanceInput {
  cost: Float
  notes: String
  serviceDate: Date!
  serviceType: VehicleServiceType
}

input CreateWarehouseInput {
  address: String
  city: String
  contactEmail: String
  contactPerson: String
  contactPhone: String
  country: String
  isActive: Boolean
  name: String!
  postalCode: String
  state: String
  timezone: String
}

input CreateWmsProductInput {
  barcode: String
  clientId: ID
  costPrice: Float
  description: String
  height: Float
  length: Float
  name: String!
  sku: String!
  status: ProductStatus
  supplierId: ID
  weight: Float
  width: Float
}

type CreditNoteAppliedEvent {
  appliedAmount: String!
  creditNote: CreditNotes!
}

type CreditNoteOnDisputeApprovalEvent {
  creditNote: CreditNotes!
  disputeId: ID!
}

type CreditNotes {
  amount: Float!
  appliedAt: String
  createdAt: Date
  createdByUser: User
  creditNoteNumber: String!
  currency: String
  dispute: Disputes
  id: ID!
  invoice: BillingInvoices!
  issueDate: String!
  notes: String
  reason: String!
  updatedAt: Date
}

type CrmCaseAssignedEvent {
  id: ID!
  ownerId: ID!
  previousOwnerId: ID!
}

type CrmCaseStatusChangedEvent {
  id: ID!
  newStatus: CaseStatus!
  previousStatus: CaseStatus!
}

enum CrmInvoicePaymentMethod {
  BANK_TRANSFER
  CASH
  CHECK
  CREDIT_CARD
  MAYA
  OTHER
  PAYPAL
  STRIPE
  WIRE_TRANSFER
}

type CrmInvoiceStatusChangedEvent {
  id: ID!
  newStatus: InvoiceStatus!
  previousStatus: InvoiceStatus!
}

type CrmLeadStatusChangedEvent {
  id: ID!
  newStatus: LeadStatus!
  previousStatus: LeadStatus!
}

type CrmMutation {
  addInvoiceItem(id: ID!, value: AddInvoiceItemInput!): InvoiceItems!
  addOpportunityProduct(id: ID!, value: CreateOpportunityProductInput!): OpportunityProducts!
  createAttachment(value: CreateAttachmentInput!): Attachments!
  createCampaign(value: CreateCampaignInput!): Campaigns!
  createCase(value: CreateCaseInput!): Cases!
  createCompany(value: CreateCompanyInput!): Companies!
  createContact(value: CreateContactInput!): Contacts!
  createInteraction(value: CreateInteractionInput!): Interactions!
  createInvoice(value: CreateInvoiceInput!): Invoices!
  createLead(value: CreateLeadInput!): Leads!
  createNotification(value: CreateNotificationInput!): Notifications!
  createOpportunity(value: CreateOpportunityInput!): Opportunities!
  createProduct(value: CreateProductInput!): Products!
  removeAttachment(id: ID!): DeleteResult!
  removeCampaign(id: ID!): DeleteResult!
  removeCase(id: ID!): DeleteResult!
  removeCompany(id: ID!): DeleteResult!
  removeContact(id: ID!): DeleteResult!
  removeInteraction(id: ID!): DeleteResult!
  removeInvoiceItem(id: ID!): DeleteResult!
  removeLead(id: ID!): DeleteResult!
  removeOpportunityProduct(id: ID!): DeleteResult!
  removeProduct(id: ID!): DeleteResult!
  updateCampaign(id: ID!, value: UpdateCampaignInput): Campaigns!
  updateCase(id: ID!, value: UpdateCaseInput): Cases!
  updateCompany(id: ID!, value: UpdateCompanyInput): Companies!
  updateContact(id: ID!, value: UpdateContactInput): Contacts!
  updateInteraction(id: ID!, value: UpdateInteractionInput): Interactions!
  updateInvoice(id: ID!, value: UpdateInvoiceInput): Invoices!
  updateInvoiceItem(id: ID!, value: UpdateInvoiceItemInput!): InvoiceItems!
  updateLead(id: ID!, value: UpdateLeadInput): Leads!
  updateNotification(id: ID!, value: UpdateNotificationInput): Notifications!
  updateOpportunity(id: ID!, value: UpdateOpportunityInput!): Opportunities!
  updateOpportunityProduct(id: ID!, value: UpdateOpportunityProductInput!): OpportunityProducts!
  updateProduct(id: ID!, value: UpdateProductInput): Products!
}

type CrmNotificationMarkedEvent {
  id: ID!
  isRead: Boolean!
  userId: ID!
}

type CrmOpportunityStageChangedEvent {
  id: ID!
  newStage: OpportunityStage!
  previousStage: OpportunityStage!
  probability: Float
}

type CrmQuery {
  attachment(id: ID!): Attachments!
  attachments(from: Date, page: Int, perPage: Int, search: String, to: Date): [Attachments!]!
  campaign(id: ID!): Campaigns!
  campaigns(from: Date, page: Int, perPage: Int, search: String, to: Date): [Campaigns!]!
  case(id: ID!): Cases!
  cases(from: Date, page: Int, perPage: Int, priority: CasePriority, search: String, status: CaseStatus, to: Date, type: CaseType): [Cases!]!
  companies(from: Date, page: Int, perPage: Int, search: String, to: Date): [Companies!]!
  company(id: ID!): Companies!
  contact(id: ID!): Contacts!
  contacts(from: Date, page: Int, perPage: Int, search: String, to: Date): [Contacts!]!
  interaction(id: ID!): Interactions!
  interactions(from: Date, interactionType: InteractionType, page: Int, perPage: Int, search: String, to: Date): [Interactions!]!
  invoice(id: ID!): Invoices!
  invoices(from: Date, page: Int, paymentMethod: CrmInvoicePaymentMethod, perPage: Int, search: String, status: InvoiceStatus, to: Date): [Invoices!]!
  lead(id: ID!): Leads!
  leads(from: Date, leadSource: LeadSource, page: Int, perPage: Int, search: String, status: LeadStatus, to: Date): [Leads!]!
  notification(id: ID!): Notifications!
  notifications(from: Date, page: Int, perPage: Int, search: String, to: Date): [Notifications!]!
  opportunities(from: Date, page: Int, perPage: Int, search: String, source: OpportunitySource, stage: OpportunityStage, to: Date): [Opportunities!]!
  opportunity(id: ID!): Opportunities!
  product(id: ID!): Products!
  products(from: Date, page: Int, perPage: Int, search: String, to: Date, type: ProductType): [Products!]!
}

type CrmSubscription {
  caseAssigned: CrmCaseAssignedEvent!
  caseStatusChanged: CrmCaseStatusChangedEvent!
  invoicePaid: Invoices!
  invoiceStatusChanged: CrmInvoiceStatusChangedEvent!
  leadConverted: Leads!
  leadStatusChanged: CrmLeadStatusChangedEvent!
  notificationMarked: CrmNotificationMarkedEvent!
  opportunityLost: Opportunities!
  opportunityStageChanged: CrmOpportunityStageChangedEvent!
  opportunityWon: Opportunities!
}

enum Currency {
  AUD
  CAD
  EUR
  GBP
  JPY
  PHP
  USD
}

type CustomerTrackingLinks {
  accessCount: Int
  createdAt: Date
  deliveryTask: DeliveryTasks!
  expiresAt: String
  id: ID!
  isActive: Boolean
  lastAccessedAt: String
  trackingToken: String!
  updatedAt: Date
}

scalar Date

type DeleteResult {
  numDeletedRows: Int!
  success: Boolean!
}

enum DeliveryFailureReason {
  ACCESS_DENIED
  ADDRESS_NOT_FOUND
  DAMAGED_PACKAGE
  OTHER
  RECIPIENT_NOT_HOME
  REFUSED_DELIVERY
  VEHICLE_BREAKDOWN
  WEATHER_CONDITIONS
}

enum DeliveryRouteStatus {
  CANCELLED
  COMPLETED
  IN_PROGRESS
  PAUSED
  PLANNED
}

type DeliveryRoutes {
  actualDurationMinutes: Int
  completedAt: String
  createdAt: Date
  driver: Drivers!
  estimatedDurationMinutes: Int
  id: ID!
  optimizedRouteData: String
  routeDate: String!
  startedAt: String
  status: DeliveryRouteStatus
  tasks: [DeliveryTasks!]
  totalDistanceKm: Float
  updatedAt: Date
}

enum DeliveryTaskStatus {
  ASSIGNED
  CANCELLED
  DELIVERED
  FAILED
  OUT_FOR_DELIVERY
  PENDING
  RESCHEDULED
}

type DeliveryTasks {
  actualArrivalTime: String
  attemptCount: Int
  createdAt: Date
  customerTrackingLinks: [CustomerTrackingLinks!]
  deliveryAddress: String!
  deliveryInstructions: String
  deliveryRoute: DeliveryRoutes!
  deliveryTime: String
  estimatedArrivalTime: String
  events: [TaskEvents!]
  failureReason: DeliveryFailureReason
  id: ID!
  package: Packages!
  proofOfDeliveries: [DmsProofOfDeliveries!]
  recipientName: String
  recipientPhone: String
  routeSequence: Int!
  status: DeliveryTaskStatus
  updatedAt: Date
}

type DisputeApprovedEvent {
  creditNoteId: ID
  dispute: Disputes!
}

type DisputeDeniedEvent {
  denialReason: String
  dispute: Disputes!
}

type DisputeResolvedEvent {
  dispute: Disputes!
  resolutionDetails: String
}

enum DisputeStatus {
  APPROVED
  CLOSED
  DENIED
  ESCALATED
  OPEN
  UNDER_REVIEW
}

type DisputeStatusChangedEvent {
  clientId: ID!
  id: ID!
  newStatus: DisputeStatus!
  previousStatus: DisputeStatus!
}

type Disputes {
  client: Companies!
  createdAt: Date
  creditNotes: [CreditNotes!]
  disputedAmount: Float
  id: ID!
  lineItem: InvoiceLineItems!
  reason: String!
  resolutionNotes: String
  resolvedAt: String
  resolvedByUser: User
  status: DisputeStatus
  submittedAt: String
  updatedAt: Date
}

type DmsDeliveryTaskFailedEvent {
  deliveryTask: DeliveryTasks!
  failureReason: String
}

type DmsDeliveryTaskStatusChangedEvent {
  deliveryRouteId: ID!
  id: ID!
  newStatus: DeliveryTaskStatus!
  previousStatus: DeliveryTaskStatus!
}

type DmsDriverLocationRemovedEvent {
  driverId: ID!
  id: ID!
}

type DmsMutation {
  createCustomerTrackingLink(value: CreateCustomerTrackingLinkInput!): CustomerTrackingLinks!
  createDeliveryRoute(value: CreateDeliveryRouteInput!): DeliveryRoutes!
  createDeliveryTask(value: CreateDeliveryTaskInput!): DeliveryTasks!
  createDmsProofOfDelivery(value: CreateDmsProofOfDeliveryInput!): DmsProofOfDeliveries!
  createDriverLocation(value: CreateDriverLocationInput!): DriverLocations!
  createTaskEvent(value: CreateTaskEventInput!): TaskEvents!
  removeDeliveryRoute(id: ID!): DeleteResult!
  removeDriverLocation(id: ID!): DeleteResult!
  updateCustomerTrackingLink(id: ID!, value: UpdateCustomerTrackingLinkInput): CustomerTrackingLinks!
  updateDeliveryRoute(id: ID!, value: UpdateDeliveryRouteInput): DeliveryRoutes!
  updateDeliveryTask(id: ID!, value: UpdateDeliveryTaskInput): DeliveryTasks!
  updateDriverLocation(id: ID!, value: UpdateDriverLocationInput): DriverLocations!
}

type DmsProofOfDeliveries {
  createdAt: Date
  deliveryTask: DeliveryTasks!
  filePath: String
  id: ID!
  latitude: Float
  longitude: Float
  recipientName: String
  signatureData: String
  timestamp: String
  type: ProofOfDeliveryType!
  updatedAt: Date
  verificationCode: String
}

type DmsQuery {
  customerTrackingLink(id: ID!): CustomerTrackingLinks!
  customerTrackingLinks(from: Date, page: Int, perPage: Int, search: String, to: Date): [CustomerTrackingLinks!]!
  deliveryRoute(id: ID!): DeliveryRoutes!
  deliveryRoutes(from: Date, page: Int, perPage: Int, search: String, status: DeliveryRouteStatus, to: Date): [DeliveryRoutes!]!
  deliveryTask(id: ID!): DeliveryTasks!
  deliveryTasks(failureReason: DeliveryFailureReason, from: Date, page: Int, perPage: Int, search: String, status: DeliveryTaskStatus, to: Date): [DeliveryTasks!]!
  dmsProofOfDeliveries(from: Date, page: Int, perPage: Int, search: String, to: Date, type: ProofOfDeliveryType): [DmsProofOfDeliveries!]!
  dmsProofOfDelivery(id: ID!): DmsProofOfDeliveries!
  driverLocation(id: ID!): DriverLocations!
  driverLocations(from: Date, page: Int, perPage: Int, to: Date): [DriverLocations!]!
  taskEvent(id: ID!): TaskEvents!
  taskEvents(from: Date, page: Int, perPage: Int, search: String, status: TaskEventStatus, to: Date): [TaskEvents!]!
}

type DmsSubscription {
  deliveryRouteCancelled: DeliveryRoutes!
  deliveryRouteCompleted: DeliveryRoutes!
  deliveryRoutePaused: DeliveryRoutes!
  deliveryRouteStarted: DeliveryRoutes!
  deliveryTaskDelivered: DeliveryTasks!
  deliveryTaskFailed: DmsDeliveryTaskFailedEvent!
  deliveryTaskOutForDelivery: DeliveryTasks!
  deliveryTaskStatusChanged: DmsDeliveryTaskStatusChangedEvent!
  driverLocationRemoved: DmsDriverLocationRemovedEvent!
  driverLocationUpdated: DriverLocations!
  proofOfDeliveryRecorded: DmsProofOfDeliveries!
  taskEventRecorded: TaskEvents!
  taskEventStatusUpdated: DmsTaskEventStatusUpdatedEvent!
  trackingLinkExpired: DmsTrackingLinkExpiredEvent!
  trackingLinkGenerated: CustomerTrackingLinks!
}

type DmsTaskEventStatusUpdatedEvent {
  deliveryTaskId: ID!
  newStatus: TaskEventStatus!
  taskEventId: ID!
}

type DmsTrackingLinkExpiredEvent {
  deliveryTaskId: ID!
  id: ID!
  trackingToken: String!
}

type DocumentGeneratedEvent {
  documentId: ID!
  documentType: String!
  shipmentId: ID!
}

enum DocumentType {
  BOL
  COMMERCIAL_INVOICE
  CREDIT_NOTE
  CUSTOMS_DECLARATION
  PACKING_LIST
  PROOF_OF_DELIVERY
  RECEIPT
  SHIPPING_LABEL
}

type Documents {
  createdAt: Date
  documentType: DocumentType!
  fileName: String!
  filePath: String!
  fileSize: Int
  id: ID!
  mimeType: String
  recordId: ID!
  recordType: String!
  updatedAt: Date
  uploadedByUser: User
}

type DriverLocations {
  accuracy: Float
  altitude: Float
  createdAt: Date
  driver: Drivers!
  heading: Float
  id: ID!
  latitude: Float!
  longitude: Float!
  speedKmh: Float
  timestamp: String
  updatedAt: Date
}

enum DriverScheduleReason {
  PERSONAL_LEAVE
  SICK_LEAVE
  TRAINING
  VACATION
}

type DriverSchedules {
  createdAt: Date
  driver: Drivers!
  endDate: String!
  id: ID!
  reason: DriverScheduleReason
  startDate: String!
  updatedAt: Date
}

enum DriverStatus {
  ACTIVE
  INACTIVE
  ON_LEAVE
}

type Drivers {
  contactPhone: String
  createdAt: Date
  deliveryRoutes: [DeliveryRoutes!]
  driverLocations: [DriverLocations!]
  expenses: [Expenses!]
  id: ID!
  licenseExpiryDate: String
  licenseNumber: String!
  schedules: [DriverSchedules!]
  status: DriverStatus
  trips: [Trips!]
  updatedAt: Date
  user: User!
}

enum ExpenseStatus {
  APPROVED
  PENDING
  REIMBURSED
  REJECTED
}

enum ExpenseType {
  ACCOMMODATION
  FUEL
  MAINTENANCE
  MEALS
  PARKING
  TOLLS
}

type Expenses {
  amount: Float!
  createdAt: Date
  currency: Currency
  description: String
  driver: Drivers
  expenseDate: String
  fuelQuantity: Float
  id: ID!
  odometerReading: Int
  receiptUrl: String
  status: ExpenseStatus
  trip: Trips
  type: ExpenseType
  updatedAt: Date
}

scalar File

enum GeofenceEventType {
  ENTER
  EXIT
}

type GeofenceEvents {
  eventType: GeofenceEventType!
  geofence: Geofences!
  id: ID!
  timestamp: String!
  vehicle: Vehicles!
}

type Geofences {
  createdAt: Date
  events: [GeofenceEvents!]
  id: ID!
  latitude: Float
  longitude: Float
  name: String!
  updatedAt: Date
}

type GpsPings {
  id: ID!
  latitude: Float!
  longitude: Float!
  timestamp: Date!
  vehicle: Vehicles!
}

type InboundShipmentItems {
  createdAt: Date
  discrepancyNotes: String
  discrepancyQuantity: Int
  expectedQuantity: Int!
  id: ID!
  inboundShipment: InboundShipments!
  product: WmsProducts!
  receivedQuantity: Int
  updatedAt: Date
}

enum InboundShipmentStatus {
  ARRIVED
  CANCELLED
  COMPLETED
  PENDING
  PROCESSING
}

type InboundShipments {
  actualArrivalDate: String
  client: Companies
  createdAt: Date
  expectedArrivalDate: String
  id: ID!
  items: [InboundShipmentItems!]
  status: InboundShipmentStatus
  updatedAt: Date
  warehouseId: ID!
}

enum InteractionOutcome {
  COMPLETED
  NO_ANSWER
  OTHER
  SCHEDULED
}

enum InteractionType {
  CALL
  EMAIL
  MEETING
  TEXT
}

type Interactions {
  case: Cases
  contact: Contacts!
  createdAt: Date
  id: ID!
  interactionDate: Date
  notes: String
  outcome: InteractionOutcome
  type: InteractionType
  updatedAt: Date
  user: User
}

enum InventoryAdjustmentReason {
  CYCLE_COUNT
  DAMAGED_GOODS
  EXPIRED
  MANUAL_CORRECTION
  RETURN_TO_VENDOR
  THEFT
}

type InventoryAdjustments {
  createdAt: Date
  id: ID!
  notes: String
  product: WmsProducts!
  quantityChange: Int!
  reason: InventoryAdjustmentReason
  updatedAt: Date
  user: User!
  warehouseId: ID!
}

type InventoryBatches {
  batchNumber: String!
  createdAt: Date
  expirationDate: Date
  id: ID!
  inventoryStock: [InventoryStock!]
  outboundShipmentItems: [OutboundShipmentItems!]
  packageItems: [PackageItems!]
  product: WmsProducts!
  taskItems: [TaskItems!]
  updatedAt: Date
}

type InventoryStock {
  availableQuantity: Int
  batch: InventoryBatches
  createdAt: Date
  id: ID!
  lastCountedAt: Date
  lastMovementAt: Date
  location: Locations!
  product: WmsProducts!
  quantity: Int!
  reservedQuantity: Int!
  status: InventoryStockStatus
  updatedAt: Date
}

enum InventoryStockStatus {
  ALLOCATED
  AVAILABLE
  DAMAGED
  EXPIRED
  HOLD
  QUARANTINE
  SHIPPED
}

type InvoiceDisputedEvent {
  disputeId: ID!
  invoice: BillingInvoices!
}

type InvoiceItems {
  createdAt: Date
  id: ID!
  invoice: Invoices!
  price: Float!
  product: Products!
  quantity: Float!
  updatedAt: Date
}

type InvoiceLineItems {
  createdAt: Date
  description: String!
  discountAmount: Float
  discountRate: Float
  disputes: [Disputes!]
  id: ID!
  invoice: BillingInvoices!
  lineTotal: Float
  quantity: Float!
  sourceRecordId: ID
  sourceRecordType: String
  taxAmount: Float
  taxRate: Float
  totalPrice: Float
  unitPrice: Float!
  updatedAt: Date
}

type InvoiceOverdueEvent {
  amountOutstanding: String!
  clientId: ID!
  dueDate: String!
  id: ID!
}

type InvoicePaidEvent {
  invoice: BillingInvoices!
  paidAmount: String!
  remainingBalance: String!
}

type InvoicePartiallyPaidEvent {
  invoice: BillingInvoices!
  paymentAmount: String!
  remainingBalance: String!
}

enum InvoiceStatus {
  CANCELLED
  DRAFT
  OVERDUE
  PAID
  SENT
}

type InvoiceStatusChangedEvent {
  clientId: ID!
  id: ID!
  newStatus: BillingInvoiceStatus!
  previousStatus: BillingInvoiceStatus!
}

type Invoices {
  createdAt: Date
  dueDate: Date!
  id: ID!
  issueDate: Date!
  items: [InvoiceItems!]
  opportunity: Opportunities!
  paidAt: Date
  paymentMethod: CrmInvoicePaymentMethod
  sentAt: Date
  status: InvoiceStatus
  total: Float!
  updatedAt: Date
}

enum LeadSource {
  ADVERTISMENT
  COLD_CALL
  EMAIL_CAMPAIGN
  EVENT
  OTHER
  PARTNER
  REFERRAL
  SOCIAL_MEDIA
  WEBSITE
}

enum LeadStatus {
  CONTACTED
  CONVERTED
  NEW
  QUALIFIED
  UNQUALIFIED
}

type Leads {
  campaign: Campaigns
  convertedAt: Date
  convertedCompany: Companies
  convertedContact: Contacts
  convertedOpportunity: Opportunities
  createdAt: Date
  email: String
  id: ID!
  leadScore: Int
  leadSource: LeadSource
  name: String!
  owner: User
  status: LeadStatus
  updatedAt: Date
}

enum LocationType {
  BULK_STORAGE
  CROSS_DOCK_AREA
  DAMAGED_GOODS
  PACKING_STATION
  PICK_BIN
  QUALITY_CONTROL
  RECEIVING_DOCK
  RESERVE_STORAGE
  RETURNS_AREA
  STAGING_AREA
}

type Locations {
  barcode: String
  binThresholds: [BinThresholds!]
  createdAt: Date
  destinationTaskItems: [TaskItems!]
  hazmatApproved: Boolean
  id: ID!
  inventoryStock: [InventoryStock!]
  isActive: Boolean
  isPickable: Boolean
  isReceivable: Boolean
  level: Int
  maxPallets: Int
  maxVolume: Float
  maxWeight: Float
  name: String!
  parentLocation: Locations
  path: String
  putawayRules: [PutawayRules!]
  sourceTaskItems: [TaskItems!]
  temperatureControlled: Boolean
  type: LocationType!
  updatedAt: Date
  warehouse: Warehouses!
  xCoordinate: Float
  yCoordinate: Float
  zCoordinate: Float
}

type Mutation {
  billing: BillingMutation
  crm: CrmMutation
  dms: DmsMutation
  tms: TmsMutation
  wms: WmsMutation
}

type Notifications {
  createdAt: Date
  id: ID!
  isRead: Boolean
  link: String
  message: String!
  updatedAt: Date
  user: User!
}

type Opportunities {
  campaign: Campaigns
  company: Companies
  contact: Contacts
  createdAt: Date
  dealValue: Float
  expectedCloseDate: Date
  id: ID!
  lostReason: String
  name: String!
  owner: User
  probability: Float
  products: [OpportunityProducts!]
  salesOrders: [SalesOrders!]
  source: OpportunitySource
  stage: OpportunityStage
  updatedAt: Date
}

type OpportunityProducts {
  id: ID!
  opportunity: Opportunities!
  product: Products!
  quantity: Float!
}

enum OpportunitySource {
  ADVERTISMENT
  COLD_CALL
  EMAIL_CAMPAIGN
  EVENT
  EXISTING_CUSTOMER
  OTHER
  PARTNER
  REFERRAL
  SOCIAL_MEDIA
  WEBSITE
}

enum OpportunityStage {
  CLOSED_LOST
  CLOSED_WON
  DEMO
  NEED_ANALYSIS
  NEGOTIATION
  PROPOSAL
  PROSPECTING
  QUALIFICATION
}

type OutboundShipmentItems {
  batch: InventoryBatches
  createdAt: Date
  id: ID!
  outboundShipment: OutboundShipments!
  product: WmsProducts!
  quantityShipped: Int!
  salesOrderItem: SalesOrderItems!
  updatedAt: Date
}

enum OutboundShipmentStatus {
  CANCELLED
  DELIVERED
  PACKED
  PICKING
  SHIPPED
}

type OutboundShipments {
  carrier: String
  createdAt: Date
  id: ID!
  items: [OutboundShipmentItems!]
  salesOrder: SalesOrders!
  status: OutboundShipmentStatus
  trackingNumber: String
  updatedAt: Date
  warehouseId: ID!
}

type PackageItems {
  batch: InventoryBatches
  createdAt: Date
  expiryDate: String
  id: ID!
  lotNumber: String
  package: Packages!
  product: WmsProducts!
  quantity: Int!
  serialNumbers: [String!]!
  totalWeight: Float
  unitWeight: Float
  updatedAt: Date
}

type Packages {
  carrier: String
  createdAt: Date
  deliveryTasks: [DeliveryTasks!]
  height: Float
  id: ID!
  insuranceValue: Float
  isFragile: Boolean
  isHazmat: Boolean
  items: [PackageItems!]
  length: Float
  packageNumber: String!
  packageType: String
  packedAt: String
  packedByUser: User
  requiresSignature: Boolean
  salesOrder: SalesOrders!
  serviceLevel: String
  shippedAt: String
  trackingNumber: String
  updatedAt: Date
  volume: Float
  warehouse: Warehouses!
  weight: Float
  width: Float
}

type PartnerInvoiceItems {
  amount: Float!
  id: ID!
  partnerInvoice: PartnerInvoices!
  shipmentLeg: ShipmentLegs!
}

enum PartnerInvoiceStatus {
  CANCELLED
  DISPUTED
  OVERDUE
  PAID
  PENDING
}

type PartnerInvoices {
  carrier: Carriers!
  createdAt: Date
  id: ID!
  invoiceDate: String!
  invoiceNumber: String!
  items: [PartnerInvoiceItems!]
  status: PartnerInvoiceStatus
  totalAmount: Float!
  updatedAt: Date
}

type PaymentFailedEvent {
  failureReason: String
  payment: Payments!
}

enum PaymentMethod {
  BANK_TRANSFER
  CASH
  CHECK
  CLIENT_CREDIT
  CREDIT_CARD
  DEBIT_CARD
  QR_PH
  WALLET
}

type PaymentRefundedEvent {
  payment: Payments!
  refundAmount: String!
}

enum PaymentStatus {
  CANCELLED
  FAILED
  PENDING
  PROCESSING
  REFUNDED
  SUCCESSFUL
}

type PaymentStatusChangedEvent {
  id: ID!
  invoiceId: ID!
  newStatus: PaymentStatus!
  previousStatus: PaymentStatus!
}

type Payments {
  amount: Float!
  createdAt: Date
  currency: String
  exchangeRate: Float
  fees: Float
  gatewayReference: String
  id: ID!
  invoice: BillingInvoices!
  netAmount: Float
  notes: String
  paymentDate: String
  paymentMethod: PaymentMethod!
  processedAt: String
  processedByUser: User
  status: PaymentStatus
  transactionId: String
  updatedAt: Date
}

type PickBatchItems {
  actualPickTime: Int
  createdAt: Date
  estimatedPickTime: Int
  id: ID!
  orderPriority: Int
  pickBatch: PickBatches!
  salesOrder: SalesOrders!
  updatedAt: Date
}

enum PickBatchStatus {
  CANCELLED
  COMPLETED
  IN_PROGRESS
  OPEN
}

type PickBatches {
  actualDuration: Int
  assignedUser: User
  batchNumber: String!
  completedAt: String
  completedItems: Int
  createdAt: Date
  estimatedDuration: Int
  id: ID!
  items: [PickBatchItems!]
  priority: Int
  startedAt: String
  status: PickBatchStatus
  strategy: PickStrategy!
  tasks: [Tasks!]
  totalItems: Int
  updatedAt: Date
  warehouse: Warehouses!
  waveId: String
  zoneRestrictions: [String]
}

enum PickStrategy {
  BATCH_PICKING
  CLUSTER_PICKING
  SINGLE_ORDER_PICKING
  WAVE_PICKING
  ZONE_PICKING
}

enum PricingModel {
  FLAT_RATE
  PERCENTAGE
  PER_CUBIC_METER
  PER_ITEM
  PER_KG
  PER_ZONE
  TIERED
}

enum ProductStatus {
  ACTIVE
  DISCONTINUED
  INACTIVE
  OBSOLETE
}

enum ProductType {
  DIGITAL
  GOOD
  SERVICE
  SUBSCRIPTION
}

type Products {
  createdAt: Date
  description: String
  id: ID!
  name: String!
  price: Float!
  sku: String
  type: ProductType
  updatedAt: Date
}

type ProofOfDeliveries {
  createdAt: Date
  filePath: String
  id: ID!
  latitude: Float
  longitude: Float
  timestamp: String!
  tripStop: TripStops!
  type: ProofType
  updatedAt: Date
}

enum ProofOfDeliveryType {
  CODE_VERIFICATION
  CONTACTLESS_DELIVERY
  LEFT_AT_DOOR
  PHOTO
  SIGNATURE
}

enum ProofType {
  BARCODE_SCAN
  PHOTO
  PIN_VERIFICATION
  SIGNATURE
}

type PutawayRules {
  client: Companies
  createdAt: Date
  id: ID!
  isActive: Boolean
  locationType: LocationType
  maxQuantity: Int
  minQuantity: Int
  preferredLocation: Locations
  priority: Int!
  product: WmsProducts!
  requiresHazmatApproval: Boolean
  requiresTemperatureControl: Boolean
  updatedAt: Date
  volumeThreshold: Float
  warehouse: Warehouses!
  weightThreshold: Float
}

type Query {
  billing: BillingQuery
  crm: CrmQuery
  dms: DmsQuery
  tms: TmsQuery
  wms: WmsQuery
}

type QuoteConvertedEvent {
  invoiceId: ID!
  quote: Quotes!
}

type QuoteExpiredEvent {
  clientId: ID
  id: ID!
  quoteNumber: String
}

enum QuoteStatus {
  ACCEPTED
  CANCELLED
  CONVERTED
  EXPIRED
  PENDING
}

type QuoteStatusChangedEvent {
  clientId: ID
  id: ID!
  newStatus: QuoteStatus!
  previousStatus: QuoteStatus!
}

type Quotes {
  billingInvoices: [BillingInvoices!]
  client: Companies
  createdAt: Date
  createdByUser: User
  destinationDetails: String!
  expiresAt: String
  height: Float
  id: ID!
  length: Float
  notes: String
  originDetails: String!
  quoteNumber: String
  quotedPrice: Float!
  serviceLevel: String
  status: QuoteStatus
  updatedAt: Date
  volume: Float
  weight: Float
  width: Float
}

type RateCardDeactivatedEvent {
  id: ID!
  name: String!
  reason: String!
}

type RateCards {
  createdAt: Date
  createdByUser: User
  description: String
  id: ID!
  isActive: Boolean
  name: String!
  rules: [RateRules!]
  serviceType: ServiceType!
  updatedAt: Date
  validFrom: String!
  validTo: String
}

type RateRules {
  condition: String!
  createdAt: Date
  id: ID!
  isActive: Boolean
  maxValue: Float
  minValue: Float
  price: Float!
  pricingModel: PricingModel!
  priority: Int
  rateCard: RateCards!
  updatedAt: Date
  value: String!
}

enum RecordType {
  CAMPAIGNS
  CASES
  COMPANIES
  CONTACTS
  INTERACTIONS
  INVOICES
  LEADS
  OPPORTUNITIES
  PRODUCTS
}

type ReorderPoints {
  createdAt: Date
  id: ID!
  product: WmsProducts!
  threshold: Int!
  updatedAt: Date
  warehouse: Warehouses!
}

enum ReturnItemCondition {
  DAMAGED
  DEFECTIVE
  EXPIRED
  SELLABLE
  UNSELLABLE
}

type ReturnItems {
  condition: ReturnItemCondition
  createdAt: Date
  id: ID!
  product: WmsProducts!
  quantityExpected: Int!
  quantityReceived: Int
  quantityVariance: Int
  return: Returns!
  updatedAt: Date
}

enum ReturnStatus {
  APPROVED
  PROCESSED
  RECEIVED
  REJECTED
  REQUESTED
}

type Returns {
  client: Companies!
  createdAt: Date
  id: ID!
  items: [ReturnItems!]
  reason: String
  returnNumber: String!
  salesOrder: SalesOrders
  status: ReturnStatus
  updatedAt: Date
}

type Routes {
  createdAt: Date
  id: ID!
  optimizedRouteData: String
  totalDistance: Float
  totalDuration: Float
  trip: Trips!
  updatedAt: Date
}

type SalesOrderItems {
  createdAt: Date
  id: ID!
  outboundShipmentItems: [OutboundShipmentItems!]
  product: WmsProducts!
  quantityOrdered: Int!
  salesOrder: SalesOrders!
  updatedAt: Date
}

enum SalesOrderStatus {
  CANCELLED
  COMPLETED
  PENDING
  PROCESSING
  SHIPPED
}

type SalesOrders {
  client: Companies!
  createdAt: Date
  crmOpportunity: Opportunities
  id: ID!
  items: [SalesOrderItems!]
  orderNumber: String!
  outboundShipments: [OutboundShipments!]
  packages: [Packages!]
  pickBatchItems: [PickBatchItems!]
  returns: [Returns!]
  shippingAddress: String
  status: SalesOrderStatus
  updatedAt: Date
}

enum ServiceType {
  CUSTOMS
  FULFILLMENT
  HANDLING
  INSURANCE
  PACKAGING
  RETURNS
  SHIPPING
  STORAGE
}

type ShipmentCreatedFromPaymentEvent {
  paymentId: ID!
  quoteId: ID
  shipmentId: ID!
}

type ShipmentLegEvents {
  eventTimestamp: String!
  id: ID!
  location: String
  shipmentLeg: ShipmentLegs!
  statusMessage: String
}

enum ShipmentLegStatus {
  CANCELLED
  DELIVERED
  FAILED
  IN_TRANSIT
  PENDING
}

type ShipmentLegs {
  carrier: Carriers
  createdAt: Date
  endLocation: String
  events: [ShipmentLegEvents!]
  id: ID!
  internalTrip: Trips
  legSequence: Int!
  partnerInvoiceItems: [PartnerInvoiceItems!]
  shipment: OutboundShipments
  startLocation: String
  status: ShipmentLegStatus
  updatedAt: Date
}

enum StockTransferStatus {
  CANCELLED
  IN_TRANSIT
  PENDING
  RECEIVED
}

type StockTransfers {
  createdAt: Date
  destinationWarehouse: Warehouses!
  id: ID!
  product: WmsProducts!
  quantity: Int!
  sourceWarehouse: Warehouses!
  status: StockTransferStatus
  updatedAt: Date
}

type Subscription {
  billing: BillingSubscription
  crm: CrmSubscription
  dms: DmsSubscription
  tms: TmsSubscription
  wms: WmsSubscription
}

type Suppliers {
  contactPerson: String
  createdAt: Date
  email: String
  id: ID!
  name: String!
  phoneNumber: String
  products: [WmsProducts!]
  updatedAt: Date
}

enum SurchargeCalculationMethod {
  FIXED
  PERCENTAGE
  PER_UNIT
  SLIDING_SCALE
}

type SurchargeDeactivatedEvent {
  id: ID!
  reason: String!
}

type Surcharges {
  amount: Float!
  calculationMethod: SurchargeCalculationMethod!
  createdAt: Date
  description: String
  id: ID!
  isActive: Boolean
  name: String!
  type: String!
  updatedAt: Date
  validFrom: String
  validTo: String
}

enum SyncStatus {
  FAILED
  IN_PROGRESS
  PENDING
  RETRY
  SUCCESS
}

enum TaskEventStatus {
  ARRIVED
  ASSIGNED
  CANCELLED
  DELIVERED
  EXCEPTION
  FAILED
  RESCHEDULED
  STARTED
}

type TaskEvents {
  createdAt: Date
  deliveryTask: DeliveryTasks!
  id: ID!
  latitude: Float
  longitude: Float
  notes: String
  reason: String
  status: TaskEventStatus!
  timestamp: String
  updatedAt: Date
}

enum TaskItemStatus {
  COMPLETED
  DAMAGED
  IN_PROGRESS
  NOT_FOUND
  PENDING
  SHORT_PICKED
}

type TaskItems {
  batch: InventoryBatches
  completedAt: String
  createdAt: Date
  destinationLocation: Locations
  expiryDate: String
  id: ID!
  lotNumber: String
  notes: String
  product: WmsProducts!
  quantityCompleted: Int!
  quantityRemaining: Int
  quantityRequired: Int!
  serialNumbers: [String]
  sourceLocation: Locations
  status: TaskItemStatus
  task: Tasks!
  updatedAt: Date
}

enum TaskStatus {
  ASSIGNED
  CANCELLED
  COMPLETED
  ERROR
  IN_PROGRESS
  PENDING
}

enum TaskType {
  CROSS_DOCK
  CYCLE_COUNT
  DAMAGE_INSPECTION
  PACK
  PICK
  PUTAWAY
  QUALITY_CHECK
  REPLENISHMENT
  RETURNS_PROCESSING
}

type Tasks {
  actualDuration: Int
  createdAt: Date
  durationSeconds: Int
  endTime: String
  estimatedDuration: Int
  id: ID!
  instructions: String
  items: [TaskItems!]
  notes: String
  pickBatch: PickBatches
  priority: Int
  sourceEntityId: ID
  sourceEntityType: String
  startTime: String
  status: TaskStatus
  taskNumber: String!
  type: TaskType!
  updatedAt: Date
  user: User
  warehouse: Warehouses!
}

type TmsDriverStatusChangedEvent {
  id: ID!
  newStatus: DriverStatus!
  previousStatus: DriverStatus!
}

type TmsExpenseRejectedEvent {
  expense: Expenses!
  rejectionReason: String
}

type TmsExpenseStatusChangedEvent {
  driverId: ID
  id: ID!
  newStatus: ExpenseStatus!
  previousStatus: ExpenseStatus!
}

type TmsGeofenceEvent {
  geofenceEvent: GeofenceEvents!
  geofenceName: String!
}

type TmsMutation {
  addPartnerInvoiceItem(id: ID!, value: CreatePartnerInvoiceItemInput!): PartnerInvoiceItems!
  addVehicleMaintenance(id: ID!, value: CreateVehicleMaintenanceInput!): VehicleMaintenance!
  createCarrier(value: CreateCarrierInput!): Carriers!
  createCarrierRate(value: CreateCarrierRateInput!): CarrierRates!
  createDriver(value: CreateDriverInput!): Drivers!
  createDriverSchedule(value: CreateDriverScheduleInput!): DriverSchedules!
  createExpense(value: CreateExpenseInput!): Expenses!
  createGeofence(value: CreateGeofenceInput!): Geofences!
  createGeofenceEvent(value: CreateGeofenceEventInput!): GeofenceEvents!
  createGpsPing(value: CreateGpsPingInput!): GpsPings!
  createPartnerInvoice(value: CreatePartnerInvoiceInput!): PartnerInvoices!
  createProofOfDelivery(value: CreateProofOfDeliveryInput!): ProofOfDeliveries!
  createRoute(value: CreateRouteInput!): Routes!
  createShipmentLeg(value: CreateShipmentLegInput!): ShipmentLegs!
  createShipmentLegEvent(value: CreateShipmentLegEventInput!): ShipmentLegEvents!
  createTrip(value: CreateTripInput!): Trips!
  createTripStop(value: CreateTripStopInput!): TripStops!
  createVehicle(value: CreateVehicleInput!): Vehicles!
  removeCarrier(id: ID!): DeleteResult!
  removeCarrierRate(id: ID!): DeleteResult!
  removeDriver(id: ID!): DeleteResult!
  removeDriverSchedule(id: ID!): DeleteResult!
  removeExpense(id: ID!): DeleteResult!
  removeGeofence(id: ID!): DeleteResult!
  removePartnerInvoiceItem(id: ID!): DeleteResult!
  removeRoute(id: ID!): DeleteResult!
  removeTrip(id: ID!): DeleteResult!
  removeTripStop(id: ID!): DeleteResult!
  removeVehicle(id: ID!): DeleteResult!
  removeVehicleMaintenance(id: ID!): DeleteResult!
  updateCarrier(id: ID!, value: UpdateCarrierInput): Carriers!
  updateCarrierRate(id: ID!, value: UpdateCarrierRateInput): CarrierRates!
  updateDriver(id: ID!, value: UpdateDriverInput): Drivers!
  updateDriverSchedule(id: ID!, value: UpdateDriverScheduleInput): DriverSchedules!
  updateExpense(id: ID!, value: UpdateExpenseInput): Expenses!
  updateGeofence(id: ID!, value: UpdateGeofenceInput): Geofences!
  updateGeofenceEvent(id: ID!, value: UpdateGeofenceEventInput): GeofenceEvents!
  updateGpsPing(id: ID!, value: UpdateGpsPingInput): GpsPings!
  updatePartnerInvoice(id: ID!, value: UpdatePartnerInvoiceInput): PartnerInvoices!
  updatePartnerInvoiceItem(id: ID!, value: UpdatePartnerInvoiceItemInput): PartnerInvoiceItems!
  updateProofOfDelivery(id: ID!, value: UpdateProofOfDeliveryInput): ProofOfDeliveries!
  updateRoute(id: ID!, value: UpdateRouteInput): Routes!
  updateShipmentLeg(id: ID!, value: UpdateShipmentLegInput): ShipmentLegs!
  updateTrip(id: ID!, value: UpdateTripInput): Trips!
  updateTripStop(id: ID!, value: UpdateTripStopInput): TripStops!
  updateVehicle(id: ID!, value: UpdateVehicleInput): Vehicles!
  updateVehicleMaintenance(id: ID!, value: UpdateVehicleMaintenanceInput): VehicleMaintenance!
}

type TmsQuery {
  carrier(id: ID!): Carriers!
  carriers(from: Date, page: Int, perPage: Int, search: String, to: Date): [Carriers!]!
  driver(id: ID!): Drivers!
  drivers(from: Date, page: Int, perPage: Int, search: String, status: DriverStatus, to: Date): [Drivers!]!
  expense(id: ID!): Expenses!
  expenses(currency: Currency, from: Date, page: Int, perPage: Int, search: String, status: ExpenseStatus, to: Date, type: ExpenseType): [Expenses!]!
  geofence(id: ID!): Geofences!
  geofences(from: Date, page: Int, perPage: Int, search: String, to: Date): [Geofences!]!
  gpsPing(id: ID!): GpsPings!
  gpsPings(from: Date, page: Int, perPage: Int, to: Date): [GpsPings!]!
  partnerInvoice(id: ID!): PartnerInvoices!
  partnerInvoices(from: Date, page: Int, perPage: Int, search: String, status: PartnerInvoiceStatus, to: Date): [PartnerInvoices!]!
  proofOfDeliveries(from: Date, page: Int, perPage: Int, search: String, to: Date, type: ProofType): [ProofOfDeliveries!]!
  proofOfDelivery(id: ID!): ProofOfDeliveries!
  route(id: ID!): Routes!
  routes(from: Date, page: Int, perPage: Int, search: String, to: Date): [Routes!]!
  shipmentLeg(id: ID!): ShipmentLegs!
  shipmentLegs(from: Date, page: Int, perPage: Int, search: String, status: ShipmentLegStatus, to: Date): [ShipmentLegs!]!
  trip(id: ID!): Trips!
  trips(from: Date, page: Int, perPage: Int, search: String, status: TripStatus, to: Date): [Trips!]!
  vehicle(id: ID!): Vehicles!
  vehicles(from: Date, page: Int, perPage: Int, search: String, status: VehicleStatus, to: Date): [Vehicles!]!
}

type TmsSubscription {
  driverStatusChanged: TmsDriverStatusChangedEvent!
  expenseApproved: Expenses!
  expenseRejected: TmsExpenseRejectedEvent!
  expenseStatusChanged: TmsExpenseStatusChangedEvent!
  expenseSubmitted: Expenses!
  geofenceEntered: TmsGeofenceEvent!
  geofenceExited: TmsGeofenceEvent!
  tripCancelled: Trips!
  tripCompleted: Trips!
  tripCreated: Trips!
  tripStarted: Trips!
  tripStatusChanged: TmsTripStatusChangedEvent!
  tripStopArrived: TripStops!
  tripStopCompleted: TripStops!
  tripStopSkipped: TmsTripStopSkippedEvent!
  vehicleMaintenanceScheduled: VehicleMaintenance!
  vehicleStatusChanged: TmsVehicleStatusChangedEvent!
}

type TmsTripStatusChangedEvent {
  driverId: ID
  id: ID!
  newStatus: TripStatus!
  previousStatus: TripStatus!
  vehicleId: ID
}

type TmsTripStopSkippedEvent {
  reason: String
  tripStop: TripStops!
}

type TmsVehicleStatusChangedEvent {
  id: ID!
  newStatus: VehicleStatus!
  previousStatus: VehicleStatus!
}

type TransactionCreditedEvent {
  amount: String!
  clientId: ID!
  paymentId: ID!
  runningBalance: String!
  transactionId: ID!
}

type TransactionDebitedEvent {
  amount: String!
  clientId: ID!
  invoiceId: ID!
  runningBalance: String!
  transactionId: ID!
}

enum TransactionType {
  ADJUSTMENT
  CREDIT
  DEBIT
  FEE
  REFUND
  TOP_UP
}

enum TripStatus {
  CANCELLED
  COMPLETED
  IN_PROGRESS
  PLANNED
}

enum TripStopStatus {
  ARRIVED
  COMPLETED
  PENDING
  SKIPPED
}

type TripStops {
  actualArrivalTime: String
  actualDepartureTime: String
  address: String
  createdAt: Date
  estimatedArrivalTime: String
  estimatedDepartureTime: String
  id: ID!
  proofOfDeliveries: [ProofOfDeliveries!]
  sequence: Int!
  shipment: OutboundShipments
  status: TripStopStatus
  trip: Trips!
  updatedAt: Date
}

type Trips {
  createdAt: Date
  driver: Drivers
  endLocation: String
  endTime: String
  expenses: [Expenses!]
  id: ID!
  routes: [Routes!]
  shipmentLegs: [ShipmentLegs!]
  startLocation: String
  startTime: String
  status: TripStatus
  stops: [TripStops!]
  updatedAt: Date
  vehicle: Vehicles
}

input UpdateBillingInvoiceInput {
  amountPaid: Float
  currency: String
  dueDate: String
  notes: String
  paidAt: Date
  paymentTerms: String
  status: BillingInvoiceStatus
}

input UpdateBinThresholdInput {
  alertThreshold: Int
  isActive: Boolean
  maxQuantity: Int
  minQuantity: Int
  reorderQuantity: Int
}

input UpdateCampaignInput {
  budget: Float
  endDate: Date
  name: String
  startDate: Date
}

input UpdateCarrierInput {
  contactEmail: String
  contactPerson: String
  contactPhone: String
  name: String
  servicesOffered: String
}

input UpdateCarrierRateInput {
  destination: String
  origin: String
  rate: Float
  serviceType: String
  unit: CarrierRateUnit
}

input UpdateCaseInput {
  priority: CasePriority
  status: CaseStatus
  type: CaseType
}

input UpdateClientAccountInput {
  availableCredit: Float
  creditLimit: Float
  currency: String
  isCreditApproved: Boolean
  lastPaymentDate: Date
  paymentTermsDays: Int
  walletBalance: Float
}

input UpdateCompanyInput {
  annualRevenue: Float
  city: String
  country: String
  industry: String
  name: String
  phoneNumber: String
  postalCode: String
  state: String
  street: String
  website: String
}

input UpdateContactInput {
  email: String
  jobTitle: String
  name: String
  phoneNumber: String
}

input UpdateCreditNoteInput {
  amount: Float
  appliedAt: String
  creditNoteNumber: String
  currency: String
  notes: String
  reason: String
}

input UpdateCustomerTrackingLinkInput {
  accessCount: Int
  expiresAt: String
  isActive: Boolean
}

input UpdateDeliveryRouteInput {
  completedAt: String
  estimatedDurationMinutes: Int
  optimizedRouteData: String
  routeDate: String
  startedAt: String
  status: DeliveryRouteStatus
  totalDistanceKm: Float
}

input UpdateDeliveryTaskInput {
  actualArrivalTime: String
  attemptCount: Int
  deliveryAddress: String
  deliveryInstructions: String
  deliveryTime: String
  estimatedArrivalTime: String
  failureReason: DeliveryFailureReason
  recipientName: String
  recipientPhone: String
  status: DeliveryTaskStatus
}

input UpdateDisputeInput {
  disputedAmount: Float
  reason: String
  resolutionNotes: String
  resolvedAt: String
  resolvedByUserId: ID
  status: DisputeStatus
}

input UpdateDocumentInput {
  documentType: DocumentType
  fileName: String
  filePath: String
  fileSize: Int
  mimeType: String
  recordId: ID
  recordType: String
  uploadedByUserId: ID
}

input UpdateDriverInput {
  contactPhone: String
  licenseExpiryDate: String
  licenseNumber: String
  status: DriverStatus
}

input UpdateDriverLocationInput {
  accuracy: Float
  altitude: Float
  heading: Float
  latitude: Float
  longitude: Float
  speedKmh: Float
}

input UpdateDriverScheduleInput {
  endDate: String
  reason: DriverScheduleReason
  startDate: String
}

input UpdateExpenseInput {
  amount: Float
  currency: Currency
  description: String
  expenseDate: Date
  fuelQuantity: Float
  odometerReading: Int
  receiptUrl: String
  status: ExpenseStatus
  type: ExpenseType
}

input UpdateGeofenceEventInput {
  eventType: GeofenceEventType
}

input UpdateGeofenceInput {
  latitude: Float
  longitude: Float
  name: String
}

input UpdateGpsPingInput {
  latitude: Float
  longitude: Float
}

input UpdateInboundShipmentInput {
  actualArrivalDate: String
  expectedArrivalDate: String
  status: InboundShipmentStatus
}

input UpdateInboundShipmentItemInput {
  discrepancyNotes: String
  expectedQuantity: Int
  receivedQuantity: Int
}

input UpdateInteractionInput {
  interactionDate: Date
  notes: String
  outcome: InteractionOutcome
  type: InteractionType
}

input UpdateInventoryAdjustmentInput {
  notes: String
  quantityChange: Int
  reason: InventoryAdjustmentReason
  userId: ID
}

input UpdateInventoryBatchInput {
  batchNumber: String
  expirationDate: Date
}

input UpdateInventoryStockInput {
  lastCountedAt: Date
  lastMovementAt: Date
  quantity: Int
  reservedQuantity: Int
  status: InventoryStockStatus
}

input UpdateInvoiceInput {
  dueDate: Date
  paidAt: Date
  paymentMethod: CrmInvoicePaymentMethod
  status: InvoiceStatus
}

input UpdateInvoiceItemInput {
  quantity: Float!
}

input UpdateInvoiceLineItemInput {
  description: String
  discountRate: Float
  quantity: Float
  taxRate: Float
  unitPrice: Float
}

input UpdateLeadInput {
  convertedAt: Date
  convertedCompanyId: ID
  convertedContactId: ID
  convertedOpportunityId: ID
  email: String
  leadScore: Int
  leadSource: LeadSource
  name: String
  status: LeadStatus
}

input UpdateLocationInput {
  barcode: String
  hazmatApproved: Boolean
  isActive: Boolean
  isPickable: Boolean
  isReceivable: Boolean
  level: Int
  maxPallets: Int
  maxVolume: Float
  maxWeight: Float
  name: String
  path: String
  temperatureControlled: Boolean
  type: LocationType
  xCoordinate: Float
  yCoordinate: Float
  zCoordinate: Float
}

input UpdateNotificationInput {
  isRead: Boolean
}

input UpdateOpportunityInput {
  dealValue: Float
  expectedCloseDate: Date
  lostReason: String
  name: String
  probability: Float
  source: OpportunitySource
  stage: OpportunityStage
}

input UpdateOpportunityProductInput {
  quantity: Float!
}

input UpdateOutboundShipmentInput {
  carrier: String
  status: OutboundShipmentStatus
}

input UpdateOutboundShipmentItemInput {
  quantityShipped: Int
}

input UpdatePackageInput {
  carrier: String
  height: Float
  insuranceValue: Float
  isFragile: Boolean
  isHazmat: Boolean
  length: Float
  packageNumber: String
  packageType: String
  packedAt: Date
  requiresSignature: Boolean
  serviceLevel: String
  shippedAt: Date
  trackingNumber: String
  warehouseId: ID
  weight: Float
  width: Float
}

input UpdatePackageItemInput {
  expiryDate: String
  lotNumber: String
  quantity: Int
  unitWeight: Float
}

input UpdatePartnerInvoiceInput {
  status: PartnerInvoiceStatus
}

input UpdatePartnerInvoiceItemInput {
  amount: Float!
}

input UpdatePaymentInput {
  currency: String
  exchangeRate: Float
  fees: Float
  notes: String
  status: PaymentStatus
}

input UpdatePickBatchInput {
  actualDuration: Int
  assignedUserId: ID
  batchNumber: String
  completedAt: Date
  completedItems: Int
  priority: Int
  status: PickBatchStatus
  strategy: PickStrategy
  warehouseId: ID
  waveId: String
  zoneRestrictions: [String!]!
}

input UpdatePickBatchItemInput {
  actualPickTime: Int
  estimatedPickTime: Int
  orderPriority: Int
}

input UpdateProductInput {
  description: String
  name: String
  price: Float
  sku: String
  type: ProductType
}

input UpdateProofOfDeliveryInput {
  type: ProofType
}

input UpdatePutawayRuleInput {
  isActive: Boolean
  locationType: LocationType
  maxQuantity: Int
  minQuantity: Int
  preferredLocationId: ID
  priority: Int
  requiresHazmatApproval: Boolean
  requiresTemperatureControl: Boolean
  volumeThreshold: Float
  warehouseId: ID
  weightThreshold: Float
}

input UpdateQuoteInput {
  destinationDetails: String
  expiresAt: String
  height: Float
  length: Float
  notes: String
  originDetails: String
  quotedPrice: Float
  serviceLevel: String
  status: QuoteStatus
  weight: Float
  width: Float
}

input UpdateRateCardInput {
  createdByUserId: ID
  description: String
  isActive: Boolean
  name: String
  serviceType: ServiceType
  validFrom: String
  validTo: String
}

input UpdateRateRuleInput {
  condition: String
  isActive: Boolean
  maxValue: Float
  minValue: Float
  price: Float
  pricingModel: PricingModel
  priority: Int
  rateCardId: ID
  value: String
}

input UpdateReorderPointInput {
  threshold: Int
}

input UpdateReturnInput {
  reason: String
  status: ReturnStatus
}

input UpdateReturnItemInput {
  condition: ReturnItemCondition
  quantityReceived: Int
}

input UpdateRouteInput {
  optimizedRouteData: String
  totalDistance: Float
  totalDuration: Float
}

input UpdateSalesOrderInput {
  shippingAddress: String
  status: SalesOrderStatus
}

input UpdateSalesOrderItemInput {
  quantityOrdered: Int
}

input UpdateShipmentLegInput {
  carrierId: ID
  endLocation: String
  internalTripId: ID
  legSequence: Int
  startLocation: String
  status: ShipmentLegStatus
}

input UpdateStockTransferInput {
  destinationWarehouseId: ID
  quantity: Int
  status: StockTransferStatus
}

input UpdateSupplierInput {
  contactPerson: String
  email: String
  name: String
  phoneNumber: String
}

input UpdateSurchargeInput {
  amount: Float
  calculationMethod: SurchargeCalculationMethod
  description: String
  isActive: Boolean
  name: String
  type: String
  validFrom: String
  validTo: String
}

input UpdateTaskInput {
  actualDuration: Int
  endTime: Date
  estimatedDuration: Int
  instructions: String
  notes: String
  pickBatchId: ID
  priority: Int
  sourceEntityId: ID
  sourceEntityType: String
  startTime: Date
  status: TaskStatus
  taskNumber: String
  type: TaskType
  userId: ID
}

input UpdateTaskItemInput {
  completedAt: String
  destinationLocationId: ID
  expiryDate: Date
  notes: String
  quantityCompleted: Int
  quantityRequired: Int
  sourceLocationId: ID
  status: TaskItemStatus
}

input UpdateTripInput {
  endLocation: String
  endTime: String
  startLocation: String
  startTime: String
  status: TripStatus
}

input UpdateTripStopInput {
  actualArrivalTime: String
  actualDepartureTime: String
  address: String
  estimatedArrivalTime: String
  estimatedDepartureTime: String
  sequence: Int
  status: TripStopStatus
}

input UpdateVehicleInput {
  capacityVolume: Float
  capacityWeight: Float
  currentMileage: Int
  lastMaintenanceDate: String
  make: String
  model: String
  registrationNumber: String
  status: VehicleStatus
  vin: String
  year: Int
}

input UpdateVehicleMaintenanceInput {
  cost: Float
  notes: String
  serviceDate: Date
  serviceType: VehicleServiceType
}

input UpdateWarehouseInput {
  address: String
  city: String
  contactEmail: String
  contactPerson: String
  contactPhone: String
  country: String
  isActive: Boolean
  name: String
  postalCode: String
  state: String
  timezone: String
}

input UpdateWmsProductInput {
  barcode: String
  costPrice: Float
  description: String
  height: Float
  length: Float
  name: String
  sku: String
  status: ProductStatus
  weight: Float
  width: Float
}

type User {
  banExpires: Date
  banReason: String
  banned: Boolean
  createdAt: Date!
  email: String!
  emailVerified: Boolean!
  id: ID!
  image: String
  name: String!
  role: String
  updatedAt: Date!
}

type VehicleMaintenance {
  cost: Float
  createdAt: Date
  id: ID!
  notes: String
  serviceDate: Date!
  serviceType: VehicleServiceType
  updatedAt: Date
  vehicle: Vehicles!
}

enum VehicleServiceType {
  BRAKE_SERVICE
  INSPECTION
  OIL_CHANGE
  REPAIR
  ROUTINE_MAINTENANCE
  TIRE_REPLACEMENT
}

enum VehicleStatus {
  AVAILABLE
  IN_MAINTENANCE
  ON_TRIP
  OUT_OF_SERVICE
}

type Vehicles {
  capacityVolume: Float
  capacityWeight: Float
  createdAt: Date
  currentMileage: Int
  geofenceEvents: [GeofenceEvents!]
  gpsPings: [GpsPings!]
  id: ID!
  lastMaintenanceDate: String
  maintenances: [VehicleMaintenance!]
  make: String
  model: String
  registrationNumber: String!
  status: VehicleStatus
  trips: [Trips!]
  updatedAt: Date
  vin: String
  year: Int
}

type Warehouses {
  address: String
  city: String
  contactEmail: String
  contactPerson: String
  contactPhone: String
  country: String
  createdAt: Date
  destinationStockTransfers: [StockTransfers!]
  id: ID!
  inboundShipments: [InboundShipments!]
  isActive: Boolean
  locations: [Locations!]
  name: String!
  outboundShipments: [OutboundShipments!]
  packages: [Packages!]
  pickBatches: [PickBatches!]
  postalCode: String
  putawayRules: [PutawayRules!]
  sourceStockTransfers: [StockTransfers!]
  state: String
  tasks: [Tasks!]
  timezone: String
  updatedAt: Date
}

type WmsInboundShipmentStatusChangedEvent {
  id: ID!
  newStatus: InboundShipmentStatus!
  previousStatus: InboundShipmentStatus!
  warehouseId: ID!
}

type WmsInventoryAdjustmentDamagedReturnEvent {
  inventoryAdjustment: InventoryAdjustments!
  returnId: ID!
}

type WmsInventoryAdjustmentRecordedEvent {
  inventoryAdjustment: InventoryAdjustments!
  previousQuantity: Int!
}

type WmsInventoryStockLowStockAlertEvent {
  currentQuantity: Int!
  id: ID!
  locationId: ID!
  productId: ID!
  reorderPoint: Int!
  warehouseId: ID!
}

type WmsInventoryStockReleasedEvent {
  inventoryStock: InventoryStock!
  releasedQuantity: Int!
}

type WmsInventoryStockReservedEvent {
  inventoryStock: InventoryStock!
  reservedQuantity: Int!
}

type WmsInventoryStockStatusChangedEvent {
  id: ID!
  locationId: ID!
  newStatus: InventoryStockStatus!
  previousStatus: InventoryStockStatus!
  productId: ID!
  quantity: Int!
}

type WmsMutation {
  addInboundShipmentItem(id: ID!, value: CreateInboundShipmentItemInput!): InboundShipmentItems!
  addOutboundShipmentItem(id: ID!, value: CreateOutboundShipmentItemInput!): OutboundShipmentItems!
  addPackageItem(id: ID!, value: CreatePackageItemInput!): PackageItems!
  addPickBatchItem(id: ID!, value: CreatePickBatchItemInput!): PickBatchItems!
  addReturnItem(id: ID!, value: CreateReturnItemInput!): ReturnItems!
  addSalesOrderItem(id: ID!, value: CreateSalesOrderItemInput!): SalesOrderItems!
  addTaskItem(id: ID!, value: CreateTaskItemInput!): TaskItems!
  createBinThreshold(value: CreateBinThresholdInput!): BinThresholds!
  createInboundShipment(value: CreateInboundShipmentInput!): InboundShipments!
  createInventoryAdjustment(value: CreateInventoryAdjustmentInput!): InventoryAdjustments!
  createInventoryBatch(value: CreateInventoryBatchInput!): InventoryBatches!
  createInventoryStock(value: CreateInventoryStockInput!): InventoryStock!
  createLocation(value: CreateLocationInput!): Locations!
  createOutboundShipment(value: CreateOutboundShipmentInput!): OutboundShipments!
  createPackage(value: CreatePackageInput!): Packages!
  createPickBatch(value: CreatePickBatchInput!): PickBatches!
  createPutawayRule(value: CreatePutawayRuleInput!): PutawayRules!
  createReorderPoint(value: CreateReorderPointInput!): ReorderPoints!
  createReturn(value: CreateReturnInput!): Returns!
  createSalesOrder(value: CreateSalesOrderInput!): SalesOrders!
  createStockTransfer(value: CreateStockTransferInput!): StockTransfers!
  createSupplier(value: CreateSupplierInput!): Suppliers!
  createTask(value: CreateTaskInput!): Tasks!
  createWarehouse(value: CreateWarehouseInput!): Warehouses!
  createWmsProduct(value: CreateWmsProductInput!): WmsProducts!
  removeBinThreshold(id: ID!): DeleteResult!
  removeInboundShipment(id: ID!): DeleteResult!
  removeInboundShipmentItem(id: ID!): DeleteResult!
  removeInventoryAdjustment(id: ID!): DeleteResult!
  removeInventoryBatch(id: ID!): DeleteResult!
  removeInventoryStock(id: ID!): DeleteResult!
  removeLocation(id: ID!): DeleteResult!
  removeOutboundShipment(id: ID!): DeleteResult!
  removeOutboundShipmentItem(id: ID!): DeleteResult!
  removePackage(id: ID!): DeleteResult!
  removePackageItem(id: ID!): DeleteResult!
  removePickBatch(id: ID!): DeleteResult!
  removePickBatchItem(id: ID!): DeleteResult!
  removePutawayRule(id: ID!): DeleteResult!
  removeReorderPoint(id: ID!): DeleteResult!
  removeReturn(id: ID!): DeleteResult!
  removeReturnItem(id: ID!): DeleteResult!
  removeSalesOrder(id: ID!): DeleteResult!
  removeSalesOrderItem(id: ID!): DeleteResult!
  removeStockTransfer(id: ID!): DeleteResult!
  removeSupplier(id: ID!): DeleteResult!
  removeTask(id: ID!): DeleteResult!
  removeTaskItem(id: ID!): DeleteResult!
  removeWarehouse(id: ID!): DeleteResult!
  removeWmsProduct(id: ID!): DeleteResult!
  updateBinThreshold(id: ID!, value: UpdateBinThresholdInput): BinThresholds!
  updateInboundShipment(id: ID!, value: UpdateInboundShipmentInput): InboundShipments!
  updateInboundShipmentItem(id: ID!, value: UpdateInboundShipmentItemInput): InboundShipmentItems!
  updateInventoryAdjustment(id: ID!, value: UpdateInventoryAdjustmentInput): InventoryAdjustments!
  updateInventoryBatch(id: ID!, value: UpdateInventoryBatchInput): InventoryBatches!
  updateInventoryStock(id: ID!, value: UpdateInventoryStockInput): InventoryStock!
  updateLocation(id: ID!, value: UpdateLocationInput): Locations!
  updateOutboundShipment(id: ID!, value: UpdateOutboundShipmentInput): OutboundShipments!
  updateOutboundShipmentItem(id: ID!, value: UpdateOutboundShipmentItemInput!): OutboundShipmentItems!
  updatePackage(id: ID!, value: UpdatePackageInput): Packages!
  updatePackageItem(id: ID!, value: UpdatePackageItemInput!): PackageItems!
  updatePickBatch(id: ID!, value: UpdatePickBatchInput): PickBatches!
  updatePickBatchItem(id: ID!, value: UpdatePickBatchItemInput): PickBatchItems!
  updatePutawayRule(id: ID!, value: UpdatePutawayRuleInput): PutawayRules!
  updateReorderPoint(id: ID!, value: UpdateReorderPointInput): ReorderPoints!
  updateReturn(id: ID!, value: UpdateReturnInput): Returns!
  updateReturnItem(id: ID!, value: UpdateReturnItemInput): ReturnItems!
  updateSalesOrder(id: ID!, value: UpdateSalesOrderInput): SalesOrders!
  updateSalesOrderItem(id: ID!, value: UpdateSalesOrderItemInput!): SalesOrderItems!
  updateStockTransfer(id: ID!, value: UpdateStockTransferInput): StockTransfers!
  updateSupplier(id: ID!, value: UpdateSupplierInput!): Suppliers!
  updateTask(id: ID!, value: UpdateTaskInput): Tasks!
  updateTaskItem(id: ID!, value: UpdateTaskItemInput): TaskItems!
  updateWarehouse(id: ID!, value: UpdateWarehouseInput!): Warehouses!
  updateWmsProduct(id: ID!, value: UpdateWmsProductInput): WmsProducts!
}

type WmsOutboundShipmentStatusChangedEvent {
  id: ID!
  newStatus: OutboundShipmentStatus!
  previousStatus: OutboundShipmentStatus!
  salesOrderId: ID!
}

type WmsPickBatchStatusChangedEvent {
  id: ID!
  newStatus: PickBatchStatus!
  previousStatus: PickBatchStatus!
}

type WmsProducts {
  adjustments: [InventoryAdjustments!]
  barcode: String
  batches: [InventoryBatches!]
  binThresholds: [BinThresholds!]
  client: Companies
  costPrice: Float
  createdAt: Date
  description: String
  height: Float
  id: ID!
  inboundShipmentItems: [InboundShipmentItems!]
  inventoryStock: [InventoryStock!]
  length: Float
  name: String!
  outboundShipmentItems: [OutboundShipmentItems!]
  packageItems: [PackageItems!]
  putawayRules: [PutawayRules!]
  reorderPoints: [ReorderPoints!]
  returnItems: [ReturnItems!]
  salesOrderItems: [SalesOrderItems!]
  sku: String!
  status: ProductStatus
  stockTransfers: [StockTransfers!]
  supplier: Suppliers
  taskItems: [TaskItems!]
  updatedAt: Date
  volume: Float
  weight: Float
  width: Float
}

type WmsQuery {
  binThreshold(id: ID!): BinThresholds!
  binThresholds(from: Date, page: Int, perPage: Int, to: Date): [BinThresholds!]!
  inboundShipment(id: ID!): InboundShipments!
  inboundShipments(from: Date, page: Int, perPage: Int, status: InboundShipmentStatus, to: Date): [InboundShipments!]!
  inventoryAdjustment(id: ID!): InventoryAdjustments!
  inventoryAdjustments(from: Date, page: Int, perPage: Int, reason: InventoryAdjustmentReason, search: String, to: Date): [InventoryAdjustments!]!
  inventoryBatch(id: ID!): InventoryBatches!
  inventoryBatches(from: Date, page: Int, perPage: Int, search: String, to: Date): [InventoryBatches!]!
  inventoryStock(id: ID!): InventoryStock!
  inventoryStocks(from: Date, page: Int, perPage: Int, status: InventoryStockStatus, to: Date): [InventoryStock!]!
  location(id: ID!): Locations!
  locations(from: Date, page: Int, perPage: Int, search: String, to: Date, type: LocationType): [Locations!]!
  outboundShipment(id: ID!): OutboundShipments!
  outboundShipments(from: Date, page: Int, perPage: Int, search: String, status: OutboundShipmentStatus, to: Date): [OutboundShipments!]!
  package(id: ID!): Packages!
  packages(from: Date, page: Int, perPage: Int, search: String, to: Date): [Packages!]!
  pickBatch(id: ID!): PickBatches!
  pickBatches(from: Date, page: Int, perPage: Int, search: String, status: PickBatchStatus, strategy: PickStrategy, to: Date): [PickBatches!]!
  putawayRule(id: ID!): PutawayRules!
  putawayRules(from: Date, locationType: LocationType, page: Int, perPage: Int, to: Date): [PutawayRules!]!
  reorderPoint(id: ID!): ReorderPoints!
  reorderPoints(from: Date, page: Int, perPage: Int, to: Date): [ReorderPoints!]!
  return(id: ID!): Returns!
  returns(from: Date, page: Int, perPage: Int, search: String, status: ReturnStatus, to: Date): [Returns!]!
  salesOrder(id: ID!): SalesOrders!
  salesOrders(from: Date, page: Int, perPage: Int, search: String, status: SalesOrderStatus, to: Date): [SalesOrders!]!
  stockTransfer(id: ID!): StockTransfers!
  stockTransfers(from: Date, page: Int, perPage: Int, status: StockTransferStatus, to: Date): [StockTransfers!]!
  supplier(id: ID!): Suppliers!
  suppliers(from: Date, page: Int, perPage: Int, search: String, to: Date): [Suppliers!]!
  task(id: ID!): Tasks!
  tasks(from: Date, page: Int, perPage: Int, search: String, status: TaskStatus, to: Date, type: TaskType): [Tasks!]!
  warehouse(id: ID!): Warehouses!
  warehouses(from: Date, page: Int, perPage: Int, search: String, to: Date): [Warehouses!]!
  wmsProduct(id: ID!): WmsProducts!
  wmsProducts(from: Date, page: Int, perPage: Int, search: String, status: ProductStatus, to: Date): [WmsProducts!]!
}

type WmsReturnItemEvaluatedEvent {
  condition: ReturnItemCondition
  returnItem: ReturnItems!
}

type WmsReturnRejectedEvent {
  rejectionReason: String
  return: Returns!
}

type WmsReturnStatusChangedEvent {
  clientId: ID!
  id: ID!
  newStatus: ReturnStatus!
  previousStatus: ReturnStatus!
}

type WmsSalesOrderStatusChangedEvent {
  clientId: ID!
  id: ID!
  newStatus: SalesOrderStatus!
  previousStatus: SalesOrderStatus!
}

type WmsStockTransferStatusChangedEvent {
  id: ID!
  newStatus: StockTransferStatus!
  previousStatus: StockTransferStatus!
  productId: ID!
}

type WmsSubscription {
  inboundShipmentCompleted: InboundShipments!
  inboundShipmentProcessing: InboundShipments!
  inboundShipmentReceived: InboundShipments!
  inboundShipmentStatusChanged: WmsInboundShipmentStatusChangedEvent!
  inventoryAdjustmentDamagedReturn: WmsInventoryAdjustmentDamagedReturnEvent!
  inventoryAdjustmentRecorded: WmsInventoryAdjustmentRecordedEvent!
  inventoryStockLowStockAlert: WmsInventoryStockLowStockAlertEvent!
  inventoryStockReleased: WmsInventoryStockReleasedEvent!
  inventoryStockReserved: WmsInventoryStockReservedEvent!
  inventoryStockStatusChanged: WmsInventoryStockStatusChangedEvent!
  outboundShipmentCreated: OutboundShipments!
  outboundShipmentDelivered: OutboundShipments!
  outboundShipmentPacked: OutboundShipments!
  outboundShipmentPicking: OutboundShipments!
  outboundShipmentShipped: OutboundShipments!
  outboundShipmentStatusChanged: WmsOutboundShipmentStatusChangedEvent!
  pickBatchCompleted: PickBatches!
  pickBatchCreated: PickBatches!
  pickBatchStarted: PickBatches!
  pickBatchStatusChanged: WmsPickBatchStatusChangedEvent!
  returnApproved: Returns!
  returnItemEvaluated: WmsReturnItemEvaluatedEvent!
  returnProcessed: Returns!
  returnReceived: Returns!
  returnRejected: WmsReturnRejectedEvent!
  returnStatusChanged: WmsReturnStatusChangedEvent!
  salesOrderCompleted: SalesOrders!
  salesOrderCreated: SalesOrders!
  salesOrderProcessing: SalesOrders!
  salesOrderShipped: SalesOrders!
  salesOrderStatusChanged: WmsSalesOrderStatusChangedEvent!
  stockTransferInTransit: StockTransfers!
  stockTransferInitiated: StockTransfers!
  stockTransferReceived: StockTransfers!
  stockTransferStatusChanged: WmsStockTransferStatusChangedEvent!
  taskAssigned: WmsTaskAssignedEvent!
  taskCancelled: Tasks!
  taskCompleted: Tasks!
  taskCreated: Tasks!
  taskItemCompleted: TaskItems!
  taskItemDamaged: TaskItems!
  taskItemShortPicked: WmsTaskItemShortPickedEvent!
  taskItemStatusChanged: WmsTaskItemStatusChangedEvent!
  taskPutawayCreated: WmsTaskPutawayCreatedEvent!
  taskReplenishmentCreated: WmsTaskReplenishmentCreatedEvent!
  taskStarted: Tasks!
  taskStatusChanged: WmsTaskStatusChangedEvent!
}

type WmsTaskAssignedEvent {
  previousUserId: ID
  task: Tasks!
}

type WmsTaskItemShortPickedEvent {
  shortQuantity: Int!
  taskItem: TaskItems!
}

type WmsTaskItemStatusChangedEvent {
  id: ID!
  newStatus: TaskItemStatus!
  previousStatus: TaskItemStatus!
  taskId: ID!
}

type WmsTaskPutawayCreatedEvent {
  reason: String!
  returnId: ID!
  task: Tasks!
}

type WmsTaskReplenishmentCreatedEvent {
  binId: ID!
  reason: String!
  task: Tasks!
}

type WmsTaskStatusChangedEvent {
  id: ID!
  newStatus: TaskStatus!
  previousStatus: TaskStatus!
  type: TaskType!
}